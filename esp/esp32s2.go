// Automatically generated file. DO NOT EDIT.
// Generated by gen-device-svd.go from esp32s2.svd, see https://github.com/posborne/cmsis-svd/tree/master/data/Espressif

//go:build esp && esp32s2
// +build esp,esp32s2

// 32-bit MCU & 2.4 GHz Wi-Fi
//
//     Copyright 2021 Espressif Systems (Shanghai) PTE LTD Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
package esp

import (
	"runtime/volatile"
	"unsafe"
)

// Some information about this device.
const (
	Device       = "ESP32-S2"
	CPU          = "Xtensa LX7"
	FPUPresent   = false
	NVICPrioBits = 3
)

// Interrupt numbers.
const (
	// Highest interrupt number on this device.
	IRQ_max = 0
)

// Pseudo function call that is replaced by the compiler with the actual
// functions registered through interrupt.New.
//go:linkname callHandlers runtime/interrupt.callHandlers
func callHandlers(num int)
func HandleInterrupt(num int) {
	switch num {
	}
}

// Peripherals.
var (
	// Peripheral AES
	AES = (*AES_Type)(unsafe.Pointer(uintptr(0x6003a000)))

	// Peripheral APB_SARADC
	APB_SARADC = (*APB_SARADC_Type)(unsafe.Pointer(uintptr(0x3f440000)))

	// Peripheral DEDICATED_GPIO
	DEDICATED_GPIO = (*DEDICATED_GPIO_Type)(unsafe.Pointer(uintptr(0x3f4cf000)))

	// Peripheral DS
	DS = (*DS_Type)(unsafe.Pointer(uintptr(0x6003d000)))

	// Peripheral EFUSE
	EFUSE = (*EFUSE_Type)(unsafe.Pointer(uintptr(0x3f41a000)))

	// Peripheral GPIO
	GPIO = (*GPIO_Type)(unsafe.Pointer(uintptr(0x3f404000)))

	// Peripheral GPIO_SD
	GPIO_SD = (*GPIO_SD_Type)(unsafe.Pointer(uintptr(0x3f404f00)))

	// Peripheral HMAC
	HMAC = (*HMAC_Type)(unsafe.Pointer(uintptr(0x6003e000)))

	// Peripheral I2C
	I2C0 = (*I2C0_Type)(unsafe.Pointer(uintptr(0x3f413000)))

	// Peripheral I2C
	I2C1 = (*I2C0_Type)(unsafe.Pointer(uintptr(0x3f427000)))

	// Peripheral I2S
	I2S = (*I2S_Type)(unsafe.Pointer(uintptr(0x3f40f000)))

	// Peripheral INTERRUPT
	INTERRUPT = (*INTERRUPT_Type)(unsafe.Pointer(uintptr(0x3f4c2000)))

	// Peripheral IO_MUX
	IO_MUX = (*IO_MUX_Type)(unsafe.Pointer(uintptr(0x3f409000)))

	// Peripheral LEDC
	LEDC = (*LEDC_Type)(unsafe.Pointer(uintptr(0x3f419000)))

	// Peripheral PCNT
	PCNT = (*PCNT_Type)(unsafe.Pointer(uintptr(0x3f417000)))

	// Peripheral RMT
	RMT = (*RMT_Type)(unsafe.Pointer(uintptr(0x3f416000)))

	// Peripheral RSA
	RSA = (*RSA_Type)(unsafe.Pointer(uintptr(0x6003c000)))

	// Peripheral RTCIO
	RTCIO = (*RTCIO_Type)(unsafe.Pointer(uintptr(0x3f408400)))

	// Peripheral RTC_CNTL
	RTC_CNTL = (*RTC_CNTL_Type)(unsafe.Pointer(uintptr(0x3f408000)))

	// Peripheral SENS
	SENS = (*SENS_Type)(unsafe.Pointer(uintptr(0x3f408800)))

	// Peripheral SHA
	SHA = (*SHA_Type)(unsafe.Pointer(uintptr(0x6003b000)))

	// Peripheral SYSTEM
	SYSTEM = (*SYSTEM_Type)(unsafe.Pointer(uintptr(0x3f4c0000)))

	// Peripheral SYSTIMER
	SYSTIMER = (*SYSTIMER_Type)(unsafe.Pointer(uintptr(0x3f423000)))

	// Peripheral TIMG
	TIMG0 = (*TIMG0_Type)(unsafe.Pointer(uintptr(0x3f41f000)))

	// Peripheral TIMG
	TIMG1 = (*TIMG0_Type)(unsafe.Pointer(uintptr(0x3f420000)))

	// Peripheral UART
	UART0 = (*UART0_Type)(unsafe.Pointer(uintptr(0x3f400000)))

	// Peripheral UART
	UART1 = (*UART0_Type)(unsafe.Pointer(uintptr(0x3f410000)))

	// Peripheral UHCI0
	UHCI0 = (*UHCI0_Type)(unsafe.Pointer(uintptr(0x3f414000)))

	// Peripheral XTS_AES
	XTS_AES = (*XTS_AES_Type)(unsafe.Pointer(uintptr(0x6003a100)))
)

// Peripheral AES
type AES_Type struct {
	KEY_0             volatile.Register32 // 0x0
	KEY_1             volatile.Register32 // 0x4
	KEY_2             volatile.Register32 // 0x8
	KEY_3             volatile.Register32 // 0xC
	KEY_4             volatile.Register32 // 0x10
	KEY_5             volatile.Register32 // 0x14
	KEY_6             volatile.Register32 // 0x18
	KEY_7             volatile.Register32 // 0x1C
	TEXT_IN_0         volatile.Register32 // 0x20
	TEXT_IN_1         volatile.Register32 // 0x24
	TEXT_IN_2         volatile.Register32 // 0x28
	TEXT_IN_3         volatile.Register32 // 0x2C
	TEXT_OUT_0        volatile.Register32 // 0x30
	TEXT_OUT_1        volatile.Register32 // 0x34
	TEXT_OUT_2        volatile.Register32 // 0x38
	TEXT_OUT_3        volatile.Register32 // 0x3C
	MODE              volatile.Register32 // 0x40
	ENDIAN            volatile.Register32 // 0x44
	TRIGGER           volatile.Register32 // 0x48
	STATE             volatile.Register32 // 0x4C
	IV_0              volatile.Register32 // 0x50
	IV_1              volatile.Register32 // 0x54
	IV_2              volatile.Register32 // 0x58
	IV_3              volatile.Register32 // 0x5C
	H_0               volatile.Register32 // 0x60
	H_1               volatile.Register32 // 0x64
	H_2               volatile.Register32 // 0x68
	H_3               volatile.Register32 // 0x6C
	J0_0              volatile.Register32 // 0x70
	J0_1              volatile.Register32 // 0x74
	J0_2              volatile.Register32 // 0x78
	J0_3              volatile.Register32 // 0x7C
	T0_0              volatile.Register32 // 0x80
	T0_1              volatile.Register32 // 0x84
	T0_2              volatile.Register32 // 0x88
	T0_3              volatile.Register32 // 0x8C
	DMA_ENABLE        volatile.Register32 // 0x90
	BLOCK_MODE        volatile.Register32 // 0x94
	BLOCK_NUM         volatile.Register32 // 0x98
	INC_SEL           volatile.Register32 // 0x9C
	AAD_BLOCK_NUM     volatile.Register32 // 0xA0
	REMAINDER_BIT_NUM volatile.Register32 // 0xA4
	CONTINUE_OP       volatile.Register32 // 0xA8
	INT_CLR           volatile.Register32 // 0xAC
	INT_ENA           volatile.Register32 // 0xB0
	DATE              volatile.Register32 // 0xB4
	DMA_EXIT          volatile.Register32 // 0xB8
}

// AES.KEY_0: AES key register %s
func (o *AES_Type) SetKEY_0(value uint32) {
	volatile.StoreUint32(&o.KEY_0.Reg, value)
}
func (o *AES_Type) GetKEY_0() uint32 {
	return volatile.LoadUint32(&o.KEY_0.Reg)
}

// AES.KEY_1: AES key register %s
func (o *AES_Type) SetKEY_1(value uint32) {
	volatile.StoreUint32(&o.KEY_1.Reg, value)
}
func (o *AES_Type) GetKEY_1() uint32 {
	return volatile.LoadUint32(&o.KEY_1.Reg)
}

// AES.KEY_2: AES key register %s
func (o *AES_Type) SetKEY_2(value uint32) {
	volatile.StoreUint32(&o.KEY_2.Reg, value)
}
func (o *AES_Type) GetKEY_2() uint32 {
	return volatile.LoadUint32(&o.KEY_2.Reg)
}

// AES.KEY_3: AES key register %s
func (o *AES_Type) SetKEY_3(value uint32) {
	volatile.StoreUint32(&o.KEY_3.Reg, value)
}
func (o *AES_Type) GetKEY_3() uint32 {
	return volatile.LoadUint32(&o.KEY_3.Reg)
}

// AES.KEY_4: AES key register %s
func (o *AES_Type) SetKEY_4(value uint32) {
	volatile.StoreUint32(&o.KEY_4.Reg, value)
}
func (o *AES_Type) GetKEY_4() uint32 {
	return volatile.LoadUint32(&o.KEY_4.Reg)
}

// AES.KEY_5: AES key register %s
func (o *AES_Type) SetKEY_5(value uint32) {
	volatile.StoreUint32(&o.KEY_5.Reg, value)
}
func (o *AES_Type) GetKEY_5() uint32 {
	return volatile.LoadUint32(&o.KEY_5.Reg)
}

// AES.KEY_6: AES key register %s
func (o *AES_Type) SetKEY_6(value uint32) {
	volatile.StoreUint32(&o.KEY_6.Reg, value)
}
func (o *AES_Type) GetKEY_6() uint32 {
	return volatile.LoadUint32(&o.KEY_6.Reg)
}

// AES.KEY_7: AES key register %s
func (o *AES_Type) SetKEY_7(value uint32) {
	volatile.StoreUint32(&o.KEY_7.Reg, value)
}
func (o *AES_Type) GetKEY_7() uint32 {
	return volatile.LoadUint32(&o.KEY_7.Reg)
}

// AES.TEXT_IN_0: Source data register %s
func (o *AES_Type) SetTEXT_IN_0(value uint32) {
	volatile.StoreUint32(&o.TEXT_IN_0.Reg, value)
}
func (o *AES_Type) GetTEXT_IN_0() uint32 {
	return volatile.LoadUint32(&o.TEXT_IN_0.Reg)
}

// AES.TEXT_IN_1: Source data register %s
func (o *AES_Type) SetTEXT_IN_1(value uint32) {
	volatile.StoreUint32(&o.TEXT_IN_1.Reg, value)
}
func (o *AES_Type) GetTEXT_IN_1() uint32 {
	return volatile.LoadUint32(&o.TEXT_IN_1.Reg)
}

// AES.TEXT_IN_2: Source data register %s
func (o *AES_Type) SetTEXT_IN_2(value uint32) {
	volatile.StoreUint32(&o.TEXT_IN_2.Reg, value)
}
func (o *AES_Type) GetTEXT_IN_2() uint32 {
	return volatile.LoadUint32(&o.TEXT_IN_2.Reg)
}

// AES.TEXT_IN_3: Source data register %s
func (o *AES_Type) SetTEXT_IN_3(value uint32) {
	volatile.StoreUint32(&o.TEXT_IN_3.Reg, value)
}
func (o *AES_Type) GetTEXT_IN_3() uint32 {
	return volatile.LoadUint32(&o.TEXT_IN_3.Reg)
}

// AES.TEXT_OUT_0: Result data register %s
func (o *AES_Type) SetTEXT_OUT_0(value uint32) {
	volatile.StoreUint32(&o.TEXT_OUT_0.Reg, value)
}
func (o *AES_Type) GetTEXT_OUT_0() uint32 {
	return volatile.LoadUint32(&o.TEXT_OUT_0.Reg)
}

// AES.TEXT_OUT_1: Result data register %s
func (o *AES_Type) SetTEXT_OUT_1(value uint32) {
	volatile.StoreUint32(&o.TEXT_OUT_1.Reg, value)
}
func (o *AES_Type) GetTEXT_OUT_1() uint32 {
	return volatile.LoadUint32(&o.TEXT_OUT_1.Reg)
}

// AES.TEXT_OUT_2: Result data register %s
func (o *AES_Type) SetTEXT_OUT_2(value uint32) {
	volatile.StoreUint32(&o.TEXT_OUT_2.Reg, value)
}
func (o *AES_Type) GetTEXT_OUT_2() uint32 {
	return volatile.LoadUint32(&o.TEXT_OUT_2.Reg)
}

// AES.TEXT_OUT_3: Result data register %s
func (o *AES_Type) SetTEXT_OUT_3(value uint32) {
	volatile.StoreUint32(&o.TEXT_OUT_3.Reg, value)
}
func (o *AES_Type) GetTEXT_OUT_3() uint32 {
	return volatile.LoadUint32(&o.TEXT_OUT_3.Reg)
}

// AES.MODE: AES working mode configuration register
func (o *AES_Type) SetMODE(value uint32) {
	volatile.StoreUint32(&o.MODE.Reg, volatile.LoadUint32(&o.MODE.Reg)&^(0x7)|value)
}
func (o *AES_Type) GetMODE() uint32 {
	return volatile.LoadUint32(&o.MODE.Reg) & 0x7
}

// AES.ENDIAN: Endian configuration register
func (o *AES_Type) SetENDIAN(value uint32) {
	volatile.StoreUint32(&o.ENDIAN.Reg, volatile.LoadUint32(&o.ENDIAN.Reg)&^(0x3f)|value)
}
func (o *AES_Type) GetENDIAN() uint32 {
	return volatile.LoadUint32(&o.ENDIAN.Reg) & 0x3f
}

// AES.TRIGGER: Operation start controlling register
func (o *AES_Type) SetTRIGGER(value uint32) {
	volatile.StoreUint32(&o.TRIGGER.Reg, volatile.LoadUint32(&o.TRIGGER.Reg)&^(0x1)|value)
}
func (o *AES_Type) GetTRIGGER() uint32 {
	return volatile.LoadUint32(&o.TRIGGER.Reg) & 0x1
}

// AES.STATE: Operation status register
func (o *AES_Type) SetSTATE(value uint32) {
	volatile.StoreUint32(&o.STATE.Reg, volatile.LoadUint32(&o.STATE.Reg)&^(0x3)|value)
}
func (o *AES_Type) GetSTATE() uint32 {
	return volatile.LoadUint32(&o.STATE.Reg) & 0x3
}

// AES.IV_0: initialization vector
func (o *AES_Type) SetIV_0(value uint32) {
	volatile.StoreUint32(&o.IV_0.Reg, value)
}
func (o *AES_Type) GetIV_0() uint32 {
	return volatile.LoadUint32(&o.IV_0.Reg)
}

// AES.IV_1: initialization vector
func (o *AES_Type) SetIV_1(value uint32) {
	volatile.StoreUint32(&o.IV_1.Reg, value)
}
func (o *AES_Type) GetIV_1() uint32 {
	return volatile.LoadUint32(&o.IV_1.Reg)
}

// AES.IV_2: initialization vector
func (o *AES_Type) SetIV_2(value uint32) {
	volatile.StoreUint32(&o.IV_2.Reg, value)
}
func (o *AES_Type) GetIV_2() uint32 {
	return volatile.LoadUint32(&o.IV_2.Reg)
}

// AES.IV_3: initialization vector
func (o *AES_Type) SetIV_3(value uint32) {
	volatile.StoreUint32(&o.IV_3.Reg, value)
}
func (o *AES_Type) GetIV_3() uint32 {
	return volatile.LoadUint32(&o.IV_3.Reg)
}

// AES.H_0: GCM hash subkey
func (o *AES_Type) SetH_0(value uint32) {
	volatile.StoreUint32(&o.H_0.Reg, value)
}
func (o *AES_Type) GetH_0() uint32 {
	return volatile.LoadUint32(&o.H_0.Reg)
}

// AES.H_1: GCM hash subkey
func (o *AES_Type) SetH_1(value uint32) {
	volatile.StoreUint32(&o.H_1.Reg, value)
}
func (o *AES_Type) GetH_1() uint32 {
	return volatile.LoadUint32(&o.H_1.Reg)
}

// AES.H_2: GCM hash subkey
func (o *AES_Type) SetH_2(value uint32) {
	volatile.StoreUint32(&o.H_2.Reg, value)
}
func (o *AES_Type) GetH_2() uint32 {
	return volatile.LoadUint32(&o.H_2.Reg)
}

// AES.H_3: GCM hash subkey
func (o *AES_Type) SetH_3(value uint32) {
	volatile.StoreUint32(&o.H_3.Reg, value)
}
func (o *AES_Type) GetH_3() uint32 {
	return volatile.LoadUint32(&o.H_3.Reg)
}

// AES.J0_0: J0
func (o *AES_Type) SetJ0_0(value uint32) {
	volatile.StoreUint32(&o.J0_0.Reg, value)
}
func (o *AES_Type) GetJ0_0() uint32 {
	return volatile.LoadUint32(&o.J0_0.Reg)
}

// AES.J0_1: J0
func (o *AES_Type) SetJ0_1(value uint32) {
	volatile.StoreUint32(&o.J0_1.Reg, value)
}
func (o *AES_Type) GetJ0_1() uint32 {
	return volatile.LoadUint32(&o.J0_1.Reg)
}

// AES.J0_2: J0
func (o *AES_Type) SetJ0_2(value uint32) {
	volatile.StoreUint32(&o.J0_2.Reg, value)
}
func (o *AES_Type) GetJ0_2() uint32 {
	return volatile.LoadUint32(&o.J0_2.Reg)
}

// AES.J0_3: J0
func (o *AES_Type) SetJ0_3(value uint32) {
	volatile.StoreUint32(&o.J0_3.Reg, value)
}
func (o *AES_Type) GetJ0_3() uint32 {
	return volatile.LoadUint32(&o.J0_3.Reg)
}

// AES.T0_0: T0
func (o *AES_Type) SetT0_0(value uint32) {
	volatile.StoreUint32(&o.T0_0.Reg, value)
}
func (o *AES_Type) GetT0_0() uint32 {
	return volatile.LoadUint32(&o.T0_0.Reg)
}

// AES.T0_1: T0
func (o *AES_Type) SetT0_1(value uint32) {
	volatile.StoreUint32(&o.T0_1.Reg, value)
}
func (o *AES_Type) GetT0_1() uint32 {
	return volatile.LoadUint32(&o.T0_1.Reg)
}

// AES.T0_2: T0
func (o *AES_Type) SetT0_2(value uint32) {
	volatile.StoreUint32(&o.T0_2.Reg, value)
}
func (o *AES_Type) GetT0_2() uint32 {
	return volatile.LoadUint32(&o.T0_2.Reg)
}

// AES.T0_3: T0
func (o *AES_Type) SetT0_3(value uint32) {
	volatile.StoreUint32(&o.T0_3.Reg, value)
}
func (o *AES_Type) GetT0_3() uint32 {
	return volatile.LoadUint32(&o.T0_3.Reg)
}

// AES.DMA_ENABLE: DMA enable register
func (o *AES_Type) SetDMA_ENABLE(value uint32) {
	volatile.StoreUint32(&o.DMA_ENABLE.Reg, volatile.LoadUint32(&o.DMA_ENABLE.Reg)&^(0x1)|value)
}
func (o *AES_Type) GetDMA_ENABLE() uint32 {
	return volatile.LoadUint32(&o.DMA_ENABLE.Reg) & 0x1
}

// AES.BLOCK_MODE: Block operation type register
func (o *AES_Type) SetBLOCK_MODE(value uint32) {
	volatile.StoreUint32(&o.BLOCK_MODE.Reg, volatile.LoadUint32(&o.BLOCK_MODE.Reg)&^(0x7)|value)
}
func (o *AES_Type) GetBLOCK_MODE() uint32 {
	return volatile.LoadUint32(&o.BLOCK_MODE.Reg) & 0x7
}

// AES.BLOCK_NUM: Block number configuration register
func (o *AES_Type) SetBLOCK_NUM(value uint32) {
	volatile.StoreUint32(&o.BLOCK_NUM.Reg, value)
}
func (o *AES_Type) GetBLOCK_NUM() uint32 {
	return volatile.LoadUint32(&o.BLOCK_NUM.Reg)
}

// AES.INC_SEL: Standard incrementing function register
func (o *AES_Type) SetINC_SEL(value uint32) {
	volatile.StoreUint32(&o.INC_SEL.Reg, volatile.LoadUint32(&o.INC_SEL.Reg)&^(0x1)|value)
}
func (o *AES_Type) GetINC_SEL() uint32 {
	return volatile.LoadUint32(&o.INC_SEL.Reg) & 0x1
}

// AES.AAD_BLOCK_NUM: AAD block number configuration register
func (o *AES_Type) SetAAD_BLOCK_NUM(value uint32) {
	volatile.StoreUint32(&o.AAD_BLOCK_NUM.Reg, value)
}
func (o *AES_Type) GetAAD_BLOCK_NUM() uint32 {
	return volatile.LoadUint32(&o.AAD_BLOCK_NUM.Reg)
}

// AES.REMAINDER_BIT_NUM: Remainder bit number of plaintext/ciphertext
func (o *AES_Type) SetREMAINDER_BIT_NUM(value uint32) {
	volatile.StoreUint32(&o.REMAINDER_BIT_NUM.Reg, volatile.LoadUint32(&o.REMAINDER_BIT_NUM.Reg)&^(0x7f)|value)
}
func (o *AES_Type) GetREMAINDER_BIT_NUM() uint32 {
	return volatile.LoadUint32(&o.REMAINDER_BIT_NUM.Reg) & 0x7f
}

// AES.CONTINUE_OP: Operation continue controlling register
func (o *AES_Type) SetCONTINUE_OP(value uint32) {
	volatile.StoreUint32(&o.CONTINUE_OP.Reg, volatile.LoadUint32(&o.CONTINUE_OP.Reg)&^(0x1)|value)
}
func (o *AES_Type) GetCONTINUE_OP() uint32 {
	return volatile.LoadUint32(&o.CONTINUE_OP.Reg) & 0x1
}

// AES.INT_CLR: DMA-AES interrupt clear register
func (o *AES_Type) SetINT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x1)|value)
}
func (o *AES_Type) GetINT_CLR() uint32 {
	return volatile.LoadUint32(&o.INT_CLR.Reg) & 0x1
}

// AES.INT_ENA: DMA-AES interrupt enable register
func (o *AES_Type) SetINT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x1)|value)
}
func (o *AES_Type) GetINT_ENA() uint32 {
	return volatile.LoadUint32(&o.INT_ENA.Reg) & 0x1
}

// AES.DATE: Version control register
func (o *AES_Type) SetDATE(value uint32) {
	volatile.StoreUint32(&o.DATE.Reg, volatile.LoadUint32(&o.DATE.Reg)&^(0x3fffffff)|value)
}
func (o *AES_Type) GetDATE() uint32 {
	return volatile.LoadUint32(&o.DATE.Reg) & 0x3fffffff
}

// AES.DMA_EXIT: Operation exit controlling register
func (o *AES_Type) SetDMA_EXIT(value uint32) {
	volatile.StoreUint32(&o.DMA_EXIT.Reg, volatile.LoadUint32(&o.DMA_EXIT.Reg)&^(0x1)|value)
}
func (o *AES_Type) GetDMA_EXIT() uint32 {
	return volatile.LoadUint32(&o.DMA_EXIT.Reg) & 0x1
}

// Peripheral APB_SARADC
type APB_SARADC_Type struct {
	CTRL           volatile.Register32 // 0x0
	CTRL2          volatile.Register32 // 0x4
	FSM            volatile.Register32 // 0x8
	FSM_WAIT       volatile.Register32 // 0xC
	SAR1_STATUS    volatile.Register32 // 0x10
	SAR2_STATUS    volatile.Register32 // 0x14
	SAR1_PATT_TAB1 volatile.Register32 // 0x18
	SAR1_PATT_TAB2 volatile.Register32 // 0x1C
	SAR1_PATT_TAB3 volatile.Register32 // 0x20
	SAR1_PATT_TAB4 volatile.Register32 // 0x24
	SAR2_PATT_TAB1 volatile.Register32 // 0x28
	SAR2_PATT_TAB2 volatile.Register32 // 0x2C
	SAR2_PATT_TAB3 volatile.Register32 // 0x30
	SAR2_PATT_TAB4 volatile.Register32 // 0x34
	ARB_CTRL       volatile.Register32 // 0x38
	FILTER_CTRL    volatile.Register32 // 0x3C
	FILTER_STATUS  volatile.Register32 // 0x40
	THRES_CTRL     volatile.Register32 // 0x44
	INT_ENA        volatile.Register32 // 0x48
	INT_RAW        volatile.Register32 // 0x4C
	INT_ST         volatile.Register32 // 0x50
	INT_CLR        volatile.Register32 // 0x54
	DMA_CONF       volatile.Register32 // 0x58
	CLKM_CONF      volatile.Register32 // 0x5C
	APB_DAC_CTRL   volatile.Register32 // 0x60
	_              [920]byte
	APB_CTRL_DATE  volatile.Register32 // 0x3FC
}

// APB_SARADC.CTRL: DIG ADC common configuration
func (o *APB_SARADC_Type) SetCTRL_START_FORCE(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x1)|value)
}
func (o *APB_SARADC_Type) GetCTRL_START_FORCE() uint32 {
	return volatile.LoadUint32(&o.CTRL.Reg) & 0x1
}
func (o *APB_SARADC_Type) SetCTRL_START(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x2)|value<<1)
}
func (o *APB_SARADC_Type) GetCTRL_START() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x2) >> 1
}
func (o *APB_SARADC_Type) SetCTRL_WORK_MODE(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x18)|value<<3)
}
func (o *APB_SARADC_Type) GetCTRL_WORK_MODE() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x18) >> 3
}
func (o *APB_SARADC_Type) SetCTRL_SAR_SEL(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x20)|value<<5)
}
func (o *APB_SARADC_Type) GetCTRL_SAR_SEL() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x20) >> 5
}
func (o *APB_SARADC_Type) SetCTRL_SAR_CLK_GATED(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x40)|value<<6)
}
func (o *APB_SARADC_Type) GetCTRL_SAR_CLK_GATED() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x40) >> 6
}
func (o *APB_SARADC_Type) SetCTRL_SAR_CLK_DIV(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x7f80)|value<<7)
}
func (o *APB_SARADC_Type) GetCTRL_SAR_CLK_DIV() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x7f80) >> 7
}
func (o *APB_SARADC_Type) SetCTRL_SAR1_PATT_LEN(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x78000)|value<<15)
}
func (o *APB_SARADC_Type) GetCTRL_SAR1_PATT_LEN() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x78000) >> 15
}
func (o *APB_SARADC_Type) SetCTRL_SAR2_PATT_LEN(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x780000)|value<<19)
}
func (o *APB_SARADC_Type) GetCTRL_SAR2_PATT_LEN() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x780000) >> 19
}
func (o *APB_SARADC_Type) SetCTRL_SAR1_PATT_P_CLEAR(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x800000)|value<<23)
}
func (o *APB_SARADC_Type) GetCTRL_SAR1_PATT_P_CLEAR() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x800000) >> 23
}
func (o *APB_SARADC_Type) SetCTRL_SAR2_PATT_P_CLEAR(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x1000000)|value<<24)
}
func (o *APB_SARADC_Type) GetCTRL_SAR2_PATT_P_CLEAR() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x1000000) >> 24
}
func (o *APB_SARADC_Type) SetCTRL_DATA_SAR_SEL(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x2000000)|value<<25)
}
func (o *APB_SARADC_Type) GetCTRL_DATA_SAR_SEL() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x2000000) >> 25
}
func (o *APB_SARADC_Type) SetCTRL_DATA_TO_I2S(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x4000000)|value<<26)
}
func (o *APB_SARADC_Type) GetCTRL_DATA_TO_I2S() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x4000000) >> 26
}
func (o *APB_SARADC_Type) SetCTRL_XPD_SAR_FORCE(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x18000000)|value<<27)
}
func (o *APB_SARADC_Type) GetCTRL_XPD_SAR_FORCE() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x18000000) >> 27
}
func (o *APB_SARADC_Type) SetCTRL_WAIT_ARB_CYCLE(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0xc0000000)|value<<30)
}
func (o *APB_SARADC_Type) GetCTRL_WAIT_ARB_CYCLE() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0xc0000000) >> 30
}

// APB_SARADC.CTRL2: DIG ADC common configuration
func (o *APB_SARADC_Type) SetCTRL2_MEAS_NUM_LIMIT(value uint32) {
	volatile.StoreUint32(&o.CTRL2.Reg, volatile.LoadUint32(&o.CTRL2.Reg)&^(0x1)|value)
}
func (o *APB_SARADC_Type) GetCTRL2_MEAS_NUM_LIMIT() uint32 {
	return volatile.LoadUint32(&o.CTRL2.Reg) & 0x1
}
func (o *APB_SARADC_Type) SetCTRL2_MAX_MEAS_NUM(value uint32) {
	volatile.StoreUint32(&o.CTRL2.Reg, volatile.LoadUint32(&o.CTRL2.Reg)&^(0x1fe)|value<<1)
}
func (o *APB_SARADC_Type) GetCTRL2_MAX_MEAS_NUM() uint32 {
	return (volatile.LoadUint32(&o.CTRL2.Reg) & 0x1fe) >> 1
}
func (o *APB_SARADC_Type) SetCTRL2_SAR1_INV(value uint32) {
	volatile.StoreUint32(&o.CTRL2.Reg, volatile.LoadUint32(&o.CTRL2.Reg)&^(0x200)|value<<9)
}
func (o *APB_SARADC_Type) GetCTRL2_SAR1_INV() uint32 {
	return (volatile.LoadUint32(&o.CTRL2.Reg) & 0x200) >> 9
}
func (o *APB_SARADC_Type) SetCTRL2_SAR2_INV(value uint32) {
	volatile.StoreUint32(&o.CTRL2.Reg, volatile.LoadUint32(&o.CTRL2.Reg)&^(0x400)|value<<10)
}
func (o *APB_SARADC_Type) GetCTRL2_SAR2_INV() uint32 {
	return (volatile.LoadUint32(&o.CTRL2.Reg) & 0x400) >> 10
}
func (o *APB_SARADC_Type) SetCTRL2_TIMER_SEL(value uint32) {
	volatile.StoreUint32(&o.CTRL2.Reg, volatile.LoadUint32(&o.CTRL2.Reg)&^(0x800)|value<<11)
}
func (o *APB_SARADC_Type) GetCTRL2_TIMER_SEL() uint32 {
	return (volatile.LoadUint32(&o.CTRL2.Reg) & 0x800) >> 11
}
func (o *APB_SARADC_Type) SetCTRL2_TIMER_TARGET(value uint32) {
	volatile.StoreUint32(&o.CTRL2.Reg, volatile.LoadUint32(&o.CTRL2.Reg)&^(0xfff000)|value<<12)
}
func (o *APB_SARADC_Type) GetCTRL2_TIMER_TARGET() uint32 {
	return (volatile.LoadUint32(&o.CTRL2.Reg) & 0xfff000) >> 12
}
func (o *APB_SARADC_Type) SetCTRL2_TIMER_EN(value uint32) {
	volatile.StoreUint32(&o.CTRL2.Reg, volatile.LoadUint32(&o.CTRL2.Reg)&^(0x1000000)|value<<24)
}
func (o *APB_SARADC_Type) GetCTRL2_TIMER_EN() uint32 {
	return (volatile.LoadUint32(&o.CTRL2.Reg) & 0x1000000) >> 24
}

// APB_SARADC.FSM: digital adc control register
func (o *APB_SARADC_Type) SetFSM_SAMPLE_NUM(value uint32) {
	volatile.StoreUint32(&o.FSM.Reg, volatile.LoadUint32(&o.FSM.Reg)&^(0xff0000)|value<<16)
}
func (o *APB_SARADC_Type) GetFSM_SAMPLE_NUM() uint32 {
	return (volatile.LoadUint32(&o.FSM.Reg) & 0xff0000) >> 16
}
func (o *APB_SARADC_Type) SetFSM_SAMPLE_CYCLE(value uint32) {
	volatile.StoreUint32(&o.FSM.Reg, volatile.LoadUint32(&o.FSM.Reg)&^(0xff000000)|value<<24)
}
func (o *APB_SARADC_Type) GetFSM_SAMPLE_CYCLE() uint32 {
	return (volatile.LoadUint32(&o.FSM.Reg) & 0xff000000) >> 24
}

// APB_SARADC.FSM_WAIT: configure saradc fsm internal parameter base on test
func (o *APB_SARADC_Type) SetFSM_WAIT_XPD_WAIT(value uint32) {
	volatile.StoreUint32(&o.FSM_WAIT.Reg, volatile.LoadUint32(&o.FSM_WAIT.Reg)&^(0xff)|value)
}
func (o *APB_SARADC_Type) GetFSM_WAIT_XPD_WAIT() uint32 {
	return volatile.LoadUint32(&o.FSM_WAIT.Reg) & 0xff
}
func (o *APB_SARADC_Type) SetFSM_WAIT_RSTB_WAIT(value uint32) {
	volatile.StoreUint32(&o.FSM_WAIT.Reg, volatile.LoadUint32(&o.FSM_WAIT.Reg)&^(0xff00)|value<<8)
}
func (o *APB_SARADC_Type) GetFSM_WAIT_RSTB_WAIT() uint32 {
	return (volatile.LoadUint32(&o.FSM_WAIT.Reg) & 0xff00) >> 8
}
func (o *APB_SARADC_Type) SetFSM_WAIT_STANDBY_WAIT(value uint32) {
	volatile.StoreUint32(&o.FSM_WAIT.Reg, volatile.LoadUint32(&o.FSM_WAIT.Reg)&^(0xff0000)|value<<16)
}
func (o *APB_SARADC_Type) GetFSM_WAIT_STANDBY_WAIT() uint32 {
	return (volatile.LoadUint32(&o.FSM_WAIT.Reg) & 0xff0000) >> 16
}

// APB_SARADC.SAR1_STATUS: digital adc1 status
func (o *APB_SARADC_Type) SetSAR1_STATUS(value uint32) {
	volatile.StoreUint32(&o.SAR1_STATUS.Reg, value)
}
func (o *APB_SARADC_Type) GetSAR1_STATUS() uint32 {
	return volatile.LoadUint32(&o.SAR1_STATUS.Reg)
}

// APB_SARADC.SAR2_STATUS: digital adc2 status
func (o *APB_SARADC_Type) SetSAR2_STATUS(value uint32) {
	volatile.StoreUint32(&o.SAR2_STATUS.Reg, value)
}
func (o *APB_SARADC_Type) GetSAR2_STATUS() uint32 {
	return volatile.LoadUint32(&o.SAR2_STATUS.Reg)
}

// APB_SARADC.SAR1_PATT_TAB1: item 0 ~ 3 for pattern table 1 (each item one byte)
func (o *APB_SARADC_Type) SetSAR1_PATT_TAB1(value uint32) {
	volatile.StoreUint32(&o.SAR1_PATT_TAB1.Reg, value)
}
func (o *APB_SARADC_Type) GetSAR1_PATT_TAB1() uint32 {
	return volatile.LoadUint32(&o.SAR1_PATT_TAB1.Reg)
}

// APB_SARADC.SAR1_PATT_TAB2: Item 4 ~ 7 for pattern table 1 (each item one byte)
func (o *APB_SARADC_Type) SetSAR1_PATT_TAB2(value uint32) {
	volatile.StoreUint32(&o.SAR1_PATT_TAB2.Reg, value)
}
func (o *APB_SARADC_Type) GetSAR1_PATT_TAB2() uint32 {
	return volatile.LoadUint32(&o.SAR1_PATT_TAB2.Reg)
}

// APB_SARADC.SAR1_PATT_TAB3: Item 8 ~ 11 for pattern table 1 (each item one byte)
func (o *APB_SARADC_Type) SetSAR1_PATT_TAB3(value uint32) {
	volatile.StoreUint32(&o.SAR1_PATT_TAB3.Reg, value)
}
func (o *APB_SARADC_Type) GetSAR1_PATT_TAB3() uint32 {
	return volatile.LoadUint32(&o.SAR1_PATT_TAB3.Reg)
}

// APB_SARADC.SAR1_PATT_TAB4: Item 12 ~ 15 for pattern table 1 (each item one byte)
func (o *APB_SARADC_Type) SetSAR1_PATT_TAB4(value uint32) {
	volatile.StoreUint32(&o.SAR1_PATT_TAB4.Reg, value)
}
func (o *APB_SARADC_Type) GetSAR1_PATT_TAB4() uint32 {
	return volatile.LoadUint32(&o.SAR1_PATT_TAB4.Reg)
}

// APB_SARADC.SAR2_PATT_TAB1: item 0 ~ 3 for pattern table 2 (each item one byte)
func (o *APB_SARADC_Type) SetSAR2_PATT_TAB1(value uint32) {
	volatile.StoreUint32(&o.SAR2_PATT_TAB1.Reg, value)
}
func (o *APB_SARADC_Type) GetSAR2_PATT_TAB1() uint32 {
	return volatile.LoadUint32(&o.SAR2_PATT_TAB1.Reg)
}

// APB_SARADC.SAR2_PATT_TAB2: Item 4 ~ 7 for pattern table 2 (each item one byte)
func (o *APB_SARADC_Type) SetSAR2_PATT_TAB2(value uint32) {
	volatile.StoreUint32(&o.SAR2_PATT_TAB2.Reg, value)
}
func (o *APB_SARADC_Type) GetSAR2_PATT_TAB2() uint32 {
	return volatile.LoadUint32(&o.SAR2_PATT_TAB2.Reg)
}

// APB_SARADC.SAR2_PATT_TAB3: Item 8 ~ 11 for pattern table 2 (each item one byte)
func (o *APB_SARADC_Type) SetSAR2_PATT_TAB3(value uint32) {
	volatile.StoreUint32(&o.SAR2_PATT_TAB3.Reg, value)
}
func (o *APB_SARADC_Type) GetSAR2_PATT_TAB3() uint32 {
	return volatile.LoadUint32(&o.SAR2_PATT_TAB3.Reg)
}

// APB_SARADC.SAR2_PATT_TAB4: Item 12 ~ 15 for pattern table 2 (each item one byte)
func (o *APB_SARADC_Type) SetSAR2_PATT_TAB4(value uint32) {
	volatile.StoreUint32(&o.SAR2_PATT_TAB4.Reg, value)
}
func (o *APB_SARADC_Type) GetSAR2_PATT_TAB4() uint32 {
	return volatile.LoadUint32(&o.SAR2_PATT_TAB4.Reg)
}

// APB_SARADC.ARB_CTRL: Configure the settings of DIG ADC2 arbiter
func (o *APB_SARADC_Type) SetARB_CTRL_ADC_ARB_APB_FORCE(value uint32) {
	volatile.StoreUint32(&o.ARB_CTRL.Reg, volatile.LoadUint32(&o.ARB_CTRL.Reg)&^(0x4)|value<<2)
}
func (o *APB_SARADC_Type) GetARB_CTRL_ADC_ARB_APB_FORCE() uint32 {
	return (volatile.LoadUint32(&o.ARB_CTRL.Reg) & 0x4) >> 2
}
func (o *APB_SARADC_Type) SetARB_CTRL_ADC_ARB_RTC_FORCE(value uint32) {
	volatile.StoreUint32(&o.ARB_CTRL.Reg, volatile.LoadUint32(&o.ARB_CTRL.Reg)&^(0x8)|value<<3)
}
func (o *APB_SARADC_Type) GetARB_CTRL_ADC_ARB_RTC_FORCE() uint32 {
	return (volatile.LoadUint32(&o.ARB_CTRL.Reg) & 0x8) >> 3
}
func (o *APB_SARADC_Type) SetARB_CTRL_ADC_ARB_WIFI_FORCE(value uint32) {
	volatile.StoreUint32(&o.ARB_CTRL.Reg, volatile.LoadUint32(&o.ARB_CTRL.Reg)&^(0x10)|value<<4)
}
func (o *APB_SARADC_Type) GetARB_CTRL_ADC_ARB_WIFI_FORCE() uint32 {
	return (volatile.LoadUint32(&o.ARB_CTRL.Reg) & 0x10) >> 4
}
func (o *APB_SARADC_Type) SetARB_CTRL_ADC_ARB_GRANT_FORCE(value uint32) {
	volatile.StoreUint32(&o.ARB_CTRL.Reg, volatile.LoadUint32(&o.ARB_CTRL.Reg)&^(0x20)|value<<5)
}
func (o *APB_SARADC_Type) GetARB_CTRL_ADC_ARB_GRANT_FORCE() uint32 {
	return (volatile.LoadUint32(&o.ARB_CTRL.Reg) & 0x20) >> 5
}
func (o *APB_SARADC_Type) SetARB_CTRL_ADC_ARB_APB_PRIORITY(value uint32) {
	volatile.StoreUint32(&o.ARB_CTRL.Reg, volatile.LoadUint32(&o.ARB_CTRL.Reg)&^(0xc0)|value<<6)
}
func (o *APB_SARADC_Type) GetARB_CTRL_ADC_ARB_APB_PRIORITY() uint32 {
	return (volatile.LoadUint32(&o.ARB_CTRL.Reg) & 0xc0) >> 6
}
func (o *APB_SARADC_Type) SetARB_CTRL_ADC_ARB_RTC_PRIORITY(value uint32) {
	volatile.StoreUint32(&o.ARB_CTRL.Reg, volatile.LoadUint32(&o.ARB_CTRL.Reg)&^(0x300)|value<<8)
}
func (o *APB_SARADC_Type) GetARB_CTRL_ADC_ARB_RTC_PRIORITY() uint32 {
	return (volatile.LoadUint32(&o.ARB_CTRL.Reg) & 0x300) >> 8
}
func (o *APB_SARADC_Type) SetARB_CTRL_ADC_ARB_WIFI_PRIORITY(value uint32) {
	volatile.StoreUint32(&o.ARB_CTRL.Reg, volatile.LoadUint32(&o.ARB_CTRL.Reg)&^(0xc00)|value<<10)
}
func (o *APB_SARADC_Type) GetARB_CTRL_ADC_ARB_WIFI_PRIORITY() uint32 {
	return (volatile.LoadUint32(&o.ARB_CTRL.Reg) & 0xc00) >> 10
}
func (o *APB_SARADC_Type) SetARB_CTRL_ADC_ARB_FIX_PRIORITY(value uint32) {
	volatile.StoreUint32(&o.ARB_CTRL.Reg, volatile.LoadUint32(&o.ARB_CTRL.Reg)&^(0x1000)|value<<12)
}
func (o *APB_SARADC_Type) GetARB_CTRL_ADC_ARB_FIX_PRIORITY() uint32 {
	return (volatile.LoadUint32(&o.ARB_CTRL.Reg) & 0x1000) >> 12
}

// APB_SARADC.FILTER_CTRL: Configure the settings of DIG ADC2 filter
func (o *APB_SARADC_Type) SetFILTER_CTRL_ADC2_FILTER_RESET(value uint32) {
	volatile.StoreUint32(&o.FILTER_CTRL.Reg, volatile.LoadUint32(&o.FILTER_CTRL.Reg)&^(0x1)|value)
}
func (o *APB_SARADC_Type) GetFILTER_CTRL_ADC2_FILTER_RESET() uint32 {
	return volatile.LoadUint32(&o.FILTER_CTRL.Reg) & 0x1
}
func (o *APB_SARADC_Type) SetFILTER_CTRL_ADC1_FILTER_RESET(value uint32) {
	volatile.StoreUint32(&o.FILTER_CTRL.Reg, volatile.LoadUint32(&o.FILTER_CTRL.Reg)&^(0x2)|value<<1)
}
func (o *APB_SARADC_Type) GetFILTER_CTRL_ADC1_FILTER_RESET() uint32 {
	return (volatile.LoadUint32(&o.FILTER_CTRL.Reg) & 0x2) >> 1
}
func (o *APB_SARADC_Type) SetFILTER_CTRL_ADC2_FILTER_FACTOR(value uint32) {
	volatile.StoreUint32(&o.FILTER_CTRL.Reg, volatile.LoadUint32(&o.FILTER_CTRL.Reg)&^(0x7f0000)|value<<16)
}
func (o *APB_SARADC_Type) GetFILTER_CTRL_ADC2_FILTER_FACTOR() uint32 {
	return (volatile.LoadUint32(&o.FILTER_CTRL.Reg) & 0x7f0000) >> 16
}
func (o *APB_SARADC_Type) SetFILTER_CTRL_ADC1_FILTER_FACTOR(value uint32) {
	volatile.StoreUint32(&o.FILTER_CTRL.Reg, volatile.LoadUint32(&o.FILTER_CTRL.Reg)&^(0x3f800000)|value<<23)
}
func (o *APB_SARADC_Type) GetFILTER_CTRL_ADC1_FILTER_FACTOR() uint32 {
	return (volatile.LoadUint32(&o.FILTER_CTRL.Reg) & 0x3f800000) >> 23
}
func (o *APB_SARADC_Type) SetFILTER_CTRL_ADC2_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.FILTER_CTRL.Reg, volatile.LoadUint32(&o.FILTER_CTRL.Reg)&^(0x40000000)|value<<30)
}
func (o *APB_SARADC_Type) GetFILTER_CTRL_ADC2_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.FILTER_CTRL.Reg) & 0x40000000) >> 30
}
func (o *APB_SARADC_Type) SetFILTER_CTRL_ADC1_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.FILTER_CTRL.Reg, volatile.LoadUint32(&o.FILTER_CTRL.Reg)&^(0x80000000)|value<<31)
}
func (o *APB_SARADC_Type) GetFILTER_CTRL_ADC1_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.FILTER_CTRL.Reg) & 0x80000000) >> 31
}

// APB_SARADC.FILTER_STATUS: Data status of DIG ADC2 filter
func (o *APB_SARADC_Type) SetFILTER_STATUS_ADC2_FILTER_DATA(value uint32) {
	volatile.StoreUint32(&o.FILTER_STATUS.Reg, volatile.LoadUint32(&o.FILTER_STATUS.Reg)&^(0xffff)|value)
}
func (o *APB_SARADC_Type) GetFILTER_STATUS_ADC2_FILTER_DATA() uint32 {
	return volatile.LoadUint32(&o.FILTER_STATUS.Reg) & 0xffff
}
func (o *APB_SARADC_Type) SetFILTER_STATUS_ADC1_FILTER_DATA(value uint32) {
	volatile.StoreUint32(&o.FILTER_STATUS.Reg, volatile.LoadUint32(&o.FILTER_STATUS.Reg)&^(0xffff0000)|value<<16)
}
func (o *APB_SARADC_Type) GetFILTER_STATUS_ADC1_FILTER_DATA() uint32 {
	return (volatile.LoadUint32(&o.FILTER_STATUS.Reg) & 0xffff0000) >> 16
}

// APB_SARADC.THRES_CTRL: Configure monitor threshold for DIG ADC2
func (o *APB_SARADC_Type) SetTHRES_CTRL_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.THRES_CTRL.Reg, volatile.LoadUint32(&o.THRES_CTRL.Reg)&^(0x1)|value)
}
func (o *APB_SARADC_Type) GetTHRES_CTRL_CLK_EN() uint32 {
	return volatile.LoadUint32(&o.THRES_CTRL.Reg) & 0x1
}
func (o *APB_SARADC_Type) SetTHRES_CTRL_ADC2_THRES_MODE(value uint32) {
	volatile.StoreUint32(&o.THRES_CTRL.Reg, volatile.LoadUint32(&o.THRES_CTRL.Reg)&^(0x4)|value<<2)
}
func (o *APB_SARADC_Type) GetTHRES_CTRL_ADC2_THRES_MODE() uint32 {
	return (volatile.LoadUint32(&o.THRES_CTRL.Reg) & 0x4) >> 2
}
func (o *APB_SARADC_Type) SetTHRES_CTRL_ADC1_THRES_MODE(value uint32) {
	volatile.StoreUint32(&o.THRES_CTRL.Reg, volatile.LoadUint32(&o.THRES_CTRL.Reg)&^(0x8)|value<<3)
}
func (o *APB_SARADC_Type) GetTHRES_CTRL_ADC1_THRES_MODE() uint32 {
	return (volatile.LoadUint32(&o.THRES_CTRL.Reg) & 0x8) >> 3
}
func (o *APB_SARADC_Type) SetTHRES_CTRL_ADC2_THRES(value uint32) {
	volatile.StoreUint32(&o.THRES_CTRL.Reg, volatile.LoadUint32(&o.THRES_CTRL.Reg)&^(0x1fff0)|value<<4)
}
func (o *APB_SARADC_Type) GetTHRES_CTRL_ADC2_THRES() uint32 {
	return (volatile.LoadUint32(&o.THRES_CTRL.Reg) & 0x1fff0) >> 4
}
func (o *APB_SARADC_Type) SetTHRES_CTRL_ADC1_THRES(value uint32) {
	volatile.StoreUint32(&o.THRES_CTRL.Reg, volatile.LoadUint32(&o.THRES_CTRL.Reg)&^(0x3ffe0000)|value<<17)
}
func (o *APB_SARADC_Type) GetTHRES_CTRL_ADC1_THRES() uint32 {
	return (volatile.LoadUint32(&o.THRES_CTRL.Reg) & 0x3ffe0000) >> 17
}
func (o *APB_SARADC_Type) SetTHRES_CTRL_ADC2_THRES_EN(value uint32) {
	volatile.StoreUint32(&o.THRES_CTRL.Reg, volatile.LoadUint32(&o.THRES_CTRL.Reg)&^(0x40000000)|value<<30)
}
func (o *APB_SARADC_Type) GetTHRES_CTRL_ADC2_THRES_EN() uint32 {
	return (volatile.LoadUint32(&o.THRES_CTRL.Reg) & 0x40000000) >> 30
}
func (o *APB_SARADC_Type) SetTHRES_CTRL_ADC1_THRES_EN(value uint32) {
	volatile.StoreUint32(&o.THRES_CTRL.Reg, volatile.LoadUint32(&o.THRES_CTRL.Reg)&^(0x80000000)|value<<31)
}
func (o *APB_SARADC_Type) GetTHRES_CTRL_ADC1_THRES_EN() uint32 {
	return (volatile.LoadUint32(&o.THRES_CTRL.Reg) & 0x80000000) >> 31
}

// APB_SARADC.INT_ENA: Enable DIG ADC interrupts
func (o *APB_SARADC_Type) SetINT_ENA_ADC2_THRES_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x10000000)|value<<28)
}
func (o *APB_SARADC_Type) GetINT_ENA_ADC2_THRES_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x10000000) >> 28
}
func (o *APB_SARADC_Type) SetINT_ENA_ADC1_THRES_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x20000000)|value<<29)
}
func (o *APB_SARADC_Type) GetINT_ENA_ADC1_THRES_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x20000000) >> 29
}
func (o *APB_SARADC_Type) SetINT_ENA_ADC2_DONE_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x40000000)|value<<30)
}
func (o *APB_SARADC_Type) GetINT_ENA_ADC2_DONE_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x40000000) >> 30
}
func (o *APB_SARADC_Type) SetINT_ENA_ADC1_DONE_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x80000000)|value<<31)
}
func (o *APB_SARADC_Type) GetINT_ENA_ADC1_DONE_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x80000000) >> 31
}

// APB_SARADC.INT_RAW: DIG ADC interrupt raw bits
func (o *APB_SARADC_Type) SetINT_RAW_ADC2_THRES_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x10000000)|value<<28)
}
func (o *APB_SARADC_Type) GetINT_RAW_ADC2_THRES_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x10000000) >> 28
}
func (o *APB_SARADC_Type) SetINT_RAW_ADC1_THRES_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x20000000)|value<<29)
}
func (o *APB_SARADC_Type) GetINT_RAW_ADC1_THRES_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x20000000) >> 29
}
func (o *APB_SARADC_Type) SetINT_RAW_ADC2_DONE_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x40000000)|value<<30)
}
func (o *APB_SARADC_Type) GetINT_RAW_ADC2_DONE_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x40000000) >> 30
}
func (o *APB_SARADC_Type) SetINT_RAW_ADC1_DONE_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x80000000)|value<<31)
}
func (o *APB_SARADC_Type) GetINT_RAW_ADC1_DONE_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x80000000) >> 31
}

// APB_SARADC.INT_ST: DIG ADC interrupt status
func (o *APB_SARADC_Type) SetINT_ST_ADC2_THRES_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x10000000)|value<<28)
}
func (o *APB_SARADC_Type) GetINT_ST_ADC2_THRES_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x10000000) >> 28
}
func (o *APB_SARADC_Type) SetINT_ST_ADC1_THRES_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x20000000)|value<<29)
}
func (o *APB_SARADC_Type) GetINT_ST_ADC1_THRES_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x20000000) >> 29
}
func (o *APB_SARADC_Type) SetINT_ST_ADC2_DONE_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x40000000)|value<<30)
}
func (o *APB_SARADC_Type) GetINT_ST_ADC2_DONE_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x40000000) >> 30
}
func (o *APB_SARADC_Type) SetINT_ST_ADC1_DONE_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x80000000)|value<<31)
}
func (o *APB_SARADC_Type) GetINT_ST_ADC1_DONE_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x80000000) >> 31
}

// APB_SARADC.INT_CLR: Clear DIG ADC interrupts
func (o *APB_SARADC_Type) SetINT_CLR_ADC2_THRES_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x10000000)|value<<28)
}
func (o *APB_SARADC_Type) GetINT_CLR_ADC2_THRES_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x10000000) >> 28
}
func (o *APB_SARADC_Type) SetINT_CLR_ADC1_THRES_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x20000000)|value<<29)
}
func (o *APB_SARADC_Type) GetINT_CLR_ADC1_THRES_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x20000000) >> 29
}
func (o *APB_SARADC_Type) SetINT_CLR_ADC2_DONE_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x40000000)|value<<30)
}
func (o *APB_SARADC_Type) GetINT_CLR_ADC2_DONE_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x40000000) >> 30
}
func (o *APB_SARADC_Type) SetINT_CLR_ADC1_DONE_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x80000000)|value<<31)
}
func (o *APB_SARADC_Type) GetINT_CLR_ADC1_DONE_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x80000000) >> 31
}

// APB_SARADC.DMA_CONF: Configure digital ADC DMA path
func (o *APB_SARADC_Type) SetDMA_CONF_APB_ADC_EOF_NUM(value uint32) {
	volatile.StoreUint32(&o.DMA_CONF.Reg, volatile.LoadUint32(&o.DMA_CONF.Reg)&^(0xffff)|value)
}
func (o *APB_SARADC_Type) GetDMA_CONF_APB_ADC_EOF_NUM() uint32 {
	return volatile.LoadUint32(&o.DMA_CONF.Reg) & 0xffff
}
func (o *APB_SARADC_Type) SetDMA_CONF_APB_ADC_RESET_FSM(value uint32) {
	volatile.StoreUint32(&o.DMA_CONF.Reg, volatile.LoadUint32(&o.DMA_CONF.Reg)&^(0x40000000)|value<<30)
}
func (o *APB_SARADC_Type) GetDMA_CONF_APB_ADC_RESET_FSM() uint32 {
	return (volatile.LoadUint32(&o.DMA_CONF.Reg) & 0x40000000) >> 30
}
func (o *APB_SARADC_Type) SetDMA_CONF_APB_ADC_TRANS(value uint32) {
	volatile.StoreUint32(&o.DMA_CONF.Reg, volatile.LoadUint32(&o.DMA_CONF.Reg)&^(0x80000000)|value<<31)
}
func (o *APB_SARADC_Type) GetDMA_CONF_APB_ADC_TRANS() uint32 {
	return (volatile.LoadUint32(&o.DMA_CONF.Reg) & 0x80000000) >> 31
}

// APB_SARADC.CLKM_CONF: Configure DIG ADC clock
func (o *APB_SARADC_Type) SetCLKM_CONF_CLKM_DIV_NUM(value uint32) {
	volatile.StoreUint32(&o.CLKM_CONF.Reg, volatile.LoadUint32(&o.CLKM_CONF.Reg)&^(0xff)|value)
}
func (o *APB_SARADC_Type) GetCLKM_CONF_CLKM_DIV_NUM() uint32 {
	return volatile.LoadUint32(&o.CLKM_CONF.Reg) & 0xff
}
func (o *APB_SARADC_Type) SetCLKM_CONF_CLKM_DIV_B(value uint32) {
	volatile.StoreUint32(&o.CLKM_CONF.Reg, volatile.LoadUint32(&o.CLKM_CONF.Reg)&^(0x3f00)|value<<8)
}
func (o *APB_SARADC_Type) GetCLKM_CONF_CLKM_DIV_B() uint32 {
	return (volatile.LoadUint32(&o.CLKM_CONF.Reg) & 0x3f00) >> 8
}
func (o *APB_SARADC_Type) SetCLKM_CONF_CLKM_DIV_A(value uint32) {
	volatile.StoreUint32(&o.CLKM_CONF.Reg, volatile.LoadUint32(&o.CLKM_CONF.Reg)&^(0xfc000)|value<<14)
}
func (o *APB_SARADC_Type) GetCLKM_CONF_CLKM_DIV_A() uint32 {
	return (volatile.LoadUint32(&o.CLKM_CONF.Reg) & 0xfc000) >> 14
}
func (o *APB_SARADC_Type) SetCLKM_CONF_CLK_SEL(value uint32) {
	volatile.StoreUint32(&o.CLKM_CONF.Reg, volatile.LoadUint32(&o.CLKM_CONF.Reg)&^(0x600000)|value<<21)
}
func (o *APB_SARADC_Type) GetCLKM_CONF_CLK_SEL() uint32 {
	return (volatile.LoadUint32(&o.CLKM_CONF.Reg) & 0x600000) >> 21
}

// APB_SARADC.APB_DAC_CTRL: Configure DAC settings
func (o *APB_SARADC_Type) SetAPB_DAC_CTRL_DAC_TIMER_TARGET(value uint32) {
	volatile.StoreUint32(&o.APB_DAC_CTRL.Reg, volatile.LoadUint32(&o.APB_DAC_CTRL.Reg)&^(0xfff)|value)
}
func (o *APB_SARADC_Type) GetAPB_DAC_CTRL_DAC_TIMER_TARGET() uint32 {
	return volatile.LoadUint32(&o.APB_DAC_CTRL.Reg) & 0xfff
}
func (o *APB_SARADC_Type) SetAPB_DAC_CTRL_DAC_TIMER_EN(value uint32) {
	volatile.StoreUint32(&o.APB_DAC_CTRL.Reg, volatile.LoadUint32(&o.APB_DAC_CTRL.Reg)&^(0x1000)|value<<12)
}
func (o *APB_SARADC_Type) GetAPB_DAC_CTRL_DAC_TIMER_EN() uint32 {
	return (volatile.LoadUint32(&o.APB_DAC_CTRL.Reg) & 0x1000) >> 12
}
func (o *APB_SARADC_Type) SetAPB_DAC_CTRL_APB_DAC_ALTER_MODE(value uint32) {
	volatile.StoreUint32(&o.APB_DAC_CTRL.Reg, volatile.LoadUint32(&o.APB_DAC_CTRL.Reg)&^(0x2000)|value<<13)
}
func (o *APB_SARADC_Type) GetAPB_DAC_CTRL_APB_DAC_ALTER_MODE() uint32 {
	return (volatile.LoadUint32(&o.APB_DAC_CTRL.Reg) & 0x2000) >> 13
}
func (o *APB_SARADC_Type) SetAPB_DAC_CTRL_APB_DAC_TRANS(value uint32) {
	volatile.StoreUint32(&o.APB_DAC_CTRL.Reg, volatile.LoadUint32(&o.APB_DAC_CTRL.Reg)&^(0x4000)|value<<14)
}
func (o *APB_SARADC_Type) GetAPB_DAC_CTRL_APB_DAC_TRANS() uint32 {
	return (volatile.LoadUint32(&o.APB_DAC_CTRL.Reg) & 0x4000) >> 14
}
func (o *APB_SARADC_Type) SetAPB_DAC_CTRL_DAC_RESET_FIFO(value uint32) {
	volatile.StoreUint32(&o.APB_DAC_CTRL.Reg, volatile.LoadUint32(&o.APB_DAC_CTRL.Reg)&^(0x8000)|value<<15)
}
func (o *APB_SARADC_Type) GetAPB_DAC_CTRL_DAC_RESET_FIFO() uint32 {
	return (volatile.LoadUint32(&o.APB_DAC_CTRL.Reg) & 0x8000) >> 15
}
func (o *APB_SARADC_Type) SetAPB_DAC_CTRL_APB_DAC_RST(value uint32) {
	volatile.StoreUint32(&o.APB_DAC_CTRL.Reg, volatile.LoadUint32(&o.APB_DAC_CTRL.Reg)&^(0x10000)|value<<16)
}
func (o *APB_SARADC_Type) GetAPB_DAC_CTRL_APB_DAC_RST() uint32 {
	return (volatile.LoadUint32(&o.APB_DAC_CTRL.Reg) & 0x10000) >> 16
}

// APB_SARADC.APB_CTRL_DATE: Version control register
func (o *APB_SARADC_Type) SetAPB_CTRL_DATE(value uint32) {
	volatile.StoreUint32(&o.APB_CTRL_DATE.Reg, value)
}
func (o *APB_SARADC_Type) GetAPB_CTRL_DATE() uint32 {
	return volatile.LoadUint32(&o.APB_CTRL_DATE.Reg)
}

// Peripheral DEDICATED_GPIO
type DEDICATED_GPIO_Type struct {
	OUT_DRT   volatile.Register32 // 0x0
	OUT_MSK   volatile.Register32 // 0x4
	OUT_IDV   volatile.Register32 // 0x8
	OUT_SCAN  volatile.Register32 // 0xC
	OUT_CPU   volatile.Register32 // 0x10
	IN_DLY    volatile.Register32 // 0x14
	IN_SCAN   volatile.Register32 // 0x18
	INTR_RCGN volatile.Register32 // 0x1C
	INTR_RAW  volatile.Register32 // 0x20
	INTR_RLS  volatile.Register32 // 0x24
	INTR_ST   volatile.Register32 // 0x28
	INTR_CLR  volatile.Register32 // 0x2C
}

// DEDICATED_GPIO.OUT_DRT: Dedicated GPIO Directive Output register
func (o *DEDICATED_GPIO_Type) SetOUT_DRT_VLAUE(value uint32) {
	volatile.StoreUint32(&o.OUT_DRT.Reg, volatile.LoadUint32(&o.OUT_DRT.Reg)&^(0xff)|value)
}
func (o *DEDICATED_GPIO_Type) GetOUT_DRT_VLAUE() uint32 {
	return volatile.LoadUint32(&o.OUT_DRT.Reg) & 0xff
}

// DEDICATED_GPIO.OUT_MSK: Dedicated GPIO Mask Output register
func (o *DEDICATED_GPIO_Type) SetOUT_MSK_OUT_VALUE(value uint32) {
	volatile.StoreUint32(&o.OUT_MSK.Reg, volatile.LoadUint32(&o.OUT_MSK.Reg)&^(0xff)|value)
}
func (o *DEDICATED_GPIO_Type) GetOUT_MSK_OUT_VALUE() uint32 {
	return volatile.LoadUint32(&o.OUT_MSK.Reg) & 0xff
}
func (o *DEDICATED_GPIO_Type) SetOUT_MSK(value uint32) {
	volatile.StoreUint32(&o.OUT_MSK.Reg, volatile.LoadUint32(&o.OUT_MSK.Reg)&^(0xff00)|value<<8)
}
func (o *DEDICATED_GPIO_Type) GetOUT_MSK() uint32 {
	return (volatile.LoadUint32(&o.OUT_MSK.Reg) & 0xff00) >> 8
}

// DEDICATED_GPIO.OUT_IDV: Dedicated GPIO Individual Output register
func (o *DEDICATED_GPIO_Type) SetOUT_IDV_CH0(value uint32) {
	volatile.StoreUint32(&o.OUT_IDV.Reg, volatile.LoadUint32(&o.OUT_IDV.Reg)&^(0x3)|value)
}
func (o *DEDICATED_GPIO_Type) GetOUT_IDV_CH0() uint32 {
	return volatile.LoadUint32(&o.OUT_IDV.Reg) & 0x3
}
func (o *DEDICATED_GPIO_Type) SetOUT_IDV_CH1(value uint32) {
	volatile.StoreUint32(&o.OUT_IDV.Reg, volatile.LoadUint32(&o.OUT_IDV.Reg)&^(0xc)|value<<2)
}
func (o *DEDICATED_GPIO_Type) GetOUT_IDV_CH1() uint32 {
	return (volatile.LoadUint32(&o.OUT_IDV.Reg) & 0xc) >> 2
}
func (o *DEDICATED_GPIO_Type) SetOUT_IDV_CH2(value uint32) {
	volatile.StoreUint32(&o.OUT_IDV.Reg, volatile.LoadUint32(&o.OUT_IDV.Reg)&^(0x30)|value<<4)
}
func (o *DEDICATED_GPIO_Type) GetOUT_IDV_CH2() uint32 {
	return (volatile.LoadUint32(&o.OUT_IDV.Reg) & 0x30) >> 4
}
func (o *DEDICATED_GPIO_Type) SetOUT_IDV_CH3(value uint32) {
	volatile.StoreUint32(&o.OUT_IDV.Reg, volatile.LoadUint32(&o.OUT_IDV.Reg)&^(0xc0)|value<<6)
}
func (o *DEDICATED_GPIO_Type) GetOUT_IDV_CH3() uint32 {
	return (volatile.LoadUint32(&o.OUT_IDV.Reg) & 0xc0) >> 6
}
func (o *DEDICATED_GPIO_Type) SetOUT_IDV_CH4(value uint32) {
	volatile.StoreUint32(&o.OUT_IDV.Reg, volatile.LoadUint32(&o.OUT_IDV.Reg)&^(0x300)|value<<8)
}
func (o *DEDICATED_GPIO_Type) GetOUT_IDV_CH4() uint32 {
	return (volatile.LoadUint32(&o.OUT_IDV.Reg) & 0x300) >> 8
}
func (o *DEDICATED_GPIO_Type) SetOUT_IDV_CH5(value uint32) {
	volatile.StoreUint32(&o.OUT_IDV.Reg, volatile.LoadUint32(&o.OUT_IDV.Reg)&^(0xc00)|value<<10)
}
func (o *DEDICATED_GPIO_Type) GetOUT_IDV_CH5() uint32 {
	return (volatile.LoadUint32(&o.OUT_IDV.Reg) & 0xc00) >> 10
}
func (o *DEDICATED_GPIO_Type) SetOUT_IDV_CH6(value uint32) {
	volatile.StoreUint32(&o.OUT_IDV.Reg, volatile.LoadUint32(&o.OUT_IDV.Reg)&^(0x3000)|value<<12)
}
func (o *DEDICATED_GPIO_Type) GetOUT_IDV_CH6() uint32 {
	return (volatile.LoadUint32(&o.OUT_IDV.Reg) & 0x3000) >> 12
}
func (o *DEDICATED_GPIO_Type) SetOUT_IDV_CH7(value uint32) {
	volatile.StoreUint32(&o.OUT_IDV.Reg, volatile.LoadUint32(&o.OUT_IDV.Reg)&^(0xc000)|value<<14)
}
func (o *DEDICATED_GPIO_Type) GetOUT_IDV_CH7() uint32 {
	return (volatile.LoadUint32(&o.OUT_IDV.Reg) & 0xc000) >> 14
}

// DEDICATED_GPIO.OUT_SCAN: Dedicated GPIO Output Status register
func (o *DEDICATED_GPIO_Type) SetOUT_SCAN_OUT_STATUS(value uint32) {
	volatile.StoreUint32(&o.OUT_SCAN.Reg, volatile.LoadUint32(&o.OUT_SCAN.Reg)&^(0xff)|value)
}
func (o *DEDICATED_GPIO_Type) GetOUT_SCAN_OUT_STATUS() uint32 {
	return volatile.LoadUint32(&o.OUT_SCAN.Reg) & 0xff
}

// DEDICATED_GPIO.OUT_CPU: Dedicated GPIO Output Mode Select register
func (o *DEDICATED_GPIO_Type) SetOUT_CPU_SEL0(value uint32) {
	volatile.StoreUint32(&o.OUT_CPU.Reg, volatile.LoadUint32(&o.OUT_CPU.Reg)&^(0x1)|value)
}
func (o *DEDICATED_GPIO_Type) GetOUT_CPU_SEL0() uint32 {
	return volatile.LoadUint32(&o.OUT_CPU.Reg) & 0x1
}
func (o *DEDICATED_GPIO_Type) SetOUT_CPU_SEL1(value uint32) {
	volatile.StoreUint32(&o.OUT_CPU.Reg, volatile.LoadUint32(&o.OUT_CPU.Reg)&^(0x2)|value<<1)
}
func (o *DEDICATED_GPIO_Type) GetOUT_CPU_SEL1() uint32 {
	return (volatile.LoadUint32(&o.OUT_CPU.Reg) & 0x2) >> 1
}
func (o *DEDICATED_GPIO_Type) SetOUT_CPU_SEL2(value uint32) {
	volatile.StoreUint32(&o.OUT_CPU.Reg, volatile.LoadUint32(&o.OUT_CPU.Reg)&^(0x4)|value<<2)
}
func (o *DEDICATED_GPIO_Type) GetOUT_CPU_SEL2() uint32 {
	return (volatile.LoadUint32(&o.OUT_CPU.Reg) & 0x4) >> 2
}
func (o *DEDICATED_GPIO_Type) SetOUT_CPU_SEL3(value uint32) {
	volatile.StoreUint32(&o.OUT_CPU.Reg, volatile.LoadUint32(&o.OUT_CPU.Reg)&^(0x8)|value<<3)
}
func (o *DEDICATED_GPIO_Type) GetOUT_CPU_SEL3() uint32 {
	return (volatile.LoadUint32(&o.OUT_CPU.Reg) & 0x8) >> 3
}
func (o *DEDICATED_GPIO_Type) SetOUT_CPU_SEL4(value uint32) {
	volatile.StoreUint32(&o.OUT_CPU.Reg, volatile.LoadUint32(&o.OUT_CPU.Reg)&^(0x10)|value<<4)
}
func (o *DEDICATED_GPIO_Type) GetOUT_CPU_SEL4() uint32 {
	return (volatile.LoadUint32(&o.OUT_CPU.Reg) & 0x10) >> 4
}
func (o *DEDICATED_GPIO_Type) SetOUT_CPU_SEL5(value uint32) {
	volatile.StoreUint32(&o.OUT_CPU.Reg, volatile.LoadUint32(&o.OUT_CPU.Reg)&^(0x20)|value<<5)
}
func (o *DEDICATED_GPIO_Type) GetOUT_CPU_SEL5() uint32 {
	return (volatile.LoadUint32(&o.OUT_CPU.Reg) & 0x20) >> 5
}
func (o *DEDICATED_GPIO_Type) SetOUT_CPU_SEL6(value uint32) {
	volatile.StoreUint32(&o.OUT_CPU.Reg, volatile.LoadUint32(&o.OUT_CPU.Reg)&^(0x40)|value<<6)
}
func (o *DEDICATED_GPIO_Type) GetOUT_CPU_SEL6() uint32 {
	return (volatile.LoadUint32(&o.OUT_CPU.Reg) & 0x40) >> 6
}
func (o *DEDICATED_GPIO_Type) SetOUT_CPU_SEL7(value uint32) {
	volatile.StoreUint32(&o.OUT_CPU.Reg, volatile.LoadUint32(&o.OUT_CPU.Reg)&^(0x80)|value<<7)
}
func (o *DEDICATED_GPIO_Type) GetOUT_CPU_SEL7() uint32 {
	return (volatile.LoadUint32(&o.OUT_CPU.Reg) & 0x80) >> 7
}

// DEDICATED_GPIO.IN_DLY: Dedicated GPIO Input Delay Configuration register
func (o *DEDICATED_GPIO_Type) SetIN_DLY_CH0(value uint32) {
	volatile.StoreUint32(&o.IN_DLY.Reg, volatile.LoadUint32(&o.IN_DLY.Reg)&^(0x3)|value)
}
func (o *DEDICATED_GPIO_Type) GetIN_DLY_CH0() uint32 {
	return volatile.LoadUint32(&o.IN_DLY.Reg) & 0x3
}
func (o *DEDICATED_GPIO_Type) SetIN_DLY_CH1(value uint32) {
	volatile.StoreUint32(&o.IN_DLY.Reg, volatile.LoadUint32(&o.IN_DLY.Reg)&^(0xc)|value<<2)
}
func (o *DEDICATED_GPIO_Type) GetIN_DLY_CH1() uint32 {
	return (volatile.LoadUint32(&o.IN_DLY.Reg) & 0xc) >> 2
}
func (o *DEDICATED_GPIO_Type) SetIN_DLY_CH2(value uint32) {
	volatile.StoreUint32(&o.IN_DLY.Reg, volatile.LoadUint32(&o.IN_DLY.Reg)&^(0x30)|value<<4)
}
func (o *DEDICATED_GPIO_Type) GetIN_DLY_CH2() uint32 {
	return (volatile.LoadUint32(&o.IN_DLY.Reg) & 0x30) >> 4
}
func (o *DEDICATED_GPIO_Type) SetIN_DLY_CH3(value uint32) {
	volatile.StoreUint32(&o.IN_DLY.Reg, volatile.LoadUint32(&o.IN_DLY.Reg)&^(0xc0)|value<<6)
}
func (o *DEDICATED_GPIO_Type) GetIN_DLY_CH3() uint32 {
	return (volatile.LoadUint32(&o.IN_DLY.Reg) & 0xc0) >> 6
}
func (o *DEDICATED_GPIO_Type) SetIN_DLY_CH4(value uint32) {
	volatile.StoreUint32(&o.IN_DLY.Reg, volatile.LoadUint32(&o.IN_DLY.Reg)&^(0x300)|value<<8)
}
func (o *DEDICATED_GPIO_Type) GetIN_DLY_CH4() uint32 {
	return (volatile.LoadUint32(&o.IN_DLY.Reg) & 0x300) >> 8
}
func (o *DEDICATED_GPIO_Type) SetIN_DLY_CH5(value uint32) {
	volatile.StoreUint32(&o.IN_DLY.Reg, volatile.LoadUint32(&o.IN_DLY.Reg)&^(0xc00)|value<<10)
}
func (o *DEDICATED_GPIO_Type) GetIN_DLY_CH5() uint32 {
	return (volatile.LoadUint32(&o.IN_DLY.Reg) & 0xc00) >> 10
}
func (o *DEDICATED_GPIO_Type) SetIN_DLY_CH6(value uint32) {
	volatile.StoreUint32(&o.IN_DLY.Reg, volatile.LoadUint32(&o.IN_DLY.Reg)&^(0x3000)|value<<12)
}
func (o *DEDICATED_GPIO_Type) GetIN_DLY_CH6() uint32 {
	return (volatile.LoadUint32(&o.IN_DLY.Reg) & 0x3000) >> 12
}
func (o *DEDICATED_GPIO_Type) SetIN_DLY_CH7(value uint32) {
	volatile.StoreUint32(&o.IN_DLY.Reg, volatile.LoadUint32(&o.IN_DLY.Reg)&^(0xc000)|value<<14)
}
func (o *DEDICATED_GPIO_Type) GetIN_DLY_CH7() uint32 {
	return (volatile.LoadUint32(&o.IN_DLY.Reg) & 0xc000) >> 14
}

// DEDICATED_GPIO.IN_SCAN: Dedicated GPIO Input Status register
func (o *DEDICATED_GPIO_Type) SetIN_SCAN_IN_STATUS(value uint32) {
	volatile.StoreUint32(&o.IN_SCAN.Reg, volatile.LoadUint32(&o.IN_SCAN.Reg)&^(0xff)|value)
}
func (o *DEDICATED_GPIO_Type) GetIN_SCAN_IN_STATUS() uint32 {
	return volatile.LoadUint32(&o.IN_SCAN.Reg) & 0xff
}

// DEDICATED_GPIO.INTR_RCGN: Dedicated GPIO Interrupts Generate Mode register
func (o *DEDICATED_GPIO_Type) SetINTR_RCGN_INTR_MODE_CH0(value uint32) {
	volatile.StoreUint32(&o.INTR_RCGN.Reg, volatile.LoadUint32(&o.INTR_RCGN.Reg)&^(0x7)|value)
}
func (o *DEDICATED_GPIO_Type) GetINTR_RCGN_INTR_MODE_CH0() uint32 {
	return volatile.LoadUint32(&o.INTR_RCGN.Reg) & 0x7
}
func (o *DEDICATED_GPIO_Type) SetINTR_RCGN_INTR_MODE_CH1(value uint32) {
	volatile.StoreUint32(&o.INTR_RCGN.Reg, volatile.LoadUint32(&o.INTR_RCGN.Reg)&^(0x38)|value<<3)
}
func (o *DEDICATED_GPIO_Type) GetINTR_RCGN_INTR_MODE_CH1() uint32 {
	return (volatile.LoadUint32(&o.INTR_RCGN.Reg) & 0x38) >> 3
}
func (o *DEDICATED_GPIO_Type) SetINTR_RCGN_INTR_MODE_CH2(value uint32) {
	volatile.StoreUint32(&o.INTR_RCGN.Reg, volatile.LoadUint32(&o.INTR_RCGN.Reg)&^(0x1c0)|value<<6)
}
func (o *DEDICATED_GPIO_Type) GetINTR_RCGN_INTR_MODE_CH2() uint32 {
	return (volatile.LoadUint32(&o.INTR_RCGN.Reg) & 0x1c0) >> 6
}
func (o *DEDICATED_GPIO_Type) SetINTR_RCGN_INTR_MODE_CH3(value uint32) {
	volatile.StoreUint32(&o.INTR_RCGN.Reg, volatile.LoadUint32(&o.INTR_RCGN.Reg)&^(0xe00)|value<<9)
}
func (o *DEDICATED_GPIO_Type) GetINTR_RCGN_INTR_MODE_CH3() uint32 {
	return (volatile.LoadUint32(&o.INTR_RCGN.Reg) & 0xe00) >> 9
}
func (o *DEDICATED_GPIO_Type) SetINTR_RCGN_INTR_MODE_CH4(value uint32) {
	volatile.StoreUint32(&o.INTR_RCGN.Reg, volatile.LoadUint32(&o.INTR_RCGN.Reg)&^(0x7000)|value<<12)
}
func (o *DEDICATED_GPIO_Type) GetINTR_RCGN_INTR_MODE_CH4() uint32 {
	return (volatile.LoadUint32(&o.INTR_RCGN.Reg) & 0x7000) >> 12
}
func (o *DEDICATED_GPIO_Type) SetINTR_RCGN_INTR_MODE_CH5(value uint32) {
	volatile.StoreUint32(&o.INTR_RCGN.Reg, volatile.LoadUint32(&o.INTR_RCGN.Reg)&^(0x38000)|value<<15)
}
func (o *DEDICATED_GPIO_Type) GetINTR_RCGN_INTR_MODE_CH5() uint32 {
	return (volatile.LoadUint32(&o.INTR_RCGN.Reg) & 0x38000) >> 15
}
func (o *DEDICATED_GPIO_Type) SetINTR_RCGN_INTR_MODE_CH6(value uint32) {
	volatile.StoreUint32(&o.INTR_RCGN.Reg, volatile.LoadUint32(&o.INTR_RCGN.Reg)&^(0x1c0000)|value<<18)
}
func (o *DEDICATED_GPIO_Type) GetINTR_RCGN_INTR_MODE_CH6() uint32 {
	return (volatile.LoadUint32(&o.INTR_RCGN.Reg) & 0x1c0000) >> 18
}
func (o *DEDICATED_GPIO_Type) SetINTR_RCGN_INTR_MODE_CH7(value uint32) {
	volatile.StoreUint32(&o.INTR_RCGN.Reg, volatile.LoadUint32(&o.INTR_RCGN.Reg)&^(0xe00000)|value<<21)
}
func (o *DEDICATED_GPIO_Type) GetINTR_RCGN_INTR_MODE_CH7() uint32 {
	return (volatile.LoadUint32(&o.INTR_RCGN.Reg) & 0xe00000) >> 21
}

// DEDICATED_GPIO.INTR_RAW: Raw interrupt status
func (o *DEDICATED_GPIO_Type) SetINTR_RAW_GPIO0(value uint32) {
	volatile.StoreUint32(&o.INTR_RAW.Reg, volatile.LoadUint32(&o.INTR_RAW.Reg)&^(0x1)|value)
}
func (o *DEDICATED_GPIO_Type) GetINTR_RAW_GPIO0() uint32 {
	return volatile.LoadUint32(&o.INTR_RAW.Reg) & 0x1
}
func (o *DEDICATED_GPIO_Type) SetINTR_RAW_GPIO1(value uint32) {
	volatile.StoreUint32(&o.INTR_RAW.Reg, volatile.LoadUint32(&o.INTR_RAW.Reg)&^(0x2)|value<<1)
}
func (o *DEDICATED_GPIO_Type) GetINTR_RAW_GPIO1() uint32 {
	return (volatile.LoadUint32(&o.INTR_RAW.Reg) & 0x2) >> 1
}
func (o *DEDICATED_GPIO_Type) SetINTR_RAW_GPIO2(value uint32) {
	volatile.StoreUint32(&o.INTR_RAW.Reg, volatile.LoadUint32(&o.INTR_RAW.Reg)&^(0x4)|value<<2)
}
func (o *DEDICATED_GPIO_Type) GetINTR_RAW_GPIO2() uint32 {
	return (volatile.LoadUint32(&o.INTR_RAW.Reg) & 0x4) >> 2
}
func (o *DEDICATED_GPIO_Type) SetINTR_RAW_GPIO3(value uint32) {
	volatile.StoreUint32(&o.INTR_RAW.Reg, volatile.LoadUint32(&o.INTR_RAW.Reg)&^(0x8)|value<<3)
}
func (o *DEDICATED_GPIO_Type) GetINTR_RAW_GPIO3() uint32 {
	return (volatile.LoadUint32(&o.INTR_RAW.Reg) & 0x8) >> 3
}
func (o *DEDICATED_GPIO_Type) SetINTR_RAW_GPIO4(value uint32) {
	volatile.StoreUint32(&o.INTR_RAW.Reg, volatile.LoadUint32(&o.INTR_RAW.Reg)&^(0x10)|value<<4)
}
func (o *DEDICATED_GPIO_Type) GetINTR_RAW_GPIO4() uint32 {
	return (volatile.LoadUint32(&o.INTR_RAW.Reg) & 0x10) >> 4
}
func (o *DEDICATED_GPIO_Type) SetINTR_RAW_GPIO5(value uint32) {
	volatile.StoreUint32(&o.INTR_RAW.Reg, volatile.LoadUint32(&o.INTR_RAW.Reg)&^(0x20)|value<<5)
}
func (o *DEDICATED_GPIO_Type) GetINTR_RAW_GPIO5() uint32 {
	return (volatile.LoadUint32(&o.INTR_RAW.Reg) & 0x20) >> 5
}
func (o *DEDICATED_GPIO_Type) SetINTR_RAW_GPIO6(value uint32) {
	volatile.StoreUint32(&o.INTR_RAW.Reg, volatile.LoadUint32(&o.INTR_RAW.Reg)&^(0x40)|value<<6)
}
func (o *DEDICATED_GPIO_Type) GetINTR_RAW_GPIO6() uint32 {
	return (volatile.LoadUint32(&o.INTR_RAW.Reg) & 0x40) >> 6
}
func (o *DEDICATED_GPIO_Type) SetINTR_RAW_GPIO7(value uint32) {
	volatile.StoreUint32(&o.INTR_RAW.Reg, volatile.LoadUint32(&o.INTR_RAW.Reg)&^(0x80)|value<<7)
}
func (o *DEDICATED_GPIO_Type) GetINTR_RAW_GPIO7() uint32 {
	return (volatile.LoadUint32(&o.INTR_RAW.Reg) & 0x80) >> 7
}

// DEDICATED_GPIO.INTR_RLS: Interrupt enable bits
func (o *DEDICATED_GPIO_Type) SetINTR_RLS_GPIO0_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INTR_RLS.Reg, volatile.LoadUint32(&o.INTR_RLS.Reg)&^(0x1)|value)
}
func (o *DEDICATED_GPIO_Type) GetINTR_RLS_GPIO0_INT_ENA() uint32 {
	return volatile.LoadUint32(&o.INTR_RLS.Reg) & 0x1
}
func (o *DEDICATED_GPIO_Type) SetINTR_RLS_GPIO1_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INTR_RLS.Reg, volatile.LoadUint32(&o.INTR_RLS.Reg)&^(0x2)|value<<1)
}
func (o *DEDICATED_GPIO_Type) GetINTR_RLS_GPIO1_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INTR_RLS.Reg) & 0x2) >> 1
}
func (o *DEDICATED_GPIO_Type) SetINTR_RLS_GPIO2_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INTR_RLS.Reg, volatile.LoadUint32(&o.INTR_RLS.Reg)&^(0x4)|value<<2)
}
func (o *DEDICATED_GPIO_Type) GetINTR_RLS_GPIO2_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INTR_RLS.Reg) & 0x4) >> 2
}
func (o *DEDICATED_GPIO_Type) SetINTR_RLS_GPIO3_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INTR_RLS.Reg, volatile.LoadUint32(&o.INTR_RLS.Reg)&^(0x8)|value<<3)
}
func (o *DEDICATED_GPIO_Type) GetINTR_RLS_GPIO3_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INTR_RLS.Reg) & 0x8) >> 3
}
func (o *DEDICATED_GPIO_Type) SetINTR_RLS_GPIO4_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INTR_RLS.Reg, volatile.LoadUint32(&o.INTR_RLS.Reg)&^(0x10)|value<<4)
}
func (o *DEDICATED_GPIO_Type) GetINTR_RLS_GPIO4_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INTR_RLS.Reg) & 0x10) >> 4
}
func (o *DEDICATED_GPIO_Type) SetINTR_RLS_GPIO5_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INTR_RLS.Reg, volatile.LoadUint32(&o.INTR_RLS.Reg)&^(0x20)|value<<5)
}
func (o *DEDICATED_GPIO_Type) GetINTR_RLS_GPIO5_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INTR_RLS.Reg) & 0x20) >> 5
}
func (o *DEDICATED_GPIO_Type) SetINTR_RLS_GPIO6_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INTR_RLS.Reg, volatile.LoadUint32(&o.INTR_RLS.Reg)&^(0x40)|value<<6)
}
func (o *DEDICATED_GPIO_Type) GetINTR_RLS_GPIO6_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INTR_RLS.Reg) & 0x40) >> 6
}
func (o *DEDICATED_GPIO_Type) SetINTR_RLS_GPIO7_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INTR_RLS.Reg, volatile.LoadUint32(&o.INTR_RLS.Reg)&^(0x80)|value<<7)
}
func (o *DEDICATED_GPIO_Type) GetINTR_RLS_GPIO7_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INTR_RLS.Reg) & 0x80) >> 7
}

// DEDICATED_GPIO.INTR_ST: Masked interrupt status
func (o *DEDICATED_GPIO_Type) SetINTR_ST_GPIO0_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INTR_ST.Reg, volatile.LoadUint32(&o.INTR_ST.Reg)&^(0x1)|value)
}
func (o *DEDICATED_GPIO_Type) GetINTR_ST_GPIO0_INT_ST() uint32 {
	return volatile.LoadUint32(&o.INTR_ST.Reg) & 0x1
}
func (o *DEDICATED_GPIO_Type) SetINTR_ST_GPIO1_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INTR_ST.Reg, volatile.LoadUint32(&o.INTR_ST.Reg)&^(0x2)|value<<1)
}
func (o *DEDICATED_GPIO_Type) GetINTR_ST_GPIO1_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INTR_ST.Reg) & 0x2) >> 1
}
func (o *DEDICATED_GPIO_Type) SetINTR_ST_GPIO2_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INTR_ST.Reg, volatile.LoadUint32(&o.INTR_ST.Reg)&^(0x4)|value<<2)
}
func (o *DEDICATED_GPIO_Type) GetINTR_ST_GPIO2_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INTR_ST.Reg) & 0x4) >> 2
}
func (o *DEDICATED_GPIO_Type) SetINTR_ST_GPIO3_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INTR_ST.Reg, volatile.LoadUint32(&o.INTR_ST.Reg)&^(0x8)|value<<3)
}
func (o *DEDICATED_GPIO_Type) GetINTR_ST_GPIO3_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INTR_ST.Reg) & 0x8) >> 3
}
func (o *DEDICATED_GPIO_Type) SetINTR_ST_GPIO4_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INTR_ST.Reg, volatile.LoadUint32(&o.INTR_ST.Reg)&^(0x10)|value<<4)
}
func (o *DEDICATED_GPIO_Type) GetINTR_ST_GPIO4_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INTR_ST.Reg) & 0x10) >> 4
}
func (o *DEDICATED_GPIO_Type) SetINTR_ST_GPIO5_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INTR_ST.Reg, volatile.LoadUint32(&o.INTR_ST.Reg)&^(0x20)|value<<5)
}
func (o *DEDICATED_GPIO_Type) GetINTR_ST_GPIO5_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INTR_ST.Reg) & 0x20) >> 5
}
func (o *DEDICATED_GPIO_Type) SetINTR_ST_GPIO6_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INTR_ST.Reg, volatile.LoadUint32(&o.INTR_ST.Reg)&^(0x40)|value<<6)
}
func (o *DEDICATED_GPIO_Type) GetINTR_ST_GPIO6_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INTR_ST.Reg) & 0x40) >> 6
}
func (o *DEDICATED_GPIO_Type) SetINTR_ST_GPIO7_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INTR_ST.Reg, volatile.LoadUint32(&o.INTR_ST.Reg)&^(0x80)|value<<7)
}
func (o *DEDICATED_GPIO_Type) GetINTR_ST_GPIO7_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INTR_ST.Reg) & 0x80) >> 7
}

// DEDICATED_GPIO.INTR_CLR: Interrupt clear bits
func (o *DEDICATED_GPIO_Type) SetINTR_CLR_GPIO0_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INTR_CLR.Reg, volatile.LoadUint32(&o.INTR_CLR.Reg)&^(0x1)|value)
}
func (o *DEDICATED_GPIO_Type) GetINTR_CLR_GPIO0_INT_CLR() uint32 {
	return volatile.LoadUint32(&o.INTR_CLR.Reg) & 0x1
}
func (o *DEDICATED_GPIO_Type) SetINTR_CLR_GPIO1_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INTR_CLR.Reg, volatile.LoadUint32(&o.INTR_CLR.Reg)&^(0x2)|value<<1)
}
func (o *DEDICATED_GPIO_Type) GetINTR_CLR_GPIO1_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INTR_CLR.Reg) & 0x2) >> 1
}
func (o *DEDICATED_GPIO_Type) SetINTR_CLR_GPIO2_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INTR_CLR.Reg, volatile.LoadUint32(&o.INTR_CLR.Reg)&^(0x4)|value<<2)
}
func (o *DEDICATED_GPIO_Type) GetINTR_CLR_GPIO2_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INTR_CLR.Reg) & 0x4) >> 2
}
func (o *DEDICATED_GPIO_Type) SetINTR_CLR_GPIO3_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INTR_CLR.Reg, volatile.LoadUint32(&o.INTR_CLR.Reg)&^(0x8)|value<<3)
}
func (o *DEDICATED_GPIO_Type) GetINTR_CLR_GPIO3_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INTR_CLR.Reg) & 0x8) >> 3
}
func (o *DEDICATED_GPIO_Type) SetINTR_CLR_GPIO4_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INTR_CLR.Reg, volatile.LoadUint32(&o.INTR_CLR.Reg)&^(0x10)|value<<4)
}
func (o *DEDICATED_GPIO_Type) GetINTR_CLR_GPIO4_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INTR_CLR.Reg) & 0x10) >> 4
}
func (o *DEDICATED_GPIO_Type) SetINTR_CLR_GPIO5_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INTR_CLR.Reg, volatile.LoadUint32(&o.INTR_CLR.Reg)&^(0x20)|value<<5)
}
func (o *DEDICATED_GPIO_Type) GetINTR_CLR_GPIO5_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INTR_CLR.Reg) & 0x20) >> 5
}
func (o *DEDICATED_GPIO_Type) SetINTR_CLR_GPIO6_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INTR_CLR.Reg, volatile.LoadUint32(&o.INTR_CLR.Reg)&^(0x40)|value<<6)
}
func (o *DEDICATED_GPIO_Type) GetINTR_CLR_GPIO6_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INTR_CLR.Reg) & 0x40) >> 6
}
func (o *DEDICATED_GPIO_Type) SetINTR_CLR_GPIO7_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INTR_CLR.Reg, volatile.LoadUint32(&o.INTR_CLR.Reg)&^(0x80)|value<<7)
}
func (o *DEDICATED_GPIO_Type) GetINTR_CLR_GPIO7_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INTR_CLR.Reg) & 0x80) >> 7
}

// Peripheral DS
type DS_Type struct {
	C_MEM           volatile.Register32 // 0x0
	_               [1580]byte
	IV_0            volatile.Register32 // 0x630
	IV_1            volatile.Register32 // 0x634
	IV_2            volatile.Register32 // 0x638
	IV_3            volatile.Register32 // 0x63C
	_               [448]byte
	X_MEM           volatile.Register32 // 0x800
	_               [508]byte
	Z_MEM           volatile.Register32 // 0xA00
	_               [1020]byte
	SET_START       volatile.Register32 // 0xE00
	SET_ME          volatile.Register32 // 0xE04
	SET_FINISH      volatile.Register32 // 0xE08
	QUERY_BUSY      volatile.Register32 // 0xE0C
	QUERY_KEY_WRONG volatile.Register32 // 0xE10
	QUERY_CHECK     volatile.Register32 // 0xE14
	_               [8]byte
	DATE            volatile.Register32 // 0xE20
}

// DS.IV_0: IV block data
func (o *DS_Type) SetIV_0(value uint32) {
	volatile.StoreUint32(&o.IV_0.Reg, value)
}
func (o *DS_Type) GetIV_0() uint32 {
	return volatile.LoadUint32(&o.IV_0.Reg)
}

// DS.IV_1: IV block data
func (o *DS_Type) SetIV_1(value uint32) {
	volatile.StoreUint32(&o.IV_1.Reg, value)
}
func (o *DS_Type) GetIV_1() uint32 {
	return volatile.LoadUint32(&o.IV_1.Reg)
}

// DS.IV_2: IV block data
func (o *DS_Type) SetIV_2(value uint32) {
	volatile.StoreUint32(&o.IV_2.Reg, value)
}
func (o *DS_Type) GetIV_2() uint32 {
	return volatile.LoadUint32(&o.IV_2.Reg)
}

// DS.IV_3: IV block data
func (o *DS_Type) SetIV_3(value uint32) {
	volatile.StoreUint32(&o.IV_3.Reg, value)
}
func (o *DS_Type) GetIV_3() uint32 {
	return volatile.LoadUint32(&o.IV_3.Reg)
}

// DS.SET_START: Activates the DS peripheral
func (o *DS_Type) SetSET_START(value uint32) {
	volatile.StoreUint32(&o.SET_START.Reg, volatile.LoadUint32(&o.SET_START.Reg)&^(0x1)|value)
}
func (o *DS_Type) GetSET_START() uint32 {
	return volatile.LoadUint32(&o.SET_START.Reg) & 0x1
}

// DS.SET_ME: Starts DS operation
func (o *DS_Type) SetSET_ME(value uint32) {
	volatile.StoreUint32(&o.SET_ME.Reg, volatile.LoadUint32(&o.SET_ME.Reg)&^(0x1)|value)
}
func (o *DS_Type) GetSET_ME() uint32 {
	return volatile.LoadUint32(&o.SET_ME.Reg) & 0x1
}

// DS.SET_FINISH: Ends DS operation
func (o *DS_Type) SetSET_FINISH(value uint32) {
	volatile.StoreUint32(&o.SET_FINISH.Reg, volatile.LoadUint32(&o.SET_FINISH.Reg)&^(0x1)|value)
}
func (o *DS_Type) GetSET_FINISH() uint32 {
	return volatile.LoadUint32(&o.SET_FINISH.Reg) & 0x1
}

// DS.QUERY_BUSY: Status of the DS
func (o *DS_Type) SetQUERY_BUSY(value uint32) {
	volatile.StoreUint32(&o.QUERY_BUSY.Reg, volatile.LoadUint32(&o.QUERY_BUSY.Reg)&^(0x1)|value)
}
func (o *DS_Type) GetQUERY_BUSY() uint32 {
	return volatile.LoadUint32(&o.QUERY_BUSY.Reg) & 0x1
}

// DS.QUERY_KEY_WRONG: Checks the reason why DS_KEY is not ready.
func (o *DS_Type) SetQUERY_KEY_WRONG(value uint32) {
	volatile.StoreUint32(&o.QUERY_KEY_WRONG.Reg, volatile.LoadUint32(&o.QUERY_KEY_WRONG.Reg)&^(0xf)|value)
}
func (o *DS_Type) GetQUERY_KEY_WRONG() uint32 {
	return volatile.LoadUint32(&o.QUERY_KEY_WRONG.Reg) & 0xf
}

// DS.QUERY_CHECK: Queries DS check result
func (o *DS_Type) SetQUERY_CHECK_MD_ERROR(value uint32) {
	volatile.StoreUint32(&o.QUERY_CHECK.Reg, volatile.LoadUint32(&o.QUERY_CHECK.Reg)&^(0x1)|value)
}
func (o *DS_Type) GetQUERY_CHECK_MD_ERROR() uint32 {
	return volatile.LoadUint32(&o.QUERY_CHECK.Reg) & 0x1
}
func (o *DS_Type) SetQUERY_CHECK_PADDING_BAD(value uint32) {
	volatile.StoreUint32(&o.QUERY_CHECK.Reg, volatile.LoadUint32(&o.QUERY_CHECK.Reg)&^(0x2)|value<<1)
}
func (o *DS_Type) GetQUERY_CHECK_PADDING_BAD() uint32 {
	return (volatile.LoadUint32(&o.QUERY_CHECK.Reg) & 0x2) >> 1
}

// DS.DATE: version register
func (o *DS_Type) SetDATE(value uint32) {
	volatile.StoreUint32(&o.DATE.Reg, volatile.LoadUint32(&o.DATE.Reg)&^(0x3fffffff)|value)
}
func (o *DS_Type) GetDATE() uint32 {
	return volatile.LoadUint32(&o.DATE.Reg) & 0x3fffffff
}

// Peripheral EFUSE
type EFUSE_Type struct {
	PGM_DATA0           volatile.Register32 // 0x0
	PGM_DATA1           volatile.Register32 // 0x4
	PGM_DATA2           volatile.Register32 // 0x8
	PGM_DATA3           volatile.Register32 // 0xC
	PGM_DATA4           volatile.Register32 // 0x10
	PGM_DATA5           volatile.Register32 // 0x14
	PGM_DATA6           volatile.Register32 // 0x18
	PGM_DATA7           volatile.Register32 // 0x1C
	PGM_CHECK_VALUE0    volatile.Register32 // 0x20
	PGM_CHECK_VALUE1    volatile.Register32 // 0x24
	PGM_CHECK_VALUE2    volatile.Register32 // 0x28
	RD_WR_DIS           volatile.Register32 // 0x2C
	RD_REPEAT_DATA0     volatile.Register32 // 0x30
	RD_REPEAT_DATA1     volatile.Register32 // 0x34
	RD_REPEAT_DATA2     volatile.Register32 // 0x38
	RD_REPEAT_DATA3     volatile.Register32 // 0x3C
	RD_REPEAT_DATA4     volatile.Register32 // 0x40
	RD_MAC_SPI_SYS_0    volatile.Register32 // 0x44
	RD_MAC_SPI_SYS_1    volatile.Register32 // 0x48
	RD_MAC_SPI_SYS_2    volatile.Register32 // 0x4C
	RD_MAC_SPI_SYS_3    volatile.Register32 // 0x50
	RD_MAC_SPI_SYS_4    volatile.Register32 // 0x54
	RD_MAC_SPI_SYS_5    volatile.Register32 // 0x58
	RD_SYS_DATA_PART1_0 volatile.Register32 // 0x5C
	RD_SYS_DATA_PART1_1 volatile.Register32 // 0x60
	RD_SYS_DATA_PART1_2 volatile.Register32 // 0x64
	RD_SYS_DATA_PART1_3 volatile.Register32 // 0x68
	RD_SYS_DATA_PART1_4 volatile.Register32 // 0x6C
	RD_SYS_DATA_PART1_5 volatile.Register32 // 0x70
	RD_SYS_DATA_PART1_6 volatile.Register32 // 0x74
	RD_SYS_DATA_PART1_7 volatile.Register32 // 0x78
	RD_USR_DATA0        volatile.Register32 // 0x7C
	RD_USR_DATA1        volatile.Register32 // 0x80
	RD_USR_DATA2        volatile.Register32 // 0x84
	RD_USR_DATA3        volatile.Register32 // 0x88
	RD_USR_DATA4        volatile.Register32 // 0x8C
	RD_USR_DATA5        volatile.Register32 // 0x90
	RD_USR_DATA6        volatile.Register32 // 0x94
	RD_USR_DATA7        volatile.Register32 // 0x98
	RD_KEY0_DATA0       volatile.Register32 // 0x9C
	RD_KEY0_DATA1       volatile.Register32 // 0xA0
	RD_KEY0_DATA2       volatile.Register32 // 0xA4
	RD_KEY0_DATA3       volatile.Register32 // 0xA8
	RD_KEY0_DATA4       volatile.Register32 // 0xAC
	RD_KEY0_DATA5       volatile.Register32 // 0xB0
	RD_KEY0_DATA6       volatile.Register32 // 0xB4
	RD_KEY0_DATA7       volatile.Register32 // 0xB8
	RD_KEY1_DATA0       volatile.Register32 // 0xBC
	RD_KEY1_DATA1       volatile.Register32 // 0xC0
	RD_KEY1_DATA2       volatile.Register32 // 0xC4
	RD_KEY1_DATA3       volatile.Register32 // 0xC8
	RD_KEY1_DATA4       volatile.Register32 // 0xCC
	RD_KEY1_DATA5       volatile.Register32 // 0xD0
	RD_KEY1_DATA6       volatile.Register32 // 0xD4
	RD_KEY1_DATA7       volatile.Register32 // 0xD8
	RD_KEY2_DATA0       volatile.Register32 // 0xDC
	RD_KEY2_DATA1       volatile.Register32 // 0xE0
	RD_KEY2_DATA2       volatile.Register32 // 0xE4
	RD_KEY2_DATA3       volatile.Register32 // 0xE8
	RD_KEY2_DATA4       volatile.Register32 // 0xEC
	RD_KEY2_DATA5       volatile.Register32 // 0xF0
	RD_KEY2_DATA6       volatile.Register32 // 0xF4
	RD_KEY2_DATA7       volatile.Register32 // 0xF8
	RD_KEY3_DATA0       volatile.Register32 // 0xFC
	RD_KEY3_DATA1       volatile.Register32 // 0x100
	RD_KEY3_DATA2       volatile.Register32 // 0x104
	RD_KEY3_DATA3       volatile.Register32 // 0x108
	RD_KEY3_DATA4       volatile.Register32 // 0x10C
	RD_KEY3_DATA5       volatile.Register32 // 0x110
	RD_KEY3_DATA6       volatile.Register32 // 0x114
	RD_KEY3_DATA7       volatile.Register32 // 0x118
	RD_KEY4_DATA0       volatile.Register32 // 0x11C
	RD_KEY4_DATA1       volatile.Register32 // 0x120
	RD_KEY4_DATA2       volatile.Register32 // 0x124
	RD_KEY4_DATA3       volatile.Register32 // 0x128
	RD_KEY4_DATA4       volatile.Register32 // 0x12C
	RD_KEY4_DATA5       volatile.Register32 // 0x130
	RD_KEY4_DATA6       volatile.Register32 // 0x134
	RD_KEY4_DATA7       volatile.Register32 // 0x138
	RD_KEY5_DATA0       volatile.Register32 // 0x13C
	RD_KEY5_DATA1       volatile.Register32 // 0x140
	RD_KEY5_DATA2       volatile.Register32 // 0x144
	RD_KEY5_DATA3       volatile.Register32 // 0x148
	RD_KEY5_DATA4       volatile.Register32 // 0x14C
	RD_KEY5_DATA5       volatile.Register32 // 0x150
	RD_KEY5_DATA6       volatile.Register32 // 0x154
	RD_KEY5_DATA7       volatile.Register32 // 0x158
	RD_SYS_DATA_PART2_0 volatile.Register32 // 0x15C
	RD_SYS_DATA_PART2_1 volatile.Register32 // 0x160
	RD_SYS_DATA_PART2_2 volatile.Register32 // 0x164
	RD_SYS_DATA_PART2_3 volatile.Register32 // 0x168
	RD_SYS_DATA_PART2_4 volatile.Register32 // 0x16C
	RD_SYS_DATA_PART2_5 volatile.Register32 // 0x170
	RD_SYS_DATA_PART2_6 volatile.Register32 // 0x174
	RD_SYS_DATA_PART2_7 volatile.Register32 // 0x178
	RD_REPEAT_ERR0      volatile.Register32 // 0x17C
	RD_REPEAT_ERR1      volatile.Register32 // 0x180
	RD_REPEAT_ERR2      volatile.Register32 // 0x184
	RD_REPEAT_ERR3      volatile.Register32 // 0x188
	_                   [4]byte
	RD_REPEAT_ERR4      volatile.Register32 // 0x190
	_                   [44]byte
	RD_RS_ERR0          volatile.Register32 // 0x1C0
	RD_RS_ERR1          volatile.Register32 // 0x1C4
	CLK                 volatile.Register32 // 0x1C8
	CONF                volatile.Register32 // 0x1CC
	STATUS              volatile.Register32 // 0x1D0
	CMD                 volatile.Register32 // 0x1D4
	INT_RAW             volatile.Register32 // 0x1D8
	INT_ST              volatile.Register32 // 0x1DC
	INT_ENA             volatile.Register32 // 0x1E0
	INT_CLR             volatile.Register32 // 0x1E4
	DAC_CONF            volatile.Register32 // 0x1E8
	RD_TIM_CONF         volatile.Register32 // 0x1EC
	WR_TIM_CONF0        volatile.Register32 // 0x1F0
	WR_TIM_CONF1        volatile.Register32 // 0x1F4
	WR_TIM_CONF2        volatile.Register32 // 0x1F8
	DATE                volatile.Register32 // 0x1FC
}

// EFUSE.PGM_DATA0: Register %s that stores data to be programmed.
func (o *EFUSE_Type) SetPGM_DATA0(value uint32) {
	volatile.StoreUint32(&o.PGM_DATA0.Reg, value)
}
func (o *EFUSE_Type) GetPGM_DATA0() uint32 {
	return volatile.LoadUint32(&o.PGM_DATA0.Reg)
}

// EFUSE.PGM_DATA1: Register %s that stores data to be programmed.
func (o *EFUSE_Type) SetPGM_DATA1(value uint32) {
	volatile.StoreUint32(&o.PGM_DATA1.Reg, value)
}
func (o *EFUSE_Type) GetPGM_DATA1() uint32 {
	return volatile.LoadUint32(&o.PGM_DATA1.Reg)
}

// EFUSE.PGM_DATA2: Register %s that stores data to be programmed.
func (o *EFUSE_Type) SetPGM_DATA2(value uint32) {
	volatile.StoreUint32(&o.PGM_DATA2.Reg, value)
}
func (o *EFUSE_Type) GetPGM_DATA2() uint32 {
	return volatile.LoadUint32(&o.PGM_DATA2.Reg)
}

// EFUSE.PGM_DATA3: Register %s that stores data to be programmed.
func (o *EFUSE_Type) SetPGM_DATA3(value uint32) {
	volatile.StoreUint32(&o.PGM_DATA3.Reg, value)
}
func (o *EFUSE_Type) GetPGM_DATA3() uint32 {
	return volatile.LoadUint32(&o.PGM_DATA3.Reg)
}

// EFUSE.PGM_DATA4: Register %s that stores data to be programmed.
func (o *EFUSE_Type) SetPGM_DATA4(value uint32) {
	volatile.StoreUint32(&o.PGM_DATA4.Reg, value)
}
func (o *EFUSE_Type) GetPGM_DATA4() uint32 {
	return volatile.LoadUint32(&o.PGM_DATA4.Reg)
}

// EFUSE.PGM_DATA5: Register %s that stores data to be programmed.
func (o *EFUSE_Type) SetPGM_DATA5(value uint32) {
	volatile.StoreUint32(&o.PGM_DATA5.Reg, value)
}
func (o *EFUSE_Type) GetPGM_DATA5() uint32 {
	return volatile.LoadUint32(&o.PGM_DATA5.Reg)
}

// EFUSE.PGM_DATA6: Register %s that stores data to be programmed.
func (o *EFUSE_Type) SetPGM_DATA6(value uint32) {
	volatile.StoreUint32(&o.PGM_DATA6.Reg, value)
}
func (o *EFUSE_Type) GetPGM_DATA6() uint32 {
	return volatile.LoadUint32(&o.PGM_DATA6.Reg)
}

// EFUSE.PGM_DATA7: Register %s that stores data to be programmed.
func (o *EFUSE_Type) SetPGM_DATA7(value uint32) {
	volatile.StoreUint32(&o.PGM_DATA7.Reg, value)
}
func (o *EFUSE_Type) GetPGM_DATA7() uint32 {
	return volatile.LoadUint32(&o.PGM_DATA7.Reg)
}

// EFUSE.PGM_CHECK_VALUE0: Register %s that stores the RS code to be programmed.
func (o *EFUSE_Type) SetPGM_CHECK_VALUE0(value uint32) {
	volatile.StoreUint32(&o.PGM_CHECK_VALUE0.Reg, value)
}
func (o *EFUSE_Type) GetPGM_CHECK_VALUE0() uint32 {
	return volatile.LoadUint32(&o.PGM_CHECK_VALUE0.Reg)
}

// EFUSE.PGM_CHECK_VALUE1: Register %s that stores the RS code to be programmed.
func (o *EFUSE_Type) SetPGM_CHECK_VALUE1(value uint32) {
	volatile.StoreUint32(&o.PGM_CHECK_VALUE1.Reg, value)
}
func (o *EFUSE_Type) GetPGM_CHECK_VALUE1() uint32 {
	return volatile.LoadUint32(&o.PGM_CHECK_VALUE1.Reg)
}

// EFUSE.PGM_CHECK_VALUE2: Register %s that stores the RS code to be programmed.
func (o *EFUSE_Type) SetPGM_CHECK_VALUE2(value uint32) {
	volatile.StoreUint32(&o.PGM_CHECK_VALUE2.Reg, value)
}
func (o *EFUSE_Type) GetPGM_CHECK_VALUE2() uint32 {
	return volatile.LoadUint32(&o.PGM_CHECK_VALUE2.Reg)
}

// EFUSE.RD_WR_DIS: Register 0 of BLOCK0.
func (o *EFUSE_Type) SetRD_WR_DIS(value uint32) {
	volatile.StoreUint32(&o.RD_WR_DIS.Reg, value)
}
func (o *EFUSE_Type) GetRD_WR_DIS() uint32 {
	return volatile.LoadUint32(&o.RD_WR_DIS.Reg)
}

// EFUSE.RD_REPEAT_DATA0: Register 1 of BLOCK0.
func (o *EFUSE_Type) SetRD_REPEAT_DATA0_RD_DIS(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA0.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg)&^(0x7f)|value)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA0_RD_DIS() uint32 {
	return volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg) & 0x7f
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA0_DIS_RTC_RAM_BOOT(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA0.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg)&^(0x80)|value<<7)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA0_DIS_RTC_RAM_BOOT() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg) & 0x80) >> 7
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA0_DIS_ICACHE(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA0.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg)&^(0x100)|value<<8)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA0_DIS_ICACHE() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg) & 0x100) >> 8
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA0_DIS_DCACHE(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA0.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg)&^(0x200)|value<<9)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA0_DIS_DCACHE() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg) & 0x200) >> 9
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA0_DIS_DOWNLOAD_ICACHE(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA0.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg)&^(0x400)|value<<10)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA0_DIS_DOWNLOAD_ICACHE() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg) & 0x400) >> 10
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA0_DIS_DOWNLOAD_DCACHE(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA0.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg)&^(0x800)|value<<11)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA0_DIS_DOWNLOAD_DCACHE() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg) & 0x800) >> 11
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA0_DIS_FORCE_DOWNLOAD(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA0.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg)&^(0x1000)|value<<12)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA0_DIS_FORCE_DOWNLOAD() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg) & 0x1000) >> 12
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA0_DIS_USB(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA0.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg)&^(0x2000)|value<<13)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA0_DIS_USB() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg) & 0x2000) >> 13
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA0_DIS_CAN(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA0.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg)&^(0x4000)|value<<14)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA0_DIS_CAN() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg) & 0x4000) >> 14
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA0_DIS_BOOT_REMAP(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA0.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg)&^(0x8000)|value<<15)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA0_DIS_BOOT_REMAP() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg) & 0x8000) >> 15
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA0_RPT4_RESERVED5(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA0.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg)&^(0x10000)|value<<16)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA0_RPT4_RESERVED5() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg) & 0x10000) >> 16
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA0_SOFT_DIS_JTAG(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA0.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg)&^(0x20000)|value<<17)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA0_SOFT_DIS_JTAG() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg) & 0x20000) >> 17
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA0_HARD_DIS_JTAG(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA0.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg)&^(0x40000)|value<<18)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA0_HARD_DIS_JTAG() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg) & 0x40000) >> 18
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA0_DIS_DOWNLOAD_MANUAL_ENCRYPT(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA0.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg)&^(0x80000)|value<<19)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA0_DIS_DOWNLOAD_MANUAL_ENCRYPT() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg) & 0x80000) >> 19
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA0_USB_DREFH(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA0.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg)&^(0x300000)|value<<20)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA0_USB_DREFH() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg) & 0x300000) >> 20
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA0_USB_DREFL(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA0.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg)&^(0xc00000)|value<<22)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA0_USB_DREFL() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg) & 0xc00000) >> 22
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA0_USB_EXCHG_PINS(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA0.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg)&^(0x1000000)|value<<24)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA0_USB_EXCHG_PINS() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg) & 0x1000000) >> 24
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA0_EXT_PHY_ENABLE(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA0.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg)&^(0x2000000)|value<<25)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA0_EXT_PHY_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg) & 0x2000000) >> 25
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA0_USB_FORCE_NOPERSIST(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA0.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg)&^(0x4000000)|value<<26)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA0_USB_FORCE_NOPERSIST() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg) & 0x4000000) >> 26
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA0_RPT4_RESERVED0(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA0.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg)&^(0x18000000)|value<<27)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA0_RPT4_RESERVED0() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg) & 0x18000000) >> 27
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA0_VDD_SPI_MODECURLIM(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA0.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg)&^(0x20000000)|value<<29)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA0_VDD_SPI_MODECURLIM() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg) & 0x20000000) >> 29
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA0_VDD_SPI_DREFH(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA0.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg)&^(0xc0000000)|value<<30)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA0_VDD_SPI_DREFH() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg) & 0xc0000000) >> 30
}

// EFUSE.RD_REPEAT_DATA1: Register 2 of BLOCK0.
func (o *EFUSE_Type) SetRD_REPEAT_DATA1_VDD_SPI_DREFM(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA1.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA1.Reg)&^(0x3)|value)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA1_VDD_SPI_DREFM() uint32 {
	return volatile.LoadUint32(&o.RD_REPEAT_DATA1.Reg) & 0x3
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA1_VDD_SPI_DREFL(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA1.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA1.Reg)&^(0xc)|value<<2)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA1_VDD_SPI_DREFL() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA1.Reg) & 0xc) >> 2
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA1_VDD_SPI_XPD(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA1.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA1.Reg)&^(0x10)|value<<4)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA1_VDD_SPI_XPD() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA1.Reg) & 0x10) >> 4
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA1_VDD_SPI_TIEH(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA1.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA1.Reg)&^(0x20)|value<<5)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA1_VDD_SPI_TIEH() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA1.Reg) & 0x20) >> 5
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA1_VDD_SPI_FORCE(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA1.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA1.Reg)&^(0x40)|value<<6)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA1_VDD_SPI_FORCE() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA1.Reg) & 0x40) >> 6
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA1_VDD_SPI_EN_INIT(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA1.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA1.Reg)&^(0x80)|value<<7)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA1_VDD_SPI_EN_INIT() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA1.Reg) & 0x80) >> 7
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA1_VDD_SPI_ENCURLIM(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA1.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA1.Reg)&^(0x100)|value<<8)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA1_VDD_SPI_ENCURLIM() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA1.Reg) & 0x100) >> 8
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA1_VDD_SPI_DCURLIM(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA1.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA1.Reg)&^(0xe00)|value<<9)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA1_VDD_SPI_DCURLIM() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA1.Reg) & 0xe00) >> 9
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA1_VDD_SPI_INIT(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA1.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA1.Reg)&^(0x3000)|value<<12)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA1_VDD_SPI_INIT() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA1.Reg) & 0x3000) >> 12
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA1_VDD_SPI_DCAP(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA1.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA1.Reg)&^(0xc000)|value<<14)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA1_VDD_SPI_DCAP() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA1.Reg) & 0xc000) >> 14
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA1_WDT_DELAY_SEL(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA1.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA1.Reg)&^(0x30000)|value<<16)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA1_WDT_DELAY_SEL() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA1.Reg) & 0x30000) >> 16
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA1_SPI_BOOT_CRYPT_CNT(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA1.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA1.Reg)&^(0x1c0000)|value<<18)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA1_SPI_BOOT_CRYPT_CNT() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA1.Reg) & 0x1c0000) >> 18
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA1_SECURE_BOOT_KEY_REVOKE0(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA1.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA1.Reg)&^(0x200000)|value<<21)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA1_SECURE_BOOT_KEY_REVOKE0() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA1.Reg) & 0x200000) >> 21
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA1_SECURE_BOOT_KEY_REVOKE1(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA1.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA1.Reg)&^(0x400000)|value<<22)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA1_SECURE_BOOT_KEY_REVOKE1() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA1.Reg) & 0x400000) >> 22
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA1_SECURE_BOOT_KEY_REVOKE2(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA1.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA1.Reg)&^(0x800000)|value<<23)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA1_SECURE_BOOT_KEY_REVOKE2() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA1.Reg) & 0x800000) >> 23
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA1_KEY_PURPOSE_0(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA1.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA1.Reg)&^(0xf000000)|value<<24)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA1_KEY_PURPOSE_0() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA1.Reg) & 0xf000000) >> 24
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA1_KEY_PURPOSE_1(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA1.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA1.Reg)&^(0xf0000000)|value<<28)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA1_KEY_PURPOSE_1() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA1.Reg) & 0xf0000000) >> 28
}

// EFUSE.RD_REPEAT_DATA2: Register 3 of BLOCK0.
func (o *EFUSE_Type) SetRD_REPEAT_DATA2_KEY_PURPOSE_2(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA2.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA2.Reg)&^(0xf)|value)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA2_KEY_PURPOSE_2() uint32 {
	return volatile.LoadUint32(&o.RD_REPEAT_DATA2.Reg) & 0xf
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA2_KEY_PURPOSE_3(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA2.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA2.Reg)&^(0xf0)|value<<4)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA2_KEY_PURPOSE_3() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA2.Reg) & 0xf0) >> 4
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA2_KEY_PURPOSE_4(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA2.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA2.Reg)&^(0xf00)|value<<8)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA2_KEY_PURPOSE_4() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA2.Reg) & 0xf00) >> 8
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA2_KEY_PURPOSE_5(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA2.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA2.Reg)&^(0xf000)|value<<12)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA2_KEY_PURPOSE_5() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA2.Reg) & 0xf000) >> 12
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA2_KEY_PURPOSE_6(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA2.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA2.Reg)&^(0xf0000)|value<<16)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA2_KEY_PURPOSE_6() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA2.Reg) & 0xf0000) >> 16
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA2_SECURE_BOOT_EN(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA2.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA2.Reg)&^(0x100000)|value<<20)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA2_SECURE_BOOT_EN() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA2.Reg) & 0x100000) >> 20
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA2_SECURE_BOOT_AGGRESSIVE_REVOKE(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA2.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA2.Reg)&^(0x200000)|value<<21)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA2_SECURE_BOOT_AGGRESSIVE_REVOKE() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA2.Reg) & 0x200000) >> 21
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA2_RPT4_RESERVED1(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA2.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA2.Reg)&^(0xfc00000)|value<<22)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA2_RPT4_RESERVED1() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA2.Reg) & 0xfc00000) >> 22
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA2_FLASH_TPUW(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA2.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA2.Reg)&^(0xf0000000)|value<<28)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA2_FLASH_TPUW() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA2.Reg) & 0xf0000000) >> 28
}

// EFUSE.RD_REPEAT_DATA3: Register 4 of BLOCK0.
func (o *EFUSE_Type) SetRD_REPEAT_DATA3_DIS_DOWNLOAD_MODE(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA3.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA3.Reg)&^(0x1)|value)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA3_DIS_DOWNLOAD_MODE() uint32 {
	return volatile.LoadUint32(&o.RD_REPEAT_DATA3.Reg) & 0x1
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA3_DIS_LEGACY_SPI_BOOT(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA3.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA3.Reg)&^(0x2)|value<<1)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA3_DIS_LEGACY_SPI_BOOT() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA3.Reg) & 0x2) >> 1
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA3_UART_PRINT_CHANNEL(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA3.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA3.Reg)&^(0x4)|value<<2)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA3_UART_PRINT_CHANNEL() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA3.Reg) & 0x4) >> 2
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA3_RPT4_RESERVED3(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA3.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA3.Reg)&^(0x8)|value<<3)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA3_RPT4_RESERVED3() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA3.Reg) & 0x8) >> 3
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA3_DIS_USB_DOWNLOAD_MODE(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA3.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA3.Reg)&^(0x10)|value<<4)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA3_DIS_USB_DOWNLOAD_MODE() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA3.Reg) & 0x10) >> 4
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA3_ENABLE_SECURITY_DOWNLOAD(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA3.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA3.Reg)&^(0x20)|value<<5)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA3_ENABLE_SECURITY_DOWNLOAD() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA3.Reg) & 0x20) >> 5
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA3_UART_PRINT_CONTROL(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA3.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA3.Reg)&^(0xc0)|value<<6)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA3_UART_PRINT_CONTROL() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA3.Reg) & 0xc0) >> 6
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA3_PIN_POWER_SELECTION(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA3.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA3.Reg)&^(0x100)|value<<8)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA3_PIN_POWER_SELECTION() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA3.Reg) & 0x100) >> 8
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA3_FLASH_TYPE(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA3.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA3.Reg)&^(0x200)|value<<9)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA3_FLASH_TYPE() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA3.Reg) & 0x200) >> 9
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA3_FORCE_SEND_RESUME(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA3.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA3.Reg)&^(0x400)|value<<10)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA3_FORCE_SEND_RESUME() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA3.Reg) & 0x400) >> 10
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA3_SECURE_VERSION(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA3.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA3.Reg)&^(0x7fff800)|value<<11)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA3_SECURE_VERSION() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA3.Reg) & 0x7fff800) >> 11
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA3_RPT4_RESERVED2(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA3.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA3.Reg)&^(0xf8000000)|value<<27)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA3_RPT4_RESERVED2() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA3.Reg) & 0xf8000000) >> 27
}

// EFUSE.RD_REPEAT_DATA4: Register 5 of BLOCK0.
func (o *EFUSE_Type) SetRD_REPEAT_DATA4_RPT4_RESERVED4(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA4.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA4.Reg)&^(0xffffff)|value)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA4_RPT4_RESERVED4() uint32 {
	return volatile.LoadUint32(&o.RD_REPEAT_DATA4.Reg) & 0xffffff
}

// EFUSE.RD_MAC_SPI_SYS_0: Register 0 of BLOCK1.
func (o *EFUSE_Type) SetRD_MAC_SPI_SYS_0(value uint32) {
	volatile.StoreUint32(&o.RD_MAC_SPI_SYS_0.Reg, value)
}
func (o *EFUSE_Type) GetRD_MAC_SPI_SYS_0() uint32 {
	return volatile.LoadUint32(&o.RD_MAC_SPI_SYS_0.Reg)
}

// EFUSE.RD_MAC_SPI_SYS_1: Register 1 of BLOCK1.
func (o *EFUSE_Type) SetRD_MAC_SPI_SYS_1_MAC_1(value uint32) {
	volatile.StoreUint32(&o.RD_MAC_SPI_SYS_1.Reg, volatile.LoadUint32(&o.RD_MAC_SPI_SYS_1.Reg)&^(0xffff)|value)
}
func (o *EFUSE_Type) GetRD_MAC_SPI_SYS_1_MAC_1() uint32 {
	return volatile.LoadUint32(&o.RD_MAC_SPI_SYS_1.Reg) & 0xffff
}
func (o *EFUSE_Type) SetRD_MAC_SPI_SYS_1_SPI_PAD_CONF_0(value uint32) {
	volatile.StoreUint32(&o.RD_MAC_SPI_SYS_1.Reg, volatile.LoadUint32(&o.RD_MAC_SPI_SYS_1.Reg)&^(0xffff0000)|value<<16)
}
func (o *EFUSE_Type) GetRD_MAC_SPI_SYS_1_SPI_PAD_CONF_0() uint32 {
	return (volatile.LoadUint32(&o.RD_MAC_SPI_SYS_1.Reg) & 0xffff0000) >> 16
}

// EFUSE.RD_MAC_SPI_SYS_2: Register 2 of BLOCK1.
func (o *EFUSE_Type) SetRD_MAC_SPI_SYS_2(value uint32) {
	volatile.StoreUint32(&o.RD_MAC_SPI_SYS_2.Reg, value)
}
func (o *EFUSE_Type) GetRD_MAC_SPI_SYS_2() uint32 {
	return volatile.LoadUint32(&o.RD_MAC_SPI_SYS_2.Reg)
}

// EFUSE.RD_MAC_SPI_SYS_3: Register 3 of BLOCK1.
func (o *EFUSE_Type) SetRD_MAC_SPI_SYS_3_SPI_PAD_CONF_2(value uint32) {
	volatile.StoreUint32(&o.RD_MAC_SPI_SYS_3.Reg, volatile.LoadUint32(&o.RD_MAC_SPI_SYS_3.Reg)&^(0x3ffff)|value)
}
func (o *EFUSE_Type) GetRD_MAC_SPI_SYS_3_SPI_PAD_CONF_2() uint32 {
	return volatile.LoadUint32(&o.RD_MAC_SPI_SYS_3.Reg) & 0x3ffff
}
func (o *EFUSE_Type) SetRD_MAC_SPI_SYS_3_SYS_DATA_PART0_0(value uint32) {
	volatile.StoreUint32(&o.RD_MAC_SPI_SYS_3.Reg, volatile.LoadUint32(&o.RD_MAC_SPI_SYS_3.Reg)&^(0xfffc0000)|value<<18)
}
func (o *EFUSE_Type) GetRD_MAC_SPI_SYS_3_SYS_DATA_PART0_0() uint32 {
	return (volatile.LoadUint32(&o.RD_MAC_SPI_SYS_3.Reg) & 0xfffc0000) >> 18
}

// EFUSE.RD_MAC_SPI_SYS_4: Register 4 of BLOCK1.
func (o *EFUSE_Type) SetRD_MAC_SPI_SYS_4(value uint32) {
	volatile.StoreUint32(&o.RD_MAC_SPI_SYS_4.Reg, value)
}
func (o *EFUSE_Type) GetRD_MAC_SPI_SYS_4() uint32 {
	return volatile.LoadUint32(&o.RD_MAC_SPI_SYS_4.Reg)
}

// EFUSE.RD_MAC_SPI_SYS_5: Register 5 of BLOCK1.
func (o *EFUSE_Type) SetRD_MAC_SPI_SYS_5(value uint32) {
	volatile.StoreUint32(&o.RD_MAC_SPI_SYS_5.Reg, value)
}
func (o *EFUSE_Type) GetRD_MAC_SPI_SYS_5() uint32 {
	return volatile.LoadUint32(&o.RD_MAC_SPI_SYS_5.Reg)
}

// EFUSE.RD_SYS_DATA_PART1_0: Register %s of BLOCK2 (system).
func (o *EFUSE_Type) SetRD_SYS_DATA_PART1_0(value uint32) {
	volatile.StoreUint32(&o.RD_SYS_DATA_PART1_0.Reg, value)
}
func (o *EFUSE_Type) GetRD_SYS_DATA_PART1_0() uint32 {
	return volatile.LoadUint32(&o.RD_SYS_DATA_PART1_0.Reg)
}

// EFUSE.RD_SYS_DATA_PART1_1: Register %s of BLOCK2 (system).
func (o *EFUSE_Type) SetRD_SYS_DATA_PART1_1(value uint32) {
	volatile.StoreUint32(&o.RD_SYS_DATA_PART1_1.Reg, value)
}
func (o *EFUSE_Type) GetRD_SYS_DATA_PART1_1() uint32 {
	return volatile.LoadUint32(&o.RD_SYS_DATA_PART1_1.Reg)
}

// EFUSE.RD_SYS_DATA_PART1_2: Register %s of BLOCK2 (system).
func (o *EFUSE_Type) SetRD_SYS_DATA_PART1_2(value uint32) {
	volatile.StoreUint32(&o.RD_SYS_DATA_PART1_2.Reg, value)
}
func (o *EFUSE_Type) GetRD_SYS_DATA_PART1_2() uint32 {
	return volatile.LoadUint32(&o.RD_SYS_DATA_PART1_2.Reg)
}

// EFUSE.RD_SYS_DATA_PART1_3: Register %s of BLOCK2 (system).
func (o *EFUSE_Type) SetRD_SYS_DATA_PART1_3(value uint32) {
	volatile.StoreUint32(&o.RD_SYS_DATA_PART1_3.Reg, value)
}
func (o *EFUSE_Type) GetRD_SYS_DATA_PART1_3() uint32 {
	return volatile.LoadUint32(&o.RD_SYS_DATA_PART1_3.Reg)
}

// EFUSE.RD_SYS_DATA_PART1_4: Register %s of BLOCK2 (system).
func (o *EFUSE_Type) SetRD_SYS_DATA_PART1_4(value uint32) {
	volatile.StoreUint32(&o.RD_SYS_DATA_PART1_4.Reg, value)
}
func (o *EFUSE_Type) GetRD_SYS_DATA_PART1_4() uint32 {
	return volatile.LoadUint32(&o.RD_SYS_DATA_PART1_4.Reg)
}

// EFUSE.RD_SYS_DATA_PART1_5: Register %s of BLOCK2 (system).
func (o *EFUSE_Type) SetRD_SYS_DATA_PART1_5(value uint32) {
	volatile.StoreUint32(&o.RD_SYS_DATA_PART1_5.Reg, value)
}
func (o *EFUSE_Type) GetRD_SYS_DATA_PART1_5() uint32 {
	return volatile.LoadUint32(&o.RD_SYS_DATA_PART1_5.Reg)
}

// EFUSE.RD_SYS_DATA_PART1_6: Register %s of BLOCK2 (system).
func (o *EFUSE_Type) SetRD_SYS_DATA_PART1_6(value uint32) {
	volatile.StoreUint32(&o.RD_SYS_DATA_PART1_6.Reg, value)
}
func (o *EFUSE_Type) GetRD_SYS_DATA_PART1_6() uint32 {
	return volatile.LoadUint32(&o.RD_SYS_DATA_PART1_6.Reg)
}

// EFUSE.RD_SYS_DATA_PART1_7: Register %s of BLOCK2 (system).
func (o *EFUSE_Type) SetRD_SYS_DATA_PART1_7(value uint32) {
	volatile.StoreUint32(&o.RD_SYS_DATA_PART1_7.Reg, value)
}
func (o *EFUSE_Type) GetRD_SYS_DATA_PART1_7() uint32 {
	return volatile.LoadUint32(&o.RD_SYS_DATA_PART1_7.Reg)
}

// EFUSE.RD_USR_DATA0: Register %s of BLOCK3 (user).
func (o *EFUSE_Type) SetRD_USR_DATA0(value uint32) {
	volatile.StoreUint32(&o.RD_USR_DATA0.Reg, value)
}
func (o *EFUSE_Type) GetRD_USR_DATA0() uint32 {
	return volatile.LoadUint32(&o.RD_USR_DATA0.Reg)
}

// EFUSE.RD_USR_DATA1: Register %s of BLOCK3 (user).
func (o *EFUSE_Type) SetRD_USR_DATA1(value uint32) {
	volatile.StoreUint32(&o.RD_USR_DATA1.Reg, value)
}
func (o *EFUSE_Type) GetRD_USR_DATA1() uint32 {
	return volatile.LoadUint32(&o.RD_USR_DATA1.Reg)
}

// EFUSE.RD_USR_DATA2: Register %s of BLOCK3 (user).
func (o *EFUSE_Type) SetRD_USR_DATA2(value uint32) {
	volatile.StoreUint32(&o.RD_USR_DATA2.Reg, value)
}
func (o *EFUSE_Type) GetRD_USR_DATA2() uint32 {
	return volatile.LoadUint32(&o.RD_USR_DATA2.Reg)
}

// EFUSE.RD_USR_DATA3: Register %s of BLOCK3 (user).
func (o *EFUSE_Type) SetRD_USR_DATA3(value uint32) {
	volatile.StoreUint32(&o.RD_USR_DATA3.Reg, value)
}
func (o *EFUSE_Type) GetRD_USR_DATA3() uint32 {
	return volatile.LoadUint32(&o.RD_USR_DATA3.Reg)
}

// EFUSE.RD_USR_DATA4: Register %s of BLOCK3 (user).
func (o *EFUSE_Type) SetRD_USR_DATA4(value uint32) {
	volatile.StoreUint32(&o.RD_USR_DATA4.Reg, value)
}
func (o *EFUSE_Type) GetRD_USR_DATA4() uint32 {
	return volatile.LoadUint32(&o.RD_USR_DATA4.Reg)
}

// EFUSE.RD_USR_DATA5: Register %s of BLOCK3 (user).
func (o *EFUSE_Type) SetRD_USR_DATA5(value uint32) {
	volatile.StoreUint32(&o.RD_USR_DATA5.Reg, value)
}
func (o *EFUSE_Type) GetRD_USR_DATA5() uint32 {
	return volatile.LoadUint32(&o.RD_USR_DATA5.Reg)
}

// EFUSE.RD_USR_DATA6: Register %s of BLOCK3 (user).
func (o *EFUSE_Type) SetRD_USR_DATA6(value uint32) {
	volatile.StoreUint32(&o.RD_USR_DATA6.Reg, value)
}
func (o *EFUSE_Type) GetRD_USR_DATA6() uint32 {
	return volatile.LoadUint32(&o.RD_USR_DATA6.Reg)
}

// EFUSE.RD_USR_DATA7: Register %s of BLOCK3 (user).
func (o *EFUSE_Type) SetRD_USR_DATA7(value uint32) {
	volatile.StoreUint32(&o.RD_USR_DATA7.Reg, value)
}
func (o *EFUSE_Type) GetRD_USR_DATA7() uint32 {
	return volatile.LoadUint32(&o.RD_USR_DATA7.Reg)
}

// EFUSE.RD_KEY0_DATA0: Register %s of BLOCK4 (KEY0).
func (o *EFUSE_Type) SetRD_KEY0_DATA0(value uint32) {
	volatile.StoreUint32(&o.RD_KEY0_DATA0.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY0_DATA0() uint32 {
	return volatile.LoadUint32(&o.RD_KEY0_DATA0.Reg)
}

// EFUSE.RD_KEY0_DATA1: Register %s of BLOCK4 (KEY0).
func (o *EFUSE_Type) SetRD_KEY0_DATA1(value uint32) {
	volatile.StoreUint32(&o.RD_KEY0_DATA1.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY0_DATA1() uint32 {
	return volatile.LoadUint32(&o.RD_KEY0_DATA1.Reg)
}

// EFUSE.RD_KEY0_DATA2: Register %s of BLOCK4 (KEY0).
func (o *EFUSE_Type) SetRD_KEY0_DATA2(value uint32) {
	volatile.StoreUint32(&o.RD_KEY0_DATA2.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY0_DATA2() uint32 {
	return volatile.LoadUint32(&o.RD_KEY0_DATA2.Reg)
}

// EFUSE.RD_KEY0_DATA3: Register %s of BLOCK4 (KEY0).
func (o *EFUSE_Type) SetRD_KEY0_DATA3(value uint32) {
	volatile.StoreUint32(&o.RD_KEY0_DATA3.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY0_DATA3() uint32 {
	return volatile.LoadUint32(&o.RD_KEY0_DATA3.Reg)
}

// EFUSE.RD_KEY0_DATA4: Register %s of BLOCK4 (KEY0).
func (o *EFUSE_Type) SetRD_KEY0_DATA4(value uint32) {
	volatile.StoreUint32(&o.RD_KEY0_DATA4.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY0_DATA4() uint32 {
	return volatile.LoadUint32(&o.RD_KEY0_DATA4.Reg)
}

// EFUSE.RD_KEY0_DATA5: Register %s of BLOCK4 (KEY0).
func (o *EFUSE_Type) SetRD_KEY0_DATA5(value uint32) {
	volatile.StoreUint32(&o.RD_KEY0_DATA5.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY0_DATA5() uint32 {
	return volatile.LoadUint32(&o.RD_KEY0_DATA5.Reg)
}

// EFUSE.RD_KEY0_DATA6: Register %s of BLOCK4 (KEY0).
func (o *EFUSE_Type) SetRD_KEY0_DATA6(value uint32) {
	volatile.StoreUint32(&o.RD_KEY0_DATA6.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY0_DATA6() uint32 {
	return volatile.LoadUint32(&o.RD_KEY0_DATA6.Reg)
}

// EFUSE.RD_KEY0_DATA7: Register %s of BLOCK4 (KEY0).
func (o *EFUSE_Type) SetRD_KEY0_DATA7(value uint32) {
	volatile.StoreUint32(&o.RD_KEY0_DATA7.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY0_DATA7() uint32 {
	return volatile.LoadUint32(&o.RD_KEY0_DATA7.Reg)
}

// EFUSE.RD_KEY1_DATA0: Register %s of BLOCK5 (KEY1).
func (o *EFUSE_Type) SetRD_KEY1_DATA0(value uint32) {
	volatile.StoreUint32(&o.RD_KEY1_DATA0.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY1_DATA0() uint32 {
	return volatile.LoadUint32(&o.RD_KEY1_DATA0.Reg)
}

// EFUSE.RD_KEY1_DATA1: Register %s of BLOCK5 (KEY1).
func (o *EFUSE_Type) SetRD_KEY1_DATA1(value uint32) {
	volatile.StoreUint32(&o.RD_KEY1_DATA1.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY1_DATA1() uint32 {
	return volatile.LoadUint32(&o.RD_KEY1_DATA1.Reg)
}

// EFUSE.RD_KEY1_DATA2: Register %s of BLOCK5 (KEY1).
func (o *EFUSE_Type) SetRD_KEY1_DATA2(value uint32) {
	volatile.StoreUint32(&o.RD_KEY1_DATA2.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY1_DATA2() uint32 {
	return volatile.LoadUint32(&o.RD_KEY1_DATA2.Reg)
}

// EFUSE.RD_KEY1_DATA3: Register %s of BLOCK5 (KEY1).
func (o *EFUSE_Type) SetRD_KEY1_DATA3(value uint32) {
	volatile.StoreUint32(&o.RD_KEY1_DATA3.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY1_DATA3() uint32 {
	return volatile.LoadUint32(&o.RD_KEY1_DATA3.Reg)
}

// EFUSE.RD_KEY1_DATA4: Register %s of BLOCK5 (KEY1).
func (o *EFUSE_Type) SetRD_KEY1_DATA4(value uint32) {
	volatile.StoreUint32(&o.RD_KEY1_DATA4.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY1_DATA4() uint32 {
	return volatile.LoadUint32(&o.RD_KEY1_DATA4.Reg)
}

// EFUSE.RD_KEY1_DATA5: Register %s of BLOCK5 (KEY1).
func (o *EFUSE_Type) SetRD_KEY1_DATA5(value uint32) {
	volatile.StoreUint32(&o.RD_KEY1_DATA5.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY1_DATA5() uint32 {
	return volatile.LoadUint32(&o.RD_KEY1_DATA5.Reg)
}

// EFUSE.RD_KEY1_DATA6: Register %s of BLOCK5 (KEY1).
func (o *EFUSE_Type) SetRD_KEY1_DATA6(value uint32) {
	volatile.StoreUint32(&o.RD_KEY1_DATA6.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY1_DATA6() uint32 {
	return volatile.LoadUint32(&o.RD_KEY1_DATA6.Reg)
}

// EFUSE.RD_KEY1_DATA7: Register %s of BLOCK5 (KEY1).
func (o *EFUSE_Type) SetRD_KEY1_DATA7(value uint32) {
	volatile.StoreUint32(&o.RD_KEY1_DATA7.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY1_DATA7() uint32 {
	return volatile.LoadUint32(&o.RD_KEY1_DATA7.Reg)
}

// EFUSE.RD_KEY2_DATA0: Register %s of BLOCK6 (KEY2).
func (o *EFUSE_Type) SetRD_KEY2_DATA0(value uint32) {
	volatile.StoreUint32(&o.RD_KEY2_DATA0.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY2_DATA0() uint32 {
	return volatile.LoadUint32(&o.RD_KEY2_DATA0.Reg)
}

// EFUSE.RD_KEY2_DATA1: Register %s of BLOCK6 (KEY2).
func (o *EFUSE_Type) SetRD_KEY2_DATA1(value uint32) {
	volatile.StoreUint32(&o.RD_KEY2_DATA1.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY2_DATA1() uint32 {
	return volatile.LoadUint32(&o.RD_KEY2_DATA1.Reg)
}

// EFUSE.RD_KEY2_DATA2: Register %s of BLOCK6 (KEY2).
func (o *EFUSE_Type) SetRD_KEY2_DATA2(value uint32) {
	volatile.StoreUint32(&o.RD_KEY2_DATA2.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY2_DATA2() uint32 {
	return volatile.LoadUint32(&o.RD_KEY2_DATA2.Reg)
}

// EFUSE.RD_KEY2_DATA3: Register %s of BLOCK6 (KEY2).
func (o *EFUSE_Type) SetRD_KEY2_DATA3(value uint32) {
	volatile.StoreUint32(&o.RD_KEY2_DATA3.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY2_DATA3() uint32 {
	return volatile.LoadUint32(&o.RD_KEY2_DATA3.Reg)
}

// EFUSE.RD_KEY2_DATA4: Register %s of BLOCK6 (KEY2).
func (o *EFUSE_Type) SetRD_KEY2_DATA4(value uint32) {
	volatile.StoreUint32(&o.RD_KEY2_DATA4.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY2_DATA4() uint32 {
	return volatile.LoadUint32(&o.RD_KEY2_DATA4.Reg)
}

// EFUSE.RD_KEY2_DATA5: Register %s of BLOCK6 (KEY2).
func (o *EFUSE_Type) SetRD_KEY2_DATA5(value uint32) {
	volatile.StoreUint32(&o.RD_KEY2_DATA5.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY2_DATA5() uint32 {
	return volatile.LoadUint32(&o.RD_KEY2_DATA5.Reg)
}

// EFUSE.RD_KEY2_DATA6: Register %s of BLOCK6 (KEY2).
func (o *EFUSE_Type) SetRD_KEY2_DATA6(value uint32) {
	volatile.StoreUint32(&o.RD_KEY2_DATA6.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY2_DATA6() uint32 {
	return volatile.LoadUint32(&o.RD_KEY2_DATA6.Reg)
}

// EFUSE.RD_KEY2_DATA7: Register %s of BLOCK6 (KEY2).
func (o *EFUSE_Type) SetRD_KEY2_DATA7(value uint32) {
	volatile.StoreUint32(&o.RD_KEY2_DATA7.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY2_DATA7() uint32 {
	return volatile.LoadUint32(&o.RD_KEY2_DATA7.Reg)
}

// EFUSE.RD_KEY3_DATA0: Register %s of BLOCK7 (KEY3).
func (o *EFUSE_Type) SetRD_KEY3_DATA0(value uint32) {
	volatile.StoreUint32(&o.RD_KEY3_DATA0.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY3_DATA0() uint32 {
	return volatile.LoadUint32(&o.RD_KEY3_DATA0.Reg)
}

// EFUSE.RD_KEY3_DATA1: Register %s of BLOCK7 (KEY3).
func (o *EFUSE_Type) SetRD_KEY3_DATA1(value uint32) {
	volatile.StoreUint32(&o.RD_KEY3_DATA1.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY3_DATA1() uint32 {
	return volatile.LoadUint32(&o.RD_KEY3_DATA1.Reg)
}

// EFUSE.RD_KEY3_DATA2: Register %s of BLOCK7 (KEY3).
func (o *EFUSE_Type) SetRD_KEY3_DATA2(value uint32) {
	volatile.StoreUint32(&o.RD_KEY3_DATA2.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY3_DATA2() uint32 {
	return volatile.LoadUint32(&o.RD_KEY3_DATA2.Reg)
}

// EFUSE.RD_KEY3_DATA3: Register %s of BLOCK7 (KEY3).
func (o *EFUSE_Type) SetRD_KEY3_DATA3(value uint32) {
	volatile.StoreUint32(&o.RD_KEY3_DATA3.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY3_DATA3() uint32 {
	return volatile.LoadUint32(&o.RD_KEY3_DATA3.Reg)
}

// EFUSE.RD_KEY3_DATA4: Register %s of BLOCK7 (KEY3).
func (o *EFUSE_Type) SetRD_KEY3_DATA4(value uint32) {
	volatile.StoreUint32(&o.RD_KEY3_DATA4.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY3_DATA4() uint32 {
	return volatile.LoadUint32(&o.RD_KEY3_DATA4.Reg)
}

// EFUSE.RD_KEY3_DATA5: Register %s of BLOCK7 (KEY3).
func (o *EFUSE_Type) SetRD_KEY3_DATA5(value uint32) {
	volatile.StoreUint32(&o.RD_KEY3_DATA5.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY3_DATA5() uint32 {
	return volatile.LoadUint32(&o.RD_KEY3_DATA5.Reg)
}

// EFUSE.RD_KEY3_DATA6: Register %s of BLOCK7 (KEY3).
func (o *EFUSE_Type) SetRD_KEY3_DATA6(value uint32) {
	volatile.StoreUint32(&o.RD_KEY3_DATA6.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY3_DATA6() uint32 {
	return volatile.LoadUint32(&o.RD_KEY3_DATA6.Reg)
}

// EFUSE.RD_KEY3_DATA7: Register %s of BLOCK7 (KEY3).
func (o *EFUSE_Type) SetRD_KEY3_DATA7(value uint32) {
	volatile.StoreUint32(&o.RD_KEY3_DATA7.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY3_DATA7() uint32 {
	return volatile.LoadUint32(&o.RD_KEY3_DATA7.Reg)
}

// EFUSE.RD_KEY4_DATA0: Register %s of BLOCK8 (KEY4).
func (o *EFUSE_Type) SetRD_KEY4_DATA0(value uint32) {
	volatile.StoreUint32(&o.RD_KEY4_DATA0.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY4_DATA0() uint32 {
	return volatile.LoadUint32(&o.RD_KEY4_DATA0.Reg)
}

// EFUSE.RD_KEY4_DATA1: Register %s of BLOCK8 (KEY4).
func (o *EFUSE_Type) SetRD_KEY4_DATA1(value uint32) {
	volatile.StoreUint32(&o.RD_KEY4_DATA1.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY4_DATA1() uint32 {
	return volatile.LoadUint32(&o.RD_KEY4_DATA1.Reg)
}

// EFUSE.RD_KEY4_DATA2: Register %s of BLOCK8 (KEY4).
func (o *EFUSE_Type) SetRD_KEY4_DATA2(value uint32) {
	volatile.StoreUint32(&o.RD_KEY4_DATA2.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY4_DATA2() uint32 {
	return volatile.LoadUint32(&o.RD_KEY4_DATA2.Reg)
}

// EFUSE.RD_KEY4_DATA3: Register %s of BLOCK8 (KEY4).
func (o *EFUSE_Type) SetRD_KEY4_DATA3(value uint32) {
	volatile.StoreUint32(&o.RD_KEY4_DATA3.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY4_DATA3() uint32 {
	return volatile.LoadUint32(&o.RD_KEY4_DATA3.Reg)
}

// EFUSE.RD_KEY4_DATA4: Register %s of BLOCK8 (KEY4).
func (o *EFUSE_Type) SetRD_KEY4_DATA4(value uint32) {
	volatile.StoreUint32(&o.RD_KEY4_DATA4.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY4_DATA4() uint32 {
	return volatile.LoadUint32(&o.RD_KEY4_DATA4.Reg)
}

// EFUSE.RD_KEY4_DATA5: Register %s of BLOCK8 (KEY4).
func (o *EFUSE_Type) SetRD_KEY4_DATA5(value uint32) {
	volatile.StoreUint32(&o.RD_KEY4_DATA5.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY4_DATA5() uint32 {
	return volatile.LoadUint32(&o.RD_KEY4_DATA5.Reg)
}

// EFUSE.RD_KEY4_DATA6: Register %s of BLOCK8 (KEY4).
func (o *EFUSE_Type) SetRD_KEY4_DATA6(value uint32) {
	volatile.StoreUint32(&o.RD_KEY4_DATA6.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY4_DATA6() uint32 {
	return volatile.LoadUint32(&o.RD_KEY4_DATA6.Reg)
}

// EFUSE.RD_KEY4_DATA7: Register %s of BLOCK8 (KEY4).
func (o *EFUSE_Type) SetRD_KEY4_DATA7(value uint32) {
	volatile.StoreUint32(&o.RD_KEY4_DATA7.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY4_DATA7() uint32 {
	return volatile.LoadUint32(&o.RD_KEY4_DATA7.Reg)
}

// EFUSE.RD_KEY5_DATA0: Register %s of BLOCK9 (KEY5).
func (o *EFUSE_Type) SetRD_KEY5_DATA0(value uint32) {
	volatile.StoreUint32(&o.RD_KEY5_DATA0.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY5_DATA0() uint32 {
	return volatile.LoadUint32(&o.RD_KEY5_DATA0.Reg)
}

// EFUSE.RD_KEY5_DATA1: Register %s of BLOCK9 (KEY5).
func (o *EFUSE_Type) SetRD_KEY5_DATA1(value uint32) {
	volatile.StoreUint32(&o.RD_KEY5_DATA1.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY5_DATA1() uint32 {
	return volatile.LoadUint32(&o.RD_KEY5_DATA1.Reg)
}

// EFUSE.RD_KEY5_DATA2: Register %s of BLOCK9 (KEY5).
func (o *EFUSE_Type) SetRD_KEY5_DATA2(value uint32) {
	volatile.StoreUint32(&o.RD_KEY5_DATA2.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY5_DATA2() uint32 {
	return volatile.LoadUint32(&o.RD_KEY5_DATA2.Reg)
}

// EFUSE.RD_KEY5_DATA3: Register %s of BLOCK9 (KEY5).
func (o *EFUSE_Type) SetRD_KEY5_DATA3(value uint32) {
	volatile.StoreUint32(&o.RD_KEY5_DATA3.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY5_DATA3() uint32 {
	return volatile.LoadUint32(&o.RD_KEY5_DATA3.Reg)
}

// EFUSE.RD_KEY5_DATA4: Register %s of BLOCK9 (KEY5).
func (o *EFUSE_Type) SetRD_KEY5_DATA4(value uint32) {
	volatile.StoreUint32(&o.RD_KEY5_DATA4.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY5_DATA4() uint32 {
	return volatile.LoadUint32(&o.RD_KEY5_DATA4.Reg)
}

// EFUSE.RD_KEY5_DATA5: Register %s of BLOCK9 (KEY5).
func (o *EFUSE_Type) SetRD_KEY5_DATA5(value uint32) {
	volatile.StoreUint32(&o.RD_KEY5_DATA5.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY5_DATA5() uint32 {
	return volatile.LoadUint32(&o.RD_KEY5_DATA5.Reg)
}

// EFUSE.RD_KEY5_DATA6: Register %s of BLOCK9 (KEY5).
func (o *EFUSE_Type) SetRD_KEY5_DATA6(value uint32) {
	volatile.StoreUint32(&o.RD_KEY5_DATA6.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY5_DATA6() uint32 {
	return volatile.LoadUint32(&o.RD_KEY5_DATA6.Reg)
}

// EFUSE.RD_KEY5_DATA7: Register %s of BLOCK9 (KEY5).
func (o *EFUSE_Type) SetRD_KEY5_DATA7(value uint32) {
	volatile.StoreUint32(&o.RD_KEY5_DATA7.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY5_DATA7() uint32 {
	return volatile.LoadUint32(&o.RD_KEY5_DATA7.Reg)
}

// EFUSE.RD_SYS_DATA_PART2_0: Register %s of BLOCK10 (system).
func (o *EFUSE_Type) SetRD_SYS_DATA_PART2_0(value uint32) {
	volatile.StoreUint32(&o.RD_SYS_DATA_PART2_0.Reg, value)
}
func (o *EFUSE_Type) GetRD_SYS_DATA_PART2_0() uint32 {
	return volatile.LoadUint32(&o.RD_SYS_DATA_PART2_0.Reg)
}

// EFUSE.RD_SYS_DATA_PART2_1: Register %s of BLOCK10 (system).
func (o *EFUSE_Type) SetRD_SYS_DATA_PART2_1(value uint32) {
	volatile.StoreUint32(&o.RD_SYS_DATA_PART2_1.Reg, value)
}
func (o *EFUSE_Type) GetRD_SYS_DATA_PART2_1() uint32 {
	return volatile.LoadUint32(&o.RD_SYS_DATA_PART2_1.Reg)
}

// EFUSE.RD_SYS_DATA_PART2_2: Register %s of BLOCK10 (system).
func (o *EFUSE_Type) SetRD_SYS_DATA_PART2_2(value uint32) {
	volatile.StoreUint32(&o.RD_SYS_DATA_PART2_2.Reg, value)
}
func (o *EFUSE_Type) GetRD_SYS_DATA_PART2_2() uint32 {
	return volatile.LoadUint32(&o.RD_SYS_DATA_PART2_2.Reg)
}

// EFUSE.RD_SYS_DATA_PART2_3: Register %s of BLOCK10 (system).
func (o *EFUSE_Type) SetRD_SYS_DATA_PART2_3(value uint32) {
	volatile.StoreUint32(&o.RD_SYS_DATA_PART2_3.Reg, value)
}
func (o *EFUSE_Type) GetRD_SYS_DATA_PART2_3() uint32 {
	return volatile.LoadUint32(&o.RD_SYS_DATA_PART2_3.Reg)
}

// EFUSE.RD_SYS_DATA_PART2_4: Register %s of BLOCK10 (system).
func (o *EFUSE_Type) SetRD_SYS_DATA_PART2_4(value uint32) {
	volatile.StoreUint32(&o.RD_SYS_DATA_PART2_4.Reg, value)
}
func (o *EFUSE_Type) GetRD_SYS_DATA_PART2_4() uint32 {
	return volatile.LoadUint32(&o.RD_SYS_DATA_PART2_4.Reg)
}

// EFUSE.RD_SYS_DATA_PART2_5: Register %s of BLOCK10 (system).
func (o *EFUSE_Type) SetRD_SYS_DATA_PART2_5(value uint32) {
	volatile.StoreUint32(&o.RD_SYS_DATA_PART2_5.Reg, value)
}
func (o *EFUSE_Type) GetRD_SYS_DATA_PART2_5() uint32 {
	return volatile.LoadUint32(&o.RD_SYS_DATA_PART2_5.Reg)
}

// EFUSE.RD_SYS_DATA_PART2_6: Register %s of BLOCK10 (system).
func (o *EFUSE_Type) SetRD_SYS_DATA_PART2_6(value uint32) {
	volatile.StoreUint32(&o.RD_SYS_DATA_PART2_6.Reg, value)
}
func (o *EFUSE_Type) GetRD_SYS_DATA_PART2_6() uint32 {
	return volatile.LoadUint32(&o.RD_SYS_DATA_PART2_6.Reg)
}

// EFUSE.RD_SYS_DATA_PART2_7: Register %s of BLOCK10 (system).
func (o *EFUSE_Type) SetRD_SYS_DATA_PART2_7(value uint32) {
	volatile.StoreUint32(&o.RD_SYS_DATA_PART2_7.Reg, value)
}
func (o *EFUSE_Type) GetRD_SYS_DATA_PART2_7() uint32 {
	return volatile.LoadUint32(&o.RD_SYS_DATA_PART2_7.Reg)
}

// EFUSE.RD_REPEAT_ERR0: Programming error record register 0 of BLOCK0.
func (o *EFUSE_Type) SetRD_REPEAT_ERR0_RD_DIS_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR0.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg)&^(0x7f)|value)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR0_RD_DIS_ERR() uint32 {
	return volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg) & 0x7f
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR0_DIS_RTC_RAM_BOOT_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR0.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg)&^(0x80)|value<<7)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR0_DIS_RTC_RAM_BOOT_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg) & 0x80) >> 7
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR0_DIS_ICACHE_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR0.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg)&^(0x100)|value<<8)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR0_DIS_ICACHE_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg) & 0x100) >> 8
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR0_DIS_DCACHE_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR0.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg)&^(0x200)|value<<9)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR0_DIS_DCACHE_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg) & 0x200) >> 9
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR0_DIS_DOWNLOAD_ICACHE_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR0.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg)&^(0x400)|value<<10)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR0_DIS_DOWNLOAD_ICACHE_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg) & 0x400) >> 10
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR0_DIS_DOWNLOAD_DCACHE_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR0.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg)&^(0x800)|value<<11)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR0_DIS_DOWNLOAD_DCACHE_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg) & 0x800) >> 11
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR0_DIS_FORCE_DOWNLOAD_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR0.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg)&^(0x1000)|value<<12)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR0_DIS_FORCE_DOWNLOAD_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg) & 0x1000) >> 12
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR0_DIS_USB_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR0.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg)&^(0x2000)|value<<13)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR0_DIS_USB_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg) & 0x2000) >> 13
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR0_DIS_CAN_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR0.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg)&^(0x4000)|value<<14)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR0_DIS_CAN_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg) & 0x4000) >> 14
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR0_DIS_BOOT_REMAP_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR0.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg)&^(0x8000)|value<<15)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR0_DIS_BOOT_REMAP_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg) & 0x8000) >> 15
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR0_RPT4_RESERVED5_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR0.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg)&^(0x10000)|value<<16)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR0_RPT4_RESERVED5_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg) & 0x10000) >> 16
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR0_SOFT_DIS_JTAG_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR0.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg)&^(0x20000)|value<<17)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR0_SOFT_DIS_JTAG_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg) & 0x20000) >> 17
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR0_HARD_DIS_JTAG_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR0.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg)&^(0x40000)|value<<18)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR0_HARD_DIS_JTAG_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg) & 0x40000) >> 18
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR0_DIS_DOWNLOAD_MANUAL_ENCRYPT_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR0.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg)&^(0x80000)|value<<19)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR0_DIS_DOWNLOAD_MANUAL_ENCRYPT_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg) & 0x80000) >> 19
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR0_USB_DREFH_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR0.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg)&^(0x300000)|value<<20)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR0_USB_DREFH_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg) & 0x300000) >> 20
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR0_USB_DREFL_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR0.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg)&^(0xc00000)|value<<22)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR0_USB_DREFL_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg) & 0xc00000) >> 22
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR0_USB_EXCHG_PINS_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR0.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg)&^(0x1000000)|value<<24)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR0_USB_EXCHG_PINS_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg) & 0x1000000) >> 24
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR0_EXT_PHY_ENABLE_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR0.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg)&^(0x2000000)|value<<25)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR0_EXT_PHY_ENABLE_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg) & 0x2000000) >> 25
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR0_USB_FORCE_NOPERSIST_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR0.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg)&^(0x4000000)|value<<26)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR0_USB_FORCE_NOPERSIST_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg) & 0x4000000) >> 26
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR0_RPT4_RESERVED0_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR0.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg)&^(0x18000000)|value<<27)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR0_RPT4_RESERVED0_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg) & 0x18000000) >> 27
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR0_VDD_SPI_MODECURLIM_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR0.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg)&^(0x20000000)|value<<29)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR0_VDD_SPI_MODECURLIM_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg) & 0x20000000) >> 29
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR0_VDD_SPI_DREFH_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR0.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg)&^(0xc0000000)|value<<30)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR0_VDD_SPI_DREFH_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg) & 0xc0000000) >> 30
}

// EFUSE.RD_REPEAT_ERR1: Programming error record register 1 of BLOCK0.
func (o *EFUSE_Type) SetRD_REPEAT_ERR1_VDD_SPI_DREFM_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR1.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR1.Reg)&^(0x3)|value)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR1_VDD_SPI_DREFM_ERR() uint32 {
	return volatile.LoadUint32(&o.RD_REPEAT_ERR1.Reg) & 0x3
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR1_VDD_SPI_DREFL_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR1.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR1.Reg)&^(0xc)|value<<2)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR1_VDD_SPI_DREFL_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR1.Reg) & 0xc) >> 2
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR1_VDD_SPI_XPD_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR1.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR1.Reg)&^(0x10)|value<<4)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR1_VDD_SPI_XPD_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR1.Reg) & 0x10) >> 4
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR1_VDD_SPI_TIEH_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR1.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR1.Reg)&^(0x20)|value<<5)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR1_VDD_SPI_TIEH_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR1.Reg) & 0x20) >> 5
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR1_VDD_SPI_FORCE_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR1.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR1.Reg)&^(0x40)|value<<6)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR1_VDD_SPI_FORCE_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR1.Reg) & 0x40) >> 6
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR1_VDD_SPI_EN_INIT_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR1.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR1.Reg)&^(0x80)|value<<7)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR1_VDD_SPI_EN_INIT_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR1.Reg) & 0x80) >> 7
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR1_VDD_SPI_ENCURLIM_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR1.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR1.Reg)&^(0x100)|value<<8)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR1_VDD_SPI_ENCURLIM_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR1.Reg) & 0x100) >> 8
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR1_VDD_SPI_DCURLIM_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR1.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR1.Reg)&^(0xe00)|value<<9)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR1_VDD_SPI_DCURLIM_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR1.Reg) & 0xe00) >> 9
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR1_VDD_SPI_INIT_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR1.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR1.Reg)&^(0x3000)|value<<12)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR1_VDD_SPI_INIT_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR1.Reg) & 0x3000) >> 12
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR1_VDD_SPI_DCAP_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR1.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR1.Reg)&^(0xc000)|value<<14)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR1_VDD_SPI_DCAP_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR1.Reg) & 0xc000) >> 14
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR1_WDT_DELAY_SEL_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR1.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR1.Reg)&^(0x30000)|value<<16)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR1_WDT_DELAY_SEL_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR1.Reg) & 0x30000) >> 16
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR1_SPI_BOOT_CRYPT_CNT_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR1.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR1.Reg)&^(0x1c0000)|value<<18)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR1_SPI_BOOT_CRYPT_CNT_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR1.Reg) & 0x1c0000) >> 18
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR1_SECURE_BOOT_KEY_REVOKE0_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR1.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR1.Reg)&^(0x200000)|value<<21)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR1_SECURE_BOOT_KEY_REVOKE0_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR1.Reg) & 0x200000) >> 21
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR1_SECURE_BOOT_KEY_REVOKE1_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR1.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR1.Reg)&^(0x400000)|value<<22)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR1_SECURE_BOOT_KEY_REVOKE1_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR1.Reg) & 0x400000) >> 22
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR1_SECURE_BOOT_KEY_REVOKE2_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR1.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR1.Reg)&^(0x800000)|value<<23)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR1_SECURE_BOOT_KEY_REVOKE2_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR1.Reg) & 0x800000) >> 23
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR1_KEY_PURPOSE_0_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR1.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR1.Reg)&^(0xf000000)|value<<24)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR1_KEY_PURPOSE_0_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR1.Reg) & 0xf000000) >> 24
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR1_KEY_PURPOSE_1_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR1.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR1.Reg)&^(0xf0000000)|value<<28)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR1_KEY_PURPOSE_1_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR1.Reg) & 0xf0000000) >> 28
}

// EFUSE.RD_REPEAT_ERR2: Programming error record register 2 of BLOCK0.
func (o *EFUSE_Type) SetRD_REPEAT_ERR2_KEY_PURPOSE_2_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR2.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR2.Reg)&^(0xf)|value)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR2_KEY_PURPOSE_2_ERR() uint32 {
	return volatile.LoadUint32(&o.RD_REPEAT_ERR2.Reg) & 0xf
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR2_KEY_PURPOSE_3_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR2.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR2.Reg)&^(0xf0)|value<<4)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR2_KEY_PURPOSE_3_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR2.Reg) & 0xf0) >> 4
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR2_KEY_PURPOSE_4_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR2.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR2.Reg)&^(0xf00)|value<<8)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR2_KEY_PURPOSE_4_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR2.Reg) & 0xf00) >> 8
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR2_KEY_PURPOSE_5_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR2.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR2.Reg)&^(0xf000)|value<<12)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR2_KEY_PURPOSE_5_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR2.Reg) & 0xf000) >> 12
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR2_KEY_PURPOSE_6_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR2.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR2.Reg)&^(0xf0000)|value<<16)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR2_KEY_PURPOSE_6_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR2.Reg) & 0xf0000) >> 16
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR2_SECURE_BOOT_EN_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR2.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR2.Reg)&^(0x100000)|value<<20)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR2_SECURE_BOOT_EN_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR2.Reg) & 0x100000) >> 20
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR2_SECURE_BOOT_AGGRESSIVE_REVOKE_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR2.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR2.Reg)&^(0x200000)|value<<21)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR2_SECURE_BOOT_AGGRESSIVE_REVOKE_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR2.Reg) & 0x200000) >> 21
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR2_RPT4_RESERVED1_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR2.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR2.Reg)&^(0xfc00000)|value<<22)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR2_RPT4_RESERVED1_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR2.Reg) & 0xfc00000) >> 22
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR2_FLASH_TPUW_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR2.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR2.Reg)&^(0xf0000000)|value<<28)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR2_FLASH_TPUW_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR2.Reg) & 0xf0000000) >> 28
}

// EFUSE.RD_REPEAT_ERR3: Programming error record register 3 of BLOCK0.
func (o *EFUSE_Type) SetRD_REPEAT_ERR3_DIS_DOWNLOAD_MODE_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR3.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR3.Reg)&^(0x1)|value)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR3_DIS_DOWNLOAD_MODE_ERR() uint32 {
	return volatile.LoadUint32(&o.RD_REPEAT_ERR3.Reg) & 0x1
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR3_DIS_LEGACY_SPI_BOOT_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR3.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR3.Reg)&^(0x2)|value<<1)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR3_DIS_LEGACY_SPI_BOOT_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR3.Reg) & 0x2) >> 1
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR3_UART_PRINT_CHANNEL_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR3.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR3.Reg)&^(0x4)|value<<2)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR3_UART_PRINT_CHANNEL_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR3.Reg) & 0x4) >> 2
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR3_RPT4_RESERVED3_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR3.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR3.Reg)&^(0x8)|value<<3)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR3_RPT4_RESERVED3_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR3.Reg) & 0x8) >> 3
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR3_DIS_USB_DOWNLOAD_MODE_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR3.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR3.Reg)&^(0x10)|value<<4)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR3_DIS_USB_DOWNLOAD_MODE_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR3.Reg) & 0x10) >> 4
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR3_ENABLE_SECURITY_DOWNLOAD_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR3.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR3.Reg)&^(0x20)|value<<5)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR3_ENABLE_SECURITY_DOWNLOAD_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR3.Reg) & 0x20) >> 5
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR3_UART_PRINT_CONTROL_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR3.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR3.Reg)&^(0xc0)|value<<6)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR3_UART_PRINT_CONTROL_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR3.Reg) & 0xc0) >> 6
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR3_PIN_POWER_SELECTION_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR3.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR3.Reg)&^(0x100)|value<<8)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR3_PIN_POWER_SELECTION_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR3.Reg) & 0x100) >> 8
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR3_FLASH_TYPE_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR3.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR3.Reg)&^(0x200)|value<<9)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR3_FLASH_TYPE_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR3.Reg) & 0x200) >> 9
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR3_FORCE_SEND_RESUME_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR3.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR3.Reg)&^(0x400)|value<<10)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR3_FORCE_SEND_RESUME_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR3.Reg) & 0x400) >> 10
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR3_SECURE_VERSION_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR3.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR3.Reg)&^(0x7fff800)|value<<11)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR3_SECURE_VERSION_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR3.Reg) & 0x7fff800) >> 11
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR3_RPT4_RESERVED2_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR3.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR3.Reg)&^(0xf8000000)|value<<27)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR3_RPT4_RESERVED2_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR3.Reg) & 0xf8000000) >> 27
}

// EFUSE.RD_REPEAT_ERR4: Programming error record register 4 of BLOCK0.
func (o *EFUSE_Type) SetRD_REPEAT_ERR4_RPT4_RESERVED4_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR4.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR4.Reg)&^(0xffffff)|value)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR4_RPT4_RESERVED4_ERR() uint32 {
	return volatile.LoadUint32(&o.RD_REPEAT_ERR4.Reg) & 0xffffff
}

// EFUSE.RD_RS_ERR0: Programming error record register 0 of BLOCK1-10.
func (o *EFUSE_Type) SetRD_RS_ERR0_MAC_SPI_8M_ERR_NUM(value uint32) {
	volatile.StoreUint32(&o.RD_RS_ERR0.Reg, volatile.LoadUint32(&o.RD_RS_ERR0.Reg)&^(0x7)|value)
}
func (o *EFUSE_Type) GetRD_RS_ERR0_MAC_SPI_8M_ERR_NUM() uint32 {
	return volatile.LoadUint32(&o.RD_RS_ERR0.Reg) & 0x7
}
func (o *EFUSE_Type) SetRD_RS_ERR0_MAC_SPI_8M_FAIL(value uint32) {
	volatile.StoreUint32(&o.RD_RS_ERR0.Reg, volatile.LoadUint32(&o.RD_RS_ERR0.Reg)&^(0x8)|value<<3)
}
func (o *EFUSE_Type) GetRD_RS_ERR0_MAC_SPI_8M_FAIL() uint32 {
	return (volatile.LoadUint32(&o.RD_RS_ERR0.Reg) & 0x8) >> 3
}
func (o *EFUSE_Type) SetRD_RS_ERR0_SYS_PART1_NUM(value uint32) {
	volatile.StoreUint32(&o.RD_RS_ERR0.Reg, volatile.LoadUint32(&o.RD_RS_ERR0.Reg)&^(0x70)|value<<4)
}
func (o *EFUSE_Type) GetRD_RS_ERR0_SYS_PART1_NUM() uint32 {
	return (volatile.LoadUint32(&o.RD_RS_ERR0.Reg) & 0x70) >> 4
}
func (o *EFUSE_Type) SetRD_RS_ERR0_SYS_PART1_FAIL(value uint32) {
	volatile.StoreUint32(&o.RD_RS_ERR0.Reg, volatile.LoadUint32(&o.RD_RS_ERR0.Reg)&^(0x80)|value<<7)
}
func (o *EFUSE_Type) GetRD_RS_ERR0_SYS_PART1_FAIL() uint32 {
	return (volatile.LoadUint32(&o.RD_RS_ERR0.Reg) & 0x80) >> 7
}
func (o *EFUSE_Type) SetRD_RS_ERR0_USR_DATA_ERR_NUM(value uint32) {
	volatile.StoreUint32(&o.RD_RS_ERR0.Reg, volatile.LoadUint32(&o.RD_RS_ERR0.Reg)&^(0x700)|value<<8)
}
func (o *EFUSE_Type) GetRD_RS_ERR0_USR_DATA_ERR_NUM() uint32 {
	return (volatile.LoadUint32(&o.RD_RS_ERR0.Reg) & 0x700) >> 8
}
func (o *EFUSE_Type) SetRD_RS_ERR0_USR_DATA_FAIL(value uint32) {
	volatile.StoreUint32(&o.RD_RS_ERR0.Reg, volatile.LoadUint32(&o.RD_RS_ERR0.Reg)&^(0x800)|value<<11)
}
func (o *EFUSE_Type) GetRD_RS_ERR0_USR_DATA_FAIL() uint32 {
	return (volatile.LoadUint32(&o.RD_RS_ERR0.Reg) & 0x800) >> 11
}
func (o *EFUSE_Type) SetRD_RS_ERR0_KEY0_ERR_NUM(value uint32) {
	volatile.StoreUint32(&o.RD_RS_ERR0.Reg, volatile.LoadUint32(&o.RD_RS_ERR0.Reg)&^(0x7000)|value<<12)
}
func (o *EFUSE_Type) GetRD_RS_ERR0_KEY0_ERR_NUM() uint32 {
	return (volatile.LoadUint32(&o.RD_RS_ERR0.Reg) & 0x7000) >> 12
}
func (o *EFUSE_Type) SetRD_RS_ERR0_KEY0_FAIL(value uint32) {
	volatile.StoreUint32(&o.RD_RS_ERR0.Reg, volatile.LoadUint32(&o.RD_RS_ERR0.Reg)&^(0x8000)|value<<15)
}
func (o *EFUSE_Type) GetRD_RS_ERR0_KEY0_FAIL() uint32 {
	return (volatile.LoadUint32(&o.RD_RS_ERR0.Reg) & 0x8000) >> 15
}
func (o *EFUSE_Type) SetRD_RS_ERR0_KEY1_ERR_NUM(value uint32) {
	volatile.StoreUint32(&o.RD_RS_ERR0.Reg, volatile.LoadUint32(&o.RD_RS_ERR0.Reg)&^(0x70000)|value<<16)
}
func (o *EFUSE_Type) GetRD_RS_ERR0_KEY1_ERR_NUM() uint32 {
	return (volatile.LoadUint32(&o.RD_RS_ERR0.Reg) & 0x70000) >> 16
}
func (o *EFUSE_Type) SetRD_RS_ERR0_KEY1_FAIL(value uint32) {
	volatile.StoreUint32(&o.RD_RS_ERR0.Reg, volatile.LoadUint32(&o.RD_RS_ERR0.Reg)&^(0x80000)|value<<19)
}
func (o *EFUSE_Type) GetRD_RS_ERR0_KEY1_FAIL() uint32 {
	return (volatile.LoadUint32(&o.RD_RS_ERR0.Reg) & 0x80000) >> 19
}
func (o *EFUSE_Type) SetRD_RS_ERR0_KEY2_ERR_NUM(value uint32) {
	volatile.StoreUint32(&o.RD_RS_ERR0.Reg, volatile.LoadUint32(&o.RD_RS_ERR0.Reg)&^(0x700000)|value<<20)
}
func (o *EFUSE_Type) GetRD_RS_ERR0_KEY2_ERR_NUM() uint32 {
	return (volatile.LoadUint32(&o.RD_RS_ERR0.Reg) & 0x700000) >> 20
}
func (o *EFUSE_Type) SetRD_RS_ERR0_KEY2_FAIL(value uint32) {
	volatile.StoreUint32(&o.RD_RS_ERR0.Reg, volatile.LoadUint32(&o.RD_RS_ERR0.Reg)&^(0x800000)|value<<23)
}
func (o *EFUSE_Type) GetRD_RS_ERR0_KEY2_FAIL() uint32 {
	return (volatile.LoadUint32(&o.RD_RS_ERR0.Reg) & 0x800000) >> 23
}
func (o *EFUSE_Type) SetRD_RS_ERR0_KEY3_ERR_NUM(value uint32) {
	volatile.StoreUint32(&o.RD_RS_ERR0.Reg, volatile.LoadUint32(&o.RD_RS_ERR0.Reg)&^(0x7000000)|value<<24)
}
func (o *EFUSE_Type) GetRD_RS_ERR0_KEY3_ERR_NUM() uint32 {
	return (volatile.LoadUint32(&o.RD_RS_ERR0.Reg) & 0x7000000) >> 24
}
func (o *EFUSE_Type) SetRD_RS_ERR0_KEY3_FAIL(value uint32) {
	volatile.StoreUint32(&o.RD_RS_ERR0.Reg, volatile.LoadUint32(&o.RD_RS_ERR0.Reg)&^(0x8000000)|value<<27)
}
func (o *EFUSE_Type) GetRD_RS_ERR0_KEY3_FAIL() uint32 {
	return (volatile.LoadUint32(&o.RD_RS_ERR0.Reg) & 0x8000000) >> 27
}
func (o *EFUSE_Type) SetRD_RS_ERR0_KEY4_ERR_NUM(value uint32) {
	volatile.StoreUint32(&o.RD_RS_ERR0.Reg, volatile.LoadUint32(&o.RD_RS_ERR0.Reg)&^(0x70000000)|value<<28)
}
func (o *EFUSE_Type) GetRD_RS_ERR0_KEY4_ERR_NUM() uint32 {
	return (volatile.LoadUint32(&o.RD_RS_ERR0.Reg) & 0x70000000) >> 28
}
func (o *EFUSE_Type) SetRD_RS_ERR0_KEY4_FAIL(value uint32) {
	volatile.StoreUint32(&o.RD_RS_ERR0.Reg, volatile.LoadUint32(&o.RD_RS_ERR0.Reg)&^(0x80000000)|value<<31)
}
func (o *EFUSE_Type) GetRD_RS_ERR0_KEY4_FAIL() uint32 {
	return (volatile.LoadUint32(&o.RD_RS_ERR0.Reg) & 0x80000000) >> 31
}

// EFUSE.RD_RS_ERR1: Programming error record register 1 of BLOCK1-10.
func (o *EFUSE_Type) SetRD_RS_ERR1_KEY5_ERR_NUM(value uint32) {
	volatile.StoreUint32(&o.RD_RS_ERR1.Reg, volatile.LoadUint32(&o.RD_RS_ERR1.Reg)&^(0x7)|value)
}
func (o *EFUSE_Type) GetRD_RS_ERR1_KEY5_ERR_NUM() uint32 {
	return volatile.LoadUint32(&o.RD_RS_ERR1.Reg) & 0x7
}
func (o *EFUSE_Type) SetRD_RS_ERR1_KEY5_FAIL(value uint32) {
	volatile.StoreUint32(&o.RD_RS_ERR1.Reg, volatile.LoadUint32(&o.RD_RS_ERR1.Reg)&^(0x8)|value<<3)
}
func (o *EFUSE_Type) GetRD_RS_ERR1_KEY5_FAIL() uint32 {
	return (volatile.LoadUint32(&o.RD_RS_ERR1.Reg) & 0x8) >> 3
}
func (o *EFUSE_Type) SetRD_RS_ERR1_SYS_PART2_ERR_NUM(value uint32) {
	volatile.StoreUint32(&o.RD_RS_ERR1.Reg, volatile.LoadUint32(&o.RD_RS_ERR1.Reg)&^(0x70)|value<<4)
}
func (o *EFUSE_Type) GetRD_RS_ERR1_SYS_PART2_ERR_NUM() uint32 {
	return (volatile.LoadUint32(&o.RD_RS_ERR1.Reg) & 0x70) >> 4
}
func (o *EFUSE_Type) SetRD_RS_ERR1_SYS_PART2_FAIL(value uint32) {
	volatile.StoreUint32(&o.RD_RS_ERR1.Reg, volatile.LoadUint32(&o.RD_RS_ERR1.Reg)&^(0x80)|value<<7)
}
func (o *EFUSE_Type) GetRD_RS_ERR1_SYS_PART2_FAIL() uint32 {
	return (volatile.LoadUint32(&o.RD_RS_ERR1.Reg) & 0x80) >> 7
}

// EFUSE.CLK: eFuse clock configuration register.
func (o *EFUSE_Type) SetCLK_EFUSE_MEM_FORCE_PD(value uint32) {
	volatile.StoreUint32(&o.CLK.Reg, volatile.LoadUint32(&o.CLK.Reg)&^(0x1)|value)
}
func (o *EFUSE_Type) GetCLK_EFUSE_MEM_FORCE_PD() uint32 {
	return volatile.LoadUint32(&o.CLK.Reg) & 0x1
}
func (o *EFUSE_Type) SetCLK_MEM_CLK_FORCE_ON(value uint32) {
	volatile.StoreUint32(&o.CLK.Reg, volatile.LoadUint32(&o.CLK.Reg)&^(0x2)|value<<1)
}
func (o *EFUSE_Type) GetCLK_MEM_CLK_FORCE_ON() uint32 {
	return (volatile.LoadUint32(&o.CLK.Reg) & 0x2) >> 1
}
func (o *EFUSE_Type) SetCLK_EFUSE_MEM_FORCE_PU(value uint32) {
	volatile.StoreUint32(&o.CLK.Reg, volatile.LoadUint32(&o.CLK.Reg)&^(0x4)|value<<2)
}
func (o *EFUSE_Type) GetCLK_EFUSE_MEM_FORCE_PU() uint32 {
	return (volatile.LoadUint32(&o.CLK.Reg) & 0x4) >> 2
}
func (o *EFUSE_Type) SetCLK_EN(value uint32) {
	volatile.StoreUint32(&o.CLK.Reg, volatile.LoadUint32(&o.CLK.Reg)&^(0x10000)|value<<16)
}
func (o *EFUSE_Type) GetCLK_EN() uint32 {
	return (volatile.LoadUint32(&o.CLK.Reg) & 0x10000) >> 16
}

// EFUSE.CONF: eFuse operation mode configuration register.
func (o *EFUSE_Type) SetCONF_OP_CODE(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0xffff)|value)
}
func (o *EFUSE_Type) GetCONF_OP_CODE() uint32 {
	return volatile.LoadUint32(&o.CONF.Reg) & 0xffff
}

// EFUSE.STATUS: eFuse status register.
func (o *EFUSE_Type) SetSTATUS_STATE(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0xf)|value)
}
func (o *EFUSE_Type) GetSTATUS_STATE() uint32 {
	return volatile.LoadUint32(&o.STATUS.Reg) & 0xf
}
func (o *EFUSE_Type) SetSTATUS_OTP_LOAD_SW(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x10)|value<<4)
}
func (o *EFUSE_Type) GetSTATUS_OTP_LOAD_SW() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x10) >> 4
}
func (o *EFUSE_Type) SetSTATUS_OTP_VDDQ_C_SYNC2(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x20)|value<<5)
}
func (o *EFUSE_Type) GetSTATUS_OTP_VDDQ_C_SYNC2() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x20) >> 5
}
func (o *EFUSE_Type) SetSTATUS_OTP_STROBE_SW(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x40)|value<<6)
}
func (o *EFUSE_Type) GetSTATUS_OTP_STROBE_SW() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x40) >> 6
}
func (o *EFUSE_Type) SetSTATUS_OTP_CSB_SW(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x80)|value<<7)
}
func (o *EFUSE_Type) GetSTATUS_OTP_CSB_SW() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x80) >> 7
}
func (o *EFUSE_Type) SetSTATUS_OTP_PGENB_SW(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x100)|value<<8)
}
func (o *EFUSE_Type) GetSTATUS_OTP_PGENB_SW() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x100) >> 8
}
func (o *EFUSE_Type) SetSTATUS_OTP_VDDQ_IS_SW(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x200)|value<<9)
}
func (o *EFUSE_Type) GetSTATUS_OTP_VDDQ_IS_SW() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x200) >> 9
}
func (o *EFUSE_Type) SetSTATUS_REPEAT_ERR_CNT(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x3fc00)|value<<10)
}
func (o *EFUSE_Type) GetSTATUS_REPEAT_ERR_CNT() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x3fc00) >> 10
}

// EFUSE.CMD: eFuse command register.
func (o *EFUSE_Type) SetCMD_READ_CMD(value uint32) {
	volatile.StoreUint32(&o.CMD.Reg, volatile.LoadUint32(&o.CMD.Reg)&^(0x1)|value)
}
func (o *EFUSE_Type) GetCMD_READ_CMD() uint32 {
	return volatile.LoadUint32(&o.CMD.Reg) & 0x1
}
func (o *EFUSE_Type) SetCMD_PGM_CMD(value uint32) {
	volatile.StoreUint32(&o.CMD.Reg, volatile.LoadUint32(&o.CMD.Reg)&^(0x2)|value<<1)
}
func (o *EFUSE_Type) GetCMD_PGM_CMD() uint32 {
	return (volatile.LoadUint32(&o.CMD.Reg) & 0x2) >> 1
}
func (o *EFUSE_Type) SetCMD_BLK_NUM(value uint32) {
	volatile.StoreUint32(&o.CMD.Reg, volatile.LoadUint32(&o.CMD.Reg)&^(0x3c)|value<<2)
}
func (o *EFUSE_Type) GetCMD_BLK_NUM() uint32 {
	return (volatile.LoadUint32(&o.CMD.Reg) & 0x3c) >> 2
}

// EFUSE.INT_RAW: eFuse raw interrupt register.
func (o *EFUSE_Type) SetINT_RAW_READ_DONE_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x1)|value)
}
func (o *EFUSE_Type) GetINT_RAW_READ_DONE_INT_RAW() uint32 {
	return volatile.LoadUint32(&o.INT_RAW.Reg) & 0x1
}
func (o *EFUSE_Type) SetINT_RAW_PGM_DONE_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x2)|value<<1)
}
func (o *EFUSE_Type) GetINT_RAW_PGM_DONE_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x2) >> 1
}

// EFUSE.INT_ST: eFuse interrupt status register.
func (o *EFUSE_Type) SetINT_ST_READ_DONE_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x1)|value)
}
func (o *EFUSE_Type) GetINT_ST_READ_DONE_INT_ST() uint32 {
	return volatile.LoadUint32(&o.INT_ST.Reg) & 0x1
}
func (o *EFUSE_Type) SetINT_ST_PGM_DONE_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x2)|value<<1)
}
func (o *EFUSE_Type) GetINT_ST_PGM_DONE_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x2) >> 1
}

// EFUSE.INT_ENA: eFuse interrupt enable register.
func (o *EFUSE_Type) SetINT_ENA_READ_DONE_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x1)|value)
}
func (o *EFUSE_Type) GetINT_ENA_READ_DONE_INT_ENA() uint32 {
	return volatile.LoadUint32(&o.INT_ENA.Reg) & 0x1
}
func (o *EFUSE_Type) SetINT_ENA_PGM_DONE_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x2)|value<<1)
}
func (o *EFUSE_Type) GetINT_ENA_PGM_DONE_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x2) >> 1
}

// EFUSE.INT_CLR: eFuse interrupt clear register.
func (o *EFUSE_Type) SetINT_CLR_READ_DONE_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x1)|value)
}
func (o *EFUSE_Type) GetINT_CLR_READ_DONE_INT_CLR() uint32 {
	return volatile.LoadUint32(&o.INT_CLR.Reg) & 0x1
}
func (o *EFUSE_Type) SetINT_CLR_PGM_DONE_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x2)|value<<1)
}
func (o *EFUSE_Type) GetINT_CLR_PGM_DONE_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x2) >> 1
}

// EFUSE.DAC_CONF: Controls the eFuse programming voltage.
func (o *EFUSE_Type) SetDAC_CONF_DAC_CLK_DIV(value uint32) {
	volatile.StoreUint32(&o.DAC_CONF.Reg, volatile.LoadUint32(&o.DAC_CONF.Reg)&^(0xff)|value)
}
func (o *EFUSE_Type) GetDAC_CONF_DAC_CLK_DIV() uint32 {
	return volatile.LoadUint32(&o.DAC_CONF.Reg) & 0xff
}
func (o *EFUSE_Type) SetDAC_CONF_DAC_CLK_PAD_SEL(value uint32) {
	volatile.StoreUint32(&o.DAC_CONF.Reg, volatile.LoadUint32(&o.DAC_CONF.Reg)&^(0x100)|value<<8)
}
func (o *EFUSE_Type) GetDAC_CONF_DAC_CLK_PAD_SEL() uint32 {
	return (volatile.LoadUint32(&o.DAC_CONF.Reg) & 0x100) >> 8
}
func (o *EFUSE_Type) SetDAC_CONF_DAC_NUM(value uint32) {
	volatile.StoreUint32(&o.DAC_CONF.Reg, volatile.LoadUint32(&o.DAC_CONF.Reg)&^(0x1fe00)|value<<9)
}
func (o *EFUSE_Type) GetDAC_CONF_DAC_NUM() uint32 {
	return (volatile.LoadUint32(&o.DAC_CONF.Reg) & 0x1fe00) >> 9
}
func (o *EFUSE_Type) SetDAC_CONF_OE_CLR(value uint32) {
	volatile.StoreUint32(&o.DAC_CONF.Reg, volatile.LoadUint32(&o.DAC_CONF.Reg)&^(0x20000)|value<<17)
}
func (o *EFUSE_Type) GetDAC_CONF_OE_CLR() uint32 {
	return (volatile.LoadUint32(&o.DAC_CONF.Reg) & 0x20000) >> 17
}

// EFUSE.RD_TIM_CONF: Configures read timing parameters.
func (o *EFUSE_Type) SetRD_TIM_CONF_THR_A(value uint32) {
	volatile.StoreUint32(&o.RD_TIM_CONF.Reg, volatile.LoadUint32(&o.RD_TIM_CONF.Reg)&^(0xff)|value)
}
func (o *EFUSE_Type) GetRD_TIM_CONF_THR_A() uint32 {
	return volatile.LoadUint32(&o.RD_TIM_CONF.Reg) & 0xff
}
func (o *EFUSE_Type) SetRD_TIM_CONF_TRD(value uint32) {
	volatile.StoreUint32(&o.RD_TIM_CONF.Reg, volatile.LoadUint32(&o.RD_TIM_CONF.Reg)&^(0xff00)|value<<8)
}
func (o *EFUSE_Type) GetRD_TIM_CONF_TRD() uint32 {
	return (volatile.LoadUint32(&o.RD_TIM_CONF.Reg) & 0xff00) >> 8
}
func (o *EFUSE_Type) SetRD_TIM_CONF_TSUR_A(value uint32) {
	volatile.StoreUint32(&o.RD_TIM_CONF.Reg, volatile.LoadUint32(&o.RD_TIM_CONF.Reg)&^(0xff0000)|value<<16)
}
func (o *EFUSE_Type) GetRD_TIM_CONF_TSUR_A() uint32 {
	return (volatile.LoadUint32(&o.RD_TIM_CONF.Reg) & 0xff0000) >> 16
}
func (o *EFUSE_Type) SetRD_TIM_CONF_READ_INIT_NUM(value uint32) {
	volatile.StoreUint32(&o.RD_TIM_CONF.Reg, volatile.LoadUint32(&o.RD_TIM_CONF.Reg)&^(0xff000000)|value<<24)
}
func (o *EFUSE_Type) GetRD_TIM_CONF_READ_INIT_NUM() uint32 {
	return (volatile.LoadUint32(&o.RD_TIM_CONF.Reg) & 0xff000000) >> 24
}

// EFUSE.WR_TIM_CONF0: Configuration register 0 of eFuse programming timing parameters.
func (o *EFUSE_Type) SetWR_TIM_CONF0_THP_A(value uint32) {
	volatile.StoreUint32(&o.WR_TIM_CONF0.Reg, volatile.LoadUint32(&o.WR_TIM_CONF0.Reg)&^(0xff)|value)
}
func (o *EFUSE_Type) GetWR_TIM_CONF0_THP_A() uint32 {
	return volatile.LoadUint32(&o.WR_TIM_CONF0.Reg) & 0xff
}
func (o *EFUSE_Type) SetWR_TIM_CONF0_TPGM_INACTIVE(value uint32) {
	volatile.StoreUint32(&o.WR_TIM_CONF0.Reg, volatile.LoadUint32(&o.WR_TIM_CONF0.Reg)&^(0xff00)|value<<8)
}
func (o *EFUSE_Type) GetWR_TIM_CONF0_TPGM_INACTIVE() uint32 {
	return (volatile.LoadUint32(&o.WR_TIM_CONF0.Reg) & 0xff00) >> 8
}
func (o *EFUSE_Type) SetWR_TIM_CONF0_TPGM(value uint32) {
	volatile.StoreUint32(&o.WR_TIM_CONF0.Reg, volatile.LoadUint32(&o.WR_TIM_CONF0.Reg)&^(0xffff0000)|value<<16)
}
func (o *EFUSE_Type) GetWR_TIM_CONF0_TPGM() uint32 {
	return (volatile.LoadUint32(&o.WR_TIM_CONF0.Reg) & 0xffff0000) >> 16
}

// EFUSE.WR_TIM_CONF1: Configuration register 1 of eFuse programming timing parameters.
func (o *EFUSE_Type) SetWR_TIM_CONF1_TSUP_A(value uint32) {
	volatile.StoreUint32(&o.WR_TIM_CONF1.Reg, volatile.LoadUint32(&o.WR_TIM_CONF1.Reg)&^(0xff)|value)
}
func (o *EFUSE_Type) GetWR_TIM_CONF1_TSUP_A() uint32 {
	return volatile.LoadUint32(&o.WR_TIM_CONF1.Reg) & 0xff
}
func (o *EFUSE_Type) SetWR_TIM_CONF1_PWR_ON_NUM(value uint32) {
	volatile.StoreUint32(&o.WR_TIM_CONF1.Reg, volatile.LoadUint32(&o.WR_TIM_CONF1.Reg)&^(0xffff00)|value<<8)
}
func (o *EFUSE_Type) GetWR_TIM_CONF1_PWR_ON_NUM() uint32 {
	return (volatile.LoadUint32(&o.WR_TIM_CONF1.Reg) & 0xffff00) >> 8
}

// EFUSE.WR_TIM_CONF2: Configuration register 2 of eFuse programming timing parameters.
func (o *EFUSE_Type) SetWR_TIM_CONF2_PWR_OFF_NUM(value uint32) {
	volatile.StoreUint32(&o.WR_TIM_CONF2.Reg, volatile.LoadUint32(&o.WR_TIM_CONF2.Reg)&^(0xffff)|value)
}
func (o *EFUSE_Type) GetWR_TIM_CONF2_PWR_OFF_NUM() uint32 {
	return volatile.LoadUint32(&o.WR_TIM_CONF2.Reg) & 0xffff
}

// EFUSE.DATE: Version control register.
func (o *EFUSE_Type) SetDATE(value uint32) {
	volatile.StoreUint32(&o.DATE.Reg, value)
}
func (o *EFUSE_Type) GetDATE() uint32 {
	return volatile.LoadUint32(&o.DATE.Reg)
}

// Peripheral GPIO
type GPIO_Type struct {
	BT_SELECT          volatile.Register32 // 0x0
	OUT                volatile.Register32 // 0x4
	OUT_W1TS           volatile.Register32 // 0x8
	OUT_W1TC           volatile.Register32 // 0xC
	OUT1               volatile.Register32 // 0x10
	OUT1_W1TS          volatile.Register32 // 0x14
	OUT1_W1TC          volatile.Register32 // 0x18
	SDIO_SELECT        volatile.Register32 // 0x1C
	ENABLE             volatile.Register32 // 0x20
	ENABLE_W1TS        volatile.Register32 // 0x24
	ENABLE_W1TC        volatile.Register32 // 0x28
	ENABLE1            volatile.Register32 // 0x2C
	ENABLE1_W1TS       volatile.Register32 // 0x30
	ENABLE1_W1TC       volatile.Register32 // 0x34
	STRAP              volatile.Register32 // 0x38
	IN                 volatile.Register32 // 0x3C
	IN1                volatile.Register32 // 0x40
	STATUS             volatile.Register32 // 0x44
	STATUS_W1TS        volatile.Register32 // 0x48
	STATUS_W1TC        volatile.Register32 // 0x4C
	STATUS1            volatile.Register32 // 0x50
	STATUS1_W1TS       volatile.Register32 // 0x54
	STATUS1_W1TC       volatile.Register32 // 0x58
	PCPU_INT           volatile.Register32 // 0x5C
	PCPU_NMI_INT       volatile.Register32 // 0x60
	CPUSDIO_INT        volatile.Register32 // 0x64
	PCPU_INT1          volatile.Register32 // 0x68
	PCPU_NMI_INT1      volatile.Register32 // 0x6C
	CPUSDIO_INT1       volatile.Register32 // 0x70
	PIN0               volatile.Register32 // 0x74
	PIN1               volatile.Register32 // 0x78
	PIN2               volatile.Register32 // 0x7C
	PIN3               volatile.Register32 // 0x80
	PIN4               volatile.Register32 // 0x84
	PIN5               volatile.Register32 // 0x88
	PIN6               volatile.Register32 // 0x8C
	PIN7               volatile.Register32 // 0x90
	PIN8               volatile.Register32 // 0x94
	PIN9               volatile.Register32 // 0x98
	PIN10              volatile.Register32 // 0x9C
	PIN11              volatile.Register32 // 0xA0
	PIN12              volatile.Register32 // 0xA4
	PIN13              volatile.Register32 // 0xA8
	PIN14              volatile.Register32 // 0xAC
	PIN15              volatile.Register32 // 0xB0
	PIN16              volatile.Register32 // 0xB4
	PIN17              volatile.Register32 // 0xB8
	PIN18              volatile.Register32 // 0xBC
	PIN19              volatile.Register32 // 0xC0
	PIN20              volatile.Register32 // 0xC4
	PIN21              volatile.Register32 // 0xC8
	PIN22              volatile.Register32 // 0xCC
	PIN23              volatile.Register32 // 0xD0
	PIN24              volatile.Register32 // 0xD4
	PIN25              volatile.Register32 // 0xD8
	PIN26              volatile.Register32 // 0xDC
	PIN27              volatile.Register32 // 0xE0
	PIN28              volatile.Register32 // 0xE4
	PIN29              volatile.Register32 // 0xE8
	PIN30              volatile.Register32 // 0xEC
	PIN31              volatile.Register32 // 0xF0
	PIN32              volatile.Register32 // 0xF4
	PIN33              volatile.Register32 // 0xF8
	PIN34              volatile.Register32 // 0xFC
	PIN35              volatile.Register32 // 0x100
	PIN36              volatile.Register32 // 0x104
	PIN37              volatile.Register32 // 0x108
	PIN38              volatile.Register32 // 0x10C
	PIN39              volatile.Register32 // 0x110
	PIN40              volatile.Register32 // 0x114
	PIN41              volatile.Register32 // 0x118
	PIN42              volatile.Register32 // 0x11C
	PIN43              volatile.Register32 // 0x120
	PIN44              volatile.Register32 // 0x124
	PIN45              volatile.Register32 // 0x128
	PIN46              volatile.Register32 // 0x12C
	PIN47              volatile.Register32 // 0x130
	PIN48              volatile.Register32 // 0x134
	PIN49              volatile.Register32 // 0x138
	PIN50              volatile.Register32 // 0x13C
	PIN51              volatile.Register32 // 0x140
	PIN52              volatile.Register32 // 0x144
	PIN53              volatile.Register32 // 0x148
	STATUS_NEXT        volatile.Register32 // 0x14C
	STATUS_NEXT1       volatile.Register32 // 0x150
	FUNC0_IN_SEL_CFG   volatile.Register32 // 0x154
	FUNC1_IN_SEL_CFG   volatile.Register32 // 0x158
	FUNC2_IN_SEL_CFG   volatile.Register32 // 0x15C
	FUNC3_IN_SEL_CFG   volatile.Register32 // 0x160
	FUNC4_IN_SEL_CFG   volatile.Register32 // 0x164
	FUNC5_IN_SEL_CFG   volatile.Register32 // 0x168
	FUNC6_IN_SEL_CFG   volatile.Register32 // 0x16C
	FUNC7_IN_SEL_CFG   volatile.Register32 // 0x170
	FUNC8_IN_SEL_CFG   volatile.Register32 // 0x174
	FUNC9_IN_SEL_CFG   volatile.Register32 // 0x178
	FUNC10_IN_SEL_CFG  volatile.Register32 // 0x17C
	FUNC11_IN_SEL_CFG  volatile.Register32 // 0x180
	FUNC12_IN_SEL_CFG  volatile.Register32 // 0x184
	FUNC13_IN_SEL_CFG  volatile.Register32 // 0x188
	FUNC14_IN_SEL_CFG  volatile.Register32 // 0x18C
	FUNC15_IN_SEL_CFG  volatile.Register32 // 0x190
	FUNC16_IN_SEL_CFG  volatile.Register32 // 0x194
	FUNC17_IN_SEL_CFG  volatile.Register32 // 0x198
	FUNC18_IN_SEL_CFG  volatile.Register32 // 0x19C
	FUNC19_IN_SEL_CFG  volatile.Register32 // 0x1A0
	FUNC20_IN_SEL_CFG  volatile.Register32 // 0x1A4
	FUNC21_IN_SEL_CFG  volatile.Register32 // 0x1A8
	FUNC22_IN_SEL_CFG  volatile.Register32 // 0x1AC
	FUNC23_IN_SEL_CFG  volatile.Register32 // 0x1B0
	FUNC24_IN_SEL_CFG  volatile.Register32 // 0x1B4
	FUNC25_IN_SEL_CFG  volatile.Register32 // 0x1B8
	FUNC26_IN_SEL_CFG  volatile.Register32 // 0x1BC
	FUNC27_IN_SEL_CFG  volatile.Register32 // 0x1C0
	FUNC28_IN_SEL_CFG  volatile.Register32 // 0x1C4
	FUNC29_IN_SEL_CFG  volatile.Register32 // 0x1C8
	FUNC30_IN_SEL_CFG  volatile.Register32 // 0x1CC
	FUNC31_IN_SEL_CFG  volatile.Register32 // 0x1D0
	FUNC32_IN_SEL_CFG  volatile.Register32 // 0x1D4
	FUNC33_IN_SEL_CFG  volatile.Register32 // 0x1D8
	FUNC34_IN_SEL_CFG  volatile.Register32 // 0x1DC
	FUNC35_IN_SEL_CFG  volatile.Register32 // 0x1E0
	FUNC36_IN_SEL_CFG  volatile.Register32 // 0x1E4
	FUNC37_IN_SEL_CFG  volatile.Register32 // 0x1E8
	FUNC38_IN_SEL_CFG  volatile.Register32 // 0x1EC
	FUNC39_IN_SEL_CFG  volatile.Register32 // 0x1F0
	FUNC40_IN_SEL_CFG  volatile.Register32 // 0x1F4
	FUNC41_IN_SEL_CFG  volatile.Register32 // 0x1F8
	FUNC42_IN_SEL_CFG  volatile.Register32 // 0x1FC
	FUNC43_IN_SEL_CFG  volatile.Register32 // 0x200
	FUNC44_IN_SEL_CFG  volatile.Register32 // 0x204
	FUNC45_IN_SEL_CFG  volatile.Register32 // 0x208
	FUNC46_IN_SEL_CFG  volatile.Register32 // 0x20C
	FUNC47_IN_SEL_CFG  volatile.Register32 // 0x210
	FUNC48_IN_SEL_CFG  volatile.Register32 // 0x214
	FUNC49_IN_SEL_CFG  volatile.Register32 // 0x218
	FUNC50_IN_SEL_CFG  volatile.Register32 // 0x21C
	FUNC51_IN_SEL_CFG  volatile.Register32 // 0x220
	FUNC52_IN_SEL_CFG  volatile.Register32 // 0x224
	FUNC53_IN_SEL_CFG  volatile.Register32 // 0x228
	FUNC54_IN_SEL_CFG  volatile.Register32 // 0x22C
	FUNC55_IN_SEL_CFG  volatile.Register32 // 0x230
	FUNC56_IN_SEL_CFG  volatile.Register32 // 0x234
	FUNC57_IN_SEL_CFG  volatile.Register32 // 0x238
	FUNC58_IN_SEL_CFG  volatile.Register32 // 0x23C
	FUNC59_IN_SEL_CFG  volatile.Register32 // 0x240
	FUNC60_IN_SEL_CFG  volatile.Register32 // 0x244
	FUNC61_IN_SEL_CFG  volatile.Register32 // 0x248
	FUNC62_IN_SEL_CFG  volatile.Register32 // 0x24C
	FUNC63_IN_SEL_CFG  volatile.Register32 // 0x250
	FUNC64_IN_SEL_CFG  volatile.Register32 // 0x254
	FUNC65_IN_SEL_CFG  volatile.Register32 // 0x258
	FUNC66_IN_SEL_CFG  volatile.Register32 // 0x25C
	FUNC67_IN_SEL_CFG  volatile.Register32 // 0x260
	FUNC68_IN_SEL_CFG  volatile.Register32 // 0x264
	FUNC69_IN_SEL_CFG  volatile.Register32 // 0x268
	FUNC70_IN_SEL_CFG  volatile.Register32 // 0x26C
	FUNC71_IN_SEL_CFG  volatile.Register32 // 0x270
	FUNC72_IN_SEL_CFG  volatile.Register32 // 0x274
	FUNC73_IN_SEL_CFG  volatile.Register32 // 0x278
	FUNC74_IN_SEL_CFG  volatile.Register32 // 0x27C
	FUNC75_IN_SEL_CFG  volatile.Register32 // 0x280
	FUNC76_IN_SEL_CFG  volatile.Register32 // 0x284
	FUNC77_IN_SEL_CFG  volatile.Register32 // 0x288
	FUNC78_IN_SEL_CFG  volatile.Register32 // 0x28C
	FUNC79_IN_SEL_CFG  volatile.Register32 // 0x290
	FUNC80_IN_SEL_CFG  volatile.Register32 // 0x294
	FUNC81_IN_SEL_CFG  volatile.Register32 // 0x298
	FUNC82_IN_SEL_CFG  volatile.Register32 // 0x29C
	FUNC83_IN_SEL_CFG  volatile.Register32 // 0x2A0
	FUNC84_IN_SEL_CFG  volatile.Register32 // 0x2A4
	FUNC85_IN_SEL_CFG  volatile.Register32 // 0x2A8
	FUNC86_IN_SEL_CFG  volatile.Register32 // 0x2AC
	FUNC87_IN_SEL_CFG  volatile.Register32 // 0x2B0
	FUNC88_IN_SEL_CFG  volatile.Register32 // 0x2B4
	FUNC89_IN_SEL_CFG  volatile.Register32 // 0x2B8
	FUNC90_IN_SEL_CFG  volatile.Register32 // 0x2BC
	FUNC91_IN_SEL_CFG  volatile.Register32 // 0x2C0
	FUNC92_IN_SEL_CFG  volatile.Register32 // 0x2C4
	FUNC93_IN_SEL_CFG  volatile.Register32 // 0x2C8
	FUNC94_IN_SEL_CFG  volatile.Register32 // 0x2CC
	FUNC95_IN_SEL_CFG  volatile.Register32 // 0x2D0
	FUNC96_IN_SEL_CFG  volatile.Register32 // 0x2D4
	FUNC97_IN_SEL_CFG  volatile.Register32 // 0x2D8
	FUNC98_IN_SEL_CFG  volatile.Register32 // 0x2DC
	FUNC99_IN_SEL_CFG  volatile.Register32 // 0x2E0
	FUNC100_IN_SEL_CFG volatile.Register32 // 0x2E4
	FUNC101_IN_SEL_CFG volatile.Register32 // 0x2E8
	FUNC102_IN_SEL_CFG volatile.Register32 // 0x2EC
	FUNC103_IN_SEL_CFG volatile.Register32 // 0x2F0
	FUNC104_IN_SEL_CFG volatile.Register32 // 0x2F4
	FUNC105_IN_SEL_CFG volatile.Register32 // 0x2F8
	FUNC106_IN_SEL_CFG volatile.Register32 // 0x2FC
	FUNC107_IN_SEL_CFG volatile.Register32 // 0x300
	FUNC108_IN_SEL_CFG volatile.Register32 // 0x304
	FUNC109_IN_SEL_CFG volatile.Register32 // 0x308
	FUNC110_IN_SEL_CFG volatile.Register32 // 0x30C
	FUNC111_IN_SEL_CFG volatile.Register32 // 0x310
	FUNC112_IN_SEL_CFG volatile.Register32 // 0x314
	FUNC113_IN_SEL_CFG volatile.Register32 // 0x318
	FUNC114_IN_SEL_CFG volatile.Register32 // 0x31C
	FUNC115_IN_SEL_CFG volatile.Register32 // 0x320
	FUNC116_IN_SEL_CFG volatile.Register32 // 0x324
	FUNC117_IN_SEL_CFG volatile.Register32 // 0x328
	FUNC118_IN_SEL_CFG volatile.Register32 // 0x32C
	FUNC119_IN_SEL_CFG volatile.Register32 // 0x330
	FUNC120_IN_SEL_CFG volatile.Register32 // 0x334
	FUNC121_IN_SEL_CFG volatile.Register32 // 0x338
	FUNC122_IN_SEL_CFG volatile.Register32 // 0x33C
	FUNC123_IN_SEL_CFG volatile.Register32 // 0x340
	FUNC124_IN_SEL_CFG volatile.Register32 // 0x344
	FUNC125_IN_SEL_CFG volatile.Register32 // 0x348
	FUNC126_IN_SEL_CFG volatile.Register32 // 0x34C
	FUNC127_IN_SEL_CFG volatile.Register32 // 0x350
	FUNC128_IN_SEL_CFG volatile.Register32 // 0x354
	FUNC129_IN_SEL_CFG volatile.Register32 // 0x358
	FUNC130_IN_SEL_CFG volatile.Register32 // 0x35C
	FUNC131_IN_SEL_CFG volatile.Register32 // 0x360
	FUNC132_IN_SEL_CFG volatile.Register32 // 0x364
	FUNC133_IN_SEL_CFG volatile.Register32 // 0x368
	FUNC134_IN_SEL_CFG volatile.Register32 // 0x36C
	FUNC135_IN_SEL_CFG volatile.Register32 // 0x370
	FUNC136_IN_SEL_CFG volatile.Register32 // 0x374
	FUNC137_IN_SEL_CFG volatile.Register32 // 0x378
	FUNC138_IN_SEL_CFG volatile.Register32 // 0x37C
	FUNC139_IN_SEL_CFG volatile.Register32 // 0x380
	FUNC140_IN_SEL_CFG volatile.Register32 // 0x384
	FUNC141_IN_SEL_CFG volatile.Register32 // 0x388
	FUNC142_IN_SEL_CFG volatile.Register32 // 0x38C
	FUNC143_IN_SEL_CFG volatile.Register32 // 0x390
	FUNC144_IN_SEL_CFG volatile.Register32 // 0x394
	FUNC145_IN_SEL_CFG volatile.Register32 // 0x398
	FUNC146_IN_SEL_CFG volatile.Register32 // 0x39C
	FUNC147_IN_SEL_CFG volatile.Register32 // 0x3A0
	FUNC148_IN_SEL_CFG volatile.Register32 // 0x3A4
	FUNC149_IN_SEL_CFG volatile.Register32 // 0x3A8
	FUNC150_IN_SEL_CFG volatile.Register32 // 0x3AC
	FUNC151_IN_SEL_CFG volatile.Register32 // 0x3B0
	FUNC152_IN_SEL_CFG volatile.Register32 // 0x3B4
	FUNC153_IN_SEL_CFG volatile.Register32 // 0x3B8
	FUNC154_IN_SEL_CFG volatile.Register32 // 0x3BC
	FUNC155_IN_SEL_CFG volatile.Register32 // 0x3C0
	FUNC156_IN_SEL_CFG volatile.Register32 // 0x3C4
	FUNC157_IN_SEL_CFG volatile.Register32 // 0x3C8
	FUNC158_IN_SEL_CFG volatile.Register32 // 0x3CC
	FUNC159_IN_SEL_CFG volatile.Register32 // 0x3D0
	FUNC160_IN_SEL_CFG volatile.Register32 // 0x3D4
	FUNC161_IN_SEL_CFG volatile.Register32 // 0x3D8
	FUNC162_IN_SEL_CFG volatile.Register32 // 0x3DC
	FUNC163_IN_SEL_CFG volatile.Register32 // 0x3E0
	FUNC164_IN_SEL_CFG volatile.Register32 // 0x3E4
	FUNC165_IN_SEL_CFG volatile.Register32 // 0x3E8
	FUNC166_IN_SEL_CFG volatile.Register32 // 0x3EC
	FUNC167_IN_SEL_CFG volatile.Register32 // 0x3F0
	FUNC168_IN_SEL_CFG volatile.Register32 // 0x3F4
	FUNC169_IN_SEL_CFG volatile.Register32 // 0x3F8
	FUNC170_IN_SEL_CFG volatile.Register32 // 0x3FC
	FUNC171_IN_SEL_CFG volatile.Register32 // 0x400
	FUNC172_IN_SEL_CFG volatile.Register32 // 0x404
	FUNC173_IN_SEL_CFG volatile.Register32 // 0x408
	FUNC174_IN_SEL_CFG volatile.Register32 // 0x40C
	FUNC175_IN_SEL_CFG volatile.Register32 // 0x410
	FUNC176_IN_SEL_CFG volatile.Register32 // 0x414
	FUNC177_IN_SEL_CFG volatile.Register32 // 0x418
	FUNC178_IN_SEL_CFG volatile.Register32 // 0x41C
	FUNC179_IN_SEL_CFG volatile.Register32 // 0x420
	FUNC180_IN_SEL_CFG volatile.Register32 // 0x424
	FUNC181_IN_SEL_CFG volatile.Register32 // 0x428
	FUNC182_IN_SEL_CFG volatile.Register32 // 0x42C
	FUNC183_IN_SEL_CFG volatile.Register32 // 0x430
	FUNC184_IN_SEL_CFG volatile.Register32 // 0x434
	FUNC185_IN_SEL_CFG volatile.Register32 // 0x438
	FUNC186_IN_SEL_CFG volatile.Register32 // 0x43C
	FUNC187_IN_SEL_CFG volatile.Register32 // 0x440
	FUNC188_IN_SEL_CFG volatile.Register32 // 0x444
	FUNC189_IN_SEL_CFG volatile.Register32 // 0x448
	FUNC190_IN_SEL_CFG volatile.Register32 // 0x44C
	FUNC191_IN_SEL_CFG volatile.Register32 // 0x450
	FUNC192_IN_SEL_CFG volatile.Register32 // 0x454
	FUNC193_IN_SEL_CFG volatile.Register32 // 0x458
	FUNC194_IN_SEL_CFG volatile.Register32 // 0x45C
	FUNC195_IN_SEL_CFG volatile.Register32 // 0x460
	FUNC196_IN_SEL_CFG volatile.Register32 // 0x464
	FUNC197_IN_SEL_CFG volatile.Register32 // 0x468
	FUNC198_IN_SEL_CFG volatile.Register32 // 0x46C
	FUNC199_IN_SEL_CFG volatile.Register32 // 0x470
	FUNC200_IN_SEL_CFG volatile.Register32 // 0x474
	FUNC201_IN_SEL_CFG volatile.Register32 // 0x478
	FUNC202_IN_SEL_CFG volatile.Register32 // 0x47C
	FUNC203_IN_SEL_CFG volatile.Register32 // 0x480
	FUNC204_IN_SEL_CFG volatile.Register32 // 0x484
	FUNC205_IN_SEL_CFG volatile.Register32 // 0x488
	FUNC206_IN_SEL_CFG volatile.Register32 // 0x48C
	FUNC207_IN_SEL_CFG volatile.Register32 // 0x490
	FUNC208_IN_SEL_CFG volatile.Register32 // 0x494
	FUNC209_IN_SEL_CFG volatile.Register32 // 0x498
	FUNC210_IN_SEL_CFG volatile.Register32 // 0x49C
	FUNC211_IN_SEL_CFG volatile.Register32 // 0x4A0
	FUNC212_IN_SEL_CFG volatile.Register32 // 0x4A4
	FUNC213_IN_SEL_CFG volatile.Register32 // 0x4A8
	FUNC214_IN_SEL_CFG volatile.Register32 // 0x4AC
	FUNC215_IN_SEL_CFG volatile.Register32 // 0x4B0
	FUNC216_IN_SEL_CFG volatile.Register32 // 0x4B4
	FUNC217_IN_SEL_CFG volatile.Register32 // 0x4B8
	FUNC218_IN_SEL_CFG volatile.Register32 // 0x4BC
	FUNC219_IN_SEL_CFG volatile.Register32 // 0x4C0
	FUNC220_IN_SEL_CFG volatile.Register32 // 0x4C4
	FUNC221_IN_SEL_CFG volatile.Register32 // 0x4C8
	FUNC222_IN_SEL_CFG volatile.Register32 // 0x4CC
	FUNC223_IN_SEL_CFG volatile.Register32 // 0x4D0
	FUNC224_IN_SEL_CFG volatile.Register32 // 0x4D4
	FUNC225_IN_SEL_CFG volatile.Register32 // 0x4D8
	FUNC226_IN_SEL_CFG volatile.Register32 // 0x4DC
	FUNC227_IN_SEL_CFG volatile.Register32 // 0x4E0
	FUNC228_IN_SEL_CFG volatile.Register32 // 0x4E4
	FUNC229_IN_SEL_CFG volatile.Register32 // 0x4E8
	FUNC230_IN_SEL_CFG volatile.Register32 // 0x4EC
	FUNC231_IN_SEL_CFG volatile.Register32 // 0x4F0
	FUNC232_IN_SEL_CFG volatile.Register32 // 0x4F4
	FUNC233_IN_SEL_CFG volatile.Register32 // 0x4F8
	FUNC234_IN_SEL_CFG volatile.Register32 // 0x4FC
	FUNC235_IN_SEL_CFG volatile.Register32 // 0x500
	FUNC236_IN_SEL_CFG volatile.Register32 // 0x504
	FUNC237_IN_SEL_CFG volatile.Register32 // 0x508
	FUNC238_IN_SEL_CFG volatile.Register32 // 0x50C
	FUNC239_IN_SEL_CFG volatile.Register32 // 0x510
	FUNC240_IN_SEL_CFG volatile.Register32 // 0x514
	FUNC241_IN_SEL_CFG volatile.Register32 // 0x518
	FUNC242_IN_SEL_CFG volatile.Register32 // 0x51C
	FUNC243_IN_SEL_CFG volatile.Register32 // 0x520
	FUNC244_IN_SEL_CFG volatile.Register32 // 0x524
	FUNC245_IN_SEL_CFG volatile.Register32 // 0x528
	FUNC246_IN_SEL_CFG volatile.Register32 // 0x52C
	FUNC247_IN_SEL_CFG volatile.Register32 // 0x530
	FUNC248_IN_SEL_CFG volatile.Register32 // 0x534
	FUNC249_IN_SEL_CFG volatile.Register32 // 0x538
	FUNC250_IN_SEL_CFG volatile.Register32 // 0x53C
	FUNC251_IN_SEL_CFG volatile.Register32 // 0x540
	FUNC252_IN_SEL_CFG volatile.Register32 // 0x544
	FUNC253_IN_SEL_CFG volatile.Register32 // 0x548
	FUNC254_IN_SEL_CFG volatile.Register32 // 0x54C
	FUNC255_IN_SEL_CFG volatile.Register32 // 0x550
	FUNC0_OUT_SEL_CFG  volatile.Register32 // 0x554
	FUNC1_OUT_SEL_CFG  volatile.Register32 // 0x558
	FUNC2_OUT_SEL_CFG  volatile.Register32 // 0x55C
	FUNC3_OUT_SEL_CFG  volatile.Register32 // 0x560
	FUNC4_OUT_SEL_CFG  volatile.Register32 // 0x564
	FUNC5_OUT_SEL_CFG  volatile.Register32 // 0x568
	FUNC6_OUT_SEL_CFG  volatile.Register32 // 0x56C
	FUNC7_OUT_SEL_CFG  volatile.Register32 // 0x570
	FUNC8_OUT_SEL_CFG  volatile.Register32 // 0x574
	FUNC9_OUT_SEL_CFG  volatile.Register32 // 0x578
	FUNC10_OUT_SEL_CFG volatile.Register32 // 0x57C
	FUNC11_OUT_SEL_CFG volatile.Register32 // 0x580
	FUNC12_OUT_SEL_CFG volatile.Register32 // 0x584
	FUNC13_OUT_SEL_CFG volatile.Register32 // 0x588
	FUNC14_OUT_SEL_CFG volatile.Register32 // 0x58C
	FUNC15_OUT_SEL_CFG volatile.Register32 // 0x590
	FUNC16_OUT_SEL_CFG volatile.Register32 // 0x594
	FUNC17_OUT_SEL_CFG volatile.Register32 // 0x598
	FUNC18_OUT_SEL_CFG volatile.Register32 // 0x59C
	FUNC19_OUT_SEL_CFG volatile.Register32 // 0x5A0
	FUNC20_OUT_SEL_CFG volatile.Register32 // 0x5A4
	FUNC21_OUT_SEL_CFG volatile.Register32 // 0x5A8
	FUNC22_OUT_SEL_CFG volatile.Register32 // 0x5AC
	FUNC23_OUT_SEL_CFG volatile.Register32 // 0x5B0
	FUNC24_OUT_SEL_CFG volatile.Register32 // 0x5B4
	FUNC25_OUT_SEL_CFG volatile.Register32 // 0x5B8
	FUNC26_OUT_SEL_CFG volatile.Register32 // 0x5BC
	FUNC27_OUT_SEL_CFG volatile.Register32 // 0x5C0
	FUNC28_OUT_SEL_CFG volatile.Register32 // 0x5C4
	FUNC29_OUT_SEL_CFG volatile.Register32 // 0x5C8
	FUNC30_OUT_SEL_CFG volatile.Register32 // 0x5CC
	FUNC31_OUT_SEL_CFG volatile.Register32 // 0x5D0
	FUNC32_OUT_SEL_CFG volatile.Register32 // 0x5D4
	FUNC33_OUT_SEL_CFG volatile.Register32 // 0x5D8
	FUNC34_OUT_SEL_CFG volatile.Register32 // 0x5DC
	FUNC35_OUT_SEL_CFG volatile.Register32 // 0x5E0
	FUNC36_OUT_SEL_CFG volatile.Register32 // 0x5E4
	FUNC37_OUT_SEL_CFG volatile.Register32 // 0x5E8
	FUNC38_OUT_SEL_CFG volatile.Register32 // 0x5EC
	FUNC39_OUT_SEL_CFG volatile.Register32 // 0x5F0
	FUNC40_OUT_SEL_CFG volatile.Register32 // 0x5F4
	FUNC41_OUT_SEL_CFG volatile.Register32 // 0x5F8
	FUNC42_OUT_SEL_CFG volatile.Register32 // 0x5FC
	FUNC43_OUT_SEL_CFG volatile.Register32 // 0x600
	FUNC44_OUT_SEL_CFG volatile.Register32 // 0x604
	FUNC45_OUT_SEL_CFG volatile.Register32 // 0x608
	FUNC46_OUT_SEL_CFG volatile.Register32 // 0x60C
	FUNC47_OUT_SEL_CFG volatile.Register32 // 0x610
	FUNC48_OUT_SEL_CFG volatile.Register32 // 0x614
	FUNC49_OUT_SEL_CFG volatile.Register32 // 0x618
	FUNC50_OUT_SEL_CFG volatile.Register32 // 0x61C
	FUNC51_OUT_SEL_CFG volatile.Register32 // 0x620
	FUNC52_OUT_SEL_CFG volatile.Register32 // 0x624
	FUNC53_OUT_SEL_CFG volatile.Register32 // 0x628
	CLOCK_GATE         volatile.Register32 // 0x62C
	_                  [204]byte
	REG_DATE           volatile.Register32 // 0x6FC
}

// GPIO.BT_SELECT: GPIO bit select register
func (o *GPIO_Type) SetBT_SELECT(value uint32) {
	volatile.StoreUint32(&o.BT_SELECT.Reg, value)
}
func (o *GPIO_Type) GetBT_SELECT() uint32 {
	return volatile.LoadUint32(&o.BT_SELECT.Reg)
}

// GPIO.OUT: GPIO0 ~ 31 output register
func (o *GPIO_Type) SetOUT(value uint32) {
	volatile.StoreUint32(&o.OUT.Reg, value)
}
func (o *GPIO_Type) GetOUT() uint32 {
	return volatile.LoadUint32(&o.OUT.Reg)
}

// GPIO.OUT_W1TS: GPIO0 ~ 31 output bit set register
func (o *GPIO_Type) SetOUT_W1TS(value uint32) {
	volatile.StoreUint32(&o.OUT_W1TS.Reg, value)
}
func (o *GPIO_Type) GetOUT_W1TS() uint32 {
	return volatile.LoadUint32(&o.OUT_W1TS.Reg)
}

// GPIO.OUT_W1TC: GPIO0 ~ 31 output bit clear register
func (o *GPIO_Type) SetOUT_W1TC(value uint32) {
	volatile.StoreUint32(&o.OUT_W1TC.Reg, value)
}
func (o *GPIO_Type) GetOUT_W1TC() uint32 {
	return volatile.LoadUint32(&o.OUT_W1TC.Reg)
}

// GPIO.OUT1: GPIO32 ~ 53 output register
func (o *GPIO_Type) SetOUT1_DATA_ORIG(value uint32) {
	volatile.StoreUint32(&o.OUT1.Reg, volatile.LoadUint32(&o.OUT1.Reg)&^(0x3fffff)|value)
}
func (o *GPIO_Type) GetOUT1_DATA_ORIG() uint32 {
	return volatile.LoadUint32(&o.OUT1.Reg) & 0x3fffff
}

// GPIO.OUT1_W1TS: GPIO32 ~ 53 output bit set register
func (o *GPIO_Type) SetOUT1_W1TS(value uint32) {
	volatile.StoreUint32(&o.OUT1_W1TS.Reg, volatile.LoadUint32(&o.OUT1_W1TS.Reg)&^(0x3fffff)|value)
}
func (o *GPIO_Type) GetOUT1_W1TS() uint32 {
	return volatile.LoadUint32(&o.OUT1_W1TS.Reg) & 0x3fffff
}

// GPIO.OUT1_W1TC: GPIO32 ~ 53 output bit clear register
func (o *GPIO_Type) SetOUT1_W1TC(value uint32) {
	volatile.StoreUint32(&o.OUT1_W1TC.Reg, volatile.LoadUint32(&o.OUT1_W1TC.Reg)&^(0x3fffff)|value)
}
func (o *GPIO_Type) GetOUT1_W1TC() uint32 {
	return volatile.LoadUint32(&o.OUT1_W1TC.Reg) & 0x3fffff
}

// GPIO.SDIO_SELECT: GPIO SDIO selection register
func (o *GPIO_Type) SetSDIO_SELECT_SDIO_SEL(value uint32) {
	volatile.StoreUint32(&o.SDIO_SELECT.Reg, volatile.LoadUint32(&o.SDIO_SELECT.Reg)&^(0xff)|value)
}
func (o *GPIO_Type) GetSDIO_SELECT_SDIO_SEL() uint32 {
	return volatile.LoadUint32(&o.SDIO_SELECT.Reg) & 0xff
}

// GPIO.ENABLE: GPIO0 ~ 31 output enable register
func (o *GPIO_Type) SetENABLE(value uint32) {
	volatile.StoreUint32(&o.ENABLE.Reg, value)
}
func (o *GPIO_Type) GetENABLE() uint32 {
	return volatile.LoadUint32(&o.ENABLE.Reg)
}

// GPIO.ENABLE_W1TS: GPIO0 ~ 31 output enable bit set register
func (o *GPIO_Type) SetENABLE_W1TS(value uint32) {
	volatile.StoreUint32(&o.ENABLE_W1TS.Reg, value)
}
func (o *GPIO_Type) GetENABLE_W1TS() uint32 {
	return volatile.LoadUint32(&o.ENABLE_W1TS.Reg)
}

// GPIO.ENABLE_W1TC: GPIO0 ~ 31 output enable bit clear register
func (o *GPIO_Type) SetENABLE_W1TC(value uint32) {
	volatile.StoreUint32(&o.ENABLE_W1TC.Reg, value)
}
func (o *GPIO_Type) GetENABLE_W1TC() uint32 {
	return volatile.LoadUint32(&o.ENABLE_W1TC.Reg)
}

// GPIO.ENABLE1: GPIO32 ~ 53 output enable register
func (o *GPIO_Type) SetENABLE1_DATA(value uint32) {
	volatile.StoreUint32(&o.ENABLE1.Reg, volatile.LoadUint32(&o.ENABLE1.Reg)&^(0x3fffff)|value)
}
func (o *GPIO_Type) GetENABLE1_DATA() uint32 {
	return volatile.LoadUint32(&o.ENABLE1.Reg) & 0x3fffff
}

// GPIO.ENABLE1_W1TS: GPIO32 ~ 53 output enable bit set register
func (o *GPIO_Type) SetENABLE1_W1TS(value uint32) {
	volatile.StoreUint32(&o.ENABLE1_W1TS.Reg, volatile.LoadUint32(&o.ENABLE1_W1TS.Reg)&^(0x3fffff)|value)
}
func (o *GPIO_Type) GetENABLE1_W1TS() uint32 {
	return volatile.LoadUint32(&o.ENABLE1_W1TS.Reg) & 0x3fffff
}

// GPIO.ENABLE1_W1TC: GPIO32 ~ 53 output enable bit clear register
func (o *GPIO_Type) SetENABLE1_W1TC(value uint32) {
	volatile.StoreUint32(&o.ENABLE1_W1TC.Reg, volatile.LoadUint32(&o.ENABLE1_W1TC.Reg)&^(0x3fffff)|value)
}
func (o *GPIO_Type) GetENABLE1_W1TC() uint32 {
	return volatile.LoadUint32(&o.ENABLE1_W1TC.Reg) & 0x3fffff
}

// GPIO.STRAP: Bootstrap pin value register
func (o *GPIO_Type) SetSTRAP_STRAPPING(value uint32) {
	volatile.StoreUint32(&o.STRAP.Reg, volatile.LoadUint32(&o.STRAP.Reg)&^(0xffff)|value)
}
func (o *GPIO_Type) GetSTRAP_STRAPPING() uint32 {
	return volatile.LoadUint32(&o.STRAP.Reg) & 0xffff
}

// GPIO.IN: GPIO0 ~ 31 input register
func (o *GPIO_Type) SetIN(value uint32) {
	volatile.StoreUint32(&o.IN.Reg, value)
}
func (o *GPIO_Type) GetIN() uint32 {
	return volatile.LoadUint32(&o.IN.Reg)
}

// GPIO.IN1: GPIO32 ~ 53 input register
func (o *GPIO_Type) SetIN1_IN_DATA1_NEXT(value uint32) {
	volatile.StoreUint32(&o.IN1.Reg, volatile.LoadUint32(&o.IN1.Reg)&^(0x3fffff)|value)
}
func (o *GPIO_Type) GetIN1_IN_DATA1_NEXT() uint32 {
	return volatile.LoadUint32(&o.IN1.Reg) & 0x3fffff
}

// GPIO.STATUS: GPIO0 ~ 31 interrupt status register
func (o *GPIO_Type) SetSTATUS(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, value)
}
func (o *GPIO_Type) GetSTATUS() uint32 {
	return volatile.LoadUint32(&o.STATUS.Reg)
}

// GPIO.STATUS_W1TS: GPIO0 ~ 31 interrupt status bit set register
func (o *GPIO_Type) SetSTATUS_W1TS(value uint32) {
	volatile.StoreUint32(&o.STATUS_W1TS.Reg, value)
}
func (o *GPIO_Type) GetSTATUS_W1TS() uint32 {
	return volatile.LoadUint32(&o.STATUS_W1TS.Reg)
}

// GPIO.STATUS_W1TC: GPIO0 ~ 31 interrupt status bit clear register
func (o *GPIO_Type) SetSTATUS_W1TC(value uint32) {
	volatile.StoreUint32(&o.STATUS_W1TC.Reg, value)
}
func (o *GPIO_Type) GetSTATUS_W1TC() uint32 {
	return volatile.LoadUint32(&o.STATUS_W1TC.Reg)
}

// GPIO.STATUS1: GPIO32 ~ 53 interrupt status register
func (o *GPIO_Type) SetSTATUS1_INTERRUPT(value uint32) {
	volatile.StoreUint32(&o.STATUS1.Reg, volatile.LoadUint32(&o.STATUS1.Reg)&^(0x3fffff)|value)
}
func (o *GPIO_Type) GetSTATUS1_INTERRUPT() uint32 {
	return volatile.LoadUint32(&o.STATUS1.Reg) & 0x3fffff
}

// GPIO.STATUS1_W1TS: GPIO32 ~ 53 interrupt status bit set register
func (o *GPIO_Type) SetSTATUS1_W1TS(value uint32) {
	volatile.StoreUint32(&o.STATUS1_W1TS.Reg, volatile.LoadUint32(&o.STATUS1_W1TS.Reg)&^(0x3fffff)|value)
}
func (o *GPIO_Type) GetSTATUS1_W1TS() uint32 {
	return volatile.LoadUint32(&o.STATUS1_W1TS.Reg) & 0x3fffff
}

// GPIO.STATUS1_W1TC: GPIO32 ~ 53 interrupt status bit clear register
func (o *GPIO_Type) SetSTATUS1_W1TC(value uint32) {
	volatile.StoreUint32(&o.STATUS1_W1TC.Reg, volatile.LoadUint32(&o.STATUS1_W1TC.Reg)&^(0x3fffff)|value)
}
func (o *GPIO_Type) GetSTATUS1_W1TC() uint32 {
	return volatile.LoadUint32(&o.STATUS1_W1TC.Reg) & 0x3fffff
}

// GPIO.PCPU_INT: GPIO0 ~ 31 PRO_CPU interrupt status register
func (o *GPIO_Type) SetPCPU_INT(value uint32) {
	volatile.StoreUint32(&o.PCPU_INT.Reg, value)
}
func (o *GPIO_Type) GetPCPU_INT() uint32 {
	return volatile.LoadUint32(&o.PCPU_INT.Reg)
}

// GPIO.PCPU_NMI_INT: GPIO0 ~ 31 PRO_CPU non-maskable interrupt status register
func (o *GPIO_Type) SetPCPU_NMI_INT(value uint32) {
	volatile.StoreUint32(&o.PCPU_NMI_INT.Reg, value)
}
func (o *GPIO_Type) GetPCPU_NMI_INT() uint32 {
	return volatile.LoadUint32(&o.PCPU_NMI_INT.Reg)
}

// GPIO.CPUSDIO_INT: GPIO0 ~ 31 CPU SDIO interrupt status register
func (o *GPIO_Type) SetCPUSDIO_INT(value uint32) {
	volatile.StoreUint32(&o.CPUSDIO_INT.Reg, value)
}
func (o *GPIO_Type) GetCPUSDIO_INT() uint32 {
	return volatile.LoadUint32(&o.CPUSDIO_INT.Reg)
}

// GPIO.PCPU_INT1: GPIO32 ~ 53 PRO_CPU interrupt status register
func (o *GPIO_Type) SetPCPU_INT1_PROCPU1_INT(value uint32) {
	volatile.StoreUint32(&o.PCPU_INT1.Reg, volatile.LoadUint32(&o.PCPU_INT1.Reg)&^(0x3fffff)|value)
}
func (o *GPIO_Type) GetPCPU_INT1_PROCPU1_INT() uint32 {
	return volatile.LoadUint32(&o.PCPU_INT1.Reg) & 0x3fffff
}

// GPIO.PCPU_NMI_INT1: GPIO32 ~ 53 PRO_CPU non-maskable interrupt status register
func (o *GPIO_Type) SetPCPU_NMI_INT1_PROCPU_NMI1_INT(value uint32) {
	volatile.StoreUint32(&o.PCPU_NMI_INT1.Reg, volatile.LoadUint32(&o.PCPU_NMI_INT1.Reg)&^(0x3fffff)|value)
}
func (o *GPIO_Type) GetPCPU_NMI_INT1_PROCPU_NMI1_INT() uint32 {
	return volatile.LoadUint32(&o.PCPU_NMI_INT1.Reg) & 0x3fffff
}

// GPIO.CPUSDIO_INT1: GPIO32 ~ 53 CPU SDIO interrupt status register
func (o *GPIO_Type) SetCPUSDIO_INT1_SDIO1_INT(value uint32) {
	volatile.StoreUint32(&o.CPUSDIO_INT1.Reg, volatile.LoadUint32(&o.CPUSDIO_INT1.Reg)&^(0x3fffff)|value)
}
func (o *GPIO_Type) GetCPUSDIO_INT1_SDIO1_INT() uint32 {
	return volatile.LoadUint32(&o.CPUSDIO_INT1.Reg) & 0x3fffff
}

// GPIO.PIN0: Configuration for GPIO pin %s
func (o *GPIO_Type) SetPIN0_PIN0_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN0.Reg, volatile.LoadUint32(&o.PIN0.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN0_PIN0_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN0.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN0_PIN0_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN0.Reg, volatile.LoadUint32(&o.PIN0.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN0_PIN0_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN0.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN0_PIN0_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN0.Reg, volatile.LoadUint32(&o.PIN0.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN0_PIN0_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN0.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN0_PIN0_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN0.Reg, volatile.LoadUint32(&o.PIN0.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN0_PIN0_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN0.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN0_PIN0_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN0.Reg, volatile.LoadUint32(&o.PIN0.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN0_PIN0_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN0.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN0_PIN0_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN0.Reg, volatile.LoadUint32(&o.PIN0.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN0_PIN0_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN0.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN0_PIN0_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN0.Reg, volatile.LoadUint32(&o.PIN0.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN0_PIN0_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN0.Reg) & 0x3e000) >> 13
}

// GPIO.PIN1: Configuration for GPIO pin %s
func (o *GPIO_Type) SetPIN1_PIN0_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN1.Reg, volatile.LoadUint32(&o.PIN1.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN1_PIN0_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN1.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN1_PIN0_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN1.Reg, volatile.LoadUint32(&o.PIN1.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN1_PIN0_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN1.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN1_PIN0_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN1.Reg, volatile.LoadUint32(&o.PIN1.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN1_PIN0_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN1.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN1_PIN0_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN1.Reg, volatile.LoadUint32(&o.PIN1.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN1_PIN0_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN1.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN1_PIN0_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN1.Reg, volatile.LoadUint32(&o.PIN1.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN1_PIN0_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN1.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN1_PIN0_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN1.Reg, volatile.LoadUint32(&o.PIN1.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN1_PIN0_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN1.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN1_PIN0_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN1.Reg, volatile.LoadUint32(&o.PIN1.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN1_PIN0_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN1.Reg) & 0x3e000) >> 13
}

// GPIO.PIN2: Configuration for GPIO pin %s
func (o *GPIO_Type) SetPIN2_PIN0_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN2.Reg, volatile.LoadUint32(&o.PIN2.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN2_PIN0_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN2.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN2_PIN0_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN2.Reg, volatile.LoadUint32(&o.PIN2.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN2_PIN0_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN2.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN2_PIN0_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN2.Reg, volatile.LoadUint32(&o.PIN2.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN2_PIN0_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN2.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN2_PIN0_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN2.Reg, volatile.LoadUint32(&o.PIN2.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN2_PIN0_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN2.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN2_PIN0_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN2.Reg, volatile.LoadUint32(&o.PIN2.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN2_PIN0_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN2.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN2_PIN0_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN2.Reg, volatile.LoadUint32(&o.PIN2.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN2_PIN0_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN2.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN2_PIN0_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN2.Reg, volatile.LoadUint32(&o.PIN2.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN2_PIN0_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN2.Reg) & 0x3e000) >> 13
}

// GPIO.PIN3: Configuration for GPIO pin %s
func (o *GPIO_Type) SetPIN3_PIN0_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN3.Reg, volatile.LoadUint32(&o.PIN3.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN3_PIN0_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN3.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN3_PIN0_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN3.Reg, volatile.LoadUint32(&o.PIN3.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN3_PIN0_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN3.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN3_PIN0_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN3.Reg, volatile.LoadUint32(&o.PIN3.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN3_PIN0_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN3.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN3_PIN0_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN3.Reg, volatile.LoadUint32(&o.PIN3.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN3_PIN0_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN3.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN3_PIN0_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN3.Reg, volatile.LoadUint32(&o.PIN3.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN3_PIN0_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN3.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN3_PIN0_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN3.Reg, volatile.LoadUint32(&o.PIN3.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN3_PIN0_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN3.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN3_PIN0_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN3.Reg, volatile.LoadUint32(&o.PIN3.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN3_PIN0_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN3.Reg) & 0x3e000) >> 13
}

// GPIO.PIN4: Configuration for GPIO pin %s
func (o *GPIO_Type) SetPIN4_PIN0_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN4.Reg, volatile.LoadUint32(&o.PIN4.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN4_PIN0_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN4.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN4_PIN0_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN4.Reg, volatile.LoadUint32(&o.PIN4.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN4_PIN0_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN4.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN4_PIN0_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN4.Reg, volatile.LoadUint32(&o.PIN4.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN4_PIN0_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN4.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN4_PIN0_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN4.Reg, volatile.LoadUint32(&o.PIN4.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN4_PIN0_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN4.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN4_PIN0_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN4.Reg, volatile.LoadUint32(&o.PIN4.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN4_PIN0_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN4.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN4_PIN0_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN4.Reg, volatile.LoadUint32(&o.PIN4.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN4_PIN0_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN4.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN4_PIN0_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN4.Reg, volatile.LoadUint32(&o.PIN4.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN4_PIN0_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN4.Reg) & 0x3e000) >> 13
}

// GPIO.PIN5: Configuration for GPIO pin %s
func (o *GPIO_Type) SetPIN5_PIN0_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN5.Reg, volatile.LoadUint32(&o.PIN5.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN5_PIN0_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN5.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN5_PIN0_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN5.Reg, volatile.LoadUint32(&o.PIN5.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN5_PIN0_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN5.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN5_PIN0_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN5.Reg, volatile.LoadUint32(&o.PIN5.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN5_PIN0_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN5.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN5_PIN0_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN5.Reg, volatile.LoadUint32(&o.PIN5.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN5_PIN0_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN5.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN5_PIN0_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN5.Reg, volatile.LoadUint32(&o.PIN5.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN5_PIN0_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN5.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN5_PIN0_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN5.Reg, volatile.LoadUint32(&o.PIN5.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN5_PIN0_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN5.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN5_PIN0_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN5.Reg, volatile.LoadUint32(&o.PIN5.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN5_PIN0_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN5.Reg) & 0x3e000) >> 13
}

// GPIO.PIN6: Configuration for GPIO pin %s
func (o *GPIO_Type) SetPIN6_PIN0_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN6.Reg, volatile.LoadUint32(&o.PIN6.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN6_PIN0_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN6.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN6_PIN0_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN6.Reg, volatile.LoadUint32(&o.PIN6.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN6_PIN0_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN6.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN6_PIN0_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN6.Reg, volatile.LoadUint32(&o.PIN6.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN6_PIN0_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN6.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN6_PIN0_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN6.Reg, volatile.LoadUint32(&o.PIN6.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN6_PIN0_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN6.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN6_PIN0_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN6.Reg, volatile.LoadUint32(&o.PIN6.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN6_PIN0_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN6.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN6_PIN0_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN6.Reg, volatile.LoadUint32(&o.PIN6.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN6_PIN0_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN6.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN6_PIN0_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN6.Reg, volatile.LoadUint32(&o.PIN6.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN6_PIN0_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN6.Reg) & 0x3e000) >> 13
}

// GPIO.PIN7: Configuration for GPIO pin %s
func (o *GPIO_Type) SetPIN7_PIN0_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN7.Reg, volatile.LoadUint32(&o.PIN7.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN7_PIN0_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN7.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN7_PIN0_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN7.Reg, volatile.LoadUint32(&o.PIN7.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN7_PIN0_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN7.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN7_PIN0_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN7.Reg, volatile.LoadUint32(&o.PIN7.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN7_PIN0_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN7.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN7_PIN0_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN7.Reg, volatile.LoadUint32(&o.PIN7.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN7_PIN0_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN7.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN7_PIN0_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN7.Reg, volatile.LoadUint32(&o.PIN7.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN7_PIN0_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN7.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN7_PIN0_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN7.Reg, volatile.LoadUint32(&o.PIN7.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN7_PIN0_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN7.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN7_PIN0_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN7.Reg, volatile.LoadUint32(&o.PIN7.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN7_PIN0_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN7.Reg) & 0x3e000) >> 13
}

// GPIO.PIN8: Configuration for GPIO pin %s
func (o *GPIO_Type) SetPIN8_PIN0_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN8.Reg, volatile.LoadUint32(&o.PIN8.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN8_PIN0_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN8.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN8_PIN0_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN8.Reg, volatile.LoadUint32(&o.PIN8.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN8_PIN0_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN8.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN8_PIN0_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN8.Reg, volatile.LoadUint32(&o.PIN8.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN8_PIN0_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN8.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN8_PIN0_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN8.Reg, volatile.LoadUint32(&o.PIN8.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN8_PIN0_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN8.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN8_PIN0_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN8.Reg, volatile.LoadUint32(&o.PIN8.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN8_PIN0_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN8.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN8_PIN0_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN8.Reg, volatile.LoadUint32(&o.PIN8.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN8_PIN0_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN8.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN8_PIN0_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN8.Reg, volatile.LoadUint32(&o.PIN8.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN8_PIN0_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN8.Reg) & 0x3e000) >> 13
}

// GPIO.PIN9: Configuration for GPIO pin %s
func (o *GPIO_Type) SetPIN9_PIN0_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN9.Reg, volatile.LoadUint32(&o.PIN9.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN9_PIN0_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN9.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN9_PIN0_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN9.Reg, volatile.LoadUint32(&o.PIN9.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN9_PIN0_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN9.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN9_PIN0_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN9.Reg, volatile.LoadUint32(&o.PIN9.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN9_PIN0_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN9.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN9_PIN0_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN9.Reg, volatile.LoadUint32(&o.PIN9.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN9_PIN0_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN9.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN9_PIN0_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN9.Reg, volatile.LoadUint32(&o.PIN9.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN9_PIN0_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN9.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN9_PIN0_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN9.Reg, volatile.LoadUint32(&o.PIN9.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN9_PIN0_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN9.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN9_PIN0_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN9.Reg, volatile.LoadUint32(&o.PIN9.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN9_PIN0_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN9.Reg) & 0x3e000) >> 13
}

// GPIO.PIN10: Configuration for GPIO pin %s
func (o *GPIO_Type) SetPIN10_PIN0_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN10.Reg, volatile.LoadUint32(&o.PIN10.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN10_PIN0_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN10.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN10_PIN0_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN10.Reg, volatile.LoadUint32(&o.PIN10.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN10_PIN0_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN10.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN10_PIN0_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN10.Reg, volatile.LoadUint32(&o.PIN10.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN10_PIN0_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN10.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN10_PIN0_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN10.Reg, volatile.LoadUint32(&o.PIN10.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN10_PIN0_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN10.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN10_PIN0_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN10.Reg, volatile.LoadUint32(&o.PIN10.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN10_PIN0_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN10.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN10_PIN0_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN10.Reg, volatile.LoadUint32(&o.PIN10.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN10_PIN0_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN10.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN10_PIN0_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN10.Reg, volatile.LoadUint32(&o.PIN10.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN10_PIN0_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN10.Reg) & 0x3e000) >> 13
}

// GPIO.PIN11: Configuration for GPIO pin %s
func (o *GPIO_Type) SetPIN11_PIN0_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN11.Reg, volatile.LoadUint32(&o.PIN11.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN11_PIN0_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN11.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN11_PIN0_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN11.Reg, volatile.LoadUint32(&o.PIN11.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN11_PIN0_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN11.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN11_PIN0_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN11.Reg, volatile.LoadUint32(&o.PIN11.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN11_PIN0_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN11.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN11_PIN0_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN11.Reg, volatile.LoadUint32(&o.PIN11.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN11_PIN0_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN11.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN11_PIN0_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN11.Reg, volatile.LoadUint32(&o.PIN11.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN11_PIN0_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN11.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN11_PIN0_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN11.Reg, volatile.LoadUint32(&o.PIN11.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN11_PIN0_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN11.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN11_PIN0_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN11.Reg, volatile.LoadUint32(&o.PIN11.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN11_PIN0_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN11.Reg) & 0x3e000) >> 13
}

// GPIO.PIN12: Configuration for GPIO pin %s
func (o *GPIO_Type) SetPIN12_PIN0_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN12.Reg, volatile.LoadUint32(&o.PIN12.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN12_PIN0_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN12.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN12_PIN0_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN12.Reg, volatile.LoadUint32(&o.PIN12.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN12_PIN0_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN12.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN12_PIN0_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN12.Reg, volatile.LoadUint32(&o.PIN12.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN12_PIN0_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN12.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN12_PIN0_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN12.Reg, volatile.LoadUint32(&o.PIN12.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN12_PIN0_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN12.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN12_PIN0_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN12.Reg, volatile.LoadUint32(&o.PIN12.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN12_PIN0_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN12.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN12_PIN0_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN12.Reg, volatile.LoadUint32(&o.PIN12.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN12_PIN0_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN12.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN12_PIN0_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN12.Reg, volatile.LoadUint32(&o.PIN12.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN12_PIN0_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN12.Reg) & 0x3e000) >> 13
}

// GPIO.PIN13: Configuration for GPIO pin %s
func (o *GPIO_Type) SetPIN13_PIN0_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN13.Reg, volatile.LoadUint32(&o.PIN13.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN13_PIN0_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN13.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN13_PIN0_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN13.Reg, volatile.LoadUint32(&o.PIN13.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN13_PIN0_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN13.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN13_PIN0_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN13.Reg, volatile.LoadUint32(&o.PIN13.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN13_PIN0_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN13.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN13_PIN0_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN13.Reg, volatile.LoadUint32(&o.PIN13.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN13_PIN0_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN13.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN13_PIN0_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN13.Reg, volatile.LoadUint32(&o.PIN13.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN13_PIN0_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN13.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN13_PIN0_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN13.Reg, volatile.LoadUint32(&o.PIN13.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN13_PIN0_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN13.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN13_PIN0_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN13.Reg, volatile.LoadUint32(&o.PIN13.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN13_PIN0_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN13.Reg) & 0x3e000) >> 13
}

// GPIO.PIN14: Configuration for GPIO pin %s
func (o *GPIO_Type) SetPIN14_PIN0_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN14.Reg, volatile.LoadUint32(&o.PIN14.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN14_PIN0_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN14.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN14_PIN0_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN14.Reg, volatile.LoadUint32(&o.PIN14.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN14_PIN0_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN14.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN14_PIN0_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN14.Reg, volatile.LoadUint32(&o.PIN14.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN14_PIN0_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN14.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN14_PIN0_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN14.Reg, volatile.LoadUint32(&o.PIN14.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN14_PIN0_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN14.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN14_PIN0_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN14.Reg, volatile.LoadUint32(&o.PIN14.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN14_PIN0_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN14.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN14_PIN0_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN14.Reg, volatile.LoadUint32(&o.PIN14.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN14_PIN0_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN14.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN14_PIN0_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN14.Reg, volatile.LoadUint32(&o.PIN14.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN14_PIN0_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN14.Reg) & 0x3e000) >> 13
}

// GPIO.PIN15: Configuration for GPIO pin %s
func (o *GPIO_Type) SetPIN15_PIN0_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN15.Reg, volatile.LoadUint32(&o.PIN15.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN15_PIN0_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN15.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN15_PIN0_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN15.Reg, volatile.LoadUint32(&o.PIN15.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN15_PIN0_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN15.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN15_PIN0_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN15.Reg, volatile.LoadUint32(&o.PIN15.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN15_PIN0_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN15.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN15_PIN0_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN15.Reg, volatile.LoadUint32(&o.PIN15.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN15_PIN0_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN15.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN15_PIN0_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN15.Reg, volatile.LoadUint32(&o.PIN15.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN15_PIN0_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN15.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN15_PIN0_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN15.Reg, volatile.LoadUint32(&o.PIN15.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN15_PIN0_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN15.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN15_PIN0_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN15.Reg, volatile.LoadUint32(&o.PIN15.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN15_PIN0_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN15.Reg) & 0x3e000) >> 13
}

// GPIO.PIN16: Configuration for GPIO pin %s
func (o *GPIO_Type) SetPIN16_PIN0_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN16.Reg, volatile.LoadUint32(&o.PIN16.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN16_PIN0_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN16.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN16_PIN0_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN16.Reg, volatile.LoadUint32(&o.PIN16.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN16_PIN0_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN16.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN16_PIN0_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN16.Reg, volatile.LoadUint32(&o.PIN16.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN16_PIN0_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN16.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN16_PIN0_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN16.Reg, volatile.LoadUint32(&o.PIN16.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN16_PIN0_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN16.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN16_PIN0_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN16.Reg, volatile.LoadUint32(&o.PIN16.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN16_PIN0_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN16.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN16_PIN0_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN16.Reg, volatile.LoadUint32(&o.PIN16.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN16_PIN0_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN16.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN16_PIN0_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN16.Reg, volatile.LoadUint32(&o.PIN16.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN16_PIN0_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN16.Reg) & 0x3e000) >> 13
}

// GPIO.PIN17: Configuration for GPIO pin %s
func (o *GPIO_Type) SetPIN17_PIN0_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN17.Reg, volatile.LoadUint32(&o.PIN17.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN17_PIN0_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN17.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN17_PIN0_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN17.Reg, volatile.LoadUint32(&o.PIN17.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN17_PIN0_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN17.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN17_PIN0_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN17.Reg, volatile.LoadUint32(&o.PIN17.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN17_PIN0_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN17.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN17_PIN0_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN17.Reg, volatile.LoadUint32(&o.PIN17.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN17_PIN0_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN17.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN17_PIN0_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN17.Reg, volatile.LoadUint32(&o.PIN17.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN17_PIN0_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN17.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN17_PIN0_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN17.Reg, volatile.LoadUint32(&o.PIN17.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN17_PIN0_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN17.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN17_PIN0_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN17.Reg, volatile.LoadUint32(&o.PIN17.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN17_PIN0_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN17.Reg) & 0x3e000) >> 13
}

// GPIO.PIN18: Configuration for GPIO pin %s
func (o *GPIO_Type) SetPIN18_PIN0_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN18.Reg, volatile.LoadUint32(&o.PIN18.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN18_PIN0_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN18.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN18_PIN0_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN18.Reg, volatile.LoadUint32(&o.PIN18.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN18_PIN0_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN18.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN18_PIN0_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN18.Reg, volatile.LoadUint32(&o.PIN18.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN18_PIN0_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN18.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN18_PIN0_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN18.Reg, volatile.LoadUint32(&o.PIN18.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN18_PIN0_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN18.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN18_PIN0_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN18.Reg, volatile.LoadUint32(&o.PIN18.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN18_PIN0_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN18.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN18_PIN0_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN18.Reg, volatile.LoadUint32(&o.PIN18.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN18_PIN0_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN18.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN18_PIN0_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN18.Reg, volatile.LoadUint32(&o.PIN18.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN18_PIN0_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN18.Reg) & 0x3e000) >> 13
}

// GPIO.PIN19: Configuration for GPIO pin %s
func (o *GPIO_Type) SetPIN19_PIN0_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN19.Reg, volatile.LoadUint32(&o.PIN19.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN19_PIN0_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN19.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN19_PIN0_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN19.Reg, volatile.LoadUint32(&o.PIN19.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN19_PIN0_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN19.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN19_PIN0_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN19.Reg, volatile.LoadUint32(&o.PIN19.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN19_PIN0_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN19.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN19_PIN0_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN19.Reg, volatile.LoadUint32(&o.PIN19.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN19_PIN0_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN19.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN19_PIN0_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN19.Reg, volatile.LoadUint32(&o.PIN19.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN19_PIN0_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN19.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN19_PIN0_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN19.Reg, volatile.LoadUint32(&o.PIN19.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN19_PIN0_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN19.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN19_PIN0_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN19.Reg, volatile.LoadUint32(&o.PIN19.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN19_PIN0_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN19.Reg) & 0x3e000) >> 13
}

// GPIO.PIN20: Configuration for GPIO pin %s
func (o *GPIO_Type) SetPIN20_PIN0_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN20.Reg, volatile.LoadUint32(&o.PIN20.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN20_PIN0_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN20.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN20_PIN0_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN20.Reg, volatile.LoadUint32(&o.PIN20.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN20_PIN0_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN20.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN20_PIN0_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN20.Reg, volatile.LoadUint32(&o.PIN20.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN20_PIN0_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN20.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN20_PIN0_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN20.Reg, volatile.LoadUint32(&o.PIN20.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN20_PIN0_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN20.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN20_PIN0_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN20.Reg, volatile.LoadUint32(&o.PIN20.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN20_PIN0_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN20.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN20_PIN0_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN20.Reg, volatile.LoadUint32(&o.PIN20.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN20_PIN0_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN20.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN20_PIN0_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN20.Reg, volatile.LoadUint32(&o.PIN20.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN20_PIN0_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN20.Reg) & 0x3e000) >> 13
}

// GPIO.PIN21: Configuration for GPIO pin %s
func (o *GPIO_Type) SetPIN21_PIN0_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN21.Reg, volatile.LoadUint32(&o.PIN21.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN21_PIN0_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN21.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN21_PIN0_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN21.Reg, volatile.LoadUint32(&o.PIN21.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN21_PIN0_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN21.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN21_PIN0_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN21.Reg, volatile.LoadUint32(&o.PIN21.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN21_PIN0_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN21.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN21_PIN0_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN21.Reg, volatile.LoadUint32(&o.PIN21.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN21_PIN0_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN21.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN21_PIN0_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN21.Reg, volatile.LoadUint32(&o.PIN21.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN21_PIN0_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN21.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN21_PIN0_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN21.Reg, volatile.LoadUint32(&o.PIN21.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN21_PIN0_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN21.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN21_PIN0_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN21.Reg, volatile.LoadUint32(&o.PIN21.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN21_PIN0_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN21.Reg) & 0x3e000) >> 13
}

// GPIO.PIN22: Configuration for GPIO pin %s
func (o *GPIO_Type) SetPIN22_PIN0_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN22.Reg, volatile.LoadUint32(&o.PIN22.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN22_PIN0_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN22.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN22_PIN0_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN22.Reg, volatile.LoadUint32(&o.PIN22.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN22_PIN0_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN22.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN22_PIN0_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN22.Reg, volatile.LoadUint32(&o.PIN22.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN22_PIN0_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN22.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN22_PIN0_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN22.Reg, volatile.LoadUint32(&o.PIN22.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN22_PIN0_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN22.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN22_PIN0_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN22.Reg, volatile.LoadUint32(&o.PIN22.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN22_PIN0_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN22.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN22_PIN0_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN22.Reg, volatile.LoadUint32(&o.PIN22.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN22_PIN0_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN22.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN22_PIN0_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN22.Reg, volatile.LoadUint32(&o.PIN22.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN22_PIN0_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN22.Reg) & 0x3e000) >> 13
}

// GPIO.PIN23: Configuration for GPIO pin %s
func (o *GPIO_Type) SetPIN23_PIN0_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN23.Reg, volatile.LoadUint32(&o.PIN23.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN23_PIN0_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN23.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN23_PIN0_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN23.Reg, volatile.LoadUint32(&o.PIN23.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN23_PIN0_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN23.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN23_PIN0_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN23.Reg, volatile.LoadUint32(&o.PIN23.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN23_PIN0_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN23.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN23_PIN0_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN23.Reg, volatile.LoadUint32(&o.PIN23.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN23_PIN0_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN23.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN23_PIN0_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN23.Reg, volatile.LoadUint32(&o.PIN23.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN23_PIN0_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN23.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN23_PIN0_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN23.Reg, volatile.LoadUint32(&o.PIN23.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN23_PIN0_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN23.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN23_PIN0_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN23.Reg, volatile.LoadUint32(&o.PIN23.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN23_PIN0_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN23.Reg) & 0x3e000) >> 13
}

// GPIO.PIN24: Configuration for GPIO pin %s
func (o *GPIO_Type) SetPIN24_PIN0_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN24.Reg, volatile.LoadUint32(&o.PIN24.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN24_PIN0_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN24.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN24_PIN0_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN24.Reg, volatile.LoadUint32(&o.PIN24.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN24_PIN0_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN24.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN24_PIN0_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN24.Reg, volatile.LoadUint32(&o.PIN24.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN24_PIN0_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN24.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN24_PIN0_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN24.Reg, volatile.LoadUint32(&o.PIN24.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN24_PIN0_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN24.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN24_PIN0_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN24.Reg, volatile.LoadUint32(&o.PIN24.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN24_PIN0_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN24.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN24_PIN0_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN24.Reg, volatile.LoadUint32(&o.PIN24.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN24_PIN0_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN24.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN24_PIN0_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN24.Reg, volatile.LoadUint32(&o.PIN24.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN24_PIN0_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN24.Reg) & 0x3e000) >> 13
}

// GPIO.PIN25: Configuration for GPIO pin %s
func (o *GPIO_Type) SetPIN25_PIN0_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN25.Reg, volatile.LoadUint32(&o.PIN25.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN25_PIN0_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN25.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN25_PIN0_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN25.Reg, volatile.LoadUint32(&o.PIN25.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN25_PIN0_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN25.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN25_PIN0_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN25.Reg, volatile.LoadUint32(&o.PIN25.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN25_PIN0_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN25.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN25_PIN0_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN25.Reg, volatile.LoadUint32(&o.PIN25.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN25_PIN0_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN25.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN25_PIN0_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN25.Reg, volatile.LoadUint32(&o.PIN25.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN25_PIN0_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN25.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN25_PIN0_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN25.Reg, volatile.LoadUint32(&o.PIN25.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN25_PIN0_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN25.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN25_PIN0_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN25.Reg, volatile.LoadUint32(&o.PIN25.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN25_PIN0_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN25.Reg) & 0x3e000) >> 13
}

// GPIO.PIN26: Configuration for GPIO pin %s
func (o *GPIO_Type) SetPIN26_PIN0_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN26.Reg, volatile.LoadUint32(&o.PIN26.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN26_PIN0_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN26.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN26_PIN0_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN26.Reg, volatile.LoadUint32(&o.PIN26.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN26_PIN0_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN26.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN26_PIN0_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN26.Reg, volatile.LoadUint32(&o.PIN26.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN26_PIN0_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN26.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN26_PIN0_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN26.Reg, volatile.LoadUint32(&o.PIN26.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN26_PIN0_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN26.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN26_PIN0_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN26.Reg, volatile.LoadUint32(&o.PIN26.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN26_PIN0_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN26.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN26_PIN0_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN26.Reg, volatile.LoadUint32(&o.PIN26.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN26_PIN0_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN26.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN26_PIN0_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN26.Reg, volatile.LoadUint32(&o.PIN26.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN26_PIN0_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN26.Reg) & 0x3e000) >> 13
}

// GPIO.PIN27: Configuration for GPIO pin %s
func (o *GPIO_Type) SetPIN27_PIN0_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN27.Reg, volatile.LoadUint32(&o.PIN27.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN27_PIN0_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN27.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN27_PIN0_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN27.Reg, volatile.LoadUint32(&o.PIN27.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN27_PIN0_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN27.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN27_PIN0_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN27.Reg, volatile.LoadUint32(&o.PIN27.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN27_PIN0_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN27.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN27_PIN0_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN27.Reg, volatile.LoadUint32(&o.PIN27.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN27_PIN0_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN27.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN27_PIN0_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN27.Reg, volatile.LoadUint32(&o.PIN27.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN27_PIN0_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN27.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN27_PIN0_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN27.Reg, volatile.LoadUint32(&o.PIN27.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN27_PIN0_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN27.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN27_PIN0_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN27.Reg, volatile.LoadUint32(&o.PIN27.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN27_PIN0_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN27.Reg) & 0x3e000) >> 13
}

// GPIO.PIN28: Configuration for GPIO pin %s
func (o *GPIO_Type) SetPIN28_PIN0_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN28.Reg, volatile.LoadUint32(&o.PIN28.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN28_PIN0_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN28.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN28_PIN0_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN28.Reg, volatile.LoadUint32(&o.PIN28.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN28_PIN0_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN28.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN28_PIN0_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN28.Reg, volatile.LoadUint32(&o.PIN28.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN28_PIN0_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN28.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN28_PIN0_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN28.Reg, volatile.LoadUint32(&o.PIN28.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN28_PIN0_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN28.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN28_PIN0_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN28.Reg, volatile.LoadUint32(&o.PIN28.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN28_PIN0_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN28.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN28_PIN0_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN28.Reg, volatile.LoadUint32(&o.PIN28.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN28_PIN0_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN28.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN28_PIN0_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN28.Reg, volatile.LoadUint32(&o.PIN28.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN28_PIN0_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN28.Reg) & 0x3e000) >> 13
}

// GPIO.PIN29: Configuration for GPIO pin %s
func (o *GPIO_Type) SetPIN29_PIN0_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN29.Reg, volatile.LoadUint32(&o.PIN29.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN29_PIN0_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN29.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN29_PIN0_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN29.Reg, volatile.LoadUint32(&o.PIN29.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN29_PIN0_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN29.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN29_PIN0_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN29.Reg, volatile.LoadUint32(&o.PIN29.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN29_PIN0_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN29.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN29_PIN0_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN29.Reg, volatile.LoadUint32(&o.PIN29.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN29_PIN0_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN29.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN29_PIN0_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN29.Reg, volatile.LoadUint32(&o.PIN29.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN29_PIN0_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN29.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN29_PIN0_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN29.Reg, volatile.LoadUint32(&o.PIN29.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN29_PIN0_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN29.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN29_PIN0_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN29.Reg, volatile.LoadUint32(&o.PIN29.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN29_PIN0_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN29.Reg) & 0x3e000) >> 13
}

// GPIO.PIN30: Configuration for GPIO pin %s
func (o *GPIO_Type) SetPIN30_PIN0_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN30.Reg, volatile.LoadUint32(&o.PIN30.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN30_PIN0_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN30.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN30_PIN0_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN30.Reg, volatile.LoadUint32(&o.PIN30.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN30_PIN0_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN30.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN30_PIN0_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN30.Reg, volatile.LoadUint32(&o.PIN30.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN30_PIN0_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN30.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN30_PIN0_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN30.Reg, volatile.LoadUint32(&o.PIN30.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN30_PIN0_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN30.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN30_PIN0_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN30.Reg, volatile.LoadUint32(&o.PIN30.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN30_PIN0_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN30.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN30_PIN0_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN30.Reg, volatile.LoadUint32(&o.PIN30.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN30_PIN0_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN30.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN30_PIN0_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN30.Reg, volatile.LoadUint32(&o.PIN30.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN30_PIN0_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN30.Reg) & 0x3e000) >> 13
}

// GPIO.PIN31: Configuration for GPIO pin %s
func (o *GPIO_Type) SetPIN31_PIN0_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN31.Reg, volatile.LoadUint32(&o.PIN31.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN31_PIN0_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN31.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN31_PIN0_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN31.Reg, volatile.LoadUint32(&o.PIN31.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN31_PIN0_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN31.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN31_PIN0_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN31.Reg, volatile.LoadUint32(&o.PIN31.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN31_PIN0_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN31.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN31_PIN0_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN31.Reg, volatile.LoadUint32(&o.PIN31.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN31_PIN0_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN31.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN31_PIN0_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN31.Reg, volatile.LoadUint32(&o.PIN31.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN31_PIN0_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN31.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN31_PIN0_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN31.Reg, volatile.LoadUint32(&o.PIN31.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN31_PIN0_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN31.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN31_PIN0_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN31.Reg, volatile.LoadUint32(&o.PIN31.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN31_PIN0_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN31.Reg) & 0x3e000) >> 13
}

// GPIO.PIN32: Configuration for GPIO pin %s
func (o *GPIO_Type) SetPIN32_PIN0_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN32.Reg, volatile.LoadUint32(&o.PIN32.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN32_PIN0_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN32.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN32_PIN0_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN32.Reg, volatile.LoadUint32(&o.PIN32.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN32_PIN0_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN32.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN32_PIN0_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN32.Reg, volatile.LoadUint32(&o.PIN32.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN32_PIN0_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN32.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN32_PIN0_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN32.Reg, volatile.LoadUint32(&o.PIN32.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN32_PIN0_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN32.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN32_PIN0_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN32.Reg, volatile.LoadUint32(&o.PIN32.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN32_PIN0_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN32.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN32_PIN0_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN32.Reg, volatile.LoadUint32(&o.PIN32.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN32_PIN0_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN32.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN32_PIN0_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN32.Reg, volatile.LoadUint32(&o.PIN32.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN32_PIN0_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN32.Reg) & 0x3e000) >> 13
}

// GPIO.PIN33: Configuration for GPIO pin %s
func (o *GPIO_Type) SetPIN33_PIN0_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN33.Reg, volatile.LoadUint32(&o.PIN33.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN33_PIN0_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN33.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN33_PIN0_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN33.Reg, volatile.LoadUint32(&o.PIN33.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN33_PIN0_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN33.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN33_PIN0_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN33.Reg, volatile.LoadUint32(&o.PIN33.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN33_PIN0_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN33.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN33_PIN0_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN33.Reg, volatile.LoadUint32(&o.PIN33.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN33_PIN0_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN33.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN33_PIN0_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN33.Reg, volatile.LoadUint32(&o.PIN33.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN33_PIN0_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN33.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN33_PIN0_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN33.Reg, volatile.LoadUint32(&o.PIN33.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN33_PIN0_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN33.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN33_PIN0_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN33.Reg, volatile.LoadUint32(&o.PIN33.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN33_PIN0_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN33.Reg) & 0x3e000) >> 13
}

// GPIO.PIN34: Configuration for GPIO pin %s
func (o *GPIO_Type) SetPIN34_PIN0_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN34.Reg, volatile.LoadUint32(&o.PIN34.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN34_PIN0_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN34.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN34_PIN0_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN34.Reg, volatile.LoadUint32(&o.PIN34.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN34_PIN0_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN34.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN34_PIN0_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN34.Reg, volatile.LoadUint32(&o.PIN34.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN34_PIN0_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN34.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN34_PIN0_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN34.Reg, volatile.LoadUint32(&o.PIN34.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN34_PIN0_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN34.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN34_PIN0_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN34.Reg, volatile.LoadUint32(&o.PIN34.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN34_PIN0_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN34.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN34_PIN0_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN34.Reg, volatile.LoadUint32(&o.PIN34.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN34_PIN0_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN34.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN34_PIN0_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN34.Reg, volatile.LoadUint32(&o.PIN34.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN34_PIN0_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN34.Reg) & 0x3e000) >> 13
}

// GPIO.PIN35: Configuration for GPIO pin %s
func (o *GPIO_Type) SetPIN35_PIN0_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN35.Reg, volatile.LoadUint32(&o.PIN35.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN35_PIN0_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN35.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN35_PIN0_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN35.Reg, volatile.LoadUint32(&o.PIN35.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN35_PIN0_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN35.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN35_PIN0_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN35.Reg, volatile.LoadUint32(&o.PIN35.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN35_PIN0_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN35.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN35_PIN0_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN35.Reg, volatile.LoadUint32(&o.PIN35.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN35_PIN0_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN35.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN35_PIN0_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN35.Reg, volatile.LoadUint32(&o.PIN35.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN35_PIN0_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN35.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN35_PIN0_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN35.Reg, volatile.LoadUint32(&o.PIN35.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN35_PIN0_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN35.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN35_PIN0_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN35.Reg, volatile.LoadUint32(&o.PIN35.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN35_PIN0_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN35.Reg) & 0x3e000) >> 13
}

// GPIO.PIN36: Configuration for GPIO pin %s
func (o *GPIO_Type) SetPIN36_PIN0_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN36.Reg, volatile.LoadUint32(&o.PIN36.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN36_PIN0_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN36.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN36_PIN0_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN36.Reg, volatile.LoadUint32(&o.PIN36.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN36_PIN0_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN36.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN36_PIN0_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN36.Reg, volatile.LoadUint32(&o.PIN36.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN36_PIN0_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN36.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN36_PIN0_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN36.Reg, volatile.LoadUint32(&o.PIN36.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN36_PIN0_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN36.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN36_PIN0_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN36.Reg, volatile.LoadUint32(&o.PIN36.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN36_PIN0_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN36.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN36_PIN0_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN36.Reg, volatile.LoadUint32(&o.PIN36.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN36_PIN0_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN36.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN36_PIN0_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN36.Reg, volatile.LoadUint32(&o.PIN36.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN36_PIN0_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN36.Reg) & 0x3e000) >> 13
}

// GPIO.PIN37: Configuration for GPIO pin %s
func (o *GPIO_Type) SetPIN37_PIN0_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN37.Reg, volatile.LoadUint32(&o.PIN37.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN37_PIN0_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN37.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN37_PIN0_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN37.Reg, volatile.LoadUint32(&o.PIN37.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN37_PIN0_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN37.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN37_PIN0_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN37.Reg, volatile.LoadUint32(&o.PIN37.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN37_PIN0_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN37.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN37_PIN0_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN37.Reg, volatile.LoadUint32(&o.PIN37.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN37_PIN0_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN37.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN37_PIN0_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN37.Reg, volatile.LoadUint32(&o.PIN37.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN37_PIN0_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN37.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN37_PIN0_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN37.Reg, volatile.LoadUint32(&o.PIN37.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN37_PIN0_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN37.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN37_PIN0_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN37.Reg, volatile.LoadUint32(&o.PIN37.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN37_PIN0_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN37.Reg) & 0x3e000) >> 13
}

// GPIO.PIN38: Configuration for GPIO pin %s
func (o *GPIO_Type) SetPIN38_PIN0_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN38.Reg, volatile.LoadUint32(&o.PIN38.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN38_PIN0_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN38.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN38_PIN0_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN38.Reg, volatile.LoadUint32(&o.PIN38.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN38_PIN0_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN38.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN38_PIN0_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN38.Reg, volatile.LoadUint32(&o.PIN38.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN38_PIN0_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN38.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN38_PIN0_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN38.Reg, volatile.LoadUint32(&o.PIN38.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN38_PIN0_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN38.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN38_PIN0_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN38.Reg, volatile.LoadUint32(&o.PIN38.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN38_PIN0_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN38.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN38_PIN0_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN38.Reg, volatile.LoadUint32(&o.PIN38.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN38_PIN0_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN38.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN38_PIN0_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN38.Reg, volatile.LoadUint32(&o.PIN38.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN38_PIN0_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN38.Reg) & 0x3e000) >> 13
}

// GPIO.PIN39: Configuration for GPIO pin %s
func (o *GPIO_Type) SetPIN39_PIN0_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN39.Reg, volatile.LoadUint32(&o.PIN39.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN39_PIN0_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN39.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN39_PIN0_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN39.Reg, volatile.LoadUint32(&o.PIN39.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN39_PIN0_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN39.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN39_PIN0_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN39.Reg, volatile.LoadUint32(&o.PIN39.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN39_PIN0_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN39.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN39_PIN0_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN39.Reg, volatile.LoadUint32(&o.PIN39.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN39_PIN0_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN39.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN39_PIN0_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN39.Reg, volatile.LoadUint32(&o.PIN39.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN39_PIN0_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN39.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN39_PIN0_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN39.Reg, volatile.LoadUint32(&o.PIN39.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN39_PIN0_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN39.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN39_PIN0_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN39.Reg, volatile.LoadUint32(&o.PIN39.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN39_PIN0_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN39.Reg) & 0x3e000) >> 13
}

// GPIO.PIN40: Configuration for GPIO pin %s
func (o *GPIO_Type) SetPIN40_PIN0_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN40.Reg, volatile.LoadUint32(&o.PIN40.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN40_PIN0_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN40.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN40_PIN0_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN40.Reg, volatile.LoadUint32(&o.PIN40.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN40_PIN0_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN40.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN40_PIN0_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN40.Reg, volatile.LoadUint32(&o.PIN40.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN40_PIN0_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN40.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN40_PIN0_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN40.Reg, volatile.LoadUint32(&o.PIN40.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN40_PIN0_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN40.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN40_PIN0_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN40.Reg, volatile.LoadUint32(&o.PIN40.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN40_PIN0_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN40.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN40_PIN0_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN40.Reg, volatile.LoadUint32(&o.PIN40.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN40_PIN0_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN40.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN40_PIN0_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN40.Reg, volatile.LoadUint32(&o.PIN40.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN40_PIN0_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN40.Reg) & 0x3e000) >> 13
}

// GPIO.PIN41: Configuration for GPIO pin %s
func (o *GPIO_Type) SetPIN41_PIN0_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN41.Reg, volatile.LoadUint32(&o.PIN41.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN41_PIN0_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN41.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN41_PIN0_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN41.Reg, volatile.LoadUint32(&o.PIN41.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN41_PIN0_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN41.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN41_PIN0_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN41.Reg, volatile.LoadUint32(&o.PIN41.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN41_PIN0_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN41.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN41_PIN0_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN41.Reg, volatile.LoadUint32(&o.PIN41.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN41_PIN0_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN41.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN41_PIN0_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN41.Reg, volatile.LoadUint32(&o.PIN41.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN41_PIN0_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN41.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN41_PIN0_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN41.Reg, volatile.LoadUint32(&o.PIN41.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN41_PIN0_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN41.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN41_PIN0_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN41.Reg, volatile.LoadUint32(&o.PIN41.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN41_PIN0_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN41.Reg) & 0x3e000) >> 13
}

// GPIO.PIN42: Configuration for GPIO pin %s
func (o *GPIO_Type) SetPIN42_PIN0_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN42.Reg, volatile.LoadUint32(&o.PIN42.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN42_PIN0_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN42.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN42_PIN0_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN42.Reg, volatile.LoadUint32(&o.PIN42.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN42_PIN0_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN42.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN42_PIN0_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN42.Reg, volatile.LoadUint32(&o.PIN42.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN42_PIN0_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN42.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN42_PIN0_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN42.Reg, volatile.LoadUint32(&o.PIN42.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN42_PIN0_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN42.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN42_PIN0_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN42.Reg, volatile.LoadUint32(&o.PIN42.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN42_PIN0_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN42.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN42_PIN0_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN42.Reg, volatile.LoadUint32(&o.PIN42.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN42_PIN0_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN42.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN42_PIN0_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN42.Reg, volatile.LoadUint32(&o.PIN42.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN42_PIN0_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN42.Reg) & 0x3e000) >> 13
}

// GPIO.PIN43: Configuration for GPIO pin %s
func (o *GPIO_Type) SetPIN43_PIN0_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN43.Reg, volatile.LoadUint32(&o.PIN43.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN43_PIN0_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN43.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN43_PIN0_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN43.Reg, volatile.LoadUint32(&o.PIN43.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN43_PIN0_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN43.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN43_PIN0_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN43.Reg, volatile.LoadUint32(&o.PIN43.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN43_PIN0_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN43.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN43_PIN0_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN43.Reg, volatile.LoadUint32(&o.PIN43.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN43_PIN0_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN43.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN43_PIN0_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN43.Reg, volatile.LoadUint32(&o.PIN43.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN43_PIN0_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN43.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN43_PIN0_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN43.Reg, volatile.LoadUint32(&o.PIN43.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN43_PIN0_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN43.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN43_PIN0_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN43.Reg, volatile.LoadUint32(&o.PIN43.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN43_PIN0_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN43.Reg) & 0x3e000) >> 13
}

// GPIO.PIN44: Configuration for GPIO pin %s
func (o *GPIO_Type) SetPIN44_PIN0_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN44.Reg, volatile.LoadUint32(&o.PIN44.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN44_PIN0_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN44.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN44_PIN0_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN44.Reg, volatile.LoadUint32(&o.PIN44.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN44_PIN0_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN44.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN44_PIN0_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN44.Reg, volatile.LoadUint32(&o.PIN44.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN44_PIN0_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN44.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN44_PIN0_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN44.Reg, volatile.LoadUint32(&o.PIN44.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN44_PIN0_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN44.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN44_PIN0_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN44.Reg, volatile.LoadUint32(&o.PIN44.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN44_PIN0_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN44.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN44_PIN0_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN44.Reg, volatile.LoadUint32(&o.PIN44.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN44_PIN0_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN44.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN44_PIN0_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN44.Reg, volatile.LoadUint32(&o.PIN44.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN44_PIN0_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN44.Reg) & 0x3e000) >> 13
}

// GPIO.PIN45: Configuration for GPIO pin %s
func (o *GPIO_Type) SetPIN45_PIN0_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN45.Reg, volatile.LoadUint32(&o.PIN45.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN45_PIN0_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN45.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN45_PIN0_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN45.Reg, volatile.LoadUint32(&o.PIN45.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN45_PIN0_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN45.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN45_PIN0_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN45.Reg, volatile.LoadUint32(&o.PIN45.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN45_PIN0_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN45.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN45_PIN0_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN45.Reg, volatile.LoadUint32(&o.PIN45.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN45_PIN0_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN45.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN45_PIN0_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN45.Reg, volatile.LoadUint32(&o.PIN45.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN45_PIN0_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN45.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN45_PIN0_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN45.Reg, volatile.LoadUint32(&o.PIN45.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN45_PIN0_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN45.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN45_PIN0_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN45.Reg, volatile.LoadUint32(&o.PIN45.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN45_PIN0_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN45.Reg) & 0x3e000) >> 13
}

// GPIO.PIN46: Configuration for GPIO pin %s
func (o *GPIO_Type) SetPIN46_PIN0_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN46.Reg, volatile.LoadUint32(&o.PIN46.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN46_PIN0_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN46.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN46_PIN0_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN46.Reg, volatile.LoadUint32(&o.PIN46.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN46_PIN0_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN46.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN46_PIN0_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN46.Reg, volatile.LoadUint32(&o.PIN46.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN46_PIN0_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN46.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN46_PIN0_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN46.Reg, volatile.LoadUint32(&o.PIN46.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN46_PIN0_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN46.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN46_PIN0_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN46.Reg, volatile.LoadUint32(&o.PIN46.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN46_PIN0_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN46.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN46_PIN0_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN46.Reg, volatile.LoadUint32(&o.PIN46.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN46_PIN0_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN46.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN46_PIN0_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN46.Reg, volatile.LoadUint32(&o.PIN46.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN46_PIN0_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN46.Reg) & 0x3e000) >> 13
}

// GPIO.PIN47: Configuration for GPIO pin %s
func (o *GPIO_Type) SetPIN47_PIN0_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN47.Reg, volatile.LoadUint32(&o.PIN47.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN47_PIN0_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN47.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN47_PIN0_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN47.Reg, volatile.LoadUint32(&o.PIN47.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN47_PIN0_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN47.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN47_PIN0_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN47.Reg, volatile.LoadUint32(&o.PIN47.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN47_PIN0_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN47.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN47_PIN0_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN47.Reg, volatile.LoadUint32(&o.PIN47.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN47_PIN0_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN47.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN47_PIN0_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN47.Reg, volatile.LoadUint32(&o.PIN47.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN47_PIN0_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN47.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN47_PIN0_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN47.Reg, volatile.LoadUint32(&o.PIN47.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN47_PIN0_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN47.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN47_PIN0_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN47.Reg, volatile.LoadUint32(&o.PIN47.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN47_PIN0_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN47.Reg) & 0x3e000) >> 13
}

// GPIO.PIN48: Configuration for GPIO pin %s
func (o *GPIO_Type) SetPIN48_PIN0_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN48.Reg, volatile.LoadUint32(&o.PIN48.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN48_PIN0_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN48.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN48_PIN0_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN48.Reg, volatile.LoadUint32(&o.PIN48.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN48_PIN0_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN48.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN48_PIN0_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN48.Reg, volatile.LoadUint32(&o.PIN48.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN48_PIN0_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN48.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN48_PIN0_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN48.Reg, volatile.LoadUint32(&o.PIN48.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN48_PIN0_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN48.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN48_PIN0_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN48.Reg, volatile.LoadUint32(&o.PIN48.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN48_PIN0_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN48.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN48_PIN0_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN48.Reg, volatile.LoadUint32(&o.PIN48.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN48_PIN0_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN48.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN48_PIN0_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN48.Reg, volatile.LoadUint32(&o.PIN48.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN48_PIN0_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN48.Reg) & 0x3e000) >> 13
}

// GPIO.PIN49: Configuration for GPIO pin %s
func (o *GPIO_Type) SetPIN49_PIN0_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN49.Reg, volatile.LoadUint32(&o.PIN49.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN49_PIN0_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN49.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN49_PIN0_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN49.Reg, volatile.LoadUint32(&o.PIN49.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN49_PIN0_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN49.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN49_PIN0_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN49.Reg, volatile.LoadUint32(&o.PIN49.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN49_PIN0_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN49.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN49_PIN0_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN49.Reg, volatile.LoadUint32(&o.PIN49.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN49_PIN0_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN49.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN49_PIN0_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN49.Reg, volatile.LoadUint32(&o.PIN49.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN49_PIN0_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN49.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN49_PIN0_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN49.Reg, volatile.LoadUint32(&o.PIN49.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN49_PIN0_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN49.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN49_PIN0_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN49.Reg, volatile.LoadUint32(&o.PIN49.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN49_PIN0_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN49.Reg) & 0x3e000) >> 13
}

// GPIO.PIN50: Configuration for GPIO pin %s
func (o *GPIO_Type) SetPIN50_PIN0_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN50.Reg, volatile.LoadUint32(&o.PIN50.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN50_PIN0_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN50.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN50_PIN0_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN50.Reg, volatile.LoadUint32(&o.PIN50.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN50_PIN0_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN50.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN50_PIN0_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN50.Reg, volatile.LoadUint32(&o.PIN50.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN50_PIN0_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN50.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN50_PIN0_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN50.Reg, volatile.LoadUint32(&o.PIN50.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN50_PIN0_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN50.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN50_PIN0_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN50.Reg, volatile.LoadUint32(&o.PIN50.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN50_PIN0_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN50.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN50_PIN0_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN50.Reg, volatile.LoadUint32(&o.PIN50.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN50_PIN0_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN50.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN50_PIN0_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN50.Reg, volatile.LoadUint32(&o.PIN50.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN50_PIN0_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN50.Reg) & 0x3e000) >> 13
}

// GPIO.PIN51: Configuration for GPIO pin %s
func (o *GPIO_Type) SetPIN51_PIN0_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN51.Reg, volatile.LoadUint32(&o.PIN51.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN51_PIN0_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN51.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN51_PIN0_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN51.Reg, volatile.LoadUint32(&o.PIN51.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN51_PIN0_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN51.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN51_PIN0_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN51.Reg, volatile.LoadUint32(&o.PIN51.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN51_PIN0_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN51.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN51_PIN0_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN51.Reg, volatile.LoadUint32(&o.PIN51.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN51_PIN0_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN51.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN51_PIN0_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN51.Reg, volatile.LoadUint32(&o.PIN51.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN51_PIN0_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN51.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN51_PIN0_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN51.Reg, volatile.LoadUint32(&o.PIN51.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN51_PIN0_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN51.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN51_PIN0_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN51.Reg, volatile.LoadUint32(&o.PIN51.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN51_PIN0_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN51.Reg) & 0x3e000) >> 13
}

// GPIO.PIN52: Configuration for GPIO pin %s
func (o *GPIO_Type) SetPIN52_PIN0_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN52.Reg, volatile.LoadUint32(&o.PIN52.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN52_PIN0_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN52.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN52_PIN0_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN52.Reg, volatile.LoadUint32(&o.PIN52.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN52_PIN0_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN52.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN52_PIN0_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN52.Reg, volatile.LoadUint32(&o.PIN52.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN52_PIN0_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN52.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN52_PIN0_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN52.Reg, volatile.LoadUint32(&o.PIN52.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN52_PIN0_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN52.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN52_PIN0_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN52.Reg, volatile.LoadUint32(&o.PIN52.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN52_PIN0_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN52.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN52_PIN0_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN52.Reg, volatile.LoadUint32(&o.PIN52.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN52_PIN0_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN52.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN52_PIN0_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN52.Reg, volatile.LoadUint32(&o.PIN52.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN52_PIN0_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN52.Reg) & 0x3e000) >> 13
}

// GPIO.PIN53: Configuration for GPIO pin %s
func (o *GPIO_Type) SetPIN53_PIN0_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN53.Reg, volatile.LoadUint32(&o.PIN53.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN53_PIN0_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN53.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN53_PIN0_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN53.Reg, volatile.LoadUint32(&o.PIN53.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN53_PIN0_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN53.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN53_PIN0_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN53.Reg, volatile.LoadUint32(&o.PIN53.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN53_PIN0_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN53.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN53_PIN0_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN53.Reg, volatile.LoadUint32(&o.PIN53.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN53_PIN0_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN53.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN53_PIN0_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN53.Reg, volatile.LoadUint32(&o.PIN53.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN53_PIN0_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN53.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN53_PIN0_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN53.Reg, volatile.LoadUint32(&o.PIN53.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN53_PIN0_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN53.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN53_PIN0_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN53.Reg, volatile.LoadUint32(&o.PIN53.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN53_PIN0_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN53.Reg) & 0x3e000) >> 13
}

// GPIO.STATUS_NEXT: GPIO0 ~ 31 interrupt source register
func (o *GPIO_Type) SetSTATUS_NEXT(value uint32) {
	volatile.StoreUint32(&o.STATUS_NEXT.Reg, value)
}
func (o *GPIO_Type) GetSTATUS_NEXT() uint32 {
	return volatile.LoadUint32(&o.STATUS_NEXT.Reg)
}

// GPIO.STATUS_NEXT1: GPIO32 ~ 53 interrupt source register
func (o *GPIO_Type) SetSTATUS_NEXT1_STATUS1_INTERRUPT_NEXT(value uint32) {
	volatile.StoreUint32(&o.STATUS_NEXT1.Reg, volatile.LoadUint32(&o.STATUS_NEXT1.Reg)&^(0x3fffff)|value)
}
func (o *GPIO_Type) GetSTATUS_NEXT1_STATUS1_INTERRUPT_NEXT() uint32 {
	return volatile.LoadUint32(&o.STATUS_NEXT1.Reg) & 0x3fffff
}

// GPIO.FUNC0_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC0_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC0_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC0_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC0_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC0_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC0_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC0_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC0_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC0_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC0_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC0_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC0_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC0_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC0_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC0_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC1_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC1_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC1_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC1_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC1_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC1_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC1_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC1_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC1_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC1_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC1_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC1_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC1_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC1_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC1_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC1_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC2_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC2_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC2_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC2_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC2_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC2_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC2_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC2_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC2_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC2_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC2_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC2_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC2_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC2_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC2_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC2_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC3_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC3_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC3_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC3_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC3_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC3_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC3_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC3_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC3_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC3_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC3_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC3_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC3_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC3_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC3_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC3_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC4_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC4_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC4_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC4_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC4_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC4_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC4_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC4_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC4_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC4_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC4_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC4_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC4_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC4_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC4_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC4_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC5_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC5_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC5_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC5_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC5_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC5_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC5_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC5_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC5_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC5_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC5_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC5_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC5_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC5_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC5_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC5_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC6_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC6_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC6_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC6_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC6_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC6_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC6_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC6_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC6_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC6_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC6_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC6_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC6_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC6_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC6_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC6_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC7_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC7_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC7_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC7_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC7_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC7_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC7_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC7_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC7_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC7_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC7_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC7_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC7_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC7_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC7_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC7_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC8_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC8_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC8_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC8_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC8_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC8_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC8_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC8_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC8_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC8_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC8_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC8_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC8_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC8_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC8_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC8_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC9_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC9_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC9_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC9_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC9_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC9_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC9_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC9_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC9_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC9_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC9_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC9_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC9_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC9_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC9_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC9_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC10_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC10_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC10_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC10_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC10_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC10_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC10_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC10_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC10_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC10_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC10_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC10_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC10_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC10_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC10_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC10_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC11_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC11_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC11_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC11_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC11_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC11_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC11_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC11_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC11_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC11_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC11_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC11_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC11_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC11_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC11_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC11_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC12_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC12_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC12_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC12_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC12_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC12_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC12_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC12_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC12_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC12_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC12_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC12_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC12_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC12_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC12_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC12_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC13_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC13_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC13_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC13_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC13_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC13_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC13_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC13_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC13_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC13_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC13_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC13_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC13_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC13_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC13_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC13_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC14_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC14_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC14_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC14_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC14_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC14_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC14_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC14_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC14_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC14_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC14_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC14_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC14_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC14_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC14_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC14_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC15_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC15_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC15_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC15_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC15_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC15_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC15_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC15_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC15_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC15_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC15_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC15_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC15_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC15_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC15_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC15_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC16_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC16_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC16_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC16_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC16_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC16_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC16_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC16_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC16_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC16_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC16_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC16_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC16_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC16_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC16_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC16_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC17_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC17_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC17_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC17_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC17_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC17_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC17_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC17_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC17_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC17_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC17_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC17_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC17_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC17_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC17_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC17_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC18_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC18_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC18_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC18_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC18_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC18_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC18_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC18_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC18_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC18_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC18_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC18_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC18_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC18_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC18_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC18_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC19_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC19_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC19_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC19_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC19_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC19_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC19_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC19_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC19_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC19_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC19_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC19_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC19_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC19_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC19_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC19_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC20_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC20_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC20_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC20_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC20_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC20_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC20_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC20_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC20_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC20_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC20_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC20_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC20_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC20_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC20_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC20_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC21_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC21_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC21_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC21_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC21_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC21_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC21_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC21_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC21_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC21_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC21_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC21_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC21_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC21_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC21_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC21_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC22_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC22_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC22_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC22_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC22_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC22_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC22_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC22_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC22_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC22_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC22_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC22_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC22_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC22_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC22_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC22_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC23_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC23_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC23_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC23_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC23_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC23_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC23_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC23_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC23_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC23_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC23_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC23_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC23_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC23_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC23_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC23_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC24_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC24_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC24_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC24_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC24_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC24_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC24_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC24_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC24_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC24_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC24_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC24_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC24_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC24_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC24_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC24_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC25_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC25_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC25_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC25_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC25_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC25_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC25_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC25_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC25_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC25_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC25_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC25_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC25_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC25_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC25_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC25_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC26_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC26_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC26_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC26_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC26_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC26_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC26_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC26_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC26_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC26_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC26_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC26_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC26_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC26_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC26_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC26_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC27_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC27_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC27_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC27_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC27_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC27_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC27_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC27_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC27_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC27_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC27_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC27_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC27_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC27_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC27_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC27_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC28_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC28_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC28_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC28_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC28_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC28_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC28_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC28_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC28_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC28_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC28_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC28_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC28_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC28_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC28_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC28_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC29_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC29_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC29_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC29_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC29_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC29_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC29_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC29_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC29_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC29_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC29_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC29_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC29_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC29_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC29_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC29_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC30_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC30_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC30_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC30_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC30_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC30_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC30_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC30_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC30_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC30_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC30_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC30_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC30_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC30_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC30_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC30_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC31_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC31_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC31_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC31_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC31_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC31_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC31_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC31_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC31_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC31_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC31_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC31_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC31_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC31_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC31_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC31_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC32_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC32_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC32_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC32_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC32_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC32_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC32_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC32_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC32_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC32_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC32_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC32_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC32_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC32_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC32_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC32_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC33_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC33_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC33_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC33_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC33_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC33_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC33_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC33_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC33_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC33_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC33_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC33_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC33_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC33_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC33_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC33_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC34_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC34_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC34_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC34_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC34_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC34_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC34_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC34_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC34_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC34_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC34_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC34_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC34_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC34_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC34_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC34_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC35_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC35_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC35_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC35_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC35_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC35_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC35_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC35_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC35_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC35_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC35_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC35_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC35_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC35_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC35_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC35_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC36_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC36_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC36_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC36_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC36_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC36_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC36_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC36_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC36_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC36_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC36_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC36_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC36_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC36_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC36_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC36_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC37_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC37_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC37_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC37_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC37_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC37_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC37_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC37_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC37_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC37_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC37_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC37_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC37_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC37_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC37_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC37_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC38_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC38_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC38_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC38_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC38_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC38_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC38_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC38_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC38_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC38_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC38_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC38_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC38_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC38_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC38_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC38_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC39_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC39_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC39_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC39_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC39_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC39_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC39_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC39_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC39_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC39_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC39_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC39_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC39_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC39_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC39_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC39_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC40_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC40_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC40_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC40_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC40_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC40_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC40_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC40_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC40_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC40_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC40_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC40_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC40_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC40_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC40_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC40_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC41_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC41_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC41_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC41_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC41_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC41_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC41_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC41_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC41_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC41_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC41_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC41_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC41_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC41_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC41_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC41_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC42_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC42_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC42_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC42_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC42_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC42_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC42_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC42_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC42_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC42_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC42_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC42_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC42_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC42_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC42_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC42_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC43_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC43_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC43_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC43_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC43_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC43_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC43_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC43_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC43_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC43_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC43_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC43_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC43_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC43_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC43_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC43_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC44_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC44_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC44_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC44_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC44_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC44_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC44_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC44_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC44_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC44_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC44_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC44_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC44_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC44_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC44_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC44_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC45_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC45_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC45_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC45_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC45_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC45_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC45_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC45_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC45_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC45_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC45_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC45_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC45_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC45_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC45_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC45_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC46_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC46_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC46_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC46_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC46_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC46_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC46_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC46_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC46_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC46_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC46_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC46_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC46_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC46_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC46_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC46_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC47_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC47_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC47_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC47_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC47_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC47_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC47_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC47_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC47_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC47_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC47_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC47_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC47_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC47_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC47_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC47_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC48_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC48_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC48_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC48_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC48_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC48_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC48_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC48_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC48_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC48_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC48_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC48_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC48_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC48_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC48_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC48_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC49_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC49_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC49_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC49_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC49_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC49_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC49_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC49_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC49_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC49_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC49_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC49_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC49_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC49_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC49_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC49_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC50_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC50_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC50_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC50_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC50_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC50_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC50_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC50_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC50_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC50_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC50_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC50_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC50_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC50_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC50_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC50_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC51_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC51_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC51_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC51_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC51_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC51_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC51_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC51_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC51_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC51_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC51_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC51_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC51_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC51_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC51_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC51_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC52_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC52_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC52_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC52_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC52_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC52_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC52_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC52_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC52_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC52_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC52_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC52_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC52_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC52_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC52_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC52_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC53_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC53_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC53_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC53_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC53_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC53_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC53_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC53_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC53_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC53_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC53_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC53_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC53_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC53_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC53_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC53_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC54_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC54_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC54_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC54_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC54_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC54_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC54_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC54_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC54_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC54_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC54_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC54_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC54_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC54_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC54_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC54_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC55_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC55_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC55_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC55_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC55_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC55_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC55_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC55_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC55_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC55_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC55_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC55_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC55_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC55_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC55_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC55_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC56_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC56_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC56_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC56_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC56_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC56_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC56_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC56_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC56_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC56_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC56_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC56_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC56_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC56_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC56_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC56_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC57_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC57_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC57_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC57_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC57_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC57_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC57_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC57_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC57_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC57_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC57_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC57_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC57_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC57_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC57_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC57_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC58_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC58_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC58_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC58_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC58_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC58_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC58_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC58_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC58_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC58_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC58_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC58_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC58_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC58_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC58_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC58_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC59_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC59_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC59_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC59_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC59_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC59_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC59_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC59_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC59_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC59_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC59_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC59_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC59_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC59_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC59_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC59_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC60_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC60_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC60_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC60_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC60_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC60_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC60_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC60_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC60_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC60_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC60_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC60_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC60_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC60_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC60_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC60_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC61_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC61_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC61_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC61_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC61_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC61_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC61_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC61_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC61_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC61_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC61_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC61_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC61_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC61_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC61_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC61_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC62_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC62_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC62_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC62_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC62_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC62_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC62_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC62_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC62_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC62_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC62_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC62_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC62_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC62_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC62_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC62_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC63_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC63_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC63_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC63_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC63_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC63_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC63_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC63_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC63_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC63_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC63_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC63_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC63_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC63_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC63_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC63_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC64_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC64_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC64_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC64_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC64_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC64_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC64_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC64_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC64_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC64_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC64_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC64_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC64_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC64_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC64_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC64_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC65_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC65_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC65_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC65_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC65_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC65_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC65_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC65_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC65_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC65_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC65_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC65_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC65_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC65_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC65_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC65_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC66_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC66_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC66_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC66_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC66_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC66_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC66_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC66_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC66_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC66_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC66_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC66_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC66_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC66_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC66_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC66_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC67_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC67_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC67_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC67_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC67_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC67_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC67_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC67_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC67_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC67_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC67_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC67_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC67_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC67_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC67_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC67_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC68_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC68_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC68_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC68_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC68_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC68_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC68_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC68_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC68_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC68_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC68_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC68_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC68_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC68_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC68_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC68_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC69_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC69_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC69_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC69_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC69_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC69_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC69_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC69_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC69_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC69_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC69_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC69_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC69_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC69_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC69_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC69_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC70_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC70_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC70_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC70_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC70_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC70_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC70_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC70_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC70_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC70_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC70_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC70_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC70_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC70_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC70_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC70_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC71_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC71_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC71_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC71_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC71_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC71_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC71_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC71_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC71_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC71_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC71_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC71_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC71_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC71_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC71_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC71_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC72_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC72_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC72_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC72_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC72_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC72_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC72_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC72_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC72_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC72_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC72_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC72_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC72_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC72_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC72_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC72_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC73_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC73_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC73_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC73_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC73_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC73_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC73_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC73_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC73_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC73_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC73_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC73_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC73_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC73_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC73_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC73_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC74_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC74_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC74_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC74_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC74_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC74_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC74_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC74_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC74_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC74_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC74_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC74_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC74_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC74_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC74_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC74_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC75_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC75_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC75_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC75_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC75_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC75_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC75_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC75_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC75_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC75_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC75_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC75_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC75_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC75_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC75_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC75_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC76_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC76_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC76_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC76_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC76_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC76_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC76_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC76_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC76_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC76_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC76_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC76_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC76_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC76_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC76_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC76_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC77_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC77_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC77_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC77_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC77_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC77_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC77_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC77_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC77_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC77_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC77_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC77_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC77_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC77_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC77_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC77_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC78_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC78_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC78_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC78_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC78_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC78_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC78_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC78_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC78_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC78_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC78_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC78_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC78_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC78_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC78_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC78_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC79_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC79_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC79_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC79_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC79_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC79_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC79_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC79_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC79_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC79_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC79_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC79_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC79_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC79_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC79_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC79_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC80_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC80_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC80_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC80_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC80_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC80_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC80_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC80_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC80_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC80_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC80_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC80_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC80_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC80_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC80_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC80_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC81_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC81_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC81_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC81_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC81_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC81_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC81_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC81_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC81_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC81_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC81_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC81_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC81_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC81_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC81_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC81_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC82_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC82_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC82_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC82_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC82_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC82_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC82_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC82_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC82_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC82_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC82_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC82_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC82_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC82_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC82_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC82_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC83_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC83_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC83_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC83_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC83_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC83_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC83_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC83_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC83_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC83_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC83_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC83_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC83_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC83_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC83_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC83_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC84_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC84_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC84_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC84_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC84_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC84_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC84_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC84_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC84_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC84_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC84_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC84_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC84_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC84_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC84_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC84_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC85_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC85_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC85_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC85_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC85_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC85_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC85_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC85_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC85_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC85_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC85_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC85_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC85_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC85_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC85_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC85_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC86_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC86_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC86_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC86_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC86_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC86_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC86_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC86_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC86_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC86_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC86_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC86_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC86_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC86_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC86_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC86_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC87_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC87_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC87_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC87_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC87_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC87_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC87_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC87_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC87_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC87_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC87_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC87_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC87_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC87_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC87_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC87_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC88_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC88_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC88_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC88_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC88_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC88_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC88_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC88_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC88_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC88_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC88_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC88_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC88_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC88_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC88_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC88_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC89_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC89_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC89_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC89_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC89_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC89_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC89_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC89_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC89_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC89_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC89_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC89_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC89_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC89_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC89_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC89_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC90_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC90_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC90_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC90_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC90_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC90_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC90_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC90_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC90_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC90_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC90_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC90_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC90_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC90_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC90_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC90_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC91_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC91_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC91_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC91_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC91_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC91_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC91_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC91_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC91_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC91_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC91_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC91_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC91_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC91_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC91_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC91_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC92_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC92_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC92_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC92_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC92_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC92_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC92_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC92_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC92_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC92_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC92_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC92_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC92_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC92_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC92_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC92_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC93_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC93_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC93_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC93_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC93_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC93_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC93_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC93_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC93_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC93_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC93_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC93_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC93_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC93_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC93_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC93_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC94_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC94_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC94_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC94_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC94_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC94_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC94_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC94_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC94_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC94_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC94_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC94_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC94_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC94_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC94_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC94_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC95_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC95_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC95_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC95_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC95_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC95_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC95_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC95_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC95_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC95_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC95_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC95_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC95_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC95_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC95_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC95_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC96_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC96_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC96_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC96_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC96_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC96_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC96_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC96_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC96_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC96_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC96_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC96_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC96_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC96_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC96_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC96_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC97_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC97_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC97_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC97_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC97_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC97_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC97_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC97_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC97_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC97_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC97_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC97_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC97_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC97_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC97_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC97_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC98_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC98_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC98_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC98_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC98_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC98_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC98_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC98_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC98_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC98_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC98_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC98_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC98_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC98_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC98_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC98_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC99_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC99_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC99_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC99_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC99_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC99_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC99_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC99_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC99_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC99_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC99_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC99_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC99_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC99_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC99_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC99_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC100_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC100_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC100_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC100_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC100_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC100_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC100_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC100_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC100_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC100_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC100_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC100_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC100_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC100_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC100_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC100_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC101_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC101_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC101_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC101_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC101_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC101_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC101_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC101_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC101_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC101_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC101_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC101_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC101_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC101_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC101_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC101_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC102_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC102_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC102_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC102_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC102_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC102_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC102_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC102_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC102_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC102_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC102_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC102_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC102_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC102_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC102_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC102_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC103_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC103_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC103_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC103_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC103_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC103_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC103_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC103_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC103_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC103_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC103_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC103_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC103_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC103_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC103_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC103_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC104_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC104_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC104_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC104_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC104_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC104_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC104_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC104_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC104_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC104_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC104_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC104_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC104_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC104_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC104_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC104_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC105_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC105_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC105_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC105_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC105_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC105_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC105_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC105_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC105_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC105_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC105_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC105_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC105_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC105_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC105_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC105_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC106_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC106_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC106_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC106_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC106_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC106_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC106_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC106_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC106_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC106_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC106_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC106_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC106_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC106_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC106_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC106_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC107_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC107_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC107_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC107_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC107_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC107_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC107_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC107_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC107_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC107_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC107_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC107_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC107_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC107_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC107_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC107_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC108_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC108_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC108_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC108_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC108_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC108_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC108_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC108_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC108_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC108_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC108_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC108_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC108_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC108_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC108_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC108_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC109_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC109_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC109_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC109_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC109_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC109_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC109_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC109_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC109_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC109_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC109_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC109_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC109_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC109_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC109_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC109_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC110_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC110_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC110_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC110_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC110_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC110_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC110_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC110_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC110_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC110_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC110_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC110_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC110_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC110_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC110_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC110_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC111_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC111_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC111_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC111_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC111_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC111_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC111_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC111_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC111_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC111_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC111_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC111_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC111_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC111_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC111_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC111_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC112_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC112_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC112_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC112_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC112_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC112_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC112_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC112_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC112_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC112_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC112_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC112_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC112_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC112_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC112_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC112_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC113_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC113_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC113_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC113_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC113_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC113_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC113_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC113_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC113_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC113_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC113_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC113_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC113_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC113_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC113_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC113_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC114_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC114_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC114_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC114_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC114_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC114_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC114_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC114_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC114_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC114_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC114_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC114_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC114_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC114_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC114_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC114_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC115_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC115_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC115_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC115_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC115_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC115_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC115_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC115_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC115_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC115_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC115_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC115_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC115_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC115_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC115_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC115_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC116_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC116_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC116_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC116_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC116_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC116_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC116_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC116_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC116_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC116_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC116_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC116_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC116_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC116_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC116_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC116_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC117_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC117_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC117_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC117_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC117_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC117_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC117_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC117_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC117_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC117_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC117_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC117_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC117_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC117_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC117_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC117_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC118_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC118_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC118_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC118_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC118_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC118_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC118_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC118_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC118_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC118_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC118_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC118_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC118_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC118_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC118_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC118_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC119_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC119_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC119_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC119_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC119_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC119_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC119_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC119_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC119_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC119_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC119_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC119_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC119_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC119_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC119_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC119_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC120_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC120_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC120_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC120_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC120_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC120_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC120_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC120_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC120_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC120_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC120_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC120_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC120_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC120_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC120_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC120_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC121_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC121_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC121_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC121_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC121_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC121_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC121_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC121_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC121_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC121_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC121_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC121_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC121_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC121_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC121_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC121_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC122_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC122_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC122_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC122_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC122_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC122_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC122_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC122_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC122_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC122_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC122_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC122_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC122_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC122_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC122_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC122_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC123_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC123_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC123_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC123_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC123_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC123_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC123_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC123_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC123_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC123_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC123_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC123_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC123_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC123_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC123_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC123_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC124_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC124_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC124_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC124_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC124_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC124_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC124_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC124_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC124_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC124_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC124_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC124_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC124_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC124_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC124_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC124_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC125_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC125_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC125_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC125_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC125_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC125_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC125_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC125_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC125_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC125_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC125_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC125_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC125_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC125_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC125_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC125_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC126_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC126_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC126_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC126_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC126_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC126_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC126_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC126_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC126_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC126_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC126_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC126_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC126_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC126_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC126_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC126_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC127_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC127_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC127_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC127_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC127_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC127_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC127_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC127_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC127_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC127_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC127_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC127_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC127_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC127_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC127_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC127_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC128_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC128_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC128_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC128_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC128_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC128_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC128_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC128_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC128_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC128_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC128_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC128_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC128_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC128_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC128_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC128_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC129_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC129_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC129_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC129_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC129_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC129_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC129_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC129_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC129_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC129_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC129_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC129_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC129_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC129_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC129_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC129_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC130_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC130_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC130_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC130_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC130_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC130_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC130_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC130_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC130_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC130_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC130_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC130_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC130_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC130_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC130_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC130_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC131_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC131_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC131_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC131_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC131_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC131_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC131_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC131_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC131_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC131_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC131_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC131_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC131_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC131_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC131_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC131_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC132_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC132_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC132_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC132_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC132_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC132_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC132_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC132_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC132_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC132_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC132_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC132_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC132_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC132_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC132_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC132_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC133_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC133_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC133_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC133_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC133_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC133_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC133_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC133_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC133_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC133_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC133_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC133_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC133_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC133_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC133_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC133_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC134_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC134_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC134_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC134_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC134_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC134_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC134_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC134_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC134_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC134_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC134_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC134_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC134_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC134_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC134_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC134_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC135_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC135_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC135_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC135_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC135_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC135_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC135_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC135_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC135_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC135_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC135_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC135_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC135_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC135_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC135_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC135_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC136_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC136_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC136_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC136_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC136_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC136_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC136_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC136_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC136_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC136_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC136_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC136_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC136_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC136_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC136_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC136_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC137_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC137_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC137_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC137_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC137_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC137_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC137_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC137_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC137_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC137_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC137_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC137_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC137_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC137_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC137_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC137_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC138_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC138_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC138_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC138_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC138_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC138_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC138_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC138_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC138_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC138_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC138_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC138_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC138_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC138_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC138_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC138_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC139_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC139_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC139_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC139_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC139_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC139_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC139_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC139_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC139_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC139_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC139_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC139_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC139_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC139_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC139_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC139_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC140_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC140_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC140_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC140_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC140_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC140_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC140_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC140_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC140_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC140_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC140_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC140_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC140_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC140_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC140_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC140_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC141_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC141_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC141_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC141_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC141_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC141_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC141_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC141_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC141_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC141_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC141_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC141_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC141_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC141_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC141_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC141_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC142_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC142_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC142_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC142_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC142_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC142_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC142_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC142_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC142_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC142_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC142_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC142_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC142_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC142_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC142_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC142_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC143_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC143_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC143_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC143_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC143_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC143_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC143_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC143_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC143_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC143_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC143_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC143_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC143_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC143_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC143_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC143_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC144_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC144_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC144_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC144_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC144_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC144_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC144_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC144_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC144_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC144_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC144_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC144_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC144_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC144_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC144_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC144_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC145_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC145_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC145_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC145_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC145_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC145_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC145_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC145_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC145_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC145_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC145_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC145_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC145_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC145_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC145_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC145_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC146_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC146_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC146_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC146_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC146_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC146_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC146_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC146_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC146_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC146_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC146_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC146_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC146_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC146_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC146_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC146_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC147_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC147_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC147_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC147_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC147_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC147_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC147_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC147_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC147_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC147_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC147_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC147_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC147_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC147_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC147_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC147_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC148_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC148_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC148_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC148_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC148_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC148_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC148_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC148_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC148_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC148_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC148_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC148_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC148_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC148_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC148_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC148_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC149_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC149_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC149_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC149_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC149_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC149_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC149_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC149_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC149_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC149_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC149_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC149_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC149_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC149_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC149_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC149_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC150_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC150_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC150_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC150_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC150_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC150_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC150_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC150_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC150_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC150_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC150_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC150_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC150_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC150_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC150_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC150_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC151_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC151_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC151_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC151_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC151_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC151_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC151_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC151_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC151_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC151_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC151_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC151_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC151_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC151_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC151_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC151_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC152_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC152_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC152_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC152_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC152_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC152_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC152_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC152_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC152_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC152_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC152_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC152_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC152_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC152_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC152_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC152_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC153_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC153_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC153_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC153_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC153_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC153_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC153_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC153_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC153_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC153_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC153_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC153_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC153_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC153_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC153_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC153_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC154_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC154_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC154_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC154_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC154_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC154_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC154_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC154_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC154_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC154_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC154_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC154_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC154_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC154_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC154_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC154_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC155_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC155_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC155_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC155_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC155_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC155_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC155_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC155_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC155_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC155_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC155_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC155_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC155_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC155_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC155_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC155_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC156_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC156_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC156_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC156_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC156_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC156_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC156_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC156_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC156_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC156_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC156_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC156_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC156_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC156_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC156_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC156_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC157_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC157_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC157_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC157_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC157_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC157_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC157_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC157_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC157_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC157_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC157_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC157_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC157_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC157_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC157_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC157_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC158_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC158_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC158_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC158_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC158_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC158_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC158_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC158_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC158_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC158_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC158_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC158_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC158_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC158_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC158_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC158_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC159_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC159_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC159_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC159_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC159_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC159_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC159_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC159_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC159_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC159_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC159_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC159_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC159_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC159_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC159_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC159_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC160_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC160_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC160_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC160_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC160_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC160_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC160_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC160_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC160_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC160_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC160_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC160_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC160_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC160_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC160_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC160_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC161_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC161_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC161_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC161_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC161_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC161_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC161_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC161_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC161_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC161_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC161_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC161_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC161_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC161_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC161_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC161_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC162_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC162_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC162_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC162_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC162_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC162_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC162_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC162_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC162_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC162_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC162_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC162_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC162_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC162_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC162_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC162_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC163_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC163_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC163_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC163_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC163_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC163_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC163_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC163_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC163_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC163_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC163_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC163_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC163_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC163_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC163_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC163_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC164_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC164_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC164_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC164_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC164_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC164_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC164_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC164_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC164_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC164_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC164_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC164_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC164_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC164_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC164_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC164_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC165_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC165_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC165_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC165_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC165_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC165_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC165_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC165_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC165_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC165_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC165_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC165_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC165_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC165_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC165_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC165_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC166_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC166_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC166_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC166_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC166_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC166_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC166_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC166_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC166_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC166_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC166_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC166_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC166_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC166_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC166_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC166_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC167_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC167_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC167_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC167_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC167_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC167_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC167_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC167_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC167_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC167_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC167_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC167_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC167_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC167_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC167_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC167_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC168_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC168_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC168_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC168_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC168_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC168_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC168_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC168_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC168_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC168_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC168_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC168_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC168_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC168_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC168_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC168_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC169_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC169_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC169_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC169_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC169_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC169_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC169_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC169_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC169_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC169_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC169_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC169_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC169_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC169_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC169_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC169_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC170_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC170_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC170_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC170_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC170_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC170_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC170_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC170_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC170_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC170_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC170_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC170_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC170_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC170_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC170_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC170_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC171_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC171_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC171_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC171_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC171_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC171_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC171_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC171_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC171_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC171_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC171_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC171_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC171_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC171_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC171_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC171_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC172_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC172_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC172_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC172_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC172_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC172_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC172_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC172_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC172_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC172_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC172_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC172_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC172_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC172_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC172_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC172_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC173_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC173_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC173_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC173_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC173_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC173_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC173_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC173_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC173_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC173_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC173_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC173_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC173_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC173_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC173_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC173_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC174_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC174_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC174_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC174_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC174_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC174_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC174_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC174_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC174_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC174_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC174_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC174_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC174_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC174_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC174_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC174_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC175_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC175_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC175_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC175_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC175_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC175_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC175_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC175_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC175_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC175_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC175_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC175_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC175_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC175_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC175_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC175_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC176_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC176_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC176_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC176_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC176_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC176_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC176_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC176_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC176_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC176_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC176_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC176_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC176_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC176_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC176_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC176_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC177_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC177_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC177_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC177_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC177_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC177_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC177_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC177_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC177_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC177_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC177_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC177_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC177_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC177_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC177_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC177_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC178_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC178_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC178_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC178_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC178_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC178_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC178_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC178_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC178_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC178_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC178_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC178_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC178_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC178_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC178_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC178_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC179_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC179_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC179_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC179_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC179_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC179_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC179_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC179_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC179_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC179_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC179_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC179_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC179_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC179_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC179_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC179_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC180_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC180_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC180_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC180_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC180_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC180_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC180_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC180_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC180_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC180_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC180_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC180_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC180_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC180_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC180_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC180_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC181_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC181_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC181_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC181_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC181_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC181_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC181_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC181_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC181_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC181_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC181_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC181_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC181_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC181_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC181_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC181_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC182_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC182_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC182_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC182_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC182_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC182_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC182_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC182_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC182_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC182_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC182_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC182_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC182_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC182_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC182_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC182_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC183_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC183_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC183_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC183_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC183_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC183_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC183_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC183_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC183_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC183_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC183_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC183_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC183_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC183_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC183_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC183_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC184_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC184_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC184_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC184_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC184_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC184_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC184_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC184_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC184_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC184_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC184_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC184_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC184_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC184_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC184_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC184_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC185_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC185_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC185_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC185_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC185_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC185_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC185_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC185_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC185_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC185_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC185_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC185_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC185_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC185_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC185_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC185_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC186_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC186_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC186_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC186_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC186_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC186_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC186_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC186_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC186_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC186_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC186_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC186_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC186_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC186_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC186_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC186_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC187_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC187_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC187_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC187_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC187_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC187_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC187_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC187_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC187_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC187_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC187_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC187_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC187_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC187_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC187_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC187_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC188_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC188_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC188_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC188_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC188_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC188_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC188_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC188_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC188_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC188_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC188_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC188_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC188_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC188_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC188_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC188_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC189_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC189_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC189_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC189_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC189_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC189_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC189_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC189_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC189_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC189_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC189_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC189_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC189_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC189_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC189_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC189_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC190_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC190_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC190_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC190_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC190_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC190_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC190_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC190_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC190_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC190_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC190_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC190_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC190_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC190_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC190_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC190_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC191_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC191_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC191_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC191_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC191_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC191_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC191_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC191_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC191_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC191_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC191_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC191_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC191_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC191_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC191_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC191_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC192_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC192_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC192_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC192_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC192_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC192_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC192_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC192_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC192_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC192_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC192_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC192_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC192_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC192_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC192_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC192_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC193_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC193_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC193_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC193_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC193_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC193_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC193_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC193_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC193_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC193_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC193_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC193_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC193_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC193_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC193_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC193_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC194_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC194_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC194_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC194_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC194_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC194_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC194_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC194_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC194_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC194_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC194_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC194_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC194_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC194_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC194_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC194_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC195_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC195_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC195_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC195_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC195_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC195_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC195_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC195_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC195_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC195_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC195_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC195_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC195_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC195_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC195_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC195_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC196_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC196_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC196_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC196_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC196_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC196_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC196_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC196_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC196_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC196_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC196_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC196_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC196_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC196_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC196_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC196_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC197_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC197_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC197_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC197_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC197_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC197_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC197_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC197_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC197_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC197_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC197_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC197_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC197_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC197_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC197_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC197_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC198_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC198_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC198_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC198_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC198_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC198_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC198_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC198_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC198_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC198_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC198_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC198_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC198_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC198_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC198_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC198_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC199_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC199_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC199_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC199_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC199_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC199_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC199_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC199_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC199_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC199_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC199_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC199_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC199_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC199_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC199_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC199_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC200_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC200_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC200_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC200_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC200_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC200_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC200_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC200_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC200_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC200_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC200_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC200_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC200_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC200_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC200_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC200_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC201_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC201_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC201_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC201_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC201_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC201_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC201_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC201_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC201_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC201_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC201_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC201_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC201_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC201_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC201_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC201_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC202_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC202_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC202_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC202_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC202_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC202_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC202_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC202_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC202_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC202_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC202_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC202_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC202_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC202_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC202_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC202_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC203_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC203_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC203_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC203_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC203_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC203_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC203_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC203_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC203_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC203_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC203_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC203_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC203_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC203_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC203_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC203_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC204_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC204_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC204_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC204_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC204_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC204_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC204_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC204_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC204_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC204_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC204_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC204_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC204_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC204_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC204_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC204_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC205_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC205_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC205_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC205_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC205_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC205_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC205_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC205_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC205_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC205_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC205_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC205_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC205_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC205_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC205_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC205_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC206_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC206_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC206_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC206_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC206_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC206_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC206_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC206_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC206_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC206_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC206_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC206_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC206_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC206_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC206_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC206_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC207_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC207_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC207_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC207_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC207_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC207_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC207_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC207_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC207_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC207_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC207_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC207_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC207_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC207_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC207_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC207_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC208_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC208_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC208_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC208_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC208_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC208_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC208_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC208_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC208_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC208_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC208_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC208_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC208_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC208_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC208_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC208_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC209_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC209_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC209_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC209_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC209_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC209_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC209_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC209_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC209_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC209_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC209_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC209_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC209_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC209_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC209_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC209_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC210_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC210_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC210_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC210_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC210_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC210_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC210_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC210_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC210_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC210_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC210_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC210_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC210_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC210_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC210_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC210_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC211_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC211_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC211_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC211_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC211_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC211_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC211_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC211_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC211_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC211_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC211_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC211_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC211_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC211_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC211_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC211_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC212_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC212_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC212_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC212_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC212_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC212_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC212_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC212_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC212_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC212_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC212_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC212_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC212_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC212_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC212_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC212_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC213_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC213_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC213_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC213_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC213_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC213_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC213_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC213_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC213_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC213_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC213_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC213_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC213_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC213_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC213_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC213_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC214_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC214_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC214_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC214_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC214_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC214_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC214_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC214_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC214_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC214_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC214_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC214_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC214_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC214_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC214_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC214_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC215_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC215_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC215_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC215_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC215_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC215_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC215_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC215_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC215_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC215_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC215_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC215_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC215_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC215_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC215_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC215_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC216_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC216_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC216_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC216_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC216_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC216_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC216_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC216_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC216_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC216_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC216_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC216_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC216_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC216_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC216_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC216_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC217_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC217_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC217_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC217_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC217_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC217_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC217_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC217_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC217_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC217_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC217_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC217_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC217_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC217_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC217_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC217_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC218_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC218_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC218_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC218_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC218_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC218_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC218_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC218_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC218_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC218_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC218_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC218_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC218_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC218_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC218_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC218_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC219_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC219_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC219_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC219_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC219_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC219_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC219_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC219_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC219_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC219_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC219_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC219_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC219_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC219_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC219_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC219_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC220_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC220_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC220_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC220_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC220_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC220_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC220_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC220_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC220_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC220_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC220_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC220_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC220_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC220_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC220_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC220_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC221_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC221_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC221_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC221_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC221_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC221_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC221_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC221_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC221_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC221_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC221_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC221_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC221_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC221_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC221_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC221_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC222_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC222_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC222_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC222_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC222_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC222_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC222_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC222_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC222_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC222_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC222_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC222_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC222_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC222_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC222_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC222_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC223_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC223_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC223_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC223_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC223_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC223_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC223_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC223_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC223_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC223_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC223_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC223_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC223_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC223_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC223_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC223_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC224_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC224_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC224_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC224_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC224_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC224_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC224_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC224_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC224_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC224_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC224_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC224_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC224_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC224_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC224_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC224_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC225_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC225_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC225_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC225_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC225_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC225_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC225_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC225_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC225_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC225_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC225_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC225_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC225_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC225_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC225_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC225_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC226_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC226_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC226_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC226_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC226_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC226_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC226_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC226_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC226_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC226_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC226_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC226_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC226_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC226_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC226_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC226_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC227_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC227_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC227_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC227_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC227_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC227_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC227_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC227_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC227_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC227_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC227_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC227_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC227_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC227_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC227_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC227_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC228_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC228_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC228_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC228_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC228_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC228_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC228_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC228_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC228_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC228_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC228_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC228_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC228_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC228_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC228_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC228_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC229_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC229_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC229_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC229_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC229_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC229_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC229_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC229_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC229_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC229_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC229_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC229_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC229_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC229_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC229_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC229_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC230_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC230_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC230_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC230_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC230_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC230_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC230_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC230_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC230_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC230_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC230_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC230_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC230_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC230_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC230_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC230_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC231_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC231_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC231_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC231_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC231_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC231_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC231_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC231_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC231_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC231_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC231_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC231_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC231_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC231_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC231_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC231_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC232_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC232_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC232_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC232_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC232_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC232_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC232_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC232_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC232_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC232_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC232_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC232_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC232_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC232_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC232_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC232_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC233_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC233_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC233_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC233_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC233_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC233_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC233_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC233_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC233_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC233_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC233_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC233_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC233_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC233_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC233_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC233_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC234_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC234_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC234_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC234_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC234_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC234_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC234_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC234_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC234_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC234_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC234_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC234_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC234_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC234_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC234_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC234_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC235_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC235_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC235_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC235_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC235_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC235_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC235_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC235_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC235_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC235_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC235_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC235_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC235_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC235_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC235_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC235_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC236_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC236_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC236_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC236_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC236_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC236_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC236_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC236_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC236_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC236_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC236_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC236_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC236_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC236_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC236_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC236_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC237_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC237_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC237_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC237_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC237_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC237_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC237_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC237_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC237_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC237_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC237_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC237_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC237_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC237_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC237_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC237_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC238_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC238_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC238_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC238_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC238_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC238_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC238_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC238_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC238_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC238_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC238_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC238_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC238_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC238_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC238_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC238_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC239_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC239_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC239_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC239_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC239_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC239_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC239_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC239_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC239_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC239_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC239_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC239_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC239_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC239_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC239_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC239_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC240_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC240_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC240_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC240_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC240_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC240_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC240_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC240_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC240_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC240_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC240_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC240_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC240_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC240_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC240_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC240_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC241_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC241_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC241_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC241_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC241_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC241_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC241_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC241_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC241_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC241_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC241_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC241_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC241_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC241_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC241_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC241_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC242_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC242_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC242_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC242_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC242_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC242_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC242_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC242_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC242_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC242_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC242_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC242_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC242_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC242_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC242_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC242_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC243_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC243_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC243_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC243_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC243_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC243_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC243_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC243_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC243_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC243_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC243_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC243_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC243_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC243_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC243_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC243_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC244_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC244_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC244_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC244_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC244_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC244_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC244_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC244_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC244_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC244_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC244_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC244_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC244_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC244_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC244_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC244_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC245_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC245_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC245_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC245_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC245_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC245_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC245_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC245_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC245_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC245_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC245_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC245_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC245_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC245_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC245_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC245_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC246_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC246_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC246_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC246_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC246_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC246_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC246_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC246_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC246_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC246_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC246_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC246_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC246_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC246_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC246_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC246_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC247_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC247_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC247_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC247_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC247_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC247_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC247_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC247_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC247_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC247_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC247_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC247_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC247_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC247_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC247_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC247_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC248_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC248_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC248_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC248_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC248_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC248_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC248_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC248_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC248_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC248_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC248_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC248_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC248_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC248_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC248_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC248_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC249_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC249_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC249_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC249_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC249_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC249_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC249_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC249_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC249_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC249_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC249_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC249_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC249_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC249_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC249_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC249_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC250_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC250_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC250_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC250_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC250_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC250_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC250_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC250_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC250_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC250_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC250_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC250_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC250_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC250_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC250_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC250_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC251_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC251_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC251_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC251_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC251_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC251_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC251_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC251_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC251_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC251_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC251_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC251_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC251_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC251_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC251_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC251_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC252_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC252_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC252_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC252_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC252_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC252_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC252_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC252_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC252_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC252_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC252_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC252_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC252_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC252_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC252_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC252_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC253_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC253_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC253_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC253_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC253_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC253_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC253_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC253_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC253_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC253_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC253_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC253_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC253_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC253_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC253_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC253_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC254_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC254_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC254_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC254_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC254_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC254_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC254_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC254_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC254_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC254_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC254_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC254_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC254_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC254_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC254_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC254_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC255_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC255_IN_SEL_CFG_FUNC0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC255_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC255_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC255_IN_SEL_CFG_FUNC0_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC255_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC255_IN_SEL_CFG_FUNC0_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC255_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC255_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC255_IN_SEL_CFG_FUNC0_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC255_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC255_IN_SEL_CFG_SIG0_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC255_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC255_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC255_IN_SEL_CFG_SIG0_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC255_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC0_OUT_SEL_CFG: Peripheral output selection for GPIO %s
func (o *GPIO_Type) SetFUNC0_OUT_SEL_CFG_FUNC0_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC0_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC0_OUT_SEL_CFG.Reg)&^(0x1ff)|value)
}
func (o *GPIO_Type) GetFUNC0_OUT_SEL_CFG_FUNC0_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC0_OUT_SEL_CFG.Reg) & 0x1ff
}
func (o *GPIO_Type) SetFUNC0_OUT_SEL_CFG_FUNC0_OUT_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC0_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC0_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC0_OUT_SEL_CFG_FUNC0_OUT_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC0_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC0_OUT_SEL_CFG_FUNC0_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC0_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC0_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC0_OUT_SEL_CFG_FUNC0_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC0_OUT_SEL_CFG.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetFUNC0_OUT_SEL_CFG_FUNC0_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC0_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC0_OUT_SEL_CFG.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetFUNC0_OUT_SEL_CFG_FUNC0_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC0_OUT_SEL_CFG.Reg) & 0x800) >> 11
}

// GPIO.FUNC1_OUT_SEL_CFG: Peripheral output selection for GPIO %s
func (o *GPIO_Type) SetFUNC1_OUT_SEL_CFG_FUNC0_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC1_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC1_OUT_SEL_CFG.Reg)&^(0x1ff)|value)
}
func (o *GPIO_Type) GetFUNC1_OUT_SEL_CFG_FUNC0_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC1_OUT_SEL_CFG.Reg) & 0x1ff
}
func (o *GPIO_Type) SetFUNC1_OUT_SEL_CFG_FUNC0_OUT_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC1_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC1_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC1_OUT_SEL_CFG_FUNC0_OUT_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC1_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC1_OUT_SEL_CFG_FUNC0_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC1_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC1_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC1_OUT_SEL_CFG_FUNC0_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC1_OUT_SEL_CFG.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetFUNC1_OUT_SEL_CFG_FUNC0_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC1_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC1_OUT_SEL_CFG.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetFUNC1_OUT_SEL_CFG_FUNC0_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC1_OUT_SEL_CFG.Reg) & 0x800) >> 11
}

// GPIO.FUNC2_OUT_SEL_CFG: Peripheral output selection for GPIO %s
func (o *GPIO_Type) SetFUNC2_OUT_SEL_CFG_FUNC0_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC2_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC2_OUT_SEL_CFG.Reg)&^(0x1ff)|value)
}
func (o *GPIO_Type) GetFUNC2_OUT_SEL_CFG_FUNC0_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC2_OUT_SEL_CFG.Reg) & 0x1ff
}
func (o *GPIO_Type) SetFUNC2_OUT_SEL_CFG_FUNC0_OUT_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC2_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC2_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC2_OUT_SEL_CFG_FUNC0_OUT_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC2_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC2_OUT_SEL_CFG_FUNC0_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC2_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC2_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC2_OUT_SEL_CFG_FUNC0_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC2_OUT_SEL_CFG.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetFUNC2_OUT_SEL_CFG_FUNC0_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC2_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC2_OUT_SEL_CFG.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetFUNC2_OUT_SEL_CFG_FUNC0_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC2_OUT_SEL_CFG.Reg) & 0x800) >> 11
}

// GPIO.FUNC3_OUT_SEL_CFG: Peripheral output selection for GPIO %s
func (o *GPIO_Type) SetFUNC3_OUT_SEL_CFG_FUNC0_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC3_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC3_OUT_SEL_CFG.Reg)&^(0x1ff)|value)
}
func (o *GPIO_Type) GetFUNC3_OUT_SEL_CFG_FUNC0_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC3_OUT_SEL_CFG.Reg) & 0x1ff
}
func (o *GPIO_Type) SetFUNC3_OUT_SEL_CFG_FUNC0_OUT_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC3_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC3_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC3_OUT_SEL_CFG_FUNC0_OUT_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC3_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC3_OUT_SEL_CFG_FUNC0_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC3_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC3_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC3_OUT_SEL_CFG_FUNC0_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC3_OUT_SEL_CFG.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetFUNC3_OUT_SEL_CFG_FUNC0_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC3_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC3_OUT_SEL_CFG.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetFUNC3_OUT_SEL_CFG_FUNC0_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC3_OUT_SEL_CFG.Reg) & 0x800) >> 11
}

// GPIO.FUNC4_OUT_SEL_CFG: Peripheral output selection for GPIO %s
func (o *GPIO_Type) SetFUNC4_OUT_SEL_CFG_FUNC0_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC4_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC4_OUT_SEL_CFG.Reg)&^(0x1ff)|value)
}
func (o *GPIO_Type) GetFUNC4_OUT_SEL_CFG_FUNC0_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC4_OUT_SEL_CFG.Reg) & 0x1ff
}
func (o *GPIO_Type) SetFUNC4_OUT_SEL_CFG_FUNC0_OUT_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC4_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC4_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC4_OUT_SEL_CFG_FUNC0_OUT_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC4_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC4_OUT_SEL_CFG_FUNC0_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC4_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC4_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC4_OUT_SEL_CFG_FUNC0_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC4_OUT_SEL_CFG.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetFUNC4_OUT_SEL_CFG_FUNC0_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC4_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC4_OUT_SEL_CFG.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetFUNC4_OUT_SEL_CFG_FUNC0_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC4_OUT_SEL_CFG.Reg) & 0x800) >> 11
}

// GPIO.FUNC5_OUT_SEL_CFG: Peripheral output selection for GPIO %s
func (o *GPIO_Type) SetFUNC5_OUT_SEL_CFG_FUNC0_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC5_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC5_OUT_SEL_CFG.Reg)&^(0x1ff)|value)
}
func (o *GPIO_Type) GetFUNC5_OUT_SEL_CFG_FUNC0_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC5_OUT_SEL_CFG.Reg) & 0x1ff
}
func (o *GPIO_Type) SetFUNC5_OUT_SEL_CFG_FUNC0_OUT_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC5_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC5_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC5_OUT_SEL_CFG_FUNC0_OUT_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC5_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC5_OUT_SEL_CFG_FUNC0_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC5_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC5_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC5_OUT_SEL_CFG_FUNC0_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC5_OUT_SEL_CFG.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetFUNC5_OUT_SEL_CFG_FUNC0_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC5_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC5_OUT_SEL_CFG.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetFUNC5_OUT_SEL_CFG_FUNC0_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC5_OUT_SEL_CFG.Reg) & 0x800) >> 11
}

// GPIO.FUNC6_OUT_SEL_CFG: Peripheral output selection for GPIO %s
func (o *GPIO_Type) SetFUNC6_OUT_SEL_CFG_FUNC0_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC6_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC6_OUT_SEL_CFG.Reg)&^(0x1ff)|value)
}
func (o *GPIO_Type) GetFUNC6_OUT_SEL_CFG_FUNC0_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC6_OUT_SEL_CFG.Reg) & 0x1ff
}
func (o *GPIO_Type) SetFUNC6_OUT_SEL_CFG_FUNC0_OUT_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC6_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC6_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC6_OUT_SEL_CFG_FUNC0_OUT_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC6_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC6_OUT_SEL_CFG_FUNC0_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC6_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC6_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC6_OUT_SEL_CFG_FUNC0_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC6_OUT_SEL_CFG.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetFUNC6_OUT_SEL_CFG_FUNC0_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC6_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC6_OUT_SEL_CFG.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetFUNC6_OUT_SEL_CFG_FUNC0_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC6_OUT_SEL_CFG.Reg) & 0x800) >> 11
}

// GPIO.FUNC7_OUT_SEL_CFG: Peripheral output selection for GPIO %s
func (o *GPIO_Type) SetFUNC7_OUT_SEL_CFG_FUNC0_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC7_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC7_OUT_SEL_CFG.Reg)&^(0x1ff)|value)
}
func (o *GPIO_Type) GetFUNC7_OUT_SEL_CFG_FUNC0_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC7_OUT_SEL_CFG.Reg) & 0x1ff
}
func (o *GPIO_Type) SetFUNC7_OUT_SEL_CFG_FUNC0_OUT_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC7_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC7_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC7_OUT_SEL_CFG_FUNC0_OUT_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC7_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC7_OUT_SEL_CFG_FUNC0_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC7_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC7_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC7_OUT_SEL_CFG_FUNC0_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC7_OUT_SEL_CFG.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetFUNC7_OUT_SEL_CFG_FUNC0_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC7_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC7_OUT_SEL_CFG.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetFUNC7_OUT_SEL_CFG_FUNC0_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC7_OUT_SEL_CFG.Reg) & 0x800) >> 11
}

// GPIO.FUNC8_OUT_SEL_CFG: Peripheral output selection for GPIO %s
func (o *GPIO_Type) SetFUNC8_OUT_SEL_CFG_FUNC0_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC8_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC8_OUT_SEL_CFG.Reg)&^(0x1ff)|value)
}
func (o *GPIO_Type) GetFUNC8_OUT_SEL_CFG_FUNC0_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC8_OUT_SEL_CFG.Reg) & 0x1ff
}
func (o *GPIO_Type) SetFUNC8_OUT_SEL_CFG_FUNC0_OUT_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC8_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC8_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC8_OUT_SEL_CFG_FUNC0_OUT_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC8_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC8_OUT_SEL_CFG_FUNC0_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC8_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC8_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC8_OUT_SEL_CFG_FUNC0_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC8_OUT_SEL_CFG.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetFUNC8_OUT_SEL_CFG_FUNC0_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC8_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC8_OUT_SEL_CFG.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetFUNC8_OUT_SEL_CFG_FUNC0_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC8_OUT_SEL_CFG.Reg) & 0x800) >> 11
}

// GPIO.FUNC9_OUT_SEL_CFG: Peripheral output selection for GPIO %s
func (o *GPIO_Type) SetFUNC9_OUT_SEL_CFG_FUNC0_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC9_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC9_OUT_SEL_CFG.Reg)&^(0x1ff)|value)
}
func (o *GPIO_Type) GetFUNC9_OUT_SEL_CFG_FUNC0_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC9_OUT_SEL_CFG.Reg) & 0x1ff
}
func (o *GPIO_Type) SetFUNC9_OUT_SEL_CFG_FUNC0_OUT_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC9_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC9_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC9_OUT_SEL_CFG_FUNC0_OUT_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC9_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC9_OUT_SEL_CFG_FUNC0_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC9_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC9_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC9_OUT_SEL_CFG_FUNC0_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC9_OUT_SEL_CFG.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetFUNC9_OUT_SEL_CFG_FUNC0_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC9_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC9_OUT_SEL_CFG.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetFUNC9_OUT_SEL_CFG_FUNC0_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC9_OUT_SEL_CFG.Reg) & 0x800) >> 11
}

// GPIO.FUNC10_OUT_SEL_CFG: Peripheral output selection for GPIO %s
func (o *GPIO_Type) SetFUNC10_OUT_SEL_CFG_FUNC0_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC10_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC10_OUT_SEL_CFG.Reg)&^(0x1ff)|value)
}
func (o *GPIO_Type) GetFUNC10_OUT_SEL_CFG_FUNC0_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC10_OUT_SEL_CFG.Reg) & 0x1ff
}
func (o *GPIO_Type) SetFUNC10_OUT_SEL_CFG_FUNC0_OUT_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC10_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC10_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC10_OUT_SEL_CFG_FUNC0_OUT_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC10_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC10_OUT_SEL_CFG_FUNC0_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC10_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC10_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC10_OUT_SEL_CFG_FUNC0_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC10_OUT_SEL_CFG.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetFUNC10_OUT_SEL_CFG_FUNC0_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC10_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC10_OUT_SEL_CFG.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetFUNC10_OUT_SEL_CFG_FUNC0_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC10_OUT_SEL_CFG.Reg) & 0x800) >> 11
}

// GPIO.FUNC11_OUT_SEL_CFG: Peripheral output selection for GPIO %s
func (o *GPIO_Type) SetFUNC11_OUT_SEL_CFG_FUNC0_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC11_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC11_OUT_SEL_CFG.Reg)&^(0x1ff)|value)
}
func (o *GPIO_Type) GetFUNC11_OUT_SEL_CFG_FUNC0_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC11_OUT_SEL_CFG.Reg) & 0x1ff
}
func (o *GPIO_Type) SetFUNC11_OUT_SEL_CFG_FUNC0_OUT_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC11_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC11_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC11_OUT_SEL_CFG_FUNC0_OUT_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC11_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC11_OUT_SEL_CFG_FUNC0_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC11_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC11_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC11_OUT_SEL_CFG_FUNC0_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC11_OUT_SEL_CFG.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetFUNC11_OUT_SEL_CFG_FUNC0_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC11_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC11_OUT_SEL_CFG.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetFUNC11_OUT_SEL_CFG_FUNC0_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC11_OUT_SEL_CFG.Reg) & 0x800) >> 11
}

// GPIO.FUNC12_OUT_SEL_CFG: Peripheral output selection for GPIO %s
func (o *GPIO_Type) SetFUNC12_OUT_SEL_CFG_FUNC0_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC12_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC12_OUT_SEL_CFG.Reg)&^(0x1ff)|value)
}
func (o *GPIO_Type) GetFUNC12_OUT_SEL_CFG_FUNC0_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC12_OUT_SEL_CFG.Reg) & 0x1ff
}
func (o *GPIO_Type) SetFUNC12_OUT_SEL_CFG_FUNC0_OUT_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC12_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC12_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC12_OUT_SEL_CFG_FUNC0_OUT_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC12_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC12_OUT_SEL_CFG_FUNC0_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC12_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC12_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC12_OUT_SEL_CFG_FUNC0_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC12_OUT_SEL_CFG.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetFUNC12_OUT_SEL_CFG_FUNC0_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC12_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC12_OUT_SEL_CFG.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetFUNC12_OUT_SEL_CFG_FUNC0_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC12_OUT_SEL_CFG.Reg) & 0x800) >> 11
}

// GPIO.FUNC13_OUT_SEL_CFG: Peripheral output selection for GPIO %s
func (o *GPIO_Type) SetFUNC13_OUT_SEL_CFG_FUNC0_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC13_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC13_OUT_SEL_CFG.Reg)&^(0x1ff)|value)
}
func (o *GPIO_Type) GetFUNC13_OUT_SEL_CFG_FUNC0_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC13_OUT_SEL_CFG.Reg) & 0x1ff
}
func (o *GPIO_Type) SetFUNC13_OUT_SEL_CFG_FUNC0_OUT_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC13_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC13_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC13_OUT_SEL_CFG_FUNC0_OUT_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC13_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC13_OUT_SEL_CFG_FUNC0_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC13_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC13_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC13_OUT_SEL_CFG_FUNC0_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC13_OUT_SEL_CFG.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetFUNC13_OUT_SEL_CFG_FUNC0_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC13_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC13_OUT_SEL_CFG.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetFUNC13_OUT_SEL_CFG_FUNC0_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC13_OUT_SEL_CFG.Reg) & 0x800) >> 11
}

// GPIO.FUNC14_OUT_SEL_CFG: Peripheral output selection for GPIO %s
func (o *GPIO_Type) SetFUNC14_OUT_SEL_CFG_FUNC0_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC14_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC14_OUT_SEL_CFG.Reg)&^(0x1ff)|value)
}
func (o *GPIO_Type) GetFUNC14_OUT_SEL_CFG_FUNC0_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC14_OUT_SEL_CFG.Reg) & 0x1ff
}
func (o *GPIO_Type) SetFUNC14_OUT_SEL_CFG_FUNC0_OUT_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC14_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC14_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC14_OUT_SEL_CFG_FUNC0_OUT_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC14_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC14_OUT_SEL_CFG_FUNC0_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC14_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC14_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC14_OUT_SEL_CFG_FUNC0_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC14_OUT_SEL_CFG.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetFUNC14_OUT_SEL_CFG_FUNC0_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC14_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC14_OUT_SEL_CFG.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetFUNC14_OUT_SEL_CFG_FUNC0_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC14_OUT_SEL_CFG.Reg) & 0x800) >> 11
}

// GPIO.FUNC15_OUT_SEL_CFG: Peripheral output selection for GPIO %s
func (o *GPIO_Type) SetFUNC15_OUT_SEL_CFG_FUNC0_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC15_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC15_OUT_SEL_CFG.Reg)&^(0x1ff)|value)
}
func (o *GPIO_Type) GetFUNC15_OUT_SEL_CFG_FUNC0_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC15_OUT_SEL_CFG.Reg) & 0x1ff
}
func (o *GPIO_Type) SetFUNC15_OUT_SEL_CFG_FUNC0_OUT_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC15_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC15_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC15_OUT_SEL_CFG_FUNC0_OUT_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC15_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC15_OUT_SEL_CFG_FUNC0_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC15_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC15_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC15_OUT_SEL_CFG_FUNC0_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC15_OUT_SEL_CFG.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetFUNC15_OUT_SEL_CFG_FUNC0_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC15_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC15_OUT_SEL_CFG.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetFUNC15_OUT_SEL_CFG_FUNC0_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC15_OUT_SEL_CFG.Reg) & 0x800) >> 11
}

// GPIO.FUNC16_OUT_SEL_CFG: Peripheral output selection for GPIO %s
func (o *GPIO_Type) SetFUNC16_OUT_SEL_CFG_FUNC0_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC16_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC16_OUT_SEL_CFG.Reg)&^(0x1ff)|value)
}
func (o *GPIO_Type) GetFUNC16_OUT_SEL_CFG_FUNC0_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC16_OUT_SEL_CFG.Reg) & 0x1ff
}
func (o *GPIO_Type) SetFUNC16_OUT_SEL_CFG_FUNC0_OUT_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC16_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC16_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC16_OUT_SEL_CFG_FUNC0_OUT_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC16_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC16_OUT_SEL_CFG_FUNC0_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC16_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC16_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC16_OUT_SEL_CFG_FUNC0_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC16_OUT_SEL_CFG.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetFUNC16_OUT_SEL_CFG_FUNC0_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC16_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC16_OUT_SEL_CFG.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetFUNC16_OUT_SEL_CFG_FUNC0_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC16_OUT_SEL_CFG.Reg) & 0x800) >> 11
}

// GPIO.FUNC17_OUT_SEL_CFG: Peripheral output selection for GPIO %s
func (o *GPIO_Type) SetFUNC17_OUT_SEL_CFG_FUNC0_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC17_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC17_OUT_SEL_CFG.Reg)&^(0x1ff)|value)
}
func (o *GPIO_Type) GetFUNC17_OUT_SEL_CFG_FUNC0_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC17_OUT_SEL_CFG.Reg) & 0x1ff
}
func (o *GPIO_Type) SetFUNC17_OUT_SEL_CFG_FUNC0_OUT_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC17_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC17_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC17_OUT_SEL_CFG_FUNC0_OUT_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC17_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC17_OUT_SEL_CFG_FUNC0_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC17_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC17_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC17_OUT_SEL_CFG_FUNC0_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC17_OUT_SEL_CFG.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetFUNC17_OUT_SEL_CFG_FUNC0_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC17_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC17_OUT_SEL_CFG.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetFUNC17_OUT_SEL_CFG_FUNC0_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC17_OUT_SEL_CFG.Reg) & 0x800) >> 11
}

// GPIO.FUNC18_OUT_SEL_CFG: Peripheral output selection for GPIO %s
func (o *GPIO_Type) SetFUNC18_OUT_SEL_CFG_FUNC0_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC18_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC18_OUT_SEL_CFG.Reg)&^(0x1ff)|value)
}
func (o *GPIO_Type) GetFUNC18_OUT_SEL_CFG_FUNC0_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC18_OUT_SEL_CFG.Reg) & 0x1ff
}
func (o *GPIO_Type) SetFUNC18_OUT_SEL_CFG_FUNC0_OUT_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC18_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC18_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC18_OUT_SEL_CFG_FUNC0_OUT_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC18_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC18_OUT_SEL_CFG_FUNC0_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC18_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC18_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC18_OUT_SEL_CFG_FUNC0_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC18_OUT_SEL_CFG.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetFUNC18_OUT_SEL_CFG_FUNC0_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC18_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC18_OUT_SEL_CFG.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetFUNC18_OUT_SEL_CFG_FUNC0_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC18_OUT_SEL_CFG.Reg) & 0x800) >> 11
}

// GPIO.FUNC19_OUT_SEL_CFG: Peripheral output selection for GPIO %s
func (o *GPIO_Type) SetFUNC19_OUT_SEL_CFG_FUNC0_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC19_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC19_OUT_SEL_CFG.Reg)&^(0x1ff)|value)
}
func (o *GPIO_Type) GetFUNC19_OUT_SEL_CFG_FUNC0_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC19_OUT_SEL_CFG.Reg) & 0x1ff
}
func (o *GPIO_Type) SetFUNC19_OUT_SEL_CFG_FUNC0_OUT_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC19_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC19_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC19_OUT_SEL_CFG_FUNC0_OUT_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC19_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC19_OUT_SEL_CFG_FUNC0_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC19_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC19_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC19_OUT_SEL_CFG_FUNC0_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC19_OUT_SEL_CFG.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetFUNC19_OUT_SEL_CFG_FUNC0_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC19_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC19_OUT_SEL_CFG.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetFUNC19_OUT_SEL_CFG_FUNC0_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC19_OUT_SEL_CFG.Reg) & 0x800) >> 11
}

// GPIO.FUNC20_OUT_SEL_CFG: Peripheral output selection for GPIO %s
func (o *GPIO_Type) SetFUNC20_OUT_SEL_CFG_FUNC0_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC20_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC20_OUT_SEL_CFG.Reg)&^(0x1ff)|value)
}
func (o *GPIO_Type) GetFUNC20_OUT_SEL_CFG_FUNC0_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC20_OUT_SEL_CFG.Reg) & 0x1ff
}
func (o *GPIO_Type) SetFUNC20_OUT_SEL_CFG_FUNC0_OUT_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC20_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC20_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC20_OUT_SEL_CFG_FUNC0_OUT_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC20_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC20_OUT_SEL_CFG_FUNC0_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC20_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC20_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC20_OUT_SEL_CFG_FUNC0_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC20_OUT_SEL_CFG.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetFUNC20_OUT_SEL_CFG_FUNC0_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC20_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC20_OUT_SEL_CFG.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetFUNC20_OUT_SEL_CFG_FUNC0_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC20_OUT_SEL_CFG.Reg) & 0x800) >> 11
}

// GPIO.FUNC21_OUT_SEL_CFG: Peripheral output selection for GPIO %s
func (o *GPIO_Type) SetFUNC21_OUT_SEL_CFG_FUNC0_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC21_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC21_OUT_SEL_CFG.Reg)&^(0x1ff)|value)
}
func (o *GPIO_Type) GetFUNC21_OUT_SEL_CFG_FUNC0_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC21_OUT_SEL_CFG.Reg) & 0x1ff
}
func (o *GPIO_Type) SetFUNC21_OUT_SEL_CFG_FUNC0_OUT_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC21_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC21_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC21_OUT_SEL_CFG_FUNC0_OUT_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC21_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC21_OUT_SEL_CFG_FUNC0_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC21_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC21_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC21_OUT_SEL_CFG_FUNC0_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC21_OUT_SEL_CFG.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetFUNC21_OUT_SEL_CFG_FUNC0_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC21_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC21_OUT_SEL_CFG.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetFUNC21_OUT_SEL_CFG_FUNC0_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC21_OUT_SEL_CFG.Reg) & 0x800) >> 11
}

// GPIO.FUNC22_OUT_SEL_CFG: Peripheral output selection for GPIO %s
func (o *GPIO_Type) SetFUNC22_OUT_SEL_CFG_FUNC0_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC22_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC22_OUT_SEL_CFG.Reg)&^(0x1ff)|value)
}
func (o *GPIO_Type) GetFUNC22_OUT_SEL_CFG_FUNC0_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC22_OUT_SEL_CFG.Reg) & 0x1ff
}
func (o *GPIO_Type) SetFUNC22_OUT_SEL_CFG_FUNC0_OUT_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC22_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC22_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC22_OUT_SEL_CFG_FUNC0_OUT_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC22_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC22_OUT_SEL_CFG_FUNC0_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC22_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC22_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC22_OUT_SEL_CFG_FUNC0_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC22_OUT_SEL_CFG.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetFUNC22_OUT_SEL_CFG_FUNC0_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC22_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC22_OUT_SEL_CFG.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetFUNC22_OUT_SEL_CFG_FUNC0_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC22_OUT_SEL_CFG.Reg) & 0x800) >> 11
}

// GPIO.FUNC23_OUT_SEL_CFG: Peripheral output selection for GPIO %s
func (o *GPIO_Type) SetFUNC23_OUT_SEL_CFG_FUNC0_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC23_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC23_OUT_SEL_CFG.Reg)&^(0x1ff)|value)
}
func (o *GPIO_Type) GetFUNC23_OUT_SEL_CFG_FUNC0_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC23_OUT_SEL_CFG.Reg) & 0x1ff
}
func (o *GPIO_Type) SetFUNC23_OUT_SEL_CFG_FUNC0_OUT_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC23_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC23_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC23_OUT_SEL_CFG_FUNC0_OUT_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC23_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC23_OUT_SEL_CFG_FUNC0_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC23_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC23_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC23_OUT_SEL_CFG_FUNC0_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC23_OUT_SEL_CFG.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetFUNC23_OUT_SEL_CFG_FUNC0_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC23_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC23_OUT_SEL_CFG.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetFUNC23_OUT_SEL_CFG_FUNC0_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC23_OUT_SEL_CFG.Reg) & 0x800) >> 11
}

// GPIO.FUNC24_OUT_SEL_CFG: Peripheral output selection for GPIO %s
func (o *GPIO_Type) SetFUNC24_OUT_SEL_CFG_FUNC0_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC24_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC24_OUT_SEL_CFG.Reg)&^(0x1ff)|value)
}
func (o *GPIO_Type) GetFUNC24_OUT_SEL_CFG_FUNC0_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC24_OUT_SEL_CFG.Reg) & 0x1ff
}
func (o *GPIO_Type) SetFUNC24_OUT_SEL_CFG_FUNC0_OUT_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC24_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC24_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC24_OUT_SEL_CFG_FUNC0_OUT_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC24_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC24_OUT_SEL_CFG_FUNC0_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC24_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC24_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC24_OUT_SEL_CFG_FUNC0_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC24_OUT_SEL_CFG.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetFUNC24_OUT_SEL_CFG_FUNC0_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC24_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC24_OUT_SEL_CFG.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetFUNC24_OUT_SEL_CFG_FUNC0_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC24_OUT_SEL_CFG.Reg) & 0x800) >> 11
}

// GPIO.FUNC25_OUT_SEL_CFG: Peripheral output selection for GPIO %s
func (o *GPIO_Type) SetFUNC25_OUT_SEL_CFG_FUNC0_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC25_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC25_OUT_SEL_CFG.Reg)&^(0x1ff)|value)
}
func (o *GPIO_Type) GetFUNC25_OUT_SEL_CFG_FUNC0_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC25_OUT_SEL_CFG.Reg) & 0x1ff
}
func (o *GPIO_Type) SetFUNC25_OUT_SEL_CFG_FUNC0_OUT_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC25_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC25_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC25_OUT_SEL_CFG_FUNC0_OUT_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC25_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC25_OUT_SEL_CFG_FUNC0_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC25_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC25_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC25_OUT_SEL_CFG_FUNC0_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC25_OUT_SEL_CFG.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetFUNC25_OUT_SEL_CFG_FUNC0_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC25_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC25_OUT_SEL_CFG.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetFUNC25_OUT_SEL_CFG_FUNC0_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC25_OUT_SEL_CFG.Reg) & 0x800) >> 11
}

// GPIO.FUNC26_OUT_SEL_CFG: Peripheral output selection for GPIO %s
func (o *GPIO_Type) SetFUNC26_OUT_SEL_CFG_FUNC0_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC26_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC26_OUT_SEL_CFG.Reg)&^(0x1ff)|value)
}
func (o *GPIO_Type) GetFUNC26_OUT_SEL_CFG_FUNC0_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC26_OUT_SEL_CFG.Reg) & 0x1ff
}
func (o *GPIO_Type) SetFUNC26_OUT_SEL_CFG_FUNC0_OUT_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC26_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC26_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC26_OUT_SEL_CFG_FUNC0_OUT_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC26_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC26_OUT_SEL_CFG_FUNC0_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC26_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC26_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC26_OUT_SEL_CFG_FUNC0_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC26_OUT_SEL_CFG.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetFUNC26_OUT_SEL_CFG_FUNC0_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC26_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC26_OUT_SEL_CFG.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetFUNC26_OUT_SEL_CFG_FUNC0_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC26_OUT_SEL_CFG.Reg) & 0x800) >> 11
}

// GPIO.FUNC27_OUT_SEL_CFG: Peripheral output selection for GPIO %s
func (o *GPIO_Type) SetFUNC27_OUT_SEL_CFG_FUNC0_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC27_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC27_OUT_SEL_CFG.Reg)&^(0x1ff)|value)
}
func (o *GPIO_Type) GetFUNC27_OUT_SEL_CFG_FUNC0_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC27_OUT_SEL_CFG.Reg) & 0x1ff
}
func (o *GPIO_Type) SetFUNC27_OUT_SEL_CFG_FUNC0_OUT_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC27_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC27_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC27_OUT_SEL_CFG_FUNC0_OUT_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC27_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC27_OUT_SEL_CFG_FUNC0_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC27_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC27_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC27_OUT_SEL_CFG_FUNC0_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC27_OUT_SEL_CFG.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetFUNC27_OUT_SEL_CFG_FUNC0_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC27_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC27_OUT_SEL_CFG.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetFUNC27_OUT_SEL_CFG_FUNC0_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC27_OUT_SEL_CFG.Reg) & 0x800) >> 11
}

// GPIO.FUNC28_OUT_SEL_CFG: Peripheral output selection for GPIO %s
func (o *GPIO_Type) SetFUNC28_OUT_SEL_CFG_FUNC0_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC28_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC28_OUT_SEL_CFG.Reg)&^(0x1ff)|value)
}
func (o *GPIO_Type) GetFUNC28_OUT_SEL_CFG_FUNC0_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC28_OUT_SEL_CFG.Reg) & 0x1ff
}
func (o *GPIO_Type) SetFUNC28_OUT_SEL_CFG_FUNC0_OUT_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC28_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC28_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC28_OUT_SEL_CFG_FUNC0_OUT_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC28_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC28_OUT_SEL_CFG_FUNC0_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC28_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC28_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC28_OUT_SEL_CFG_FUNC0_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC28_OUT_SEL_CFG.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetFUNC28_OUT_SEL_CFG_FUNC0_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC28_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC28_OUT_SEL_CFG.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetFUNC28_OUT_SEL_CFG_FUNC0_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC28_OUT_SEL_CFG.Reg) & 0x800) >> 11
}

// GPIO.FUNC29_OUT_SEL_CFG: Peripheral output selection for GPIO %s
func (o *GPIO_Type) SetFUNC29_OUT_SEL_CFG_FUNC0_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC29_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC29_OUT_SEL_CFG.Reg)&^(0x1ff)|value)
}
func (o *GPIO_Type) GetFUNC29_OUT_SEL_CFG_FUNC0_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC29_OUT_SEL_CFG.Reg) & 0x1ff
}
func (o *GPIO_Type) SetFUNC29_OUT_SEL_CFG_FUNC0_OUT_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC29_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC29_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC29_OUT_SEL_CFG_FUNC0_OUT_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC29_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC29_OUT_SEL_CFG_FUNC0_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC29_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC29_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC29_OUT_SEL_CFG_FUNC0_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC29_OUT_SEL_CFG.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetFUNC29_OUT_SEL_CFG_FUNC0_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC29_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC29_OUT_SEL_CFG.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetFUNC29_OUT_SEL_CFG_FUNC0_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC29_OUT_SEL_CFG.Reg) & 0x800) >> 11
}

// GPIO.FUNC30_OUT_SEL_CFG: Peripheral output selection for GPIO %s
func (o *GPIO_Type) SetFUNC30_OUT_SEL_CFG_FUNC0_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC30_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC30_OUT_SEL_CFG.Reg)&^(0x1ff)|value)
}
func (o *GPIO_Type) GetFUNC30_OUT_SEL_CFG_FUNC0_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC30_OUT_SEL_CFG.Reg) & 0x1ff
}
func (o *GPIO_Type) SetFUNC30_OUT_SEL_CFG_FUNC0_OUT_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC30_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC30_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC30_OUT_SEL_CFG_FUNC0_OUT_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC30_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC30_OUT_SEL_CFG_FUNC0_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC30_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC30_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC30_OUT_SEL_CFG_FUNC0_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC30_OUT_SEL_CFG.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetFUNC30_OUT_SEL_CFG_FUNC0_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC30_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC30_OUT_SEL_CFG.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetFUNC30_OUT_SEL_CFG_FUNC0_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC30_OUT_SEL_CFG.Reg) & 0x800) >> 11
}

// GPIO.FUNC31_OUT_SEL_CFG: Peripheral output selection for GPIO %s
func (o *GPIO_Type) SetFUNC31_OUT_SEL_CFG_FUNC0_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC31_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC31_OUT_SEL_CFG.Reg)&^(0x1ff)|value)
}
func (o *GPIO_Type) GetFUNC31_OUT_SEL_CFG_FUNC0_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC31_OUT_SEL_CFG.Reg) & 0x1ff
}
func (o *GPIO_Type) SetFUNC31_OUT_SEL_CFG_FUNC0_OUT_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC31_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC31_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC31_OUT_SEL_CFG_FUNC0_OUT_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC31_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC31_OUT_SEL_CFG_FUNC0_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC31_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC31_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC31_OUT_SEL_CFG_FUNC0_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC31_OUT_SEL_CFG.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetFUNC31_OUT_SEL_CFG_FUNC0_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC31_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC31_OUT_SEL_CFG.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetFUNC31_OUT_SEL_CFG_FUNC0_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC31_OUT_SEL_CFG.Reg) & 0x800) >> 11
}

// GPIO.FUNC32_OUT_SEL_CFG: Peripheral output selection for GPIO %s
func (o *GPIO_Type) SetFUNC32_OUT_SEL_CFG_FUNC0_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC32_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC32_OUT_SEL_CFG.Reg)&^(0x1ff)|value)
}
func (o *GPIO_Type) GetFUNC32_OUT_SEL_CFG_FUNC0_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC32_OUT_SEL_CFG.Reg) & 0x1ff
}
func (o *GPIO_Type) SetFUNC32_OUT_SEL_CFG_FUNC0_OUT_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC32_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC32_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC32_OUT_SEL_CFG_FUNC0_OUT_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC32_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC32_OUT_SEL_CFG_FUNC0_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC32_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC32_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC32_OUT_SEL_CFG_FUNC0_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC32_OUT_SEL_CFG.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetFUNC32_OUT_SEL_CFG_FUNC0_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC32_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC32_OUT_SEL_CFG.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetFUNC32_OUT_SEL_CFG_FUNC0_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC32_OUT_SEL_CFG.Reg) & 0x800) >> 11
}

// GPIO.FUNC33_OUT_SEL_CFG: Peripheral output selection for GPIO %s
func (o *GPIO_Type) SetFUNC33_OUT_SEL_CFG_FUNC0_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC33_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC33_OUT_SEL_CFG.Reg)&^(0x1ff)|value)
}
func (o *GPIO_Type) GetFUNC33_OUT_SEL_CFG_FUNC0_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC33_OUT_SEL_CFG.Reg) & 0x1ff
}
func (o *GPIO_Type) SetFUNC33_OUT_SEL_CFG_FUNC0_OUT_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC33_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC33_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC33_OUT_SEL_CFG_FUNC0_OUT_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC33_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC33_OUT_SEL_CFG_FUNC0_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC33_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC33_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC33_OUT_SEL_CFG_FUNC0_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC33_OUT_SEL_CFG.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetFUNC33_OUT_SEL_CFG_FUNC0_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC33_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC33_OUT_SEL_CFG.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetFUNC33_OUT_SEL_CFG_FUNC0_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC33_OUT_SEL_CFG.Reg) & 0x800) >> 11
}

// GPIO.FUNC34_OUT_SEL_CFG: Peripheral output selection for GPIO %s
func (o *GPIO_Type) SetFUNC34_OUT_SEL_CFG_FUNC0_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC34_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC34_OUT_SEL_CFG.Reg)&^(0x1ff)|value)
}
func (o *GPIO_Type) GetFUNC34_OUT_SEL_CFG_FUNC0_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC34_OUT_SEL_CFG.Reg) & 0x1ff
}
func (o *GPIO_Type) SetFUNC34_OUT_SEL_CFG_FUNC0_OUT_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC34_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC34_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC34_OUT_SEL_CFG_FUNC0_OUT_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC34_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC34_OUT_SEL_CFG_FUNC0_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC34_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC34_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC34_OUT_SEL_CFG_FUNC0_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC34_OUT_SEL_CFG.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetFUNC34_OUT_SEL_CFG_FUNC0_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC34_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC34_OUT_SEL_CFG.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetFUNC34_OUT_SEL_CFG_FUNC0_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC34_OUT_SEL_CFG.Reg) & 0x800) >> 11
}

// GPIO.FUNC35_OUT_SEL_CFG: Peripheral output selection for GPIO %s
func (o *GPIO_Type) SetFUNC35_OUT_SEL_CFG_FUNC0_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC35_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC35_OUT_SEL_CFG.Reg)&^(0x1ff)|value)
}
func (o *GPIO_Type) GetFUNC35_OUT_SEL_CFG_FUNC0_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC35_OUT_SEL_CFG.Reg) & 0x1ff
}
func (o *GPIO_Type) SetFUNC35_OUT_SEL_CFG_FUNC0_OUT_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC35_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC35_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC35_OUT_SEL_CFG_FUNC0_OUT_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC35_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC35_OUT_SEL_CFG_FUNC0_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC35_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC35_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC35_OUT_SEL_CFG_FUNC0_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC35_OUT_SEL_CFG.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetFUNC35_OUT_SEL_CFG_FUNC0_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC35_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC35_OUT_SEL_CFG.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetFUNC35_OUT_SEL_CFG_FUNC0_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC35_OUT_SEL_CFG.Reg) & 0x800) >> 11
}

// GPIO.FUNC36_OUT_SEL_CFG: Peripheral output selection for GPIO %s
func (o *GPIO_Type) SetFUNC36_OUT_SEL_CFG_FUNC0_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC36_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC36_OUT_SEL_CFG.Reg)&^(0x1ff)|value)
}
func (o *GPIO_Type) GetFUNC36_OUT_SEL_CFG_FUNC0_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC36_OUT_SEL_CFG.Reg) & 0x1ff
}
func (o *GPIO_Type) SetFUNC36_OUT_SEL_CFG_FUNC0_OUT_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC36_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC36_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC36_OUT_SEL_CFG_FUNC0_OUT_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC36_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC36_OUT_SEL_CFG_FUNC0_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC36_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC36_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC36_OUT_SEL_CFG_FUNC0_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC36_OUT_SEL_CFG.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetFUNC36_OUT_SEL_CFG_FUNC0_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC36_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC36_OUT_SEL_CFG.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetFUNC36_OUT_SEL_CFG_FUNC0_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC36_OUT_SEL_CFG.Reg) & 0x800) >> 11
}

// GPIO.FUNC37_OUT_SEL_CFG: Peripheral output selection for GPIO %s
func (o *GPIO_Type) SetFUNC37_OUT_SEL_CFG_FUNC0_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC37_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC37_OUT_SEL_CFG.Reg)&^(0x1ff)|value)
}
func (o *GPIO_Type) GetFUNC37_OUT_SEL_CFG_FUNC0_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC37_OUT_SEL_CFG.Reg) & 0x1ff
}
func (o *GPIO_Type) SetFUNC37_OUT_SEL_CFG_FUNC0_OUT_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC37_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC37_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC37_OUT_SEL_CFG_FUNC0_OUT_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC37_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC37_OUT_SEL_CFG_FUNC0_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC37_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC37_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC37_OUT_SEL_CFG_FUNC0_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC37_OUT_SEL_CFG.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetFUNC37_OUT_SEL_CFG_FUNC0_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC37_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC37_OUT_SEL_CFG.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetFUNC37_OUT_SEL_CFG_FUNC0_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC37_OUT_SEL_CFG.Reg) & 0x800) >> 11
}

// GPIO.FUNC38_OUT_SEL_CFG: Peripheral output selection for GPIO %s
func (o *GPIO_Type) SetFUNC38_OUT_SEL_CFG_FUNC0_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC38_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC38_OUT_SEL_CFG.Reg)&^(0x1ff)|value)
}
func (o *GPIO_Type) GetFUNC38_OUT_SEL_CFG_FUNC0_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC38_OUT_SEL_CFG.Reg) & 0x1ff
}
func (o *GPIO_Type) SetFUNC38_OUT_SEL_CFG_FUNC0_OUT_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC38_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC38_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC38_OUT_SEL_CFG_FUNC0_OUT_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC38_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC38_OUT_SEL_CFG_FUNC0_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC38_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC38_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC38_OUT_SEL_CFG_FUNC0_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC38_OUT_SEL_CFG.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetFUNC38_OUT_SEL_CFG_FUNC0_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC38_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC38_OUT_SEL_CFG.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetFUNC38_OUT_SEL_CFG_FUNC0_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC38_OUT_SEL_CFG.Reg) & 0x800) >> 11
}

// GPIO.FUNC39_OUT_SEL_CFG: Peripheral output selection for GPIO %s
func (o *GPIO_Type) SetFUNC39_OUT_SEL_CFG_FUNC0_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC39_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC39_OUT_SEL_CFG.Reg)&^(0x1ff)|value)
}
func (o *GPIO_Type) GetFUNC39_OUT_SEL_CFG_FUNC0_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC39_OUT_SEL_CFG.Reg) & 0x1ff
}
func (o *GPIO_Type) SetFUNC39_OUT_SEL_CFG_FUNC0_OUT_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC39_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC39_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC39_OUT_SEL_CFG_FUNC0_OUT_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC39_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC39_OUT_SEL_CFG_FUNC0_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC39_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC39_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC39_OUT_SEL_CFG_FUNC0_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC39_OUT_SEL_CFG.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetFUNC39_OUT_SEL_CFG_FUNC0_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC39_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC39_OUT_SEL_CFG.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetFUNC39_OUT_SEL_CFG_FUNC0_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC39_OUT_SEL_CFG.Reg) & 0x800) >> 11
}

// GPIO.FUNC40_OUT_SEL_CFG: Peripheral output selection for GPIO %s
func (o *GPIO_Type) SetFUNC40_OUT_SEL_CFG_FUNC0_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC40_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC40_OUT_SEL_CFG.Reg)&^(0x1ff)|value)
}
func (o *GPIO_Type) GetFUNC40_OUT_SEL_CFG_FUNC0_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC40_OUT_SEL_CFG.Reg) & 0x1ff
}
func (o *GPIO_Type) SetFUNC40_OUT_SEL_CFG_FUNC0_OUT_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC40_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC40_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC40_OUT_SEL_CFG_FUNC0_OUT_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC40_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC40_OUT_SEL_CFG_FUNC0_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC40_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC40_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC40_OUT_SEL_CFG_FUNC0_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC40_OUT_SEL_CFG.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetFUNC40_OUT_SEL_CFG_FUNC0_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC40_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC40_OUT_SEL_CFG.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetFUNC40_OUT_SEL_CFG_FUNC0_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC40_OUT_SEL_CFG.Reg) & 0x800) >> 11
}

// GPIO.FUNC41_OUT_SEL_CFG: Peripheral output selection for GPIO %s
func (o *GPIO_Type) SetFUNC41_OUT_SEL_CFG_FUNC0_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC41_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC41_OUT_SEL_CFG.Reg)&^(0x1ff)|value)
}
func (o *GPIO_Type) GetFUNC41_OUT_SEL_CFG_FUNC0_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC41_OUT_SEL_CFG.Reg) & 0x1ff
}
func (o *GPIO_Type) SetFUNC41_OUT_SEL_CFG_FUNC0_OUT_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC41_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC41_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC41_OUT_SEL_CFG_FUNC0_OUT_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC41_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC41_OUT_SEL_CFG_FUNC0_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC41_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC41_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC41_OUT_SEL_CFG_FUNC0_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC41_OUT_SEL_CFG.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetFUNC41_OUT_SEL_CFG_FUNC0_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC41_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC41_OUT_SEL_CFG.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetFUNC41_OUT_SEL_CFG_FUNC0_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC41_OUT_SEL_CFG.Reg) & 0x800) >> 11
}

// GPIO.FUNC42_OUT_SEL_CFG: Peripheral output selection for GPIO %s
func (o *GPIO_Type) SetFUNC42_OUT_SEL_CFG_FUNC0_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC42_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC42_OUT_SEL_CFG.Reg)&^(0x1ff)|value)
}
func (o *GPIO_Type) GetFUNC42_OUT_SEL_CFG_FUNC0_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC42_OUT_SEL_CFG.Reg) & 0x1ff
}
func (o *GPIO_Type) SetFUNC42_OUT_SEL_CFG_FUNC0_OUT_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC42_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC42_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC42_OUT_SEL_CFG_FUNC0_OUT_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC42_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC42_OUT_SEL_CFG_FUNC0_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC42_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC42_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC42_OUT_SEL_CFG_FUNC0_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC42_OUT_SEL_CFG.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetFUNC42_OUT_SEL_CFG_FUNC0_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC42_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC42_OUT_SEL_CFG.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetFUNC42_OUT_SEL_CFG_FUNC0_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC42_OUT_SEL_CFG.Reg) & 0x800) >> 11
}

// GPIO.FUNC43_OUT_SEL_CFG: Peripheral output selection for GPIO %s
func (o *GPIO_Type) SetFUNC43_OUT_SEL_CFG_FUNC0_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC43_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC43_OUT_SEL_CFG.Reg)&^(0x1ff)|value)
}
func (o *GPIO_Type) GetFUNC43_OUT_SEL_CFG_FUNC0_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC43_OUT_SEL_CFG.Reg) & 0x1ff
}
func (o *GPIO_Type) SetFUNC43_OUT_SEL_CFG_FUNC0_OUT_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC43_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC43_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC43_OUT_SEL_CFG_FUNC0_OUT_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC43_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC43_OUT_SEL_CFG_FUNC0_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC43_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC43_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC43_OUT_SEL_CFG_FUNC0_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC43_OUT_SEL_CFG.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetFUNC43_OUT_SEL_CFG_FUNC0_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC43_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC43_OUT_SEL_CFG.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetFUNC43_OUT_SEL_CFG_FUNC0_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC43_OUT_SEL_CFG.Reg) & 0x800) >> 11
}

// GPIO.FUNC44_OUT_SEL_CFG: Peripheral output selection for GPIO %s
func (o *GPIO_Type) SetFUNC44_OUT_SEL_CFG_FUNC0_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC44_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC44_OUT_SEL_CFG.Reg)&^(0x1ff)|value)
}
func (o *GPIO_Type) GetFUNC44_OUT_SEL_CFG_FUNC0_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC44_OUT_SEL_CFG.Reg) & 0x1ff
}
func (o *GPIO_Type) SetFUNC44_OUT_SEL_CFG_FUNC0_OUT_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC44_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC44_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC44_OUT_SEL_CFG_FUNC0_OUT_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC44_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC44_OUT_SEL_CFG_FUNC0_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC44_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC44_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC44_OUT_SEL_CFG_FUNC0_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC44_OUT_SEL_CFG.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetFUNC44_OUT_SEL_CFG_FUNC0_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC44_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC44_OUT_SEL_CFG.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetFUNC44_OUT_SEL_CFG_FUNC0_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC44_OUT_SEL_CFG.Reg) & 0x800) >> 11
}

// GPIO.FUNC45_OUT_SEL_CFG: Peripheral output selection for GPIO %s
func (o *GPIO_Type) SetFUNC45_OUT_SEL_CFG_FUNC0_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC45_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC45_OUT_SEL_CFG.Reg)&^(0x1ff)|value)
}
func (o *GPIO_Type) GetFUNC45_OUT_SEL_CFG_FUNC0_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC45_OUT_SEL_CFG.Reg) & 0x1ff
}
func (o *GPIO_Type) SetFUNC45_OUT_SEL_CFG_FUNC0_OUT_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC45_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC45_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC45_OUT_SEL_CFG_FUNC0_OUT_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC45_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC45_OUT_SEL_CFG_FUNC0_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC45_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC45_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC45_OUT_SEL_CFG_FUNC0_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC45_OUT_SEL_CFG.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetFUNC45_OUT_SEL_CFG_FUNC0_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC45_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC45_OUT_SEL_CFG.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetFUNC45_OUT_SEL_CFG_FUNC0_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC45_OUT_SEL_CFG.Reg) & 0x800) >> 11
}

// GPIO.FUNC46_OUT_SEL_CFG: Peripheral output selection for GPIO %s
func (o *GPIO_Type) SetFUNC46_OUT_SEL_CFG_FUNC0_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC46_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC46_OUT_SEL_CFG.Reg)&^(0x1ff)|value)
}
func (o *GPIO_Type) GetFUNC46_OUT_SEL_CFG_FUNC0_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC46_OUT_SEL_CFG.Reg) & 0x1ff
}
func (o *GPIO_Type) SetFUNC46_OUT_SEL_CFG_FUNC0_OUT_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC46_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC46_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC46_OUT_SEL_CFG_FUNC0_OUT_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC46_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC46_OUT_SEL_CFG_FUNC0_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC46_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC46_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC46_OUT_SEL_CFG_FUNC0_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC46_OUT_SEL_CFG.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetFUNC46_OUT_SEL_CFG_FUNC0_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC46_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC46_OUT_SEL_CFG.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetFUNC46_OUT_SEL_CFG_FUNC0_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC46_OUT_SEL_CFG.Reg) & 0x800) >> 11
}

// GPIO.FUNC47_OUT_SEL_CFG: Peripheral output selection for GPIO %s
func (o *GPIO_Type) SetFUNC47_OUT_SEL_CFG_FUNC0_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC47_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC47_OUT_SEL_CFG.Reg)&^(0x1ff)|value)
}
func (o *GPIO_Type) GetFUNC47_OUT_SEL_CFG_FUNC0_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC47_OUT_SEL_CFG.Reg) & 0x1ff
}
func (o *GPIO_Type) SetFUNC47_OUT_SEL_CFG_FUNC0_OUT_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC47_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC47_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC47_OUT_SEL_CFG_FUNC0_OUT_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC47_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC47_OUT_SEL_CFG_FUNC0_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC47_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC47_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC47_OUT_SEL_CFG_FUNC0_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC47_OUT_SEL_CFG.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetFUNC47_OUT_SEL_CFG_FUNC0_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC47_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC47_OUT_SEL_CFG.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetFUNC47_OUT_SEL_CFG_FUNC0_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC47_OUT_SEL_CFG.Reg) & 0x800) >> 11
}

// GPIO.FUNC48_OUT_SEL_CFG: Peripheral output selection for GPIO %s
func (o *GPIO_Type) SetFUNC48_OUT_SEL_CFG_FUNC0_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC48_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC48_OUT_SEL_CFG.Reg)&^(0x1ff)|value)
}
func (o *GPIO_Type) GetFUNC48_OUT_SEL_CFG_FUNC0_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC48_OUT_SEL_CFG.Reg) & 0x1ff
}
func (o *GPIO_Type) SetFUNC48_OUT_SEL_CFG_FUNC0_OUT_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC48_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC48_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC48_OUT_SEL_CFG_FUNC0_OUT_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC48_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC48_OUT_SEL_CFG_FUNC0_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC48_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC48_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC48_OUT_SEL_CFG_FUNC0_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC48_OUT_SEL_CFG.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetFUNC48_OUT_SEL_CFG_FUNC0_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC48_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC48_OUT_SEL_CFG.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetFUNC48_OUT_SEL_CFG_FUNC0_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC48_OUT_SEL_CFG.Reg) & 0x800) >> 11
}

// GPIO.FUNC49_OUT_SEL_CFG: Peripheral output selection for GPIO %s
func (o *GPIO_Type) SetFUNC49_OUT_SEL_CFG_FUNC0_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC49_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC49_OUT_SEL_CFG.Reg)&^(0x1ff)|value)
}
func (o *GPIO_Type) GetFUNC49_OUT_SEL_CFG_FUNC0_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC49_OUT_SEL_CFG.Reg) & 0x1ff
}
func (o *GPIO_Type) SetFUNC49_OUT_SEL_CFG_FUNC0_OUT_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC49_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC49_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC49_OUT_SEL_CFG_FUNC0_OUT_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC49_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC49_OUT_SEL_CFG_FUNC0_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC49_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC49_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC49_OUT_SEL_CFG_FUNC0_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC49_OUT_SEL_CFG.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetFUNC49_OUT_SEL_CFG_FUNC0_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC49_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC49_OUT_SEL_CFG.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetFUNC49_OUT_SEL_CFG_FUNC0_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC49_OUT_SEL_CFG.Reg) & 0x800) >> 11
}

// GPIO.FUNC50_OUT_SEL_CFG: Peripheral output selection for GPIO %s
func (o *GPIO_Type) SetFUNC50_OUT_SEL_CFG_FUNC0_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC50_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC50_OUT_SEL_CFG.Reg)&^(0x1ff)|value)
}
func (o *GPIO_Type) GetFUNC50_OUT_SEL_CFG_FUNC0_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC50_OUT_SEL_CFG.Reg) & 0x1ff
}
func (o *GPIO_Type) SetFUNC50_OUT_SEL_CFG_FUNC0_OUT_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC50_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC50_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC50_OUT_SEL_CFG_FUNC0_OUT_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC50_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC50_OUT_SEL_CFG_FUNC0_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC50_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC50_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC50_OUT_SEL_CFG_FUNC0_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC50_OUT_SEL_CFG.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetFUNC50_OUT_SEL_CFG_FUNC0_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC50_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC50_OUT_SEL_CFG.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetFUNC50_OUT_SEL_CFG_FUNC0_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC50_OUT_SEL_CFG.Reg) & 0x800) >> 11
}

// GPIO.FUNC51_OUT_SEL_CFG: Peripheral output selection for GPIO %s
func (o *GPIO_Type) SetFUNC51_OUT_SEL_CFG_FUNC0_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC51_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC51_OUT_SEL_CFG.Reg)&^(0x1ff)|value)
}
func (o *GPIO_Type) GetFUNC51_OUT_SEL_CFG_FUNC0_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC51_OUT_SEL_CFG.Reg) & 0x1ff
}
func (o *GPIO_Type) SetFUNC51_OUT_SEL_CFG_FUNC0_OUT_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC51_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC51_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC51_OUT_SEL_CFG_FUNC0_OUT_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC51_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC51_OUT_SEL_CFG_FUNC0_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC51_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC51_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC51_OUT_SEL_CFG_FUNC0_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC51_OUT_SEL_CFG.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetFUNC51_OUT_SEL_CFG_FUNC0_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC51_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC51_OUT_SEL_CFG.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetFUNC51_OUT_SEL_CFG_FUNC0_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC51_OUT_SEL_CFG.Reg) & 0x800) >> 11
}

// GPIO.FUNC52_OUT_SEL_CFG: Peripheral output selection for GPIO %s
func (o *GPIO_Type) SetFUNC52_OUT_SEL_CFG_FUNC0_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC52_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC52_OUT_SEL_CFG.Reg)&^(0x1ff)|value)
}
func (o *GPIO_Type) GetFUNC52_OUT_SEL_CFG_FUNC0_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC52_OUT_SEL_CFG.Reg) & 0x1ff
}
func (o *GPIO_Type) SetFUNC52_OUT_SEL_CFG_FUNC0_OUT_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC52_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC52_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC52_OUT_SEL_CFG_FUNC0_OUT_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC52_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC52_OUT_SEL_CFG_FUNC0_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC52_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC52_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC52_OUT_SEL_CFG_FUNC0_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC52_OUT_SEL_CFG.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetFUNC52_OUT_SEL_CFG_FUNC0_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC52_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC52_OUT_SEL_CFG.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetFUNC52_OUT_SEL_CFG_FUNC0_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC52_OUT_SEL_CFG.Reg) & 0x800) >> 11
}

// GPIO.FUNC53_OUT_SEL_CFG: Peripheral output selection for GPIO %s
func (o *GPIO_Type) SetFUNC53_OUT_SEL_CFG_FUNC0_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC53_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC53_OUT_SEL_CFG.Reg)&^(0x1ff)|value)
}
func (o *GPIO_Type) GetFUNC53_OUT_SEL_CFG_FUNC0_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC53_OUT_SEL_CFG.Reg) & 0x1ff
}
func (o *GPIO_Type) SetFUNC53_OUT_SEL_CFG_FUNC0_OUT_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC53_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC53_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC53_OUT_SEL_CFG_FUNC0_OUT_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC53_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC53_OUT_SEL_CFG_FUNC0_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC53_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC53_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC53_OUT_SEL_CFG_FUNC0_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC53_OUT_SEL_CFG.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetFUNC53_OUT_SEL_CFG_FUNC0_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC53_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC53_OUT_SEL_CFG.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetFUNC53_OUT_SEL_CFG_FUNC0_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC53_OUT_SEL_CFG.Reg) & 0x800) >> 11
}

// GPIO.CLOCK_GATE: GPIO clock gating register
func (o *GPIO_Type) SetCLOCK_GATE_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.CLOCK_GATE.Reg, volatile.LoadUint32(&o.CLOCK_GATE.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetCLOCK_GATE_CLK_EN() uint32 {
	return volatile.LoadUint32(&o.CLOCK_GATE.Reg) & 0x1
}

// GPIO.REG_DATE: Version control register
func (o *GPIO_Type) SetREG_DATE_DATE(value uint32) {
	volatile.StoreUint32(&o.REG_DATE.Reg, volatile.LoadUint32(&o.REG_DATE.Reg)&^(0xfffffff)|value)
}
func (o *GPIO_Type) GetREG_DATE_DATE() uint32 {
	return volatile.LoadUint32(&o.REG_DATE.Reg) & 0xfffffff
}

// Peripheral GPIO_SD
type GPIO_SD_Type struct {
	SIGMADELTA0        volatile.Register32 // 0x0
	SIGMADELTA1        volatile.Register32 // 0x4
	SIGMADELTA2        volatile.Register32 // 0x8
	SIGMADELTA3        volatile.Register32 // 0xC
	SIGMADELTA4        volatile.Register32 // 0x10
	SIGMADELTA5        volatile.Register32 // 0x14
	SIGMADELTA6        volatile.Register32 // 0x18
	SIGMADELTA7        volatile.Register32 // 0x1C
	SIGMADELTA_CG      volatile.Register32 // 0x20
	SIGMADELTA_MISC    volatile.Register32 // 0x24
	SIGMADELTA_VERSION volatile.Register32 // 0x28
}

// GPIO_SD.SIGMADELTA0: Duty Cycle Configure Register of SDM%s
func (o *GPIO_SD_Type) SetSIGMADELTA0_SD0_IN(value uint32) {
	volatile.StoreUint32(&o.SIGMADELTA0.Reg, volatile.LoadUint32(&o.SIGMADELTA0.Reg)&^(0xff)|value)
}
func (o *GPIO_SD_Type) GetSIGMADELTA0_SD0_IN() uint32 {
	return volatile.LoadUint32(&o.SIGMADELTA0.Reg) & 0xff
}
func (o *GPIO_SD_Type) SetSIGMADELTA0_SD0_PRESCALE(value uint32) {
	volatile.StoreUint32(&o.SIGMADELTA0.Reg, volatile.LoadUint32(&o.SIGMADELTA0.Reg)&^(0xff00)|value<<8)
}
func (o *GPIO_SD_Type) GetSIGMADELTA0_SD0_PRESCALE() uint32 {
	return (volatile.LoadUint32(&o.SIGMADELTA0.Reg) & 0xff00) >> 8
}

// GPIO_SD.SIGMADELTA1: Duty Cycle Configure Register of SDM%s
func (o *GPIO_SD_Type) SetSIGMADELTA1_SD0_IN(value uint32) {
	volatile.StoreUint32(&o.SIGMADELTA1.Reg, volatile.LoadUint32(&o.SIGMADELTA1.Reg)&^(0xff)|value)
}
func (o *GPIO_SD_Type) GetSIGMADELTA1_SD0_IN() uint32 {
	return volatile.LoadUint32(&o.SIGMADELTA1.Reg) & 0xff
}
func (o *GPIO_SD_Type) SetSIGMADELTA1_SD0_PRESCALE(value uint32) {
	volatile.StoreUint32(&o.SIGMADELTA1.Reg, volatile.LoadUint32(&o.SIGMADELTA1.Reg)&^(0xff00)|value<<8)
}
func (o *GPIO_SD_Type) GetSIGMADELTA1_SD0_PRESCALE() uint32 {
	return (volatile.LoadUint32(&o.SIGMADELTA1.Reg) & 0xff00) >> 8
}

// GPIO_SD.SIGMADELTA2: Duty Cycle Configure Register of SDM%s
func (o *GPIO_SD_Type) SetSIGMADELTA2_SD0_IN(value uint32) {
	volatile.StoreUint32(&o.SIGMADELTA2.Reg, volatile.LoadUint32(&o.SIGMADELTA2.Reg)&^(0xff)|value)
}
func (o *GPIO_SD_Type) GetSIGMADELTA2_SD0_IN() uint32 {
	return volatile.LoadUint32(&o.SIGMADELTA2.Reg) & 0xff
}
func (o *GPIO_SD_Type) SetSIGMADELTA2_SD0_PRESCALE(value uint32) {
	volatile.StoreUint32(&o.SIGMADELTA2.Reg, volatile.LoadUint32(&o.SIGMADELTA2.Reg)&^(0xff00)|value<<8)
}
func (o *GPIO_SD_Type) GetSIGMADELTA2_SD0_PRESCALE() uint32 {
	return (volatile.LoadUint32(&o.SIGMADELTA2.Reg) & 0xff00) >> 8
}

// GPIO_SD.SIGMADELTA3: Duty Cycle Configure Register of SDM%s
func (o *GPIO_SD_Type) SetSIGMADELTA3_SD0_IN(value uint32) {
	volatile.StoreUint32(&o.SIGMADELTA3.Reg, volatile.LoadUint32(&o.SIGMADELTA3.Reg)&^(0xff)|value)
}
func (o *GPIO_SD_Type) GetSIGMADELTA3_SD0_IN() uint32 {
	return volatile.LoadUint32(&o.SIGMADELTA3.Reg) & 0xff
}
func (o *GPIO_SD_Type) SetSIGMADELTA3_SD0_PRESCALE(value uint32) {
	volatile.StoreUint32(&o.SIGMADELTA3.Reg, volatile.LoadUint32(&o.SIGMADELTA3.Reg)&^(0xff00)|value<<8)
}
func (o *GPIO_SD_Type) GetSIGMADELTA3_SD0_PRESCALE() uint32 {
	return (volatile.LoadUint32(&o.SIGMADELTA3.Reg) & 0xff00) >> 8
}

// GPIO_SD.SIGMADELTA4: Duty Cycle Configure Register of SDM%s
func (o *GPIO_SD_Type) SetSIGMADELTA4_SD0_IN(value uint32) {
	volatile.StoreUint32(&o.SIGMADELTA4.Reg, volatile.LoadUint32(&o.SIGMADELTA4.Reg)&^(0xff)|value)
}
func (o *GPIO_SD_Type) GetSIGMADELTA4_SD0_IN() uint32 {
	return volatile.LoadUint32(&o.SIGMADELTA4.Reg) & 0xff
}
func (o *GPIO_SD_Type) SetSIGMADELTA4_SD0_PRESCALE(value uint32) {
	volatile.StoreUint32(&o.SIGMADELTA4.Reg, volatile.LoadUint32(&o.SIGMADELTA4.Reg)&^(0xff00)|value<<8)
}
func (o *GPIO_SD_Type) GetSIGMADELTA4_SD0_PRESCALE() uint32 {
	return (volatile.LoadUint32(&o.SIGMADELTA4.Reg) & 0xff00) >> 8
}

// GPIO_SD.SIGMADELTA5: Duty Cycle Configure Register of SDM%s
func (o *GPIO_SD_Type) SetSIGMADELTA5_SD0_IN(value uint32) {
	volatile.StoreUint32(&o.SIGMADELTA5.Reg, volatile.LoadUint32(&o.SIGMADELTA5.Reg)&^(0xff)|value)
}
func (o *GPIO_SD_Type) GetSIGMADELTA5_SD0_IN() uint32 {
	return volatile.LoadUint32(&o.SIGMADELTA5.Reg) & 0xff
}
func (o *GPIO_SD_Type) SetSIGMADELTA5_SD0_PRESCALE(value uint32) {
	volatile.StoreUint32(&o.SIGMADELTA5.Reg, volatile.LoadUint32(&o.SIGMADELTA5.Reg)&^(0xff00)|value<<8)
}
func (o *GPIO_SD_Type) GetSIGMADELTA5_SD0_PRESCALE() uint32 {
	return (volatile.LoadUint32(&o.SIGMADELTA5.Reg) & 0xff00) >> 8
}

// GPIO_SD.SIGMADELTA6: Duty Cycle Configure Register of SDM%s
func (o *GPIO_SD_Type) SetSIGMADELTA6_SD0_IN(value uint32) {
	volatile.StoreUint32(&o.SIGMADELTA6.Reg, volatile.LoadUint32(&o.SIGMADELTA6.Reg)&^(0xff)|value)
}
func (o *GPIO_SD_Type) GetSIGMADELTA6_SD0_IN() uint32 {
	return volatile.LoadUint32(&o.SIGMADELTA6.Reg) & 0xff
}
func (o *GPIO_SD_Type) SetSIGMADELTA6_SD0_PRESCALE(value uint32) {
	volatile.StoreUint32(&o.SIGMADELTA6.Reg, volatile.LoadUint32(&o.SIGMADELTA6.Reg)&^(0xff00)|value<<8)
}
func (o *GPIO_SD_Type) GetSIGMADELTA6_SD0_PRESCALE() uint32 {
	return (volatile.LoadUint32(&o.SIGMADELTA6.Reg) & 0xff00) >> 8
}

// GPIO_SD.SIGMADELTA7: Duty Cycle Configure Register of SDM%s
func (o *GPIO_SD_Type) SetSIGMADELTA7_SD0_IN(value uint32) {
	volatile.StoreUint32(&o.SIGMADELTA7.Reg, volatile.LoadUint32(&o.SIGMADELTA7.Reg)&^(0xff)|value)
}
func (o *GPIO_SD_Type) GetSIGMADELTA7_SD0_IN() uint32 {
	return volatile.LoadUint32(&o.SIGMADELTA7.Reg) & 0xff
}
func (o *GPIO_SD_Type) SetSIGMADELTA7_SD0_PRESCALE(value uint32) {
	volatile.StoreUint32(&o.SIGMADELTA7.Reg, volatile.LoadUint32(&o.SIGMADELTA7.Reg)&^(0xff00)|value<<8)
}
func (o *GPIO_SD_Type) GetSIGMADELTA7_SD0_PRESCALE() uint32 {
	return (volatile.LoadUint32(&o.SIGMADELTA7.Reg) & 0xff00) >> 8
}

// GPIO_SD.SIGMADELTA_CG: Clock Gating Configure Register
func (o *GPIO_SD_Type) SetSIGMADELTA_CG_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.SIGMADELTA_CG.Reg, volatile.LoadUint32(&o.SIGMADELTA_CG.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_SD_Type) GetSIGMADELTA_CG_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.SIGMADELTA_CG.Reg) & 0x80000000) >> 31
}

// GPIO_SD.SIGMADELTA_MISC: MISC Register
func (o *GPIO_SD_Type) SetSIGMADELTA_MISC_FUNCTION_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.SIGMADELTA_MISC.Reg, volatile.LoadUint32(&o.SIGMADELTA_MISC.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_SD_Type) GetSIGMADELTA_MISC_FUNCTION_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.SIGMADELTA_MISC.Reg) & 0x40000000) >> 30
}
func (o *GPIO_SD_Type) SetSIGMADELTA_MISC_SPI_SWAP(value uint32) {
	volatile.StoreUint32(&o.SIGMADELTA_MISC.Reg, volatile.LoadUint32(&o.SIGMADELTA_MISC.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_SD_Type) GetSIGMADELTA_MISC_SPI_SWAP() uint32 {
	return (volatile.LoadUint32(&o.SIGMADELTA_MISC.Reg) & 0x80000000) >> 31
}

// GPIO_SD.SIGMADELTA_VERSION: Version Control Register
func (o *GPIO_SD_Type) SetSIGMADELTA_VERSION_GPIO_SD_DATE(value uint32) {
	volatile.StoreUint32(&o.SIGMADELTA_VERSION.Reg, volatile.LoadUint32(&o.SIGMADELTA_VERSION.Reg)&^(0xfffffff)|value)
}
func (o *GPIO_SD_Type) GetSIGMADELTA_VERSION_GPIO_SD_DATE() uint32 {
	return volatile.LoadUint32(&o.SIGMADELTA_VERSION.Reg) & 0xfffffff
}

// Peripheral HMAC
type HMAC_Type struct {
	_                   [64]byte
	SET_START           volatile.Register32 // 0x40
	SET_PARA_PURPOSE    volatile.Register32 // 0x44
	SET_PARA_KEY        volatile.Register32 // 0x48
	SET_PARA_FINISH     volatile.Register32 // 0x4C
	SET_MESSAGE_ONE     volatile.Register32 // 0x50
	SET_MESSAGE_ING     volatile.Register32 // 0x54
	SET_MESSAGE_END     volatile.Register32 // 0x58
	SET_RESULT_FINISH   volatile.Register32 // 0x5C
	SET_INVALIDATE_JTAG volatile.Register32 // 0x60
	SET_INVALIDATE_DS   volatile.Register32 // 0x64
	QUERY_ERROR         volatile.Register32 // 0x68
	QUERY_BUSY          volatile.Register32 // 0x6C
	_                   [16]byte
	WR_MESSAGE_0        volatile.Register32 // 0x80
	WR_MESSAGE_1        volatile.Register32 // 0x84
	WR_MESSAGE_2        volatile.Register32 // 0x88
	WR_MESSAGE_3        volatile.Register32 // 0x8C
	WR_MESSAGE_4        volatile.Register32 // 0x90
	WR_MESSAGE_5        volatile.Register32 // 0x94
	WR_MESSAGE_6        volatile.Register32 // 0x98
	WR_MESSAGE_7        volatile.Register32 // 0x9C
	WR_MESSAGE_8        volatile.Register32 // 0xA0
	WR_MESSAGE_9        volatile.Register32 // 0xA4
	WR_MESSAGE_10       volatile.Register32 // 0xA8
	WR_MESSAGE_11       volatile.Register32 // 0xAC
	WR_MESSAGE_12       volatile.Register32 // 0xB0
	WR_MESSAGE_13       volatile.Register32 // 0xB4
	WR_MESSAGE_14       volatile.Register32 // 0xB8
	WR_MESSAGE_15       volatile.Register32 // 0xBC
	RD_RESULT_0         volatile.Register32 // 0xC0
	RD_RESULT_1         volatile.Register32 // 0xC4
	RD_RESULT_2         volatile.Register32 // 0xC8
	RD_RESULT_3         volatile.Register32 // 0xCC
	RD_RESULT_4         volatile.Register32 // 0xD0
	RD_RESULT_5         volatile.Register32 // 0xD4
	RD_RESULT_6         volatile.Register32 // 0xD8
	RD_RESULT_7         volatile.Register32 // 0xDC
	_                   [16]byte
	SET_MESSAGE_PAD     volatile.Register32 // 0xF0
	ONE_BLOCK           volatile.Register32 // 0xF4
	DATE                volatile.Register32 // 0xF8
}

// HMAC.SET_START: HMAC start control register.
func (o *HMAC_Type) SetSET_START(value uint32) {
	volatile.StoreUint32(&o.SET_START.Reg, volatile.LoadUint32(&o.SET_START.Reg)&^(0x1)|value)
}
func (o *HMAC_Type) GetSET_START() uint32 {
	return volatile.LoadUint32(&o.SET_START.Reg) & 0x1
}

// HMAC.SET_PARA_PURPOSE: HMAC parameter configuration register.
func (o *HMAC_Type) SetSET_PARA_PURPOSE_PURPOSE_SET(value uint32) {
	volatile.StoreUint32(&o.SET_PARA_PURPOSE.Reg, volatile.LoadUint32(&o.SET_PARA_PURPOSE.Reg)&^(0xf)|value)
}
func (o *HMAC_Type) GetSET_PARA_PURPOSE_PURPOSE_SET() uint32 {
	return volatile.LoadUint32(&o.SET_PARA_PURPOSE.Reg) & 0xf
}

// HMAC.SET_PARA_KEY: HMAC key configuration register.
func (o *HMAC_Type) SetSET_PARA_KEY_KEY_SET(value uint32) {
	volatile.StoreUint32(&o.SET_PARA_KEY.Reg, volatile.LoadUint32(&o.SET_PARA_KEY.Reg)&^(0x7)|value)
}
func (o *HMAC_Type) GetSET_PARA_KEY_KEY_SET() uint32 {
	return volatile.LoadUint32(&o.SET_PARA_KEY.Reg) & 0x7
}

// HMAC.SET_PARA_FINISH: HMAC configuration completion register.
func (o *HMAC_Type) SetSET_PARA_FINISH_SET_PARA_END(value uint32) {
	volatile.StoreUint32(&o.SET_PARA_FINISH.Reg, volatile.LoadUint32(&o.SET_PARA_FINISH.Reg)&^(0x1)|value)
}
func (o *HMAC_Type) GetSET_PARA_FINISH_SET_PARA_END() uint32 {
	return volatile.LoadUint32(&o.SET_PARA_FINISH.Reg) & 0x1
}

// HMAC.SET_MESSAGE_ONE: HMAC one message control register.
func (o *HMAC_Type) SetSET_MESSAGE_ONE_SET_TEXT_ONE(value uint32) {
	volatile.StoreUint32(&o.SET_MESSAGE_ONE.Reg, volatile.LoadUint32(&o.SET_MESSAGE_ONE.Reg)&^(0x1)|value)
}
func (o *HMAC_Type) GetSET_MESSAGE_ONE_SET_TEXT_ONE() uint32 {
	return volatile.LoadUint32(&o.SET_MESSAGE_ONE.Reg) & 0x1
}

// HMAC.SET_MESSAGE_ING: HMAC message continue register.
func (o *HMAC_Type) SetSET_MESSAGE_ING_SET_TEXT_ING(value uint32) {
	volatile.StoreUint32(&o.SET_MESSAGE_ING.Reg, volatile.LoadUint32(&o.SET_MESSAGE_ING.Reg)&^(0x1)|value)
}
func (o *HMAC_Type) GetSET_MESSAGE_ING_SET_TEXT_ING() uint32 {
	return volatile.LoadUint32(&o.SET_MESSAGE_ING.Reg) & 0x1
}

// HMAC.SET_MESSAGE_END: HMAC message end register.
func (o *HMAC_Type) SetSET_MESSAGE_END_SET_TEXT_END(value uint32) {
	volatile.StoreUint32(&o.SET_MESSAGE_END.Reg, volatile.LoadUint32(&o.SET_MESSAGE_END.Reg)&^(0x1)|value)
}
func (o *HMAC_Type) GetSET_MESSAGE_END_SET_TEXT_END() uint32 {
	return volatile.LoadUint32(&o.SET_MESSAGE_END.Reg) & 0x1
}

// HMAC.SET_RESULT_FINISH: HMAC read result completion register.
func (o *HMAC_Type) SetSET_RESULT_FINISH_SET_RESULT_END(value uint32) {
	volatile.StoreUint32(&o.SET_RESULT_FINISH.Reg, volatile.LoadUint32(&o.SET_RESULT_FINISH.Reg)&^(0x1)|value)
}
func (o *HMAC_Type) GetSET_RESULT_FINISH_SET_RESULT_END() uint32 {
	return volatile.LoadUint32(&o.SET_RESULT_FINISH.Reg) & 0x1
}

// HMAC.SET_INVALIDATE_JTAG: Invalidate JTAG result register.
func (o *HMAC_Type) SetSET_INVALIDATE_JTAG(value uint32) {
	volatile.StoreUint32(&o.SET_INVALIDATE_JTAG.Reg, volatile.LoadUint32(&o.SET_INVALIDATE_JTAG.Reg)&^(0x1)|value)
}
func (o *HMAC_Type) GetSET_INVALIDATE_JTAG() uint32 {
	return volatile.LoadUint32(&o.SET_INVALIDATE_JTAG.Reg) & 0x1
}

// HMAC.SET_INVALIDATE_DS: Invalidate digital signature result register.
func (o *HMAC_Type) SetSET_INVALIDATE_DS(value uint32) {
	volatile.StoreUint32(&o.SET_INVALIDATE_DS.Reg, volatile.LoadUint32(&o.SET_INVALIDATE_DS.Reg)&^(0x1)|value)
}
func (o *HMAC_Type) GetSET_INVALIDATE_DS() uint32 {
	return volatile.LoadUint32(&o.SET_INVALIDATE_DS.Reg) & 0x1
}

// HMAC.QUERY_ERROR: The matching result between key and purpose user configured.
func (o *HMAC_Type) SetQUERY_ERROR_QUREY_CHECK(value uint32) {
	volatile.StoreUint32(&o.QUERY_ERROR.Reg, volatile.LoadUint32(&o.QUERY_ERROR.Reg)&^(0x1)|value)
}
func (o *HMAC_Type) GetQUERY_ERROR_QUREY_CHECK() uint32 {
	return volatile.LoadUint32(&o.QUERY_ERROR.Reg) & 0x1
}

// HMAC.QUERY_BUSY: The busy state of HMAC module.
func (o *HMAC_Type) SetQUERY_BUSY_BUSY_STATE(value uint32) {
	volatile.StoreUint32(&o.QUERY_BUSY.Reg, volatile.LoadUint32(&o.QUERY_BUSY.Reg)&^(0x1)|value)
}
func (o *HMAC_Type) GetQUERY_BUSY_BUSY_STATE() uint32 {
	return volatile.LoadUint32(&o.QUERY_BUSY.Reg) & 0x1
}

// HMAC.WR_MESSAGE_0: Message register %s.
func (o *HMAC_Type) SetWR_MESSAGE_0(value uint32) {
	volatile.StoreUint32(&o.WR_MESSAGE_0.Reg, value)
}
func (o *HMAC_Type) GetWR_MESSAGE_0() uint32 {
	return volatile.LoadUint32(&o.WR_MESSAGE_0.Reg)
}

// HMAC.WR_MESSAGE_1: Message register %s.
func (o *HMAC_Type) SetWR_MESSAGE_1(value uint32) {
	volatile.StoreUint32(&o.WR_MESSAGE_1.Reg, value)
}
func (o *HMAC_Type) GetWR_MESSAGE_1() uint32 {
	return volatile.LoadUint32(&o.WR_MESSAGE_1.Reg)
}

// HMAC.WR_MESSAGE_2: Message register %s.
func (o *HMAC_Type) SetWR_MESSAGE_2(value uint32) {
	volatile.StoreUint32(&o.WR_MESSAGE_2.Reg, value)
}
func (o *HMAC_Type) GetWR_MESSAGE_2() uint32 {
	return volatile.LoadUint32(&o.WR_MESSAGE_2.Reg)
}

// HMAC.WR_MESSAGE_3: Message register %s.
func (o *HMAC_Type) SetWR_MESSAGE_3(value uint32) {
	volatile.StoreUint32(&o.WR_MESSAGE_3.Reg, value)
}
func (o *HMAC_Type) GetWR_MESSAGE_3() uint32 {
	return volatile.LoadUint32(&o.WR_MESSAGE_3.Reg)
}

// HMAC.WR_MESSAGE_4: Message register %s.
func (o *HMAC_Type) SetWR_MESSAGE_4(value uint32) {
	volatile.StoreUint32(&o.WR_MESSAGE_4.Reg, value)
}
func (o *HMAC_Type) GetWR_MESSAGE_4() uint32 {
	return volatile.LoadUint32(&o.WR_MESSAGE_4.Reg)
}

// HMAC.WR_MESSAGE_5: Message register %s.
func (o *HMAC_Type) SetWR_MESSAGE_5(value uint32) {
	volatile.StoreUint32(&o.WR_MESSAGE_5.Reg, value)
}
func (o *HMAC_Type) GetWR_MESSAGE_5() uint32 {
	return volatile.LoadUint32(&o.WR_MESSAGE_5.Reg)
}

// HMAC.WR_MESSAGE_6: Message register %s.
func (o *HMAC_Type) SetWR_MESSAGE_6(value uint32) {
	volatile.StoreUint32(&o.WR_MESSAGE_6.Reg, value)
}
func (o *HMAC_Type) GetWR_MESSAGE_6() uint32 {
	return volatile.LoadUint32(&o.WR_MESSAGE_6.Reg)
}

// HMAC.WR_MESSAGE_7: Message register %s.
func (o *HMAC_Type) SetWR_MESSAGE_7(value uint32) {
	volatile.StoreUint32(&o.WR_MESSAGE_7.Reg, value)
}
func (o *HMAC_Type) GetWR_MESSAGE_7() uint32 {
	return volatile.LoadUint32(&o.WR_MESSAGE_7.Reg)
}

// HMAC.WR_MESSAGE_8: Message register %s.
func (o *HMAC_Type) SetWR_MESSAGE_8(value uint32) {
	volatile.StoreUint32(&o.WR_MESSAGE_8.Reg, value)
}
func (o *HMAC_Type) GetWR_MESSAGE_8() uint32 {
	return volatile.LoadUint32(&o.WR_MESSAGE_8.Reg)
}

// HMAC.WR_MESSAGE_9: Message register %s.
func (o *HMAC_Type) SetWR_MESSAGE_9(value uint32) {
	volatile.StoreUint32(&o.WR_MESSAGE_9.Reg, value)
}
func (o *HMAC_Type) GetWR_MESSAGE_9() uint32 {
	return volatile.LoadUint32(&o.WR_MESSAGE_9.Reg)
}

// HMAC.WR_MESSAGE_10: Message register %s.
func (o *HMAC_Type) SetWR_MESSAGE_10(value uint32) {
	volatile.StoreUint32(&o.WR_MESSAGE_10.Reg, value)
}
func (o *HMAC_Type) GetWR_MESSAGE_10() uint32 {
	return volatile.LoadUint32(&o.WR_MESSAGE_10.Reg)
}

// HMAC.WR_MESSAGE_11: Message register %s.
func (o *HMAC_Type) SetWR_MESSAGE_11(value uint32) {
	volatile.StoreUint32(&o.WR_MESSAGE_11.Reg, value)
}
func (o *HMAC_Type) GetWR_MESSAGE_11() uint32 {
	return volatile.LoadUint32(&o.WR_MESSAGE_11.Reg)
}

// HMAC.WR_MESSAGE_12: Message register %s.
func (o *HMAC_Type) SetWR_MESSAGE_12(value uint32) {
	volatile.StoreUint32(&o.WR_MESSAGE_12.Reg, value)
}
func (o *HMAC_Type) GetWR_MESSAGE_12() uint32 {
	return volatile.LoadUint32(&o.WR_MESSAGE_12.Reg)
}

// HMAC.WR_MESSAGE_13: Message register %s.
func (o *HMAC_Type) SetWR_MESSAGE_13(value uint32) {
	volatile.StoreUint32(&o.WR_MESSAGE_13.Reg, value)
}
func (o *HMAC_Type) GetWR_MESSAGE_13() uint32 {
	return volatile.LoadUint32(&o.WR_MESSAGE_13.Reg)
}

// HMAC.WR_MESSAGE_14: Message register %s.
func (o *HMAC_Type) SetWR_MESSAGE_14(value uint32) {
	volatile.StoreUint32(&o.WR_MESSAGE_14.Reg, value)
}
func (o *HMAC_Type) GetWR_MESSAGE_14() uint32 {
	return volatile.LoadUint32(&o.WR_MESSAGE_14.Reg)
}

// HMAC.WR_MESSAGE_15: Message register %s.
func (o *HMAC_Type) SetWR_MESSAGE_15(value uint32) {
	volatile.StoreUint32(&o.WR_MESSAGE_15.Reg, value)
}
func (o *HMAC_Type) GetWR_MESSAGE_15() uint32 {
	return volatile.LoadUint32(&o.WR_MESSAGE_15.Reg)
}

// HMAC.RD_RESULT_0: Hash result register %s.
func (o *HMAC_Type) SetRD_RESULT_0(value uint32) {
	volatile.StoreUint32(&o.RD_RESULT_0.Reg, value)
}
func (o *HMAC_Type) GetRD_RESULT_0() uint32 {
	return volatile.LoadUint32(&o.RD_RESULT_0.Reg)
}

// HMAC.RD_RESULT_1: Hash result register %s.
func (o *HMAC_Type) SetRD_RESULT_1(value uint32) {
	volatile.StoreUint32(&o.RD_RESULT_1.Reg, value)
}
func (o *HMAC_Type) GetRD_RESULT_1() uint32 {
	return volatile.LoadUint32(&o.RD_RESULT_1.Reg)
}

// HMAC.RD_RESULT_2: Hash result register %s.
func (o *HMAC_Type) SetRD_RESULT_2(value uint32) {
	volatile.StoreUint32(&o.RD_RESULT_2.Reg, value)
}
func (o *HMAC_Type) GetRD_RESULT_2() uint32 {
	return volatile.LoadUint32(&o.RD_RESULT_2.Reg)
}

// HMAC.RD_RESULT_3: Hash result register %s.
func (o *HMAC_Type) SetRD_RESULT_3(value uint32) {
	volatile.StoreUint32(&o.RD_RESULT_3.Reg, value)
}
func (o *HMAC_Type) GetRD_RESULT_3() uint32 {
	return volatile.LoadUint32(&o.RD_RESULT_3.Reg)
}

// HMAC.RD_RESULT_4: Hash result register %s.
func (o *HMAC_Type) SetRD_RESULT_4(value uint32) {
	volatile.StoreUint32(&o.RD_RESULT_4.Reg, value)
}
func (o *HMAC_Type) GetRD_RESULT_4() uint32 {
	return volatile.LoadUint32(&o.RD_RESULT_4.Reg)
}

// HMAC.RD_RESULT_5: Hash result register %s.
func (o *HMAC_Type) SetRD_RESULT_5(value uint32) {
	volatile.StoreUint32(&o.RD_RESULT_5.Reg, value)
}
func (o *HMAC_Type) GetRD_RESULT_5() uint32 {
	return volatile.LoadUint32(&o.RD_RESULT_5.Reg)
}

// HMAC.RD_RESULT_6: Hash result register %s.
func (o *HMAC_Type) SetRD_RESULT_6(value uint32) {
	volatile.StoreUint32(&o.RD_RESULT_6.Reg, value)
}
func (o *HMAC_Type) GetRD_RESULT_6() uint32 {
	return volatile.LoadUint32(&o.RD_RESULT_6.Reg)
}

// HMAC.RD_RESULT_7: Hash result register %s.
func (o *HMAC_Type) SetRD_RESULT_7(value uint32) {
	volatile.StoreUint32(&o.RD_RESULT_7.Reg, value)
}
func (o *HMAC_Type) GetRD_RESULT_7() uint32 {
	return volatile.LoadUint32(&o.RD_RESULT_7.Reg)
}

// HMAC.SET_MESSAGE_PAD: Software padding register.
func (o *HMAC_Type) SetSET_MESSAGE_PAD_SET_TEXT_PAD(value uint32) {
	volatile.StoreUint32(&o.SET_MESSAGE_PAD.Reg, volatile.LoadUint32(&o.SET_MESSAGE_PAD.Reg)&^(0x1)|value)
}
func (o *HMAC_Type) GetSET_MESSAGE_PAD_SET_TEXT_PAD() uint32 {
	return volatile.LoadUint32(&o.SET_MESSAGE_PAD.Reg) & 0x1
}

// HMAC.ONE_BLOCK: One block message register.
func (o *HMAC_Type) SetONE_BLOCK_SET_ONE_BLOCK(value uint32) {
	volatile.StoreUint32(&o.ONE_BLOCK.Reg, volatile.LoadUint32(&o.ONE_BLOCK.Reg)&^(0x1)|value)
}
func (o *HMAC_Type) GetONE_BLOCK_SET_ONE_BLOCK() uint32 {
	return volatile.LoadUint32(&o.ONE_BLOCK.Reg) & 0x1
}

// HMAC.DATE: Version control register.
func (o *HMAC_Type) SetDATE(value uint32) {
	volatile.StoreUint32(&o.DATE.Reg, volatile.LoadUint32(&o.DATE.Reg)&^(0x3fffffff)|value)
}
func (o *HMAC_Type) GetDATE() uint32 {
	return volatile.LoadUint32(&o.DATE.Reg) & 0x3fffffff
}

// Peripheral I2C
type I2C0_Type struct {
	SCL_LOW_PERIOD       volatile.Register32 // 0x0
	CTR                  volatile.Register32 // 0x4
	SR                   volatile.Register32 // 0x8
	TO                   volatile.Register32 // 0xC
	SLAVE_ADDR           volatile.Register32 // 0x10
	FIFO_ST              volatile.Register32 // 0x14
	FIFO_CONF            volatile.Register32 // 0x18
	DATA                 volatile.Register32 // 0x1C
	INT_RAW              volatile.Register32 // 0x20
	INT_CLR              volatile.Register32 // 0x24
	INT_ENA              volatile.Register32 // 0x28
	INT_STATUS           volatile.Register32 // 0x2C
	SDA_HOLD             volatile.Register32 // 0x30
	SDA_SAMPLE           volatile.Register32 // 0x34
	SCL_HIGH_PERIOD      volatile.Register32 // 0x38
	_                    [4]byte
	SCL_START_HOLD       volatile.Register32 // 0x40
	SCL_RSTART_SETUP     volatile.Register32 // 0x44
	SCL_STOP_HOLD        volatile.Register32 // 0x48
	SCL_STOP_SETUP       volatile.Register32 // 0x4C
	SCL_FILTER_CFG       volatile.Register32 // 0x50
	SDA_FILTER_CFG       volatile.Register32 // 0x54
	COMD0                volatile.Register32 // 0x58
	COMD1                volatile.Register32 // 0x5C
	COMD2                volatile.Register32 // 0x60
	COMD3                volatile.Register32 // 0x64
	COMD4                volatile.Register32 // 0x68
	COMD5                volatile.Register32 // 0x6C
	COMD6                volatile.Register32 // 0x70
	COMD7                volatile.Register32 // 0x74
	COMD8                volatile.Register32 // 0x78
	COMD9                volatile.Register32 // 0x7C
	COMD10               volatile.Register32 // 0x80
	COMD11               volatile.Register32 // 0x84
	COMD12               volatile.Register32 // 0x88
	COMD13               volatile.Register32 // 0x8C
	COMD14               volatile.Register32 // 0x90
	COMD15               volatile.Register32 // 0x94
	SCL_ST_TIME_OUT      volatile.Register32 // 0x98
	SCL_MAIN_ST_TIME_OUT volatile.Register32 // 0x9C
	SCL_SP_CONF          volatile.Register32 // 0xA0
	SCL_STRETCH_CONF     volatile.Register32 // 0xA4
	_                    [80]byte
	DATE                 volatile.Register32 // 0xF8
}

// I2C0.SCL_LOW_PERIOD: Configures the low level width of the SCL clock
func (o *I2C0_Type) SetSCL_LOW_PERIOD(value uint32) {
	volatile.StoreUint32(&o.SCL_LOW_PERIOD.Reg, volatile.LoadUint32(&o.SCL_LOW_PERIOD.Reg)&^(0x3fff)|value)
}
func (o *I2C0_Type) GetSCL_LOW_PERIOD() uint32 {
	return volatile.LoadUint32(&o.SCL_LOW_PERIOD.Reg) & 0x3fff
}

// I2C0.CTR: Transmission setting
func (o *I2C0_Type) SetCTR_SDA_FORCE_OUT(value uint32) {
	volatile.StoreUint32(&o.CTR.Reg, volatile.LoadUint32(&o.CTR.Reg)&^(0x1)|value)
}
func (o *I2C0_Type) GetCTR_SDA_FORCE_OUT() uint32 {
	return volatile.LoadUint32(&o.CTR.Reg) & 0x1
}
func (o *I2C0_Type) SetCTR_SCL_FORCE_OUT(value uint32) {
	volatile.StoreUint32(&o.CTR.Reg, volatile.LoadUint32(&o.CTR.Reg)&^(0x2)|value<<1)
}
func (o *I2C0_Type) GetCTR_SCL_FORCE_OUT() uint32 {
	return (volatile.LoadUint32(&o.CTR.Reg) & 0x2) >> 1
}
func (o *I2C0_Type) SetCTR_SAMPLE_SCL_LEVEL(value uint32) {
	volatile.StoreUint32(&o.CTR.Reg, volatile.LoadUint32(&o.CTR.Reg)&^(0x4)|value<<2)
}
func (o *I2C0_Type) GetCTR_SAMPLE_SCL_LEVEL() uint32 {
	return (volatile.LoadUint32(&o.CTR.Reg) & 0x4) >> 2
}
func (o *I2C0_Type) SetCTR_RX_FULL_ACK_LEVEL(value uint32) {
	volatile.StoreUint32(&o.CTR.Reg, volatile.LoadUint32(&o.CTR.Reg)&^(0x8)|value<<3)
}
func (o *I2C0_Type) GetCTR_RX_FULL_ACK_LEVEL() uint32 {
	return (volatile.LoadUint32(&o.CTR.Reg) & 0x8) >> 3
}
func (o *I2C0_Type) SetCTR_MS_MODE(value uint32) {
	volatile.StoreUint32(&o.CTR.Reg, volatile.LoadUint32(&o.CTR.Reg)&^(0x10)|value<<4)
}
func (o *I2C0_Type) GetCTR_MS_MODE() uint32 {
	return (volatile.LoadUint32(&o.CTR.Reg) & 0x10) >> 4
}
func (o *I2C0_Type) SetCTR_TRANS_START(value uint32) {
	volatile.StoreUint32(&o.CTR.Reg, volatile.LoadUint32(&o.CTR.Reg)&^(0x20)|value<<5)
}
func (o *I2C0_Type) GetCTR_TRANS_START() uint32 {
	return (volatile.LoadUint32(&o.CTR.Reg) & 0x20) >> 5
}
func (o *I2C0_Type) SetCTR_TX_LSB_FIRST(value uint32) {
	volatile.StoreUint32(&o.CTR.Reg, volatile.LoadUint32(&o.CTR.Reg)&^(0x40)|value<<6)
}
func (o *I2C0_Type) GetCTR_TX_LSB_FIRST() uint32 {
	return (volatile.LoadUint32(&o.CTR.Reg) & 0x40) >> 6
}
func (o *I2C0_Type) SetCTR_RX_LSB_FIRST(value uint32) {
	volatile.StoreUint32(&o.CTR.Reg, volatile.LoadUint32(&o.CTR.Reg)&^(0x80)|value<<7)
}
func (o *I2C0_Type) GetCTR_RX_LSB_FIRST() uint32 {
	return (volatile.LoadUint32(&o.CTR.Reg) & 0x80) >> 7
}
func (o *I2C0_Type) SetCTR_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.CTR.Reg, volatile.LoadUint32(&o.CTR.Reg)&^(0x100)|value<<8)
}
func (o *I2C0_Type) GetCTR_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.CTR.Reg) & 0x100) >> 8
}
func (o *I2C0_Type) SetCTR_ARBITRATION_EN(value uint32) {
	volatile.StoreUint32(&o.CTR.Reg, volatile.LoadUint32(&o.CTR.Reg)&^(0x200)|value<<9)
}
func (o *I2C0_Type) GetCTR_ARBITRATION_EN() uint32 {
	return (volatile.LoadUint32(&o.CTR.Reg) & 0x200) >> 9
}
func (o *I2C0_Type) SetCTR_FSM_RST(value uint32) {
	volatile.StoreUint32(&o.CTR.Reg, volatile.LoadUint32(&o.CTR.Reg)&^(0x400)|value<<10)
}
func (o *I2C0_Type) GetCTR_FSM_RST() uint32 {
	return (volatile.LoadUint32(&o.CTR.Reg) & 0x400) >> 10
}
func (o *I2C0_Type) SetCTR_REF_ALWAYS_ON(value uint32) {
	volatile.StoreUint32(&o.CTR.Reg, volatile.LoadUint32(&o.CTR.Reg)&^(0x800)|value<<11)
}
func (o *I2C0_Type) GetCTR_REF_ALWAYS_ON() uint32 {
	return (volatile.LoadUint32(&o.CTR.Reg) & 0x800) >> 11
}

// I2C0.SR: Describe I2C work status
func (o *I2C0_Type) SetSR_RESP_REC(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *I2C0_Type) GetSR_RESP_REC() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}
func (o *I2C0_Type) SetSR_SLAVE_RW(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2)|value<<1)
}
func (o *I2C0_Type) GetSR_SLAVE_RW() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2) >> 1
}
func (o *I2C0_Type) SetSR_TIME_OUT(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x4)|value<<2)
}
func (o *I2C0_Type) GetSR_TIME_OUT() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x4) >> 2
}
func (o *I2C0_Type) SetSR_ARB_LOST(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x8)|value<<3)
}
func (o *I2C0_Type) GetSR_ARB_LOST() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x8) >> 3
}
func (o *I2C0_Type) SetSR_BUS_BUSY(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x10)|value<<4)
}
func (o *I2C0_Type) GetSR_BUS_BUSY() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x10) >> 4
}
func (o *I2C0_Type) SetSR_SLAVE_ADDRESSED(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x20)|value<<5)
}
func (o *I2C0_Type) GetSR_SLAVE_ADDRESSED() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x20) >> 5
}
func (o *I2C0_Type) SetSR_BYTE_TRANS(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x40)|value<<6)
}
func (o *I2C0_Type) GetSR_BYTE_TRANS() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x40) >> 6
}
func (o *I2C0_Type) SetSR_RXFIFO_CNT(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x3f00)|value<<8)
}
func (o *I2C0_Type) GetSR_RXFIFO_CNT() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x3f00) >> 8
}
func (o *I2C0_Type) SetSR_STRETCH_CAUSE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0xc000)|value<<14)
}
func (o *I2C0_Type) GetSR_STRETCH_CAUSE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0xc000) >> 14
}
func (o *I2C0_Type) SetSR_TXFIFO_CNT(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0xfc0000)|value<<18)
}
func (o *I2C0_Type) GetSR_TXFIFO_CNT() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0xfc0000) >> 18
}
func (o *I2C0_Type) SetSR_SCL_MAIN_STATE_LAST(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x7000000)|value<<24)
}
func (o *I2C0_Type) GetSR_SCL_MAIN_STATE_LAST() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x7000000) >> 24
}
func (o *I2C0_Type) SetSR_SCL_STATE_LAST(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x70000000)|value<<28)
}
func (o *I2C0_Type) GetSR_SCL_STATE_LAST() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x70000000) >> 28
}

// I2C0.TO: Setting time out control for receiving data
func (o *I2C0_Type) SetTO_TIME_OUT_VALUE(value uint32) {
	volatile.StoreUint32(&o.TO.Reg, volatile.LoadUint32(&o.TO.Reg)&^(0xffffff)|value)
}
func (o *I2C0_Type) GetTO_TIME_OUT_VALUE() uint32 {
	return volatile.LoadUint32(&o.TO.Reg) & 0xffffff
}
func (o *I2C0_Type) SetTO_TIME_OUT_EN(value uint32) {
	volatile.StoreUint32(&o.TO.Reg, volatile.LoadUint32(&o.TO.Reg)&^(0x1000000)|value<<24)
}
func (o *I2C0_Type) GetTO_TIME_OUT_EN() uint32 {
	return (volatile.LoadUint32(&o.TO.Reg) & 0x1000000) >> 24
}

// I2C0.SLAVE_ADDR: Local slave address setting
func (o *I2C0_Type) SetSLAVE_ADDR(value uint32) {
	volatile.StoreUint32(&o.SLAVE_ADDR.Reg, volatile.LoadUint32(&o.SLAVE_ADDR.Reg)&^(0x7fff)|value)
}
func (o *I2C0_Type) GetSLAVE_ADDR() uint32 {
	return volatile.LoadUint32(&o.SLAVE_ADDR.Reg) & 0x7fff
}
func (o *I2C0_Type) SetSLAVE_ADDR_ADDR_10BIT_EN(value uint32) {
	volatile.StoreUint32(&o.SLAVE_ADDR.Reg, volatile.LoadUint32(&o.SLAVE_ADDR.Reg)&^(0x80000000)|value<<31)
}
func (o *I2C0_Type) GetSLAVE_ADDR_ADDR_10BIT_EN() uint32 {
	return (volatile.LoadUint32(&o.SLAVE_ADDR.Reg) & 0x80000000) >> 31
}

// I2C0.FIFO_ST: FIFO status register
func (o *I2C0_Type) SetFIFO_ST_RXFIFO_START_ADDR(value uint32) {
	volatile.StoreUint32(&o.FIFO_ST.Reg, volatile.LoadUint32(&o.FIFO_ST.Reg)&^(0x1f)|value)
}
func (o *I2C0_Type) GetFIFO_ST_RXFIFO_START_ADDR() uint32 {
	return volatile.LoadUint32(&o.FIFO_ST.Reg) & 0x1f
}
func (o *I2C0_Type) SetFIFO_ST_RXFIFO_END_ADDR(value uint32) {
	volatile.StoreUint32(&o.FIFO_ST.Reg, volatile.LoadUint32(&o.FIFO_ST.Reg)&^(0x3e0)|value<<5)
}
func (o *I2C0_Type) GetFIFO_ST_RXFIFO_END_ADDR() uint32 {
	return (volatile.LoadUint32(&o.FIFO_ST.Reg) & 0x3e0) >> 5
}
func (o *I2C0_Type) SetFIFO_ST_TXFIFO_START_ADDR(value uint32) {
	volatile.StoreUint32(&o.FIFO_ST.Reg, volatile.LoadUint32(&o.FIFO_ST.Reg)&^(0x7c00)|value<<10)
}
func (o *I2C0_Type) GetFIFO_ST_TXFIFO_START_ADDR() uint32 {
	return (volatile.LoadUint32(&o.FIFO_ST.Reg) & 0x7c00) >> 10
}
func (o *I2C0_Type) SetFIFO_ST_TXFIFO_END_ADDR(value uint32) {
	volatile.StoreUint32(&o.FIFO_ST.Reg, volatile.LoadUint32(&o.FIFO_ST.Reg)&^(0xf8000)|value<<15)
}
func (o *I2C0_Type) GetFIFO_ST_TXFIFO_END_ADDR() uint32 {
	return (volatile.LoadUint32(&o.FIFO_ST.Reg) & 0xf8000) >> 15
}
func (o *I2C0_Type) SetFIFO_ST_RX_UPDATE(value uint32) {
	volatile.StoreUint32(&o.FIFO_ST.Reg, volatile.LoadUint32(&o.FIFO_ST.Reg)&^(0x100000)|value<<20)
}
func (o *I2C0_Type) GetFIFO_ST_RX_UPDATE() uint32 {
	return (volatile.LoadUint32(&o.FIFO_ST.Reg) & 0x100000) >> 20
}
func (o *I2C0_Type) SetFIFO_ST_TX_UPDATE(value uint32) {
	volatile.StoreUint32(&o.FIFO_ST.Reg, volatile.LoadUint32(&o.FIFO_ST.Reg)&^(0x200000)|value<<21)
}
func (o *I2C0_Type) GetFIFO_ST_TX_UPDATE() uint32 {
	return (volatile.LoadUint32(&o.FIFO_ST.Reg) & 0x200000) >> 21
}
func (o *I2C0_Type) SetFIFO_ST_SLAVE_RW_POINT(value uint32) {
	volatile.StoreUint32(&o.FIFO_ST.Reg, volatile.LoadUint32(&o.FIFO_ST.Reg)&^(0x3fc00000)|value<<22)
}
func (o *I2C0_Type) GetFIFO_ST_SLAVE_RW_POINT() uint32 {
	return (volatile.LoadUint32(&o.FIFO_ST.Reg) & 0x3fc00000) >> 22
}

// I2C0.FIFO_CONF: FIFO configuration register
func (o *I2C0_Type) SetFIFO_CONF_RXFIFO_WM_THRHD(value uint32) {
	volatile.StoreUint32(&o.FIFO_CONF.Reg, volatile.LoadUint32(&o.FIFO_CONF.Reg)&^(0x1f)|value)
}
func (o *I2C0_Type) GetFIFO_CONF_RXFIFO_WM_THRHD() uint32 {
	return volatile.LoadUint32(&o.FIFO_CONF.Reg) & 0x1f
}
func (o *I2C0_Type) SetFIFO_CONF_TXFIFO_WM_THRHD(value uint32) {
	volatile.StoreUint32(&o.FIFO_CONF.Reg, volatile.LoadUint32(&o.FIFO_CONF.Reg)&^(0x3e0)|value<<5)
}
func (o *I2C0_Type) GetFIFO_CONF_TXFIFO_WM_THRHD() uint32 {
	return (volatile.LoadUint32(&o.FIFO_CONF.Reg) & 0x3e0) >> 5
}
func (o *I2C0_Type) SetFIFO_CONF_NONFIFO_EN(value uint32) {
	volatile.StoreUint32(&o.FIFO_CONF.Reg, volatile.LoadUint32(&o.FIFO_CONF.Reg)&^(0x400)|value<<10)
}
func (o *I2C0_Type) GetFIFO_CONF_NONFIFO_EN() uint32 {
	return (volatile.LoadUint32(&o.FIFO_CONF.Reg) & 0x400) >> 10
}
func (o *I2C0_Type) SetFIFO_CONF_FIFO_ADDR_CFG_EN(value uint32) {
	volatile.StoreUint32(&o.FIFO_CONF.Reg, volatile.LoadUint32(&o.FIFO_CONF.Reg)&^(0x800)|value<<11)
}
func (o *I2C0_Type) GetFIFO_CONF_FIFO_ADDR_CFG_EN() uint32 {
	return (volatile.LoadUint32(&o.FIFO_CONF.Reg) & 0x800) >> 11
}
func (o *I2C0_Type) SetFIFO_CONF_RX_FIFO_RST(value uint32) {
	volatile.StoreUint32(&o.FIFO_CONF.Reg, volatile.LoadUint32(&o.FIFO_CONF.Reg)&^(0x1000)|value<<12)
}
func (o *I2C0_Type) GetFIFO_CONF_RX_FIFO_RST() uint32 {
	return (volatile.LoadUint32(&o.FIFO_CONF.Reg) & 0x1000) >> 12
}
func (o *I2C0_Type) SetFIFO_CONF_TX_FIFO_RST(value uint32) {
	volatile.StoreUint32(&o.FIFO_CONF.Reg, volatile.LoadUint32(&o.FIFO_CONF.Reg)&^(0x2000)|value<<13)
}
func (o *I2C0_Type) GetFIFO_CONF_TX_FIFO_RST() uint32 {
	return (volatile.LoadUint32(&o.FIFO_CONF.Reg) & 0x2000) >> 13
}
func (o *I2C0_Type) SetFIFO_CONF_NONFIFO_RX_THRES(value uint32) {
	volatile.StoreUint32(&o.FIFO_CONF.Reg, volatile.LoadUint32(&o.FIFO_CONF.Reg)&^(0xfc000)|value<<14)
}
func (o *I2C0_Type) GetFIFO_CONF_NONFIFO_RX_THRES() uint32 {
	return (volatile.LoadUint32(&o.FIFO_CONF.Reg) & 0xfc000) >> 14
}
func (o *I2C0_Type) SetFIFO_CONF_NONFIFO_TX_THRES(value uint32) {
	volatile.StoreUint32(&o.FIFO_CONF.Reg, volatile.LoadUint32(&o.FIFO_CONF.Reg)&^(0x3f00000)|value<<20)
}
func (o *I2C0_Type) GetFIFO_CONF_NONFIFO_TX_THRES() uint32 {
	return (volatile.LoadUint32(&o.FIFO_CONF.Reg) & 0x3f00000) >> 20
}
func (o *I2C0_Type) SetFIFO_CONF_FIFO_PRT_EN(value uint32) {
	volatile.StoreUint32(&o.FIFO_CONF.Reg, volatile.LoadUint32(&o.FIFO_CONF.Reg)&^(0x4000000)|value<<26)
}
func (o *I2C0_Type) GetFIFO_CONF_FIFO_PRT_EN() uint32 {
	return (volatile.LoadUint32(&o.FIFO_CONF.Reg) & 0x4000000) >> 26
}

// I2C0.DATA: RX FIFO read data
func (o *I2C0_Type) SetDATA_FIFO_RDATA(value uint32) {
	volatile.StoreUint32(&o.DATA.Reg, volatile.LoadUint32(&o.DATA.Reg)&^(0xff)|value)
}
func (o *I2C0_Type) GetDATA_FIFO_RDATA() uint32 {
	return volatile.LoadUint32(&o.DATA.Reg) & 0xff
}

// I2C0.INT_RAW: Raw interrupt status
func (o *I2C0_Type) SetINT_RAW_RXFIFO_WM_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x1)|value)
}
func (o *I2C0_Type) GetINT_RAW_RXFIFO_WM_INT_RAW() uint32 {
	return volatile.LoadUint32(&o.INT_RAW.Reg) & 0x1
}
func (o *I2C0_Type) SetINT_RAW_TXFIFO_WM_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x2)|value<<1)
}
func (o *I2C0_Type) GetINT_RAW_TXFIFO_WM_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x2) >> 1
}
func (o *I2C0_Type) SetINT_RAW_RXFIFO_OVF_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x4)|value<<2)
}
func (o *I2C0_Type) GetINT_RAW_RXFIFO_OVF_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x4) >> 2
}
func (o *I2C0_Type) SetINT_RAW_END_DETECT_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x8)|value<<3)
}
func (o *I2C0_Type) GetINT_RAW_END_DETECT_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x8) >> 3
}
func (o *I2C0_Type) SetINT_RAW_BYTE_TRANS_DONE_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x10)|value<<4)
}
func (o *I2C0_Type) GetINT_RAW_BYTE_TRANS_DONE_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x10) >> 4
}
func (o *I2C0_Type) SetINT_RAW_ARBITRATION_LOST_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x20)|value<<5)
}
func (o *I2C0_Type) GetINT_RAW_ARBITRATION_LOST_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x20) >> 5
}
func (o *I2C0_Type) SetINT_RAW_MST_TXFIFO_UDF_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x40)|value<<6)
}
func (o *I2C0_Type) GetINT_RAW_MST_TXFIFO_UDF_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x40) >> 6
}
func (o *I2C0_Type) SetINT_RAW_TRANS_COMPLETE_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x80)|value<<7)
}
func (o *I2C0_Type) GetINT_RAW_TRANS_COMPLETE_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x80) >> 7
}
func (o *I2C0_Type) SetINT_RAW_TIME_OUT_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x100)|value<<8)
}
func (o *I2C0_Type) GetINT_RAW_TIME_OUT_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x100) >> 8
}
func (o *I2C0_Type) SetINT_RAW_TRANS_START_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x200)|value<<9)
}
func (o *I2C0_Type) GetINT_RAW_TRANS_START_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x200) >> 9
}
func (o *I2C0_Type) SetINT_RAW_NACK_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x400)|value<<10)
}
func (o *I2C0_Type) GetINT_RAW_NACK_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x400) >> 10
}
func (o *I2C0_Type) SetINT_RAW_TXFIFO_OVF_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x800)|value<<11)
}
func (o *I2C0_Type) GetINT_RAW_TXFIFO_OVF_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x800) >> 11
}
func (o *I2C0_Type) SetINT_RAW_RXFIFO_UDF_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x1000)|value<<12)
}
func (o *I2C0_Type) GetINT_RAW_RXFIFO_UDF_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x1000) >> 12
}
func (o *I2C0_Type) SetINT_RAW_SCL_ST_TO_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x2000)|value<<13)
}
func (o *I2C0_Type) GetINT_RAW_SCL_ST_TO_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x2000) >> 13
}
func (o *I2C0_Type) SetINT_RAW_SCL_MAIN_ST_TO_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x4000)|value<<14)
}
func (o *I2C0_Type) GetINT_RAW_SCL_MAIN_ST_TO_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x4000) >> 14
}
func (o *I2C0_Type) SetINT_RAW_DET_START_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x8000)|value<<15)
}
func (o *I2C0_Type) GetINT_RAW_DET_START_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x8000) >> 15
}
func (o *I2C0_Type) SetINT_RAW_SLAVE_STRETCH_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x10000)|value<<16)
}
func (o *I2C0_Type) GetINT_RAW_SLAVE_STRETCH_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x10000) >> 16
}

// I2C0.INT_CLR: Interrupt clear bits
func (o *I2C0_Type) SetINT_CLR_RXFIFO_WM_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x1)|value)
}
func (o *I2C0_Type) GetINT_CLR_RXFIFO_WM_INT_CLR() uint32 {
	return volatile.LoadUint32(&o.INT_CLR.Reg) & 0x1
}
func (o *I2C0_Type) SetINT_CLR_TXFIFO_WM_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x2)|value<<1)
}
func (o *I2C0_Type) GetINT_CLR_TXFIFO_WM_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x2) >> 1
}
func (o *I2C0_Type) SetINT_CLR_RXFIFO_OVF_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x4)|value<<2)
}
func (o *I2C0_Type) GetINT_CLR_RXFIFO_OVF_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x4) >> 2
}
func (o *I2C0_Type) SetINT_CLR_END_DETECT_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x8)|value<<3)
}
func (o *I2C0_Type) GetINT_CLR_END_DETECT_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x8) >> 3
}
func (o *I2C0_Type) SetINT_CLR_BYTE_TRANS_DONE_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x10)|value<<4)
}
func (o *I2C0_Type) GetINT_CLR_BYTE_TRANS_DONE_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x10) >> 4
}
func (o *I2C0_Type) SetINT_CLR_ARBITRATION_LOST_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x20)|value<<5)
}
func (o *I2C0_Type) GetINT_CLR_ARBITRATION_LOST_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x20) >> 5
}
func (o *I2C0_Type) SetINT_CLR_MST_TXFIFO_UDF_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x40)|value<<6)
}
func (o *I2C0_Type) GetINT_CLR_MST_TXFIFO_UDF_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x40) >> 6
}
func (o *I2C0_Type) SetINT_CLR_TRANS_COMPLETE_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x80)|value<<7)
}
func (o *I2C0_Type) GetINT_CLR_TRANS_COMPLETE_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x80) >> 7
}
func (o *I2C0_Type) SetINT_CLR_TIME_OUT_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x100)|value<<8)
}
func (o *I2C0_Type) GetINT_CLR_TIME_OUT_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x100) >> 8
}
func (o *I2C0_Type) SetINT_CLR_TRANS_START_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x200)|value<<9)
}
func (o *I2C0_Type) GetINT_CLR_TRANS_START_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x200) >> 9
}
func (o *I2C0_Type) SetINT_CLR_NACK_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x400)|value<<10)
}
func (o *I2C0_Type) GetINT_CLR_NACK_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x400) >> 10
}
func (o *I2C0_Type) SetINT_CLR_TXFIFO_OVF_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x800)|value<<11)
}
func (o *I2C0_Type) GetINT_CLR_TXFIFO_OVF_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x800) >> 11
}
func (o *I2C0_Type) SetINT_CLR_RXFIFO_UDF_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x1000)|value<<12)
}
func (o *I2C0_Type) GetINT_CLR_RXFIFO_UDF_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x1000) >> 12
}
func (o *I2C0_Type) SetINT_CLR_SCL_ST_TO_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x2000)|value<<13)
}
func (o *I2C0_Type) GetINT_CLR_SCL_ST_TO_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x2000) >> 13
}
func (o *I2C0_Type) SetINT_CLR_SCL_MAIN_ST_TO_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x4000)|value<<14)
}
func (o *I2C0_Type) GetINT_CLR_SCL_MAIN_ST_TO_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x4000) >> 14
}
func (o *I2C0_Type) SetINT_CLR_DET_START_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x8000)|value<<15)
}
func (o *I2C0_Type) GetINT_CLR_DET_START_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x8000) >> 15
}
func (o *I2C0_Type) SetINT_CLR_SLAVE_STRETCH_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x10000)|value<<16)
}
func (o *I2C0_Type) GetINT_CLR_SLAVE_STRETCH_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x10000) >> 16
}

// I2C0.INT_ENA: Interrupt enable bits
func (o *I2C0_Type) SetINT_ENA_RXFIFO_WM_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x1)|value)
}
func (o *I2C0_Type) GetINT_ENA_RXFIFO_WM_INT_ENA() uint32 {
	return volatile.LoadUint32(&o.INT_ENA.Reg) & 0x1
}
func (o *I2C0_Type) SetINT_ENA_TXFIFO_WM_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x2)|value<<1)
}
func (o *I2C0_Type) GetINT_ENA_TXFIFO_WM_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x2) >> 1
}
func (o *I2C0_Type) SetINT_ENA_RXFIFO_OVF_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x4)|value<<2)
}
func (o *I2C0_Type) GetINT_ENA_RXFIFO_OVF_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x4) >> 2
}
func (o *I2C0_Type) SetINT_ENA_END_DETECT_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x8)|value<<3)
}
func (o *I2C0_Type) GetINT_ENA_END_DETECT_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x8) >> 3
}
func (o *I2C0_Type) SetINT_ENA_BYTE_TRANS_DONE_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x10)|value<<4)
}
func (o *I2C0_Type) GetINT_ENA_BYTE_TRANS_DONE_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x10) >> 4
}
func (o *I2C0_Type) SetINT_ENA_ARBITRATION_LOST_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x20)|value<<5)
}
func (o *I2C0_Type) GetINT_ENA_ARBITRATION_LOST_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x20) >> 5
}
func (o *I2C0_Type) SetINT_ENA_MST_TXFIFO_UDF_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x40)|value<<6)
}
func (o *I2C0_Type) GetINT_ENA_MST_TXFIFO_UDF_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x40) >> 6
}
func (o *I2C0_Type) SetINT_ENA_TRANS_COMPLETE_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x80)|value<<7)
}
func (o *I2C0_Type) GetINT_ENA_TRANS_COMPLETE_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x80) >> 7
}
func (o *I2C0_Type) SetINT_ENA_TIME_OUT_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x100)|value<<8)
}
func (o *I2C0_Type) GetINT_ENA_TIME_OUT_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x100) >> 8
}
func (o *I2C0_Type) SetINT_ENA_TRANS_START_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x200)|value<<9)
}
func (o *I2C0_Type) GetINT_ENA_TRANS_START_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x200) >> 9
}
func (o *I2C0_Type) SetINT_ENA_NACK_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x400)|value<<10)
}
func (o *I2C0_Type) GetINT_ENA_NACK_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x400) >> 10
}
func (o *I2C0_Type) SetINT_ENA_TXFIFO_OVF_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x800)|value<<11)
}
func (o *I2C0_Type) GetINT_ENA_TXFIFO_OVF_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x800) >> 11
}
func (o *I2C0_Type) SetINT_ENA_RXFIFO_UDF_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x1000)|value<<12)
}
func (o *I2C0_Type) GetINT_ENA_RXFIFO_UDF_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x1000) >> 12
}
func (o *I2C0_Type) SetINT_ENA_SCL_ST_TO_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x2000)|value<<13)
}
func (o *I2C0_Type) GetINT_ENA_SCL_ST_TO_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x2000) >> 13
}
func (o *I2C0_Type) SetINT_ENA_SCL_MAIN_ST_TO_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x4000)|value<<14)
}
func (o *I2C0_Type) GetINT_ENA_SCL_MAIN_ST_TO_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x4000) >> 14
}
func (o *I2C0_Type) SetINT_ENA_DET_START_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x8000)|value<<15)
}
func (o *I2C0_Type) GetINT_ENA_DET_START_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x8000) >> 15
}
func (o *I2C0_Type) SetINT_ENA_SLAVE_STRETCH_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x10000)|value<<16)
}
func (o *I2C0_Type) GetINT_ENA_SLAVE_STRETCH_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x10000) >> 16
}

// I2C0.INT_STATUS: Status of captured I2C communication events
func (o *I2C0_Type) SetINT_STATUS_RXFIFO_WM_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_STATUS.Reg, volatile.LoadUint32(&o.INT_STATUS.Reg)&^(0x1)|value)
}
func (o *I2C0_Type) GetINT_STATUS_RXFIFO_WM_INT_ST() uint32 {
	return volatile.LoadUint32(&o.INT_STATUS.Reg) & 0x1
}
func (o *I2C0_Type) SetINT_STATUS_TXFIFO_WM_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_STATUS.Reg, volatile.LoadUint32(&o.INT_STATUS.Reg)&^(0x2)|value<<1)
}
func (o *I2C0_Type) GetINT_STATUS_TXFIFO_WM_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_STATUS.Reg) & 0x2) >> 1
}
func (o *I2C0_Type) SetINT_STATUS_RXFIFO_OVF_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_STATUS.Reg, volatile.LoadUint32(&o.INT_STATUS.Reg)&^(0x4)|value<<2)
}
func (o *I2C0_Type) GetINT_STATUS_RXFIFO_OVF_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_STATUS.Reg) & 0x4) >> 2
}
func (o *I2C0_Type) SetINT_STATUS_END_DETECT_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_STATUS.Reg, volatile.LoadUint32(&o.INT_STATUS.Reg)&^(0x8)|value<<3)
}
func (o *I2C0_Type) GetINT_STATUS_END_DETECT_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_STATUS.Reg) & 0x8) >> 3
}
func (o *I2C0_Type) SetINT_STATUS_BYTE_TRANS_DONE_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_STATUS.Reg, volatile.LoadUint32(&o.INT_STATUS.Reg)&^(0x10)|value<<4)
}
func (o *I2C0_Type) GetINT_STATUS_BYTE_TRANS_DONE_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_STATUS.Reg) & 0x10) >> 4
}
func (o *I2C0_Type) SetINT_STATUS_ARBITRATION_LOST_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_STATUS.Reg, volatile.LoadUint32(&o.INT_STATUS.Reg)&^(0x20)|value<<5)
}
func (o *I2C0_Type) GetINT_STATUS_ARBITRATION_LOST_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_STATUS.Reg) & 0x20) >> 5
}
func (o *I2C0_Type) SetINT_STATUS_MST_TXFIFO_UDF_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_STATUS.Reg, volatile.LoadUint32(&o.INT_STATUS.Reg)&^(0x40)|value<<6)
}
func (o *I2C0_Type) GetINT_STATUS_MST_TXFIFO_UDF_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_STATUS.Reg) & 0x40) >> 6
}
func (o *I2C0_Type) SetINT_STATUS_TRANS_COMPLETE_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_STATUS.Reg, volatile.LoadUint32(&o.INT_STATUS.Reg)&^(0x80)|value<<7)
}
func (o *I2C0_Type) GetINT_STATUS_TRANS_COMPLETE_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_STATUS.Reg) & 0x80) >> 7
}
func (o *I2C0_Type) SetINT_STATUS_TIME_OUT_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_STATUS.Reg, volatile.LoadUint32(&o.INT_STATUS.Reg)&^(0x100)|value<<8)
}
func (o *I2C0_Type) GetINT_STATUS_TIME_OUT_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_STATUS.Reg) & 0x100) >> 8
}
func (o *I2C0_Type) SetINT_STATUS_TRANS_START_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_STATUS.Reg, volatile.LoadUint32(&o.INT_STATUS.Reg)&^(0x200)|value<<9)
}
func (o *I2C0_Type) GetINT_STATUS_TRANS_START_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_STATUS.Reg) & 0x200) >> 9
}
func (o *I2C0_Type) SetINT_STATUS_NACK_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_STATUS.Reg, volatile.LoadUint32(&o.INT_STATUS.Reg)&^(0x400)|value<<10)
}
func (o *I2C0_Type) GetINT_STATUS_NACK_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_STATUS.Reg) & 0x400) >> 10
}
func (o *I2C0_Type) SetINT_STATUS_TXFIFO_OVF_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_STATUS.Reg, volatile.LoadUint32(&o.INT_STATUS.Reg)&^(0x800)|value<<11)
}
func (o *I2C0_Type) GetINT_STATUS_TXFIFO_OVF_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_STATUS.Reg) & 0x800) >> 11
}
func (o *I2C0_Type) SetINT_STATUS_RXFIFO_UDF_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_STATUS.Reg, volatile.LoadUint32(&o.INT_STATUS.Reg)&^(0x1000)|value<<12)
}
func (o *I2C0_Type) GetINT_STATUS_RXFIFO_UDF_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_STATUS.Reg) & 0x1000) >> 12
}
func (o *I2C0_Type) SetINT_STATUS_SCL_ST_TO_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_STATUS.Reg, volatile.LoadUint32(&o.INT_STATUS.Reg)&^(0x2000)|value<<13)
}
func (o *I2C0_Type) GetINT_STATUS_SCL_ST_TO_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_STATUS.Reg) & 0x2000) >> 13
}
func (o *I2C0_Type) SetINT_STATUS_SCL_MAIN_ST_TO_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_STATUS.Reg, volatile.LoadUint32(&o.INT_STATUS.Reg)&^(0x4000)|value<<14)
}
func (o *I2C0_Type) GetINT_STATUS_SCL_MAIN_ST_TO_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_STATUS.Reg) & 0x4000) >> 14
}
func (o *I2C0_Type) SetINT_STATUS_DET_START_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_STATUS.Reg, volatile.LoadUint32(&o.INT_STATUS.Reg)&^(0x8000)|value<<15)
}
func (o *I2C0_Type) GetINT_STATUS_DET_START_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_STATUS.Reg) & 0x8000) >> 15
}
func (o *I2C0_Type) SetINT_STATUS_SLAVE_STRETCH_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_STATUS.Reg, volatile.LoadUint32(&o.INT_STATUS.Reg)&^(0x10000)|value<<16)
}
func (o *I2C0_Type) GetINT_STATUS_SLAVE_STRETCH_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_STATUS.Reg) & 0x10000) >> 16
}

// I2C0.SDA_HOLD: Configures the hold time after a negative SCL edge
func (o *I2C0_Type) SetSDA_HOLD_TIME(value uint32) {
	volatile.StoreUint32(&o.SDA_HOLD.Reg, volatile.LoadUint32(&o.SDA_HOLD.Reg)&^(0x3ff)|value)
}
func (o *I2C0_Type) GetSDA_HOLD_TIME() uint32 {
	return volatile.LoadUint32(&o.SDA_HOLD.Reg) & 0x3ff
}

// I2C0.SDA_SAMPLE: Configures the sample time after a positive SCL edge
func (o *I2C0_Type) SetSDA_SAMPLE_TIME(value uint32) {
	volatile.StoreUint32(&o.SDA_SAMPLE.Reg, volatile.LoadUint32(&o.SDA_SAMPLE.Reg)&^(0x3ff)|value)
}
func (o *I2C0_Type) GetSDA_SAMPLE_TIME() uint32 {
	return volatile.LoadUint32(&o.SDA_SAMPLE.Reg) & 0x3ff
}

// I2C0.SCL_HIGH_PERIOD: Configures the high level width of the SCL clock
func (o *I2C0_Type) SetSCL_HIGH_PERIOD(value uint32) {
	volatile.StoreUint32(&o.SCL_HIGH_PERIOD.Reg, volatile.LoadUint32(&o.SCL_HIGH_PERIOD.Reg)&^(0x3fff)|value)
}
func (o *I2C0_Type) GetSCL_HIGH_PERIOD() uint32 {
	return volatile.LoadUint32(&o.SCL_HIGH_PERIOD.Reg) & 0x3fff
}
func (o *I2C0_Type) SetSCL_HIGH_PERIOD_SCL_WAIT_HIGH_PERIOD(value uint32) {
	volatile.StoreUint32(&o.SCL_HIGH_PERIOD.Reg, volatile.LoadUint32(&o.SCL_HIGH_PERIOD.Reg)&^(0xfffc000)|value<<14)
}
func (o *I2C0_Type) GetSCL_HIGH_PERIOD_SCL_WAIT_HIGH_PERIOD() uint32 {
	return (volatile.LoadUint32(&o.SCL_HIGH_PERIOD.Reg) & 0xfffc000) >> 14
}

// I2C0.SCL_START_HOLD: Configures the interval between pulling SDA low and pulling SCL low when the master generates a START condition
func (o *I2C0_Type) SetSCL_START_HOLD_TIME(value uint32) {
	volatile.StoreUint32(&o.SCL_START_HOLD.Reg, volatile.LoadUint32(&o.SCL_START_HOLD.Reg)&^(0x3ff)|value)
}
func (o *I2C0_Type) GetSCL_START_HOLD_TIME() uint32 {
	return volatile.LoadUint32(&o.SCL_START_HOLD.Reg) & 0x3ff
}

// I2C0.SCL_RSTART_SETUP: Configures the interval between the positive; ;;;;;;;; >>>>>>>>>>edge of SCL and the negative edge of SDA
func (o *I2C0_Type) SetSCL_RSTART_SETUP_TIME(value uint32) {
	volatile.StoreUint32(&o.SCL_RSTART_SETUP.Reg, volatile.LoadUint32(&o.SCL_RSTART_SETUP.Reg)&^(0x3ff)|value)
}
func (o *I2C0_Type) GetSCL_RSTART_SETUP_TIME() uint32 {
	return volatile.LoadUint32(&o.SCL_RSTART_SETUP.Reg) & 0x3ff
}

// I2C0.SCL_STOP_HOLD: Configures the delay after the SCL clock; ;;;;;;;; >>>>>>>>>>edge for a stop condition
func (o *I2C0_Type) SetSCL_STOP_HOLD_TIME(value uint32) {
	volatile.StoreUint32(&o.SCL_STOP_HOLD.Reg, volatile.LoadUint32(&o.SCL_STOP_HOLD.Reg)&^(0x3fff)|value)
}
func (o *I2C0_Type) GetSCL_STOP_HOLD_TIME() uint32 {
	return volatile.LoadUint32(&o.SCL_STOP_HOLD.Reg) & 0x3fff
}

// I2C0.SCL_STOP_SETUP: Configures the delay between the SDA and; ;;;;;;;; >>>>>>>>>>SCL positive edge for a stop condition
func (o *I2C0_Type) SetSCL_STOP_SETUP_TIME(value uint32) {
	volatile.StoreUint32(&o.SCL_STOP_SETUP.Reg, volatile.LoadUint32(&o.SCL_STOP_SETUP.Reg)&^(0x3ff)|value)
}
func (o *I2C0_Type) GetSCL_STOP_SETUP_TIME() uint32 {
	return volatile.LoadUint32(&o.SCL_STOP_SETUP.Reg) & 0x3ff
}

// I2C0.SCL_FILTER_CFG: SCL filter configuration register
func (o *I2C0_Type) SetSCL_FILTER_CFG_SCL_FILTER_THRES(value uint32) {
	volatile.StoreUint32(&o.SCL_FILTER_CFG.Reg, volatile.LoadUint32(&o.SCL_FILTER_CFG.Reg)&^(0xf)|value)
}
func (o *I2C0_Type) GetSCL_FILTER_CFG_SCL_FILTER_THRES() uint32 {
	return volatile.LoadUint32(&o.SCL_FILTER_CFG.Reg) & 0xf
}
func (o *I2C0_Type) SetSCL_FILTER_CFG_SCL_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.SCL_FILTER_CFG.Reg, volatile.LoadUint32(&o.SCL_FILTER_CFG.Reg)&^(0x10)|value<<4)
}
func (o *I2C0_Type) GetSCL_FILTER_CFG_SCL_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.SCL_FILTER_CFG.Reg) & 0x10) >> 4
}

// I2C0.SDA_FILTER_CFG: SDA filter configuration register
func (o *I2C0_Type) SetSDA_FILTER_CFG_SDA_FILTER_THRES(value uint32) {
	volatile.StoreUint32(&o.SDA_FILTER_CFG.Reg, volatile.LoadUint32(&o.SDA_FILTER_CFG.Reg)&^(0xf)|value)
}
func (o *I2C0_Type) GetSDA_FILTER_CFG_SDA_FILTER_THRES() uint32 {
	return volatile.LoadUint32(&o.SDA_FILTER_CFG.Reg) & 0xf
}
func (o *I2C0_Type) SetSDA_FILTER_CFG_SDA_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.SDA_FILTER_CFG.Reg, volatile.LoadUint32(&o.SDA_FILTER_CFG.Reg)&^(0x10)|value<<4)
}
func (o *I2C0_Type) GetSDA_FILTER_CFG_SDA_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.SDA_FILTER_CFG.Reg) & 0x10) >> 4
}

// I2C0.COMD0: I2C command register 0
func (o *I2C0_Type) SetCOMD0_COMMAND0(value uint32) {
	volatile.StoreUint32(&o.COMD0.Reg, volatile.LoadUint32(&o.COMD0.Reg)&^(0x3fff)|value)
}
func (o *I2C0_Type) GetCOMD0_COMMAND0() uint32 {
	return volatile.LoadUint32(&o.COMD0.Reg) & 0x3fff
}
func (o *I2C0_Type) SetCOMD0_COMMAND0_DONE(value uint32) {
	volatile.StoreUint32(&o.COMD0.Reg, volatile.LoadUint32(&o.COMD0.Reg)&^(0x80000000)|value<<31)
}
func (o *I2C0_Type) GetCOMD0_COMMAND0_DONE() uint32 {
	return (volatile.LoadUint32(&o.COMD0.Reg) & 0x80000000) >> 31
}

// I2C0.COMD1: I2C command register 1
func (o *I2C0_Type) SetCOMD1_COMMAND1(value uint32) {
	volatile.StoreUint32(&o.COMD1.Reg, volatile.LoadUint32(&o.COMD1.Reg)&^(0x3fff)|value)
}
func (o *I2C0_Type) GetCOMD1_COMMAND1() uint32 {
	return volatile.LoadUint32(&o.COMD1.Reg) & 0x3fff
}
func (o *I2C0_Type) SetCOMD1_COMMAND1_DONE(value uint32) {
	volatile.StoreUint32(&o.COMD1.Reg, volatile.LoadUint32(&o.COMD1.Reg)&^(0x80000000)|value<<31)
}
func (o *I2C0_Type) GetCOMD1_COMMAND1_DONE() uint32 {
	return (volatile.LoadUint32(&o.COMD1.Reg) & 0x80000000) >> 31
}

// I2C0.COMD2: I2C command register 2
func (o *I2C0_Type) SetCOMD2_COMMAND2(value uint32) {
	volatile.StoreUint32(&o.COMD2.Reg, volatile.LoadUint32(&o.COMD2.Reg)&^(0x3fff)|value)
}
func (o *I2C0_Type) GetCOMD2_COMMAND2() uint32 {
	return volatile.LoadUint32(&o.COMD2.Reg) & 0x3fff
}
func (o *I2C0_Type) SetCOMD2_COMMAND2_DONE(value uint32) {
	volatile.StoreUint32(&o.COMD2.Reg, volatile.LoadUint32(&o.COMD2.Reg)&^(0x80000000)|value<<31)
}
func (o *I2C0_Type) GetCOMD2_COMMAND2_DONE() uint32 {
	return (volatile.LoadUint32(&o.COMD2.Reg) & 0x80000000) >> 31
}

// I2C0.COMD3: I2C command register 3
func (o *I2C0_Type) SetCOMD3_COMMAND3(value uint32) {
	volatile.StoreUint32(&o.COMD3.Reg, volatile.LoadUint32(&o.COMD3.Reg)&^(0x3fff)|value)
}
func (o *I2C0_Type) GetCOMD3_COMMAND3() uint32 {
	return volatile.LoadUint32(&o.COMD3.Reg) & 0x3fff
}
func (o *I2C0_Type) SetCOMD3_COMMAND3_DONE(value uint32) {
	volatile.StoreUint32(&o.COMD3.Reg, volatile.LoadUint32(&o.COMD3.Reg)&^(0x80000000)|value<<31)
}
func (o *I2C0_Type) GetCOMD3_COMMAND3_DONE() uint32 {
	return (volatile.LoadUint32(&o.COMD3.Reg) & 0x80000000) >> 31
}

// I2C0.COMD4: I2C command register 4
func (o *I2C0_Type) SetCOMD4_COMMAND4(value uint32) {
	volatile.StoreUint32(&o.COMD4.Reg, volatile.LoadUint32(&o.COMD4.Reg)&^(0x3fff)|value)
}
func (o *I2C0_Type) GetCOMD4_COMMAND4() uint32 {
	return volatile.LoadUint32(&o.COMD4.Reg) & 0x3fff
}
func (o *I2C0_Type) SetCOMD4_COMMAND4_DONE(value uint32) {
	volatile.StoreUint32(&o.COMD4.Reg, volatile.LoadUint32(&o.COMD4.Reg)&^(0x80000000)|value<<31)
}
func (o *I2C0_Type) GetCOMD4_COMMAND4_DONE() uint32 {
	return (volatile.LoadUint32(&o.COMD4.Reg) & 0x80000000) >> 31
}

// I2C0.COMD5: I2C command register 5
func (o *I2C0_Type) SetCOMD5_COMMAND5(value uint32) {
	volatile.StoreUint32(&o.COMD5.Reg, volatile.LoadUint32(&o.COMD5.Reg)&^(0x3fff)|value)
}
func (o *I2C0_Type) GetCOMD5_COMMAND5() uint32 {
	return volatile.LoadUint32(&o.COMD5.Reg) & 0x3fff
}
func (o *I2C0_Type) SetCOMD5_COMMAND5_DONE(value uint32) {
	volatile.StoreUint32(&o.COMD5.Reg, volatile.LoadUint32(&o.COMD5.Reg)&^(0x80000000)|value<<31)
}
func (o *I2C0_Type) GetCOMD5_COMMAND5_DONE() uint32 {
	return (volatile.LoadUint32(&o.COMD5.Reg) & 0x80000000) >> 31
}

// I2C0.COMD6: I2C command register 6
func (o *I2C0_Type) SetCOMD6_COMMAND6(value uint32) {
	volatile.StoreUint32(&o.COMD6.Reg, volatile.LoadUint32(&o.COMD6.Reg)&^(0x3fff)|value)
}
func (o *I2C0_Type) GetCOMD6_COMMAND6() uint32 {
	return volatile.LoadUint32(&o.COMD6.Reg) & 0x3fff
}
func (o *I2C0_Type) SetCOMD6_COMMAND6_DONE(value uint32) {
	volatile.StoreUint32(&o.COMD6.Reg, volatile.LoadUint32(&o.COMD6.Reg)&^(0x80000000)|value<<31)
}
func (o *I2C0_Type) GetCOMD6_COMMAND6_DONE() uint32 {
	return (volatile.LoadUint32(&o.COMD6.Reg) & 0x80000000) >> 31
}

// I2C0.COMD7: I2C command register 7
func (o *I2C0_Type) SetCOMD7_COMMAND7(value uint32) {
	volatile.StoreUint32(&o.COMD7.Reg, volatile.LoadUint32(&o.COMD7.Reg)&^(0x3fff)|value)
}
func (o *I2C0_Type) GetCOMD7_COMMAND7() uint32 {
	return volatile.LoadUint32(&o.COMD7.Reg) & 0x3fff
}
func (o *I2C0_Type) SetCOMD7_COMMAND7_DONE(value uint32) {
	volatile.StoreUint32(&o.COMD7.Reg, volatile.LoadUint32(&o.COMD7.Reg)&^(0x80000000)|value<<31)
}
func (o *I2C0_Type) GetCOMD7_COMMAND7_DONE() uint32 {
	return (volatile.LoadUint32(&o.COMD7.Reg) & 0x80000000) >> 31
}

// I2C0.COMD8: I2C command register 8
func (o *I2C0_Type) SetCOMD8_COMMAND8(value uint32) {
	volatile.StoreUint32(&o.COMD8.Reg, volatile.LoadUint32(&o.COMD8.Reg)&^(0x3fff)|value)
}
func (o *I2C0_Type) GetCOMD8_COMMAND8() uint32 {
	return volatile.LoadUint32(&o.COMD8.Reg) & 0x3fff
}
func (o *I2C0_Type) SetCOMD8_COMMAND8_DONE(value uint32) {
	volatile.StoreUint32(&o.COMD8.Reg, volatile.LoadUint32(&o.COMD8.Reg)&^(0x80000000)|value<<31)
}
func (o *I2C0_Type) GetCOMD8_COMMAND8_DONE() uint32 {
	return (volatile.LoadUint32(&o.COMD8.Reg) & 0x80000000) >> 31
}

// I2C0.COMD9: I2C command register 9
func (o *I2C0_Type) SetCOMD9_COMMAND9(value uint32) {
	volatile.StoreUint32(&o.COMD9.Reg, volatile.LoadUint32(&o.COMD9.Reg)&^(0x3fff)|value)
}
func (o *I2C0_Type) GetCOMD9_COMMAND9() uint32 {
	return volatile.LoadUint32(&o.COMD9.Reg) & 0x3fff
}
func (o *I2C0_Type) SetCOMD9_COMMAND9_DONE(value uint32) {
	volatile.StoreUint32(&o.COMD9.Reg, volatile.LoadUint32(&o.COMD9.Reg)&^(0x80000000)|value<<31)
}
func (o *I2C0_Type) GetCOMD9_COMMAND9_DONE() uint32 {
	return (volatile.LoadUint32(&o.COMD9.Reg) & 0x80000000) >> 31
}

// I2C0.COMD10: I2C command register 10
func (o *I2C0_Type) SetCOMD10_COMMAND10(value uint32) {
	volatile.StoreUint32(&o.COMD10.Reg, volatile.LoadUint32(&o.COMD10.Reg)&^(0x3fff)|value)
}
func (o *I2C0_Type) GetCOMD10_COMMAND10() uint32 {
	return volatile.LoadUint32(&o.COMD10.Reg) & 0x3fff
}
func (o *I2C0_Type) SetCOMD10_COMMAND10_DONE(value uint32) {
	volatile.StoreUint32(&o.COMD10.Reg, volatile.LoadUint32(&o.COMD10.Reg)&^(0x80000000)|value<<31)
}
func (o *I2C0_Type) GetCOMD10_COMMAND10_DONE() uint32 {
	return (volatile.LoadUint32(&o.COMD10.Reg) & 0x80000000) >> 31
}

// I2C0.COMD11: I2C command register 11
func (o *I2C0_Type) SetCOMD11_COMMAND11(value uint32) {
	volatile.StoreUint32(&o.COMD11.Reg, volatile.LoadUint32(&o.COMD11.Reg)&^(0x3fff)|value)
}
func (o *I2C0_Type) GetCOMD11_COMMAND11() uint32 {
	return volatile.LoadUint32(&o.COMD11.Reg) & 0x3fff
}
func (o *I2C0_Type) SetCOMD11_COMMAND11_DONE(value uint32) {
	volatile.StoreUint32(&o.COMD11.Reg, volatile.LoadUint32(&o.COMD11.Reg)&^(0x80000000)|value<<31)
}
func (o *I2C0_Type) GetCOMD11_COMMAND11_DONE() uint32 {
	return (volatile.LoadUint32(&o.COMD11.Reg) & 0x80000000) >> 31
}

// I2C0.COMD12: I2C command register 12
func (o *I2C0_Type) SetCOMD12_COMMAND12(value uint32) {
	volatile.StoreUint32(&o.COMD12.Reg, volatile.LoadUint32(&o.COMD12.Reg)&^(0x3fff)|value)
}
func (o *I2C0_Type) GetCOMD12_COMMAND12() uint32 {
	return volatile.LoadUint32(&o.COMD12.Reg) & 0x3fff
}
func (o *I2C0_Type) SetCOMD12_COMMAND12_DONE(value uint32) {
	volatile.StoreUint32(&o.COMD12.Reg, volatile.LoadUint32(&o.COMD12.Reg)&^(0x80000000)|value<<31)
}
func (o *I2C0_Type) GetCOMD12_COMMAND12_DONE() uint32 {
	return (volatile.LoadUint32(&o.COMD12.Reg) & 0x80000000) >> 31
}

// I2C0.COMD13: I2C command register 13
func (o *I2C0_Type) SetCOMD13_COMMAND13(value uint32) {
	volatile.StoreUint32(&o.COMD13.Reg, volatile.LoadUint32(&o.COMD13.Reg)&^(0x3fff)|value)
}
func (o *I2C0_Type) GetCOMD13_COMMAND13() uint32 {
	return volatile.LoadUint32(&o.COMD13.Reg) & 0x3fff
}
func (o *I2C0_Type) SetCOMD13_COMMAND13_DONE(value uint32) {
	volatile.StoreUint32(&o.COMD13.Reg, volatile.LoadUint32(&o.COMD13.Reg)&^(0x80000000)|value<<31)
}
func (o *I2C0_Type) GetCOMD13_COMMAND13_DONE() uint32 {
	return (volatile.LoadUint32(&o.COMD13.Reg) & 0x80000000) >> 31
}

// I2C0.COMD14: I2C command register 14
func (o *I2C0_Type) SetCOMD14_COMMAND14(value uint32) {
	volatile.StoreUint32(&o.COMD14.Reg, volatile.LoadUint32(&o.COMD14.Reg)&^(0x3fff)|value)
}
func (o *I2C0_Type) GetCOMD14_COMMAND14() uint32 {
	return volatile.LoadUint32(&o.COMD14.Reg) & 0x3fff
}
func (o *I2C0_Type) SetCOMD14_COMMAND14_DONE(value uint32) {
	volatile.StoreUint32(&o.COMD14.Reg, volatile.LoadUint32(&o.COMD14.Reg)&^(0x80000000)|value<<31)
}
func (o *I2C0_Type) GetCOMD14_COMMAND14_DONE() uint32 {
	return (volatile.LoadUint32(&o.COMD14.Reg) & 0x80000000) >> 31
}

// I2C0.COMD15: I2C command register 15
func (o *I2C0_Type) SetCOMD15_COMMAND15(value uint32) {
	volatile.StoreUint32(&o.COMD15.Reg, volatile.LoadUint32(&o.COMD15.Reg)&^(0x3fff)|value)
}
func (o *I2C0_Type) GetCOMD15_COMMAND15() uint32 {
	return volatile.LoadUint32(&o.COMD15.Reg) & 0x3fff
}
func (o *I2C0_Type) SetCOMD15_COMMAND15_DONE(value uint32) {
	volatile.StoreUint32(&o.COMD15.Reg, volatile.LoadUint32(&o.COMD15.Reg)&^(0x80000000)|value<<31)
}
func (o *I2C0_Type) GetCOMD15_COMMAND15_DONE() uint32 {
	return (volatile.LoadUint32(&o.COMD15.Reg) & 0x80000000) >> 31
}

// I2C0.SCL_ST_TIME_OUT: SCL status time out register
func (o *I2C0_Type) SetSCL_ST_TIME_OUT_SCL_ST_TO(value uint32) {
	volatile.StoreUint32(&o.SCL_ST_TIME_OUT.Reg, volatile.LoadUint32(&o.SCL_ST_TIME_OUT.Reg)&^(0xffffff)|value)
}
func (o *I2C0_Type) GetSCL_ST_TIME_OUT_SCL_ST_TO() uint32 {
	return volatile.LoadUint32(&o.SCL_ST_TIME_OUT.Reg) & 0xffffff
}

// I2C0.SCL_MAIN_ST_TIME_OUT: SCL main status time out register
func (o *I2C0_Type) SetSCL_MAIN_ST_TIME_OUT_SCL_MAIN_ST_TO(value uint32) {
	volatile.StoreUint32(&o.SCL_MAIN_ST_TIME_OUT.Reg, volatile.LoadUint32(&o.SCL_MAIN_ST_TIME_OUT.Reg)&^(0xffffff)|value)
}
func (o *I2C0_Type) GetSCL_MAIN_ST_TIME_OUT_SCL_MAIN_ST_TO() uint32 {
	return volatile.LoadUint32(&o.SCL_MAIN_ST_TIME_OUT.Reg) & 0xffffff
}

// I2C0.SCL_SP_CONF: Power configuration register
func (o *I2C0_Type) SetSCL_SP_CONF_SCL_RST_SLV_EN(value uint32) {
	volatile.StoreUint32(&o.SCL_SP_CONF.Reg, volatile.LoadUint32(&o.SCL_SP_CONF.Reg)&^(0x1)|value)
}
func (o *I2C0_Type) GetSCL_SP_CONF_SCL_RST_SLV_EN() uint32 {
	return volatile.LoadUint32(&o.SCL_SP_CONF.Reg) & 0x1
}
func (o *I2C0_Type) SetSCL_SP_CONF_SCL_RST_SLV_NUM(value uint32) {
	volatile.StoreUint32(&o.SCL_SP_CONF.Reg, volatile.LoadUint32(&o.SCL_SP_CONF.Reg)&^(0x3e)|value<<1)
}
func (o *I2C0_Type) GetSCL_SP_CONF_SCL_RST_SLV_NUM() uint32 {
	return (volatile.LoadUint32(&o.SCL_SP_CONF.Reg) & 0x3e) >> 1
}
func (o *I2C0_Type) SetSCL_SP_CONF_SCL_PD_EN(value uint32) {
	volatile.StoreUint32(&o.SCL_SP_CONF.Reg, volatile.LoadUint32(&o.SCL_SP_CONF.Reg)&^(0x40)|value<<6)
}
func (o *I2C0_Type) GetSCL_SP_CONF_SCL_PD_EN() uint32 {
	return (volatile.LoadUint32(&o.SCL_SP_CONF.Reg) & 0x40) >> 6
}
func (o *I2C0_Type) SetSCL_SP_CONF_SDA_PD_EN(value uint32) {
	volatile.StoreUint32(&o.SCL_SP_CONF.Reg, volatile.LoadUint32(&o.SCL_SP_CONF.Reg)&^(0x80)|value<<7)
}
func (o *I2C0_Type) GetSCL_SP_CONF_SDA_PD_EN() uint32 {
	return (volatile.LoadUint32(&o.SCL_SP_CONF.Reg) & 0x80) >> 7
}

// I2C0.SCL_STRETCH_CONF: Set SCL stretch of I2C slave
func (o *I2C0_Type) SetSCL_STRETCH_CONF_STRETCH_PROTECT_NUM(value uint32) {
	volatile.StoreUint32(&o.SCL_STRETCH_CONF.Reg, volatile.LoadUint32(&o.SCL_STRETCH_CONF.Reg)&^(0x3ff)|value)
}
func (o *I2C0_Type) GetSCL_STRETCH_CONF_STRETCH_PROTECT_NUM() uint32 {
	return volatile.LoadUint32(&o.SCL_STRETCH_CONF.Reg) & 0x3ff
}
func (o *I2C0_Type) SetSCL_STRETCH_CONF_SLAVE_SCL_STRETCH_EN(value uint32) {
	volatile.StoreUint32(&o.SCL_STRETCH_CONF.Reg, volatile.LoadUint32(&o.SCL_STRETCH_CONF.Reg)&^(0x400)|value<<10)
}
func (o *I2C0_Type) GetSCL_STRETCH_CONF_SLAVE_SCL_STRETCH_EN() uint32 {
	return (volatile.LoadUint32(&o.SCL_STRETCH_CONF.Reg) & 0x400) >> 10
}
func (o *I2C0_Type) SetSCL_STRETCH_CONF_SLAVE_SCL_STRETCH_CLR(value uint32) {
	volatile.StoreUint32(&o.SCL_STRETCH_CONF.Reg, volatile.LoadUint32(&o.SCL_STRETCH_CONF.Reg)&^(0x800)|value<<11)
}
func (o *I2C0_Type) GetSCL_STRETCH_CONF_SLAVE_SCL_STRETCH_CLR() uint32 {
	return (volatile.LoadUint32(&o.SCL_STRETCH_CONF.Reg) & 0x800) >> 11
}

// I2C0.DATE: Version control register
func (o *I2C0_Type) SetDATE(value uint32) {
	volatile.StoreUint32(&o.DATE.Reg, value)
}
func (o *I2C0_Type) GetDATE() uint32 {
	return volatile.LoadUint32(&o.DATE.Reg)
}

// Peripheral I2S
type I2S_Type struct {
	_                    [8]byte
	CONF                 volatile.Register32 // 0x8
	INT_RAW              volatile.Register32 // 0xC
	INT_ST               volatile.Register32 // 0x10
	INT_ENA              volatile.Register32 // 0x14
	INT_CLR              volatile.Register32 // 0x18
	TIMING               volatile.Register32 // 0x1C
	FIFO_CONF            volatile.Register32 // 0x20
	RXEOF_NUM            volatile.Register32 // 0x24
	CONF_SIGLE_DATA      volatile.Register32 // 0x28
	CONF_CHAN            volatile.Register32 // 0x2C
	OUT_LINK             volatile.Register32 // 0x30
	IN_LINK              volatile.Register32 // 0x34
	OUT_EOF_DES_ADDR     volatile.Register32 // 0x38
	IN_EOF_DES_ADDR      volatile.Register32 // 0x3C
	OUT_EOF_BFR_DES_ADDR volatile.Register32 // 0x40
	_                    [4]byte
	INLINK_DSCR          volatile.Register32 // 0x48
	INLINK_DSCR_BF0      volatile.Register32 // 0x4C
	INLINK_DSCR_BF1      volatile.Register32 // 0x50
	OUTLINK_DSCR         volatile.Register32 // 0x54
	OUTLINK_DSCR_BF0     volatile.Register32 // 0x58
	OUTLINK_DSCR_BF1     volatile.Register32 // 0x5C
	LC_CONF              volatile.Register32 // 0x60
	OUTFIFO_PUSH         volatile.Register32 // 0x64
	INFIFO_POP           volatile.Register32 // 0x68
	LC_STATE0            volatile.Register32 // 0x6C
	LC_STATE1            volatile.Register32 // 0x70
	LC_HUNG_CONF         volatile.Register32 // 0x74
	_                    [40]byte
	CONF1                volatile.Register32 // 0xA0
	PD_CONF              volatile.Register32 // 0xA4
	CONF2                volatile.Register32 // 0xA8
	CLKM_CONF            volatile.Register32 // 0xAC
	SAMPLE_RATE_CONF     volatile.Register32 // 0xB0
	_                    [8]byte
	STATE                volatile.Register32 // 0xBC
	_                    [60]byte
	DATE                 volatile.Register32 // 0xFC
}

// I2S.CONF: I2S Configure register
func (o *I2S_Type) SetCONF_TX_RESET(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0x1)|value)
}
func (o *I2S_Type) GetCONF_TX_RESET() uint32 {
	return volatile.LoadUint32(&o.CONF.Reg) & 0x1
}
func (o *I2S_Type) SetCONF_RX_RESET(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0x2)|value<<1)
}
func (o *I2S_Type) GetCONF_RX_RESET() uint32 {
	return (volatile.LoadUint32(&o.CONF.Reg) & 0x2) >> 1
}
func (o *I2S_Type) SetCONF_TX_FIFO_RESET(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0x4)|value<<2)
}
func (o *I2S_Type) GetCONF_TX_FIFO_RESET() uint32 {
	return (volatile.LoadUint32(&o.CONF.Reg) & 0x4) >> 2
}
func (o *I2S_Type) SetCONF_RX_FIFO_RESET(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0x8)|value<<3)
}
func (o *I2S_Type) GetCONF_RX_FIFO_RESET() uint32 {
	return (volatile.LoadUint32(&o.CONF.Reg) & 0x8) >> 3
}
func (o *I2S_Type) SetCONF_TX_START(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0x10)|value<<4)
}
func (o *I2S_Type) GetCONF_TX_START() uint32 {
	return (volatile.LoadUint32(&o.CONF.Reg) & 0x10) >> 4
}
func (o *I2S_Type) SetCONF_RX_START(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0x20)|value<<5)
}
func (o *I2S_Type) GetCONF_RX_START() uint32 {
	return (volatile.LoadUint32(&o.CONF.Reg) & 0x20) >> 5
}
func (o *I2S_Type) SetCONF_TX_SLAVE_MOD(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0x40)|value<<6)
}
func (o *I2S_Type) GetCONF_TX_SLAVE_MOD() uint32 {
	return (volatile.LoadUint32(&o.CONF.Reg) & 0x40) >> 6
}
func (o *I2S_Type) SetCONF_RX_SLAVE_MOD(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0x80)|value<<7)
}
func (o *I2S_Type) GetCONF_RX_SLAVE_MOD() uint32 {
	return (volatile.LoadUint32(&o.CONF.Reg) & 0x80) >> 7
}
func (o *I2S_Type) SetCONF_TX_RIGHT_FIRST(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0x100)|value<<8)
}
func (o *I2S_Type) GetCONF_TX_RIGHT_FIRST() uint32 {
	return (volatile.LoadUint32(&o.CONF.Reg) & 0x100) >> 8
}
func (o *I2S_Type) SetCONF_RX_RIGHT_FIRST(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0x200)|value<<9)
}
func (o *I2S_Type) GetCONF_RX_RIGHT_FIRST() uint32 {
	return (volatile.LoadUint32(&o.CONF.Reg) & 0x200) >> 9
}
func (o *I2S_Type) SetCONF_TX_MSB_SHIFT(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0x400)|value<<10)
}
func (o *I2S_Type) GetCONF_TX_MSB_SHIFT() uint32 {
	return (volatile.LoadUint32(&o.CONF.Reg) & 0x400) >> 10
}
func (o *I2S_Type) SetCONF_RX_MSB_SHIFT(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0x800)|value<<11)
}
func (o *I2S_Type) GetCONF_RX_MSB_SHIFT() uint32 {
	return (volatile.LoadUint32(&o.CONF.Reg) & 0x800) >> 11
}
func (o *I2S_Type) SetCONF_TX_SHORT_SYNC(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0x1000)|value<<12)
}
func (o *I2S_Type) GetCONF_TX_SHORT_SYNC() uint32 {
	return (volatile.LoadUint32(&o.CONF.Reg) & 0x1000) >> 12
}
func (o *I2S_Type) SetCONF_RX_SHORT_SYNC(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0x2000)|value<<13)
}
func (o *I2S_Type) GetCONF_RX_SHORT_SYNC() uint32 {
	return (volatile.LoadUint32(&o.CONF.Reg) & 0x2000) >> 13
}
func (o *I2S_Type) SetCONF_TX_MONO(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0x4000)|value<<14)
}
func (o *I2S_Type) GetCONF_TX_MONO() uint32 {
	return (volatile.LoadUint32(&o.CONF.Reg) & 0x4000) >> 14
}
func (o *I2S_Type) SetCONF_RX_MONO(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0x8000)|value<<15)
}
func (o *I2S_Type) GetCONF_RX_MONO() uint32 {
	return (volatile.LoadUint32(&o.CONF.Reg) & 0x8000) >> 15
}
func (o *I2S_Type) SetCONF_TX_MSB_RIGHT(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0x10000)|value<<16)
}
func (o *I2S_Type) GetCONF_TX_MSB_RIGHT() uint32 {
	return (volatile.LoadUint32(&o.CONF.Reg) & 0x10000) >> 16
}
func (o *I2S_Type) SetCONF_RX_MSB_RIGHT(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0x20000)|value<<17)
}
func (o *I2S_Type) GetCONF_RX_MSB_RIGHT() uint32 {
	return (volatile.LoadUint32(&o.CONF.Reg) & 0x20000) >> 17
}
func (o *I2S_Type) SetCONF_TX_LSB_FIRST_DMA(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0x40000)|value<<18)
}
func (o *I2S_Type) GetCONF_TX_LSB_FIRST_DMA() uint32 {
	return (volatile.LoadUint32(&o.CONF.Reg) & 0x40000) >> 18
}
func (o *I2S_Type) SetCONF_RX_LSB_FIRST_DMA(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0x80000)|value<<19)
}
func (o *I2S_Type) GetCONF_RX_LSB_FIRST_DMA() uint32 {
	return (volatile.LoadUint32(&o.CONF.Reg) & 0x80000) >> 19
}
func (o *I2S_Type) SetCONF_SIG_LOOPBACK(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0x100000)|value<<20)
}
func (o *I2S_Type) GetCONF_SIG_LOOPBACK() uint32 {
	return (volatile.LoadUint32(&o.CONF.Reg) & 0x100000) >> 20
}
func (o *I2S_Type) SetCONF_TX_FIFO_RESET_ST(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0x200000)|value<<21)
}
func (o *I2S_Type) GetCONF_TX_FIFO_RESET_ST() uint32 {
	return (volatile.LoadUint32(&o.CONF.Reg) & 0x200000) >> 21
}
func (o *I2S_Type) SetCONF_RX_FIFO_RESET_ST(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0x400000)|value<<22)
}
func (o *I2S_Type) GetCONF_RX_FIFO_RESET_ST() uint32 {
	return (volatile.LoadUint32(&o.CONF.Reg) & 0x400000) >> 22
}
func (o *I2S_Type) SetCONF_TX_RESET_ST(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0x800000)|value<<23)
}
func (o *I2S_Type) GetCONF_TX_RESET_ST() uint32 {
	return (volatile.LoadUint32(&o.CONF.Reg) & 0x800000) >> 23
}
func (o *I2S_Type) SetCONF_TX_DMA_EQUAL(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0x1000000)|value<<24)
}
func (o *I2S_Type) GetCONF_TX_DMA_EQUAL() uint32 {
	return (volatile.LoadUint32(&o.CONF.Reg) & 0x1000000) >> 24
}
func (o *I2S_Type) SetCONF_RX_DMA_EQUAL(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0x2000000)|value<<25)
}
func (o *I2S_Type) GetCONF_RX_DMA_EQUAL() uint32 {
	return (volatile.LoadUint32(&o.CONF.Reg) & 0x2000000) >> 25
}
func (o *I2S_Type) SetCONF_PRE_REQ_EN(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0x4000000)|value<<26)
}
func (o *I2S_Type) GetCONF_PRE_REQ_EN() uint32 {
	return (volatile.LoadUint32(&o.CONF.Reg) & 0x4000000) >> 26
}
func (o *I2S_Type) SetCONF_TX_BIG_ENDIAN(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0x8000000)|value<<27)
}
func (o *I2S_Type) GetCONF_TX_BIG_ENDIAN() uint32 {
	return (volatile.LoadUint32(&o.CONF.Reg) & 0x8000000) >> 27
}
func (o *I2S_Type) SetCONF_RX_BIG_ENDIAN(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0x10000000)|value<<28)
}
func (o *I2S_Type) GetCONF_RX_BIG_ENDIAN() uint32 {
	return (volatile.LoadUint32(&o.CONF.Reg) & 0x10000000) >> 28
}
func (o *I2S_Type) SetCONF_RX_RESET_ST(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0x20000000)|value<<29)
}
func (o *I2S_Type) GetCONF_RX_RESET_ST() uint32 {
	return (volatile.LoadUint32(&o.CONF.Reg) & 0x20000000) >> 29
}

// I2S.INT_RAW: Raw interrupt status
func (o *I2S_Type) SetINT_RAW_RX_TAKE_DATA_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x1)|value)
}
func (o *I2S_Type) GetINT_RAW_RX_TAKE_DATA_INT_RAW() uint32 {
	return volatile.LoadUint32(&o.INT_RAW.Reg) & 0x1
}
func (o *I2S_Type) SetINT_RAW_TX_PUT_DATA_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x2)|value<<1)
}
func (o *I2S_Type) GetINT_RAW_TX_PUT_DATA_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x2) >> 1
}
func (o *I2S_Type) SetINT_RAW_RX_WFULL_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x4)|value<<2)
}
func (o *I2S_Type) GetINT_RAW_RX_WFULL_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x4) >> 2
}
func (o *I2S_Type) SetINT_RAW_RX_REMPTY_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x8)|value<<3)
}
func (o *I2S_Type) GetINT_RAW_RX_REMPTY_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x8) >> 3
}
func (o *I2S_Type) SetINT_RAW_TX_WFULL_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x10)|value<<4)
}
func (o *I2S_Type) GetINT_RAW_TX_WFULL_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x10) >> 4
}
func (o *I2S_Type) SetINT_RAW_TX_REMPTY_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x20)|value<<5)
}
func (o *I2S_Type) GetINT_RAW_TX_REMPTY_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x20) >> 5
}
func (o *I2S_Type) SetINT_RAW_RX_HUNG_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x40)|value<<6)
}
func (o *I2S_Type) GetINT_RAW_RX_HUNG_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x40) >> 6
}
func (o *I2S_Type) SetINT_RAW_TX_HUNG_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x80)|value<<7)
}
func (o *I2S_Type) GetINT_RAW_TX_HUNG_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x80) >> 7
}
func (o *I2S_Type) SetINT_RAW_IN_DONE_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x100)|value<<8)
}
func (o *I2S_Type) GetINT_RAW_IN_DONE_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x100) >> 8
}
func (o *I2S_Type) SetINT_RAW_IN_SUC_EOF_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x200)|value<<9)
}
func (o *I2S_Type) GetINT_RAW_IN_SUC_EOF_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x200) >> 9
}
func (o *I2S_Type) SetINT_RAW_IN_ERR_EOF_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x400)|value<<10)
}
func (o *I2S_Type) GetINT_RAW_IN_ERR_EOF_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x400) >> 10
}
func (o *I2S_Type) SetINT_RAW_OUT_DONE_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x800)|value<<11)
}
func (o *I2S_Type) GetINT_RAW_OUT_DONE_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x800) >> 11
}
func (o *I2S_Type) SetINT_RAW_OUT_EOF_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x1000)|value<<12)
}
func (o *I2S_Type) GetINT_RAW_OUT_EOF_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x1000) >> 12
}
func (o *I2S_Type) SetINT_RAW_IN_DSCR_ERR_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x2000)|value<<13)
}
func (o *I2S_Type) GetINT_RAW_IN_DSCR_ERR_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x2000) >> 13
}
func (o *I2S_Type) SetINT_RAW_OUT_DSCR_ERR_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x4000)|value<<14)
}
func (o *I2S_Type) GetINT_RAW_OUT_DSCR_ERR_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x4000) >> 14
}
func (o *I2S_Type) SetINT_RAW_IN_DSCR_EMPTY_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x8000)|value<<15)
}
func (o *I2S_Type) GetINT_RAW_IN_DSCR_EMPTY_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x8000) >> 15
}
func (o *I2S_Type) SetINT_RAW_OUT_TOTAL_EOF_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x10000)|value<<16)
}
func (o *I2S_Type) GetINT_RAW_OUT_TOTAL_EOF_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x10000) >> 16
}
func (o *I2S_Type) SetINT_RAW_V_SYNC_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x20000)|value<<17)
}
func (o *I2S_Type) GetINT_RAW_V_SYNC_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x20000) >> 17
}

// I2S.INT_ST: Masked interrupt status
func (o *I2S_Type) SetINT_ST_RX_TAKE_DATA_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x1)|value)
}
func (o *I2S_Type) GetINT_ST_RX_TAKE_DATA_INT_ST() uint32 {
	return volatile.LoadUint32(&o.INT_ST.Reg) & 0x1
}
func (o *I2S_Type) SetINT_ST_TX_PUT_DATA_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x2)|value<<1)
}
func (o *I2S_Type) GetINT_ST_TX_PUT_DATA_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x2) >> 1
}
func (o *I2S_Type) SetINT_ST_RX_WFULL_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x4)|value<<2)
}
func (o *I2S_Type) GetINT_ST_RX_WFULL_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x4) >> 2
}
func (o *I2S_Type) SetINT_ST_RX_REMPTY_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x8)|value<<3)
}
func (o *I2S_Type) GetINT_ST_RX_REMPTY_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x8) >> 3
}
func (o *I2S_Type) SetINT_ST_TX_WFULL_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x10)|value<<4)
}
func (o *I2S_Type) GetINT_ST_TX_WFULL_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x10) >> 4
}
func (o *I2S_Type) SetINT_ST_TX_REMPTY_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x20)|value<<5)
}
func (o *I2S_Type) GetINT_ST_TX_REMPTY_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x20) >> 5
}
func (o *I2S_Type) SetINT_ST_RX_HUNG_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x40)|value<<6)
}
func (o *I2S_Type) GetINT_ST_RX_HUNG_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x40) >> 6
}
func (o *I2S_Type) SetINT_ST_TX_HUNG_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x80)|value<<7)
}
func (o *I2S_Type) GetINT_ST_TX_HUNG_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x80) >> 7
}
func (o *I2S_Type) SetINT_ST_IN_DONE_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x100)|value<<8)
}
func (o *I2S_Type) GetINT_ST_IN_DONE_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x100) >> 8
}
func (o *I2S_Type) SetINT_ST_IN_SUC_EOF_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x200)|value<<9)
}
func (o *I2S_Type) GetINT_ST_IN_SUC_EOF_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x200) >> 9
}
func (o *I2S_Type) SetINT_ST_IN_ERR_EOF_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x400)|value<<10)
}
func (o *I2S_Type) GetINT_ST_IN_ERR_EOF_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x400) >> 10
}
func (o *I2S_Type) SetINT_ST_OUT_DONE_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x800)|value<<11)
}
func (o *I2S_Type) GetINT_ST_OUT_DONE_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x800) >> 11
}
func (o *I2S_Type) SetINT_ST_OUT_EOF_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x1000)|value<<12)
}
func (o *I2S_Type) GetINT_ST_OUT_EOF_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x1000) >> 12
}
func (o *I2S_Type) SetINT_ST_IN_DSCR_ERR_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x2000)|value<<13)
}
func (o *I2S_Type) GetINT_ST_IN_DSCR_ERR_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x2000) >> 13
}
func (o *I2S_Type) SetINT_ST_OUT_DSCR_ERR_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x4000)|value<<14)
}
func (o *I2S_Type) GetINT_ST_OUT_DSCR_ERR_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x4000) >> 14
}
func (o *I2S_Type) SetINT_ST_IN_DSCR_EMPTY_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x8000)|value<<15)
}
func (o *I2S_Type) GetINT_ST_IN_DSCR_EMPTY_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x8000) >> 15
}
func (o *I2S_Type) SetINT_ST_OUT_TOTAL_EOF_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x10000)|value<<16)
}
func (o *I2S_Type) GetINT_ST_OUT_TOTAL_EOF_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x10000) >> 16
}
func (o *I2S_Type) SetINT_ST_V_SYNC_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x20000)|value<<17)
}
func (o *I2S_Type) GetINT_ST_V_SYNC_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x20000) >> 17
}

// I2S.INT_ENA: Interrupt enable bits
func (o *I2S_Type) SetINT_ENA_RX_TAKE_DATA_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x1)|value)
}
func (o *I2S_Type) GetINT_ENA_RX_TAKE_DATA_INT_ENA() uint32 {
	return volatile.LoadUint32(&o.INT_ENA.Reg) & 0x1
}
func (o *I2S_Type) SetINT_ENA_TX_PUT_DATA_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x2)|value<<1)
}
func (o *I2S_Type) GetINT_ENA_TX_PUT_DATA_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x2) >> 1
}
func (o *I2S_Type) SetINT_ENA_RX_WFULL_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x4)|value<<2)
}
func (o *I2S_Type) GetINT_ENA_RX_WFULL_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x4) >> 2
}
func (o *I2S_Type) SetINT_ENA_RX_REMPTY_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x8)|value<<3)
}
func (o *I2S_Type) GetINT_ENA_RX_REMPTY_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x8) >> 3
}
func (o *I2S_Type) SetINT_ENA_TX_WFULL_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x10)|value<<4)
}
func (o *I2S_Type) GetINT_ENA_TX_WFULL_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x10) >> 4
}
func (o *I2S_Type) SetINT_ENA_TX_REMPTY_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x20)|value<<5)
}
func (o *I2S_Type) GetINT_ENA_TX_REMPTY_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x20) >> 5
}
func (o *I2S_Type) SetINT_ENA_RX_HUNG_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x40)|value<<6)
}
func (o *I2S_Type) GetINT_ENA_RX_HUNG_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x40) >> 6
}
func (o *I2S_Type) SetINT_ENA_TX_HUNG_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x80)|value<<7)
}
func (o *I2S_Type) GetINT_ENA_TX_HUNG_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x80) >> 7
}
func (o *I2S_Type) SetINT_ENA_IN_DONE_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x100)|value<<8)
}
func (o *I2S_Type) GetINT_ENA_IN_DONE_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x100) >> 8
}
func (o *I2S_Type) SetINT_ENA_IN_SUC_EOF_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x200)|value<<9)
}
func (o *I2S_Type) GetINT_ENA_IN_SUC_EOF_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x200) >> 9
}
func (o *I2S_Type) SetINT_ENA_IN_ERR_EOF_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x400)|value<<10)
}
func (o *I2S_Type) GetINT_ENA_IN_ERR_EOF_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x400) >> 10
}
func (o *I2S_Type) SetINT_ENA_OUT_DONE_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x800)|value<<11)
}
func (o *I2S_Type) GetINT_ENA_OUT_DONE_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x800) >> 11
}
func (o *I2S_Type) SetINT_ENA_OUT_EOF_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x1000)|value<<12)
}
func (o *I2S_Type) GetINT_ENA_OUT_EOF_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x1000) >> 12
}
func (o *I2S_Type) SetINT_ENA_IN_DSCR_ERR_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x2000)|value<<13)
}
func (o *I2S_Type) GetINT_ENA_IN_DSCR_ERR_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x2000) >> 13
}
func (o *I2S_Type) SetINT_ENA_OUT_DSCR_ERR_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x4000)|value<<14)
}
func (o *I2S_Type) GetINT_ENA_OUT_DSCR_ERR_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x4000) >> 14
}
func (o *I2S_Type) SetINT_ENA_IN_DSCR_EMPTY_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x8000)|value<<15)
}
func (o *I2S_Type) GetINT_ENA_IN_DSCR_EMPTY_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x8000) >> 15
}
func (o *I2S_Type) SetINT_ENA_OUT_TOTAL_EOF_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x10000)|value<<16)
}
func (o *I2S_Type) GetINT_ENA_OUT_TOTAL_EOF_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x10000) >> 16
}
func (o *I2S_Type) SetINT_ENA_V_SYNC_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x20000)|value<<17)
}
func (o *I2S_Type) GetINT_ENA_V_SYNC_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x20000) >> 17
}

// I2S.INT_CLR: Interrupt clear bits
func (o *I2S_Type) SetINT_CLR_TAKE_DATA_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x1)|value)
}
func (o *I2S_Type) GetINT_CLR_TAKE_DATA_INT_CLR() uint32 {
	return volatile.LoadUint32(&o.INT_CLR.Reg) & 0x1
}
func (o *I2S_Type) SetINT_CLR_PUT_DATA_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x2)|value<<1)
}
func (o *I2S_Type) GetINT_CLR_PUT_DATA_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x2) >> 1
}
func (o *I2S_Type) SetINT_CLR_RX_WFULL_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x4)|value<<2)
}
func (o *I2S_Type) GetINT_CLR_RX_WFULL_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x4) >> 2
}
func (o *I2S_Type) SetINT_CLR_RX_REMPTY_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x8)|value<<3)
}
func (o *I2S_Type) GetINT_CLR_RX_REMPTY_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x8) >> 3
}
func (o *I2S_Type) SetINT_CLR_TX_WFULL_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x10)|value<<4)
}
func (o *I2S_Type) GetINT_CLR_TX_WFULL_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x10) >> 4
}
func (o *I2S_Type) SetINT_CLR_TX_REMPTY_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x20)|value<<5)
}
func (o *I2S_Type) GetINT_CLR_TX_REMPTY_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x20) >> 5
}
func (o *I2S_Type) SetINT_CLR_RX_HUNG_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x40)|value<<6)
}
func (o *I2S_Type) GetINT_CLR_RX_HUNG_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x40) >> 6
}
func (o *I2S_Type) SetINT_CLR_TX_HUNG_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x80)|value<<7)
}
func (o *I2S_Type) GetINT_CLR_TX_HUNG_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x80) >> 7
}
func (o *I2S_Type) SetINT_CLR_IN_DONE_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x100)|value<<8)
}
func (o *I2S_Type) GetINT_CLR_IN_DONE_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x100) >> 8
}
func (o *I2S_Type) SetINT_CLR_IN_SUC_EOF_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x200)|value<<9)
}
func (o *I2S_Type) GetINT_CLR_IN_SUC_EOF_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x200) >> 9
}
func (o *I2S_Type) SetINT_CLR_IN_ERR_EOF_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x400)|value<<10)
}
func (o *I2S_Type) GetINT_CLR_IN_ERR_EOF_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x400) >> 10
}
func (o *I2S_Type) SetINT_CLR_OUT_DONE_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x800)|value<<11)
}
func (o *I2S_Type) GetINT_CLR_OUT_DONE_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x800) >> 11
}
func (o *I2S_Type) SetINT_CLR_OUT_EOF_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x1000)|value<<12)
}
func (o *I2S_Type) GetINT_CLR_OUT_EOF_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x1000) >> 12
}
func (o *I2S_Type) SetINT_CLR_IN_DSCR_ERR_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x2000)|value<<13)
}
func (o *I2S_Type) GetINT_CLR_IN_DSCR_ERR_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x2000) >> 13
}
func (o *I2S_Type) SetINT_CLR_OUT_DSCR_ERR_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x4000)|value<<14)
}
func (o *I2S_Type) GetINT_CLR_OUT_DSCR_ERR_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x4000) >> 14
}
func (o *I2S_Type) SetINT_CLR_IN_DSCR_EMPTY_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x8000)|value<<15)
}
func (o *I2S_Type) GetINT_CLR_IN_DSCR_EMPTY_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x8000) >> 15
}
func (o *I2S_Type) SetINT_CLR_OUT_TOTAL_EOF_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x10000)|value<<16)
}
func (o *I2S_Type) GetINT_CLR_OUT_TOTAL_EOF_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x10000) >> 16
}
func (o *I2S_Type) SetINT_CLR_V_SYNC_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x20000)|value<<17)
}
func (o *I2S_Type) GetINT_CLR_V_SYNC_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x20000) >> 17
}

// I2S.TIMING: I2S timing register
func (o *I2S_Type) SetTIMING_TX_BCK_IN_DELAY(value uint32) {
	volatile.StoreUint32(&o.TIMING.Reg, volatile.LoadUint32(&o.TIMING.Reg)&^(0x3)|value)
}
func (o *I2S_Type) GetTIMING_TX_BCK_IN_DELAY() uint32 {
	return volatile.LoadUint32(&o.TIMING.Reg) & 0x3
}
func (o *I2S_Type) SetTIMING_TX_WS_IN_DELAY(value uint32) {
	volatile.StoreUint32(&o.TIMING.Reg, volatile.LoadUint32(&o.TIMING.Reg)&^(0xc)|value<<2)
}
func (o *I2S_Type) GetTIMING_TX_WS_IN_DELAY() uint32 {
	return (volatile.LoadUint32(&o.TIMING.Reg) & 0xc) >> 2
}
func (o *I2S_Type) SetTIMING_RX_BCK_IN_DELAY(value uint32) {
	volatile.StoreUint32(&o.TIMING.Reg, volatile.LoadUint32(&o.TIMING.Reg)&^(0x30)|value<<4)
}
func (o *I2S_Type) GetTIMING_RX_BCK_IN_DELAY() uint32 {
	return (volatile.LoadUint32(&o.TIMING.Reg) & 0x30) >> 4
}
func (o *I2S_Type) SetTIMING_RX_WS_IN_DELAY(value uint32) {
	volatile.StoreUint32(&o.TIMING.Reg, volatile.LoadUint32(&o.TIMING.Reg)&^(0xc0)|value<<6)
}
func (o *I2S_Type) GetTIMING_RX_WS_IN_DELAY() uint32 {
	return (volatile.LoadUint32(&o.TIMING.Reg) & 0xc0) >> 6
}
func (o *I2S_Type) SetTIMING_RX_SD_IN_DELAY(value uint32) {
	volatile.StoreUint32(&o.TIMING.Reg, volatile.LoadUint32(&o.TIMING.Reg)&^(0x300)|value<<8)
}
func (o *I2S_Type) GetTIMING_RX_SD_IN_DELAY() uint32 {
	return (volatile.LoadUint32(&o.TIMING.Reg) & 0x300) >> 8
}
func (o *I2S_Type) SetTIMING_TX_BCK_OUT_DELAY(value uint32) {
	volatile.StoreUint32(&o.TIMING.Reg, volatile.LoadUint32(&o.TIMING.Reg)&^(0xc00)|value<<10)
}
func (o *I2S_Type) GetTIMING_TX_BCK_OUT_DELAY() uint32 {
	return (volatile.LoadUint32(&o.TIMING.Reg) & 0xc00) >> 10
}
func (o *I2S_Type) SetTIMING_TX_WS_OUT_DELAY(value uint32) {
	volatile.StoreUint32(&o.TIMING.Reg, volatile.LoadUint32(&o.TIMING.Reg)&^(0x3000)|value<<12)
}
func (o *I2S_Type) GetTIMING_TX_WS_OUT_DELAY() uint32 {
	return (volatile.LoadUint32(&o.TIMING.Reg) & 0x3000) >> 12
}
func (o *I2S_Type) SetTIMING_TX_SD_OUT_DELAY(value uint32) {
	volatile.StoreUint32(&o.TIMING.Reg, volatile.LoadUint32(&o.TIMING.Reg)&^(0xc000)|value<<14)
}
func (o *I2S_Type) GetTIMING_TX_SD_OUT_DELAY() uint32 {
	return (volatile.LoadUint32(&o.TIMING.Reg) & 0xc000) >> 14
}
func (o *I2S_Type) SetTIMING_RX_WS_OUT_DELAY(value uint32) {
	volatile.StoreUint32(&o.TIMING.Reg, volatile.LoadUint32(&o.TIMING.Reg)&^(0x30000)|value<<16)
}
func (o *I2S_Type) GetTIMING_RX_WS_OUT_DELAY() uint32 {
	return (volatile.LoadUint32(&o.TIMING.Reg) & 0x30000) >> 16
}
func (o *I2S_Type) SetTIMING_RX_BCK_OUT_DELAY(value uint32) {
	volatile.StoreUint32(&o.TIMING.Reg, volatile.LoadUint32(&o.TIMING.Reg)&^(0xc0000)|value<<18)
}
func (o *I2S_Type) GetTIMING_RX_BCK_OUT_DELAY() uint32 {
	return (volatile.LoadUint32(&o.TIMING.Reg) & 0xc0000) >> 18
}
func (o *I2S_Type) SetTIMING_TX_DSYNC_SW(value uint32) {
	volatile.StoreUint32(&o.TIMING.Reg, volatile.LoadUint32(&o.TIMING.Reg)&^(0x100000)|value<<20)
}
func (o *I2S_Type) GetTIMING_TX_DSYNC_SW() uint32 {
	return (volatile.LoadUint32(&o.TIMING.Reg) & 0x100000) >> 20
}
func (o *I2S_Type) SetTIMING_RX_DSYNC_SW(value uint32) {
	volatile.StoreUint32(&o.TIMING.Reg, volatile.LoadUint32(&o.TIMING.Reg)&^(0x200000)|value<<21)
}
func (o *I2S_Type) GetTIMING_RX_DSYNC_SW() uint32 {
	return (volatile.LoadUint32(&o.TIMING.Reg) & 0x200000) >> 21
}
func (o *I2S_Type) SetTIMING_DATA_ENABLE_DELAY(value uint32) {
	volatile.StoreUint32(&o.TIMING.Reg, volatile.LoadUint32(&o.TIMING.Reg)&^(0xc00000)|value<<22)
}
func (o *I2S_Type) GetTIMING_DATA_ENABLE_DELAY() uint32 {
	return (volatile.LoadUint32(&o.TIMING.Reg) & 0xc00000) >> 22
}
func (o *I2S_Type) SetTIMING_TX_BCK_IN_INV(value uint32) {
	volatile.StoreUint32(&o.TIMING.Reg, volatile.LoadUint32(&o.TIMING.Reg)&^(0x1000000)|value<<24)
}
func (o *I2S_Type) GetTIMING_TX_BCK_IN_INV() uint32 {
	return (volatile.LoadUint32(&o.TIMING.Reg) & 0x1000000) >> 24
}

// I2S.FIFO_CONF: I2S FIFO configure register
func (o *I2S_Type) SetFIFO_CONF_RX_DATA_NUM(value uint32) {
	volatile.StoreUint32(&o.FIFO_CONF.Reg, volatile.LoadUint32(&o.FIFO_CONF.Reg)&^(0x3f)|value)
}
func (o *I2S_Type) GetFIFO_CONF_RX_DATA_NUM() uint32 {
	return volatile.LoadUint32(&o.FIFO_CONF.Reg) & 0x3f
}
func (o *I2S_Type) SetFIFO_CONF_TX_DATA_NUM(value uint32) {
	volatile.StoreUint32(&o.FIFO_CONF.Reg, volatile.LoadUint32(&o.FIFO_CONF.Reg)&^(0xfc0)|value<<6)
}
func (o *I2S_Type) GetFIFO_CONF_TX_DATA_NUM() uint32 {
	return (volatile.LoadUint32(&o.FIFO_CONF.Reg) & 0xfc0) >> 6
}
func (o *I2S_Type) SetFIFO_CONF_DSCR_EN(value uint32) {
	volatile.StoreUint32(&o.FIFO_CONF.Reg, volatile.LoadUint32(&o.FIFO_CONF.Reg)&^(0x1000)|value<<12)
}
func (o *I2S_Type) GetFIFO_CONF_DSCR_EN() uint32 {
	return (volatile.LoadUint32(&o.FIFO_CONF.Reg) & 0x1000) >> 12
}
func (o *I2S_Type) SetFIFO_CONF_TX_FIFO_MOD(value uint32) {
	volatile.StoreUint32(&o.FIFO_CONF.Reg, volatile.LoadUint32(&o.FIFO_CONF.Reg)&^(0xe000)|value<<13)
}
func (o *I2S_Type) GetFIFO_CONF_TX_FIFO_MOD() uint32 {
	return (volatile.LoadUint32(&o.FIFO_CONF.Reg) & 0xe000) >> 13
}
func (o *I2S_Type) SetFIFO_CONF_RX_FIFO_MOD(value uint32) {
	volatile.StoreUint32(&o.FIFO_CONF.Reg, volatile.LoadUint32(&o.FIFO_CONF.Reg)&^(0x70000)|value<<16)
}
func (o *I2S_Type) GetFIFO_CONF_RX_FIFO_MOD() uint32 {
	return (volatile.LoadUint32(&o.FIFO_CONF.Reg) & 0x70000) >> 16
}
func (o *I2S_Type) SetFIFO_CONF_TX_FIFO_MOD_FORCE_EN(value uint32) {
	volatile.StoreUint32(&o.FIFO_CONF.Reg, volatile.LoadUint32(&o.FIFO_CONF.Reg)&^(0x80000)|value<<19)
}
func (o *I2S_Type) GetFIFO_CONF_TX_FIFO_MOD_FORCE_EN() uint32 {
	return (volatile.LoadUint32(&o.FIFO_CONF.Reg) & 0x80000) >> 19
}
func (o *I2S_Type) SetFIFO_CONF_RX_FIFO_MOD_FORCE_EN(value uint32) {
	volatile.StoreUint32(&o.FIFO_CONF.Reg, volatile.LoadUint32(&o.FIFO_CONF.Reg)&^(0x100000)|value<<20)
}
func (o *I2S_Type) GetFIFO_CONF_RX_FIFO_MOD_FORCE_EN() uint32 {
	return (volatile.LoadUint32(&o.FIFO_CONF.Reg) & 0x100000) >> 20
}
func (o *I2S_Type) SetFIFO_CONF_RX_FIFO_SYNC(value uint32) {
	volatile.StoreUint32(&o.FIFO_CONF.Reg, volatile.LoadUint32(&o.FIFO_CONF.Reg)&^(0x200000)|value<<21)
}
func (o *I2S_Type) GetFIFO_CONF_RX_FIFO_SYNC() uint32 {
	return (volatile.LoadUint32(&o.FIFO_CONF.Reg) & 0x200000) >> 21
}
func (o *I2S_Type) SetFIFO_CONF_RX_24MSB_EN(value uint32) {
	volatile.StoreUint32(&o.FIFO_CONF.Reg, volatile.LoadUint32(&o.FIFO_CONF.Reg)&^(0x400000)|value<<22)
}
func (o *I2S_Type) GetFIFO_CONF_RX_24MSB_EN() uint32 {
	return (volatile.LoadUint32(&o.FIFO_CONF.Reg) & 0x400000) >> 22
}
func (o *I2S_Type) SetFIFO_CONF_TX_24MSB_EN(value uint32) {
	volatile.StoreUint32(&o.FIFO_CONF.Reg, volatile.LoadUint32(&o.FIFO_CONF.Reg)&^(0x800000)|value<<23)
}
func (o *I2S_Type) GetFIFO_CONF_TX_24MSB_EN() uint32 {
	return (volatile.LoadUint32(&o.FIFO_CONF.Reg) & 0x800000) >> 23
}

// I2S.RXEOF_NUM: I2S DMA RX EOF data length
func (o *I2S_Type) SetRXEOF_NUM(value uint32) {
	volatile.StoreUint32(&o.RXEOF_NUM.Reg, value)
}
func (o *I2S_Type) GetRXEOF_NUM() uint32 {
	return volatile.LoadUint32(&o.RXEOF_NUM.Reg)
}

// I2S.CONF_SIGLE_DATA: Constant single channel data
func (o *I2S_Type) SetCONF_SIGLE_DATA(value uint32) {
	volatile.StoreUint32(&o.CONF_SIGLE_DATA.Reg, value)
}
func (o *I2S_Type) GetCONF_SIGLE_DATA() uint32 {
	return volatile.LoadUint32(&o.CONF_SIGLE_DATA.Reg)
}

// I2S.CONF_CHAN: I2S channel configure register
func (o *I2S_Type) SetCONF_CHAN_TX_CHAN_MOD(value uint32) {
	volatile.StoreUint32(&o.CONF_CHAN.Reg, volatile.LoadUint32(&o.CONF_CHAN.Reg)&^(0x7)|value)
}
func (o *I2S_Type) GetCONF_CHAN_TX_CHAN_MOD() uint32 {
	return volatile.LoadUint32(&o.CONF_CHAN.Reg) & 0x7
}
func (o *I2S_Type) SetCONF_CHAN_RX_CHAN_MOD(value uint32) {
	volatile.StoreUint32(&o.CONF_CHAN.Reg, volatile.LoadUint32(&o.CONF_CHAN.Reg)&^(0x18)|value<<3)
}
func (o *I2S_Type) GetCONF_CHAN_RX_CHAN_MOD() uint32 {
	return (volatile.LoadUint32(&o.CONF_CHAN.Reg) & 0x18) >> 3
}

// I2S.OUT_LINK: I2S DMA TX configure register
func (o *I2S_Type) SetOUT_LINK_OUTLINK_ADDR(value uint32) {
	volatile.StoreUint32(&o.OUT_LINK.Reg, volatile.LoadUint32(&o.OUT_LINK.Reg)&^(0xfffff)|value)
}
func (o *I2S_Type) GetOUT_LINK_OUTLINK_ADDR() uint32 {
	return volatile.LoadUint32(&o.OUT_LINK.Reg) & 0xfffff
}
func (o *I2S_Type) SetOUT_LINK_OUTLINK_STOP(value uint32) {
	volatile.StoreUint32(&o.OUT_LINK.Reg, volatile.LoadUint32(&o.OUT_LINK.Reg)&^(0x10000000)|value<<28)
}
func (o *I2S_Type) GetOUT_LINK_OUTLINK_STOP() uint32 {
	return (volatile.LoadUint32(&o.OUT_LINK.Reg) & 0x10000000) >> 28
}
func (o *I2S_Type) SetOUT_LINK_OUTLINK_START(value uint32) {
	volatile.StoreUint32(&o.OUT_LINK.Reg, volatile.LoadUint32(&o.OUT_LINK.Reg)&^(0x20000000)|value<<29)
}
func (o *I2S_Type) GetOUT_LINK_OUTLINK_START() uint32 {
	return (volatile.LoadUint32(&o.OUT_LINK.Reg) & 0x20000000) >> 29
}
func (o *I2S_Type) SetOUT_LINK_OUTLINK_RESTART(value uint32) {
	volatile.StoreUint32(&o.OUT_LINK.Reg, volatile.LoadUint32(&o.OUT_LINK.Reg)&^(0x40000000)|value<<30)
}
func (o *I2S_Type) GetOUT_LINK_OUTLINK_RESTART() uint32 {
	return (volatile.LoadUint32(&o.OUT_LINK.Reg) & 0x40000000) >> 30
}
func (o *I2S_Type) SetOUT_LINK_OUTLINK_PARK(value uint32) {
	volatile.StoreUint32(&o.OUT_LINK.Reg, volatile.LoadUint32(&o.OUT_LINK.Reg)&^(0x80000000)|value<<31)
}
func (o *I2S_Type) GetOUT_LINK_OUTLINK_PARK() uint32 {
	return (volatile.LoadUint32(&o.OUT_LINK.Reg) & 0x80000000) >> 31
}

// I2S.IN_LINK: I2S DMA RX configure register
func (o *I2S_Type) SetIN_LINK_INLINK_ADDR(value uint32) {
	volatile.StoreUint32(&o.IN_LINK.Reg, volatile.LoadUint32(&o.IN_LINK.Reg)&^(0xfffff)|value)
}
func (o *I2S_Type) GetIN_LINK_INLINK_ADDR() uint32 {
	return volatile.LoadUint32(&o.IN_LINK.Reg) & 0xfffff
}
func (o *I2S_Type) SetIN_LINK_INLINK_STOP(value uint32) {
	volatile.StoreUint32(&o.IN_LINK.Reg, volatile.LoadUint32(&o.IN_LINK.Reg)&^(0x10000000)|value<<28)
}
func (o *I2S_Type) GetIN_LINK_INLINK_STOP() uint32 {
	return (volatile.LoadUint32(&o.IN_LINK.Reg) & 0x10000000) >> 28
}
func (o *I2S_Type) SetIN_LINK_INLINK_START(value uint32) {
	volatile.StoreUint32(&o.IN_LINK.Reg, volatile.LoadUint32(&o.IN_LINK.Reg)&^(0x20000000)|value<<29)
}
func (o *I2S_Type) GetIN_LINK_INLINK_START() uint32 {
	return (volatile.LoadUint32(&o.IN_LINK.Reg) & 0x20000000) >> 29
}
func (o *I2S_Type) SetIN_LINK_INLINK_RESTART(value uint32) {
	volatile.StoreUint32(&o.IN_LINK.Reg, volatile.LoadUint32(&o.IN_LINK.Reg)&^(0x40000000)|value<<30)
}
func (o *I2S_Type) GetIN_LINK_INLINK_RESTART() uint32 {
	return (volatile.LoadUint32(&o.IN_LINK.Reg) & 0x40000000) >> 30
}
func (o *I2S_Type) SetIN_LINK_INLINK_PARK(value uint32) {
	volatile.StoreUint32(&o.IN_LINK.Reg, volatile.LoadUint32(&o.IN_LINK.Reg)&^(0x80000000)|value<<31)
}
func (o *I2S_Type) GetIN_LINK_INLINK_PARK() uint32 {
	return (volatile.LoadUint32(&o.IN_LINK.Reg) & 0x80000000) >> 31
}

// I2S.OUT_EOF_DES_ADDR: The address of outlink descriptor that produces EOF
func (o *I2S_Type) SetOUT_EOF_DES_ADDR(value uint32) {
	volatile.StoreUint32(&o.OUT_EOF_DES_ADDR.Reg, value)
}
func (o *I2S_Type) GetOUT_EOF_DES_ADDR() uint32 {
	return volatile.LoadUint32(&o.OUT_EOF_DES_ADDR.Reg)
}

// I2S.IN_EOF_DES_ADDR: The address of inlink descriptor that produces EOF
func (o *I2S_Type) SetIN_EOF_DES_ADDR(value uint32) {
	volatile.StoreUint32(&o.IN_EOF_DES_ADDR.Reg, value)
}
func (o *I2S_Type) GetIN_EOF_DES_ADDR() uint32 {
	return volatile.LoadUint32(&o.IN_EOF_DES_ADDR.Reg)
}

// I2S.OUT_EOF_BFR_DES_ADDR: The address of buffer relative to the outlink descriptor that produces EOF
func (o *I2S_Type) SetOUT_EOF_BFR_DES_ADDR(value uint32) {
	volatile.StoreUint32(&o.OUT_EOF_BFR_DES_ADDR.Reg, value)
}
func (o *I2S_Type) GetOUT_EOF_BFR_DES_ADDR() uint32 {
	return volatile.LoadUint32(&o.OUT_EOF_BFR_DES_ADDR.Reg)
}

// I2S.INLINK_DSCR: The address of current inlink descriptor
func (o *I2S_Type) SetINLINK_DSCR(value uint32) {
	volatile.StoreUint32(&o.INLINK_DSCR.Reg, value)
}
func (o *I2S_Type) GetINLINK_DSCR() uint32 {
	return volatile.LoadUint32(&o.INLINK_DSCR.Reg)
}

// I2S.INLINK_DSCR_BF0: The address of next inlink descriptor
func (o *I2S_Type) SetINLINK_DSCR_BF0(value uint32) {
	volatile.StoreUint32(&o.INLINK_DSCR_BF0.Reg, value)
}
func (o *I2S_Type) GetINLINK_DSCR_BF0() uint32 {
	return volatile.LoadUint32(&o.INLINK_DSCR_BF0.Reg)
}

// I2S.INLINK_DSCR_BF1: The address of next inlink data buffer
func (o *I2S_Type) SetINLINK_DSCR_BF1(value uint32) {
	volatile.StoreUint32(&o.INLINK_DSCR_BF1.Reg, value)
}
func (o *I2S_Type) GetINLINK_DSCR_BF1() uint32 {
	return volatile.LoadUint32(&o.INLINK_DSCR_BF1.Reg)
}

// I2S.OUTLINK_DSCR: The address of current outlink descriptor
func (o *I2S_Type) SetOUTLINK_DSCR(value uint32) {
	volatile.StoreUint32(&o.OUTLINK_DSCR.Reg, value)
}
func (o *I2S_Type) GetOUTLINK_DSCR() uint32 {
	return volatile.LoadUint32(&o.OUTLINK_DSCR.Reg)
}

// I2S.OUTLINK_DSCR_BF0: The address of next outlink descriptor
func (o *I2S_Type) SetOUTLINK_DSCR_BF0(value uint32) {
	volatile.StoreUint32(&o.OUTLINK_DSCR_BF0.Reg, value)
}
func (o *I2S_Type) GetOUTLINK_DSCR_BF0() uint32 {
	return volatile.LoadUint32(&o.OUTLINK_DSCR_BF0.Reg)
}

// I2S.OUTLINK_DSCR_BF1: The address of next outlink data buffer
func (o *I2S_Type) SetOUTLINK_DSCR_BF1(value uint32) {
	volatile.StoreUint32(&o.OUTLINK_DSCR_BF1.Reg, value)
}
func (o *I2S_Type) GetOUTLINK_DSCR_BF1() uint32 {
	return volatile.LoadUint32(&o.OUTLINK_DSCR_BF1.Reg)
}

// I2S.LC_CONF: I2S DMA configuration register
func (o *I2S_Type) SetLC_CONF_IN_RST(value uint32) {
	volatile.StoreUint32(&o.LC_CONF.Reg, volatile.LoadUint32(&o.LC_CONF.Reg)&^(0x1)|value)
}
func (o *I2S_Type) GetLC_CONF_IN_RST() uint32 {
	return volatile.LoadUint32(&o.LC_CONF.Reg) & 0x1
}
func (o *I2S_Type) SetLC_CONF_OUT_RST(value uint32) {
	volatile.StoreUint32(&o.LC_CONF.Reg, volatile.LoadUint32(&o.LC_CONF.Reg)&^(0x2)|value<<1)
}
func (o *I2S_Type) GetLC_CONF_OUT_RST() uint32 {
	return (volatile.LoadUint32(&o.LC_CONF.Reg) & 0x2) >> 1
}
func (o *I2S_Type) SetLC_CONF_AHBM_FIFO_RST(value uint32) {
	volatile.StoreUint32(&o.LC_CONF.Reg, volatile.LoadUint32(&o.LC_CONF.Reg)&^(0x4)|value<<2)
}
func (o *I2S_Type) GetLC_CONF_AHBM_FIFO_RST() uint32 {
	return (volatile.LoadUint32(&o.LC_CONF.Reg) & 0x4) >> 2
}
func (o *I2S_Type) SetLC_CONF_AHBM_RST(value uint32) {
	volatile.StoreUint32(&o.LC_CONF.Reg, volatile.LoadUint32(&o.LC_CONF.Reg)&^(0x8)|value<<3)
}
func (o *I2S_Type) GetLC_CONF_AHBM_RST() uint32 {
	return (volatile.LoadUint32(&o.LC_CONF.Reg) & 0x8) >> 3
}
func (o *I2S_Type) SetLC_CONF_OUT_LOOP_TEST(value uint32) {
	volatile.StoreUint32(&o.LC_CONF.Reg, volatile.LoadUint32(&o.LC_CONF.Reg)&^(0x10)|value<<4)
}
func (o *I2S_Type) GetLC_CONF_OUT_LOOP_TEST() uint32 {
	return (volatile.LoadUint32(&o.LC_CONF.Reg) & 0x10) >> 4
}
func (o *I2S_Type) SetLC_CONF_IN_LOOP_TEST(value uint32) {
	volatile.StoreUint32(&o.LC_CONF.Reg, volatile.LoadUint32(&o.LC_CONF.Reg)&^(0x20)|value<<5)
}
func (o *I2S_Type) GetLC_CONF_IN_LOOP_TEST() uint32 {
	return (volatile.LoadUint32(&o.LC_CONF.Reg) & 0x20) >> 5
}
func (o *I2S_Type) SetLC_CONF_OUT_AUTO_WRBACK(value uint32) {
	volatile.StoreUint32(&o.LC_CONF.Reg, volatile.LoadUint32(&o.LC_CONF.Reg)&^(0x40)|value<<6)
}
func (o *I2S_Type) GetLC_CONF_OUT_AUTO_WRBACK() uint32 {
	return (volatile.LoadUint32(&o.LC_CONF.Reg) & 0x40) >> 6
}
func (o *I2S_Type) SetLC_CONF_OUT_NO_RESTART_CLR(value uint32) {
	volatile.StoreUint32(&o.LC_CONF.Reg, volatile.LoadUint32(&o.LC_CONF.Reg)&^(0x80)|value<<7)
}
func (o *I2S_Type) GetLC_CONF_OUT_NO_RESTART_CLR() uint32 {
	return (volatile.LoadUint32(&o.LC_CONF.Reg) & 0x80) >> 7
}
func (o *I2S_Type) SetLC_CONF_OUT_EOF_MODE(value uint32) {
	volatile.StoreUint32(&o.LC_CONF.Reg, volatile.LoadUint32(&o.LC_CONF.Reg)&^(0x100)|value<<8)
}
func (o *I2S_Type) GetLC_CONF_OUT_EOF_MODE() uint32 {
	return (volatile.LoadUint32(&o.LC_CONF.Reg) & 0x100) >> 8
}
func (o *I2S_Type) SetLC_CONF_OUTDSCR_BURST_EN(value uint32) {
	volatile.StoreUint32(&o.LC_CONF.Reg, volatile.LoadUint32(&o.LC_CONF.Reg)&^(0x200)|value<<9)
}
func (o *I2S_Type) GetLC_CONF_OUTDSCR_BURST_EN() uint32 {
	return (volatile.LoadUint32(&o.LC_CONF.Reg) & 0x200) >> 9
}
func (o *I2S_Type) SetLC_CONF_INDSCR_BURST_EN(value uint32) {
	volatile.StoreUint32(&o.LC_CONF.Reg, volatile.LoadUint32(&o.LC_CONF.Reg)&^(0x400)|value<<10)
}
func (o *I2S_Type) GetLC_CONF_INDSCR_BURST_EN() uint32 {
	return (volatile.LoadUint32(&o.LC_CONF.Reg) & 0x400) >> 10
}
func (o *I2S_Type) SetLC_CONF_OUT_DATA_BURST_EN(value uint32) {
	volatile.StoreUint32(&o.LC_CONF.Reg, volatile.LoadUint32(&o.LC_CONF.Reg)&^(0x800)|value<<11)
}
func (o *I2S_Type) GetLC_CONF_OUT_DATA_BURST_EN() uint32 {
	return (volatile.LoadUint32(&o.LC_CONF.Reg) & 0x800) >> 11
}
func (o *I2S_Type) SetLC_CONF_CHECK_OWNER(value uint32) {
	volatile.StoreUint32(&o.LC_CONF.Reg, volatile.LoadUint32(&o.LC_CONF.Reg)&^(0x1000)|value<<12)
}
func (o *I2S_Type) GetLC_CONF_CHECK_OWNER() uint32 {
	return (volatile.LoadUint32(&o.LC_CONF.Reg) & 0x1000) >> 12
}
func (o *I2S_Type) SetLC_CONF_MEM_TRANS_EN(value uint32) {
	volatile.StoreUint32(&o.LC_CONF.Reg, volatile.LoadUint32(&o.LC_CONF.Reg)&^(0x2000)|value<<13)
}
func (o *I2S_Type) GetLC_CONF_MEM_TRANS_EN() uint32 {
	return (volatile.LoadUint32(&o.LC_CONF.Reg) & 0x2000) >> 13
}
func (o *I2S_Type) SetLC_CONF_EXT_MEM_BK_SIZE(value uint32) {
	volatile.StoreUint32(&o.LC_CONF.Reg, volatile.LoadUint32(&o.LC_CONF.Reg)&^(0xc000)|value<<14)
}
func (o *I2S_Type) GetLC_CONF_EXT_MEM_BK_SIZE() uint32 {
	return (volatile.LoadUint32(&o.LC_CONF.Reg) & 0xc000) >> 14
}

// I2S.OUTFIFO_PUSH: APB out FIFO mode register
func (o *I2S_Type) SetOUTFIFO_PUSH_OUTFIFO_WDATA(value uint32) {
	volatile.StoreUint32(&o.OUTFIFO_PUSH.Reg, volatile.LoadUint32(&o.OUTFIFO_PUSH.Reg)&^(0x1ff)|value)
}
func (o *I2S_Type) GetOUTFIFO_PUSH_OUTFIFO_WDATA() uint32 {
	return volatile.LoadUint32(&o.OUTFIFO_PUSH.Reg) & 0x1ff
}
func (o *I2S_Type) SetOUTFIFO_PUSH(value uint32) {
	volatile.StoreUint32(&o.OUTFIFO_PUSH.Reg, volatile.LoadUint32(&o.OUTFIFO_PUSH.Reg)&^(0x10000)|value<<16)
}
func (o *I2S_Type) GetOUTFIFO_PUSH() uint32 {
	return (volatile.LoadUint32(&o.OUTFIFO_PUSH.Reg) & 0x10000) >> 16
}

// I2S.INFIFO_POP: APB in FIFO mode register
func (o *I2S_Type) SetINFIFO_POP_INFIFO_RDATA(value uint32) {
	volatile.StoreUint32(&o.INFIFO_POP.Reg, volatile.LoadUint32(&o.INFIFO_POP.Reg)&^(0xfff)|value)
}
func (o *I2S_Type) GetINFIFO_POP_INFIFO_RDATA() uint32 {
	return volatile.LoadUint32(&o.INFIFO_POP.Reg) & 0xfff
}
func (o *I2S_Type) SetINFIFO_POP(value uint32) {
	volatile.StoreUint32(&o.INFIFO_POP.Reg, volatile.LoadUint32(&o.INFIFO_POP.Reg)&^(0x10000)|value<<16)
}
func (o *I2S_Type) GetINFIFO_POP() uint32 {
	return (volatile.LoadUint32(&o.INFIFO_POP.Reg) & 0x10000) >> 16
}

// I2S.LC_STATE0: I2S DMA TX status
func (o *I2S_Type) SetLC_STATE0_OUTLINK_DSCR_ADDR(value uint32) {
	volatile.StoreUint32(&o.LC_STATE0.Reg, volatile.LoadUint32(&o.LC_STATE0.Reg)&^(0x3ffff)|value)
}
func (o *I2S_Type) GetLC_STATE0_OUTLINK_DSCR_ADDR() uint32 {
	return volatile.LoadUint32(&o.LC_STATE0.Reg) & 0x3ffff
}
func (o *I2S_Type) SetLC_STATE0_OUT_DSCR_STATE(value uint32) {
	volatile.StoreUint32(&o.LC_STATE0.Reg, volatile.LoadUint32(&o.LC_STATE0.Reg)&^(0xc0000)|value<<18)
}
func (o *I2S_Type) GetLC_STATE0_OUT_DSCR_STATE() uint32 {
	return (volatile.LoadUint32(&o.LC_STATE0.Reg) & 0xc0000) >> 18
}
func (o *I2S_Type) SetLC_STATE0_OUT_STATE(value uint32) {
	volatile.StoreUint32(&o.LC_STATE0.Reg, volatile.LoadUint32(&o.LC_STATE0.Reg)&^(0x700000)|value<<20)
}
func (o *I2S_Type) GetLC_STATE0_OUT_STATE() uint32 {
	return (volatile.LoadUint32(&o.LC_STATE0.Reg) & 0x700000) >> 20
}
func (o *I2S_Type) SetLC_STATE0_OUTFIFO_CNT(value uint32) {
	volatile.StoreUint32(&o.LC_STATE0.Reg, volatile.LoadUint32(&o.LC_STATE0.Reg)&^(0x3f800000)|value<<23)
}
func (o *I2S_Type) GetLC_STATE0_OUTFIFO_CNT() uint32 {
	return (volatile.LoadUint32(&o.LC_STATE0.Reg) & 0x3f800000) >> 23
}
func (o *I2S_Type) SetLC_STATE0_OUT_FULL(value uint32) {
	volatile.StoreUint32(&o.LC_STATE0.Reg, volatile.LoadUint32(&o.LC_STATE0.Reg)&^(0x40000000)|value<<30)
}
func (o *I2S_Type) GetLC_STATE0_OUT_FULL() uint32 {
	return (volatile.LoadUint32(&o.LC_STATE0.Reg) & 0x40000000) >> 30
}
func (o *I2S_Type) SetLC_STATE0_OUT_EMPTY(value uint32) {
	volatile.StoreUint32(&o.LC_STATE0.Reg, volatile.LoadUint32(&o.LC_STATE0.Reg)&^(0x80000000)|value<<31)
}
func (o *I2S_Type) GetLC_STATE0_OUT_EMPTY() uint32 {
	return (volatile.LoadUint32(&o.LC_STATE0.Reg) & 0x80000000) >> 31
}

// I2S.LC_STATE1: I2S DMA RX status
func (o *I2S_Type) SetLC_STATE1_INLINK_DSCR_ADDR(value uint32) {
	volatile.StoreUint32(&o.LC_STATE1.Reg, volatile.LoadUint32(&o.LC_STATE1.Reg)&^(0x3ffff)|value)
}
func (o *I2S_Type) GetLC_STATE1_INLINK_DSCR_ADDR() uint32 {
	return volatile.LoadUint32(&o.LC_STATE1.Reg) & 0x3ffff
}
func (o *I2S_Type) SetLC_STATE1_IN_DSCR_STATE(value uint32) {
	volatile.StoreUint32(&o.LC_STATE1.Reg, volatile.LoadUint32(&o.LC_STATE1.Reg)&^(0xc0000)|value<<18)
}
func (o *I2S_Type) GetLC_STATE1_IN_DSCR_STATE() uint32 {
	return (volatile.LoadUint32(&o.LC_STATE1.Reg) & 0xc0000) >> 18
}
func (o *I2S_Type) SetLC_STATE1_IN_STATE(value uint32) {
	volatile.StoreUint32(&o.LC_STATE1.Reg, volatile.LoadUint32(&o.LC_STATE1.Reg)&^(0x700000)|value<<20)
}
func (o *I2S_Type) GetLC_STATE1_IN_STATE() uint32 {
	return (volatile.LoadUint32(&o.LC_STATE1.Reg) & 0x700000) >> 20
}
func (o *I2S_Type) SetLC_STATE1_INFIFO_CNT_DEBUG(value uint32) {
	volatile.StoreUint32(&o.LC_STATE1.Reg, volatile.LoadUint32(&o.LC_STATE1.Reg)&^(0x3f800000)|value<<23)
}
func (o *I2S_Type) GetLC_STATE1_INFIFO_CNT_DEBUG() uint32 {
	return (volatile.LoadUint32(&o.LC_STATE1.Reg) & 0x3f800000) >> 23
}
func (o *I2S_Type) SetLC_STATE1_IN_FULL(value uint32) {
	volatile.StoreUint32(&o.LC_STATE1.Reg, volatile.LoadUint32(&o.LC_STATE1.Reg)&^(0x40000000)|value<<30)
}
func (o *I2S_Type) GetLC_STATE1_IN_FULL() uint32 {
	return (volatile.LoadUint32(&o.LC_STATE1.Reg) & 0x40000000) >> 30
}
func (o *I2S_Type) SetLC_STATE1_IN_EMPTY(value uint32) {
	volatile.StoreUint32(&o.LC_STATE1.Reg, volatile.LoadUint32(&o.LC_STATE1.Reg)&^(0x80000000)|value<<31)
}
func (o *I2S_Type) GetLC_STATE1_IN_EMPTY() uint32 {
	return (volatile.LoadUint32(&o.LC_STATE1.Reg) & 0x80000000) >> 31
}

// I2S.LC_HUNG_CONF: I2S Hung configure register
func (o *I2S_Type) SetLC_HUNG_CONF_LC_FIFO_TIMEOUT(value uint32) {
	volatile.StoreUint32(&o.LC_HUNG_CONF.Reg, volatile.LoadUint32(&o.LC_HUNG_CONF.Reg)&^(0xff)|value)
}
func (o *I2S_Type) GetLC_HUNG_CONF_LC_FIFO_TIMEOUT() uint32 {
	return volatile.LoadUint32(&o.LC_HUNG_CONF.Reg) & 0xff
}
func (o *I2S_Type) SetLC_HUNG_CONF_LC_FIFO_TIMEOUT_SHIFT(value uint32) {
	volatile.StoreUint32(&o.LC_HUNG_CONF.Reg, volatile.LoadUint32(&o.LC_HUNG_CONF.Reg)&^(0x700)|value<<8)
}
func (o *I2S_Type) GetLC_HUNG_CONF_LC_FIFO_TIMEOUT_SHIFT() uint32 {
	return (volatile.LoadUint32(&o.LC_HUNG_CONF.Reg) & 0x700) >> 8
}
func (o *I2S_Type) SetLC_HUNG_CONF_LC_FIFO_TIMEOUT_ENA(value uint32) {
	volatile.StoreUint32(&o.LC_HUNG_CONF.Reg, volatile.LoadUint32(&o.LC_HUNG_CONF.Reg)&^(0x800)|value<<11)
}
func (o *I2S_Type) GetLC_HUNG_CONF_LC_FIFO_TIMEOUT_ENA() uint32 {
	return (volatile.LoadUint32(&o.LC_HUNG_CONF.Reg) & 0x800) >> 11
}

// I2S.CONF1: I2S configure1 register
func (o *I2S_Type) SetCONF1_TX_PCM_CONF(value uint32) {
	volatile.StoreUint32(&o.CONF1.Reg, volatile.LoadUint32(&o.CONF1.Reg)&^(0x7)|value)
}
func (o *I2S_Type) GetCONF1_TX_PCM_CONF() uint32 {
	return volatile.LoadUint32(&o.CONF1.Reg) & 0x7
}
func (o *I2S_Type) SetCONF1_TX_PCM_BYPASS(value uint32) {
	volatile.StoreUint32(&o.CONF1.Reg, volatile.LoadUint32(&o.CONF1.Reg)&^(0x8)|value<<3)
}
func (o *I2S_Type) GetCONF1_TX_PCM_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.CONF1.Reg) & 0x8) >> 3
}
func (o *I2S_Type) SetCONF1_RX_PCM_CONF(value uint32) {
	volatile.StoreUint32(&o.CONF1.Reg, volatile.LoadUint32(&o.CONF1.Reg)&^(0x70)|value<<4)
}
func (o *I2S_Type) GetCONF1_RX_PCM_CONF() uint32 {
	return (volatile.LoadUint32(&o.CONF1.Reg) & 0x70) >> 4
}
func (o *I2S_Type) SetCONF1_RX_PCM_BYPASS(value uint32) {
	volatile.StoreUint32(&o.CONF1.Reg, volatile.LoadUint32(&o.CONF1.Reg)&^(0x80)|value<<7)
}
func (o *I2S_Type) GetCONF1_RX_PCM_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.CONF1.Reg) & 0x80) >> 7
}
func (o *I2S_Type) SetCONF1_TX_STOP_EN(value uint32) {
	volatile.StoreUint32(&o.CONF1.Reg, volatile.LoadUint32(&o.CONF1.Reg)&^(0x100)|value<<8)
}
func (o *I2S_Type) GetCONF1_TX_STOP_EN() uint32 {
	return (volatile.LoadUint32(&o.CONF1.Reg) & 0x100) >> 8
}
func (o *I2S_Type) SetCONF1_TX_ZEROS_RM_EN(value uint32) {
	volatile.StoreUint32(&o.CONF1.Reg, volatile.LoadUint32(&o.CONF1.Reg)&^(0x200)|value<<9)
}
func (o *I2S_Type) GetCONF1_TX_ZEROS_RM_EN() uint32 {
	return (volatile.LoadUint32(&o.CONF1.Reg) & 0x200) >> 9
}

// I2S.PD_CONF: I2S power down configure register
func (o *I2S_Type) SetPD_CONF_FIFO_FORCE_PD(value uint32) {
	volatile.StoreUint32(&o.PD_CONF.Reg, volatile.LoadUint32(&o.PD_CONF.Reg)&^(0x1)|value)
}
func (o *I2S_Type) GetPD_CONF_FIFO_FORCE_PD() uint32 {
	return volatile.LoadUint32(&o.PD_CONF.Reg) & 0x1
}
func (o *I2S_Type) SetPD_CONF_FIFO_FORCE_PU(value uint32) {
	volatile.StoreUint32(&o.PD_CONF.Reg, volatile.LoadUint32(&o.PD_CONF.Reg)&^(0x2)|value<<1)
}
func (o *I2S_Type) GetPD_CONF_FIFO_FORCE_PU() uint32 {
	return (volatile.LoadUint32(&o.PD_CONF.Reg) & 0x2) >> 1
}
func (o *I2S_Type) SetPD_CONF_PLC_MEM_FORCE_PD(value uint32) {
	volatile.StoreUint32(&o.PD_CONF.Reg, volatile.LoadUint32(&o.PD_CONF.Reg)&^(0x4)|value<<2)
}
func (o *I2S_Type) GetPD_CONF_PLC_MEM_FORCE_PD() uint32 {
	return (volatile.LoadUint32(&o.PD_CONF.Reg) & 0x4) >> 2
}
func (o *I2S_Type) SetPD_CONF_PLC_MEM_FORCE_PU(value uint32) {
	volatile.StoreUint32(&o.PD_CONF.Reg, volatile.LoadUint32(&o.PD_CONF.Reg)&^(0x8)|value<<3)
}
func (o *I2S_Type) GetPD_CONF_PLC_MEM_FORCE_PU() uint32 {
	return (volatile.LoadUint32(&o.PD_CONF.Reg) & 0x8) >> 3
}
func (o *I2S_Type) SetPD_CONF_DMA_RAM_FORCE_PD(value uint32) {
	volatile.StoreUint32(&o.PD_CONF.Reg, volatile.LoadUint32(&o.PD_CONF.Reg)&^(0x10)|value<<4)
}
func (o *I2S_Type) GetPD_CONF_DMA_RAM_FORCE_PD() uint32 {
	return (volatile.LoadUint32(&o.PD_CONF.Reg) & 0x10) >> 4
}
func (o *I2S_Type) SetPD_CONF_DMA_RAM_FORCE_PU(value uint32) {
	volatile.StoreUint32(&o.PD_CONF.Reg, volatile.LoadUint32(&o.PD_CONF.Reg)&^(0x20)|value<<5)
}
func (o *I2S_Type) GetPD_CONF_DMA_RAM_FORCE_PU() uint32 {
	return (volatile.LoadUint32(&o.PD_CONF.Reg) & 0x20) >> 5
}
func (o *I2S_Type) SetPD_CONF_DMA_RAM_CLK_FO(value uint32) {
	volatile.StoreUint32(&o.PD_CONF.Reg, volatile.LoadUint32(&o.PD_CONF.Reg)&^(0x40)|value<<6)
}
func (o *I2S_Type) GetPD_CONF_DMA_RAM_CLK_FO() uint32 {
	return (volatile.LoadUint32(&o.PD_CONF.Reg) & 0x40) >> 6
}

// I2S.CONF2: I2S configure2 register
func (o *I2S_Type) SetCONF2_CAMERA_EN(value uint32) {
	volatile.StoreUint32(&o.CONF2.Reg, volatile.LoadUint32(&o.CONF2.Reg)&^(0x1)|value)
}
func (o *I2S_Type) GetCONF2_CAMERA_EN() uint32 {
	return volatile.LoadUint32(&o.CONF2.Reg) & 0x1
}
func (o *I2S_Type) SetCONF2_LCD_TX_WRX2_EN(value uint32) {
	volatile.StoreUint32(&o.CONF2.Reg, volatile.LoadUint32(&o.CONF2.Reg)&^(0x2)|value<<1)
}
func (o *I2S_Type) GetCONF2_LCD_TX_WRX2_EN() uint32 {
	return (volatile.LoadUint32(&o.CONF2.Reg) & 0x2) >> 1
}
func (o *I2S_Type) SetCONF2_LCD_TX_SDX2_EN(value uint32) {
	volatile.StoreUint32(&o.CONF2.Reg, volatile.LoadUint32(&o.CONF2.Reg)&^(0x4)|value<<2)
}
func (o *I2S_Type) GetCONF2_LCD_TX_SDX2_EN() uint32 {
	return (volatile.LoadUint32(&o.CONF2.Reg) & 0x4) >> 2
}
func (o *I2S_Type) SetCONF2_DATA_ENABLE_TEST_EN(value uint32) {
	volatile.StoreUint32(&o.CONF2.Reg, volatile.LoadUint32(&o.CONF2.Reg)&^(0x8)|value<<3)
}
func (o *I2S_Type) GetCONF2_DATA_ENABLE_TEST_EN() uint32 {
	return (volatile.LoadUint32(&o.CONF2.Reg) & 0x8) >> 3
}
func (o *I2S_Type) SetCONF2_DATA_ENABLE(value uint32) {
	volatile.StoreUint32(&o.CONF2.Reg, volatile.LoadUint32(&o.CONF2.Reg)&^(0x10)|value<<4)
}
func (o *I2S_Type) GetCONF2_DATA_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.CONF2.Reg) & 0x10) >> 4
}
func (o *I2S_Type) SetCONF2_LCD_EN(value uint32) {
	volatile.StoreUint32(&o.CONF2.Reg, volatile.LoadUint32(&o.CONF2.Reg)&^(0x20)|value<<5)
}
func (o *I2S_Type) GetCONF2_LCD_EN() uint32 {
	return (volatile.LoadUint32(&o.CONF2.Reg) & 0x20) >> 5
}
func (o *I2S_Type) SetCONF2_EXT_ADC_START_EN(value uint32) {
	volatile.StoreUint32(&o.CONF2.Reg, volatile.LoadUint32(&o.CONF2.Reg)&^(0x40)|value<<6)
}
func (o *I2S_Type) GetCONF2_EXT_ADC_START_EN() uint32 {
	return (volatile.LoadUint32(&o.CONF2.Reg) & 0x40) >> 6
}
func (o *I2S_Type) SetCONF2_INTER_VALID_EN(value uint32) {
	volatile.StoreUint32(&o.CONF2.Reg, volatile.LoadUint32(&o.CONF2.Reg)&^(0x80)|value<<7)
}
func (o *I2S_Type) GetCONF2_INTER_VALID_EN() uint32 {
	return (volatile.LoadUint32(&o.CONF2.Reg) & 0x80) >> 7
}
func (o *I2S_Type) SetCONF2_CAM_SYNC_FIFO_RESET(value uint32) {
	volatile.StoreUint32(&o.CONF2.Reg, volatile.LoadUint32(&o.CONF2.Reg)&^(0x100)|value<<8)
}
func (o *I2S_Type) GetCONF2_CAM_SYNC_FIFO_RESET() uint32 {
	return (volatile.LoadUint32(&o.CONF2.Reg) & 0x100) >> 8
}
func (o *I2S_Type) SetCONF2_CAM_CLK_LOOPBACK(value uint32) {
	volatile.StoreUint32(&o.CONF2.Reg, volatile.LoadUint32(&o.CONF2.Reg)&^(0x200)|value<<9)
}
func (o *I2S_Type) GetCONF2_CAM_CLK_LOOPBACK() uint32 {
	return (volatile.LoadUint32(&o.CONF2.Reg) & 0x200) >> 9
}
func (o *I2S_Type) SetCONF2_VSYNC_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.CONF2.Reg, volatile.LoadUint32(&o.CONF2.Reg)&^(0x400)|value<<10)
}
func (o *I2S_Type) GetCONF2_VSYNC_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.CONF2.Reg) & 0x400) >> 10
}
func (o *I2S_Type) SetCONF2_VSYNC_FILTER_THRES(value uint32) {
	volatile.StoreUint32(&o.CONF2.Reg, volatile.LoadUint32(&o.CONF2.Reg)&^(0x3800)|value<<11)
}
func (o *I2S_Type) GetCONF2_VSYNC_FILTER_THRES() uint32 {
	return (volatile.LoadUint32(&o.CONF2.Reg) & 0x3800) >> 11
}

// I2S.CLKM_CONF: I2S module clock configure register
func (o *I2S_Type) SetCLKM_CONF_CLKM_DIV_NUM(value uint32) {
	volatile.StoreUint32(&o.CLKM_CONF.Reg, volatile.LoadUint32(&o.CLKM_CONF.Reg)&^(0xff)|value)
}
func (o *I2S_Type) GetCLKM_CONF_CLKM_DIV_NUM() uint32 {
	return volatile.LoadUint32(&o.CLKM_CONF.Reg) & 0xff
}
func (o *I2S_Type) SetCLKM_CONF_CLKM_DIV_B(value uint32) {
	volatile.StoreUint32(&o.CLKM_CONF.Reg, volatile.LoadUint32(&o.CLKM_CONF.Reg)&^(0x3f00)|value<<8)
}
func (o *I2S_Type) GetCLKM_CONF_CLKM_DIV_B() uint32 {
	return (volatile.LoadUint32(&o.CLKM_CONF.Reg) & 0x3f00) >> 8
}
func (o *I2S_Type) SetCLKM_CONF_CLKM_DIV_A(value uint32) {
	volatile.StoreUint32(&o.CLKM_CONF.Reg, volatile.LoadUint32(&o.CLKM_CONF.Reg)&^(0xfc000)|value<<14)
}
func (o *I2S_Type) GetCLKM_CONF_CLKM_DIV_A() uint32 {
	return (volatile.LoadUint32(&o.CLKM_CONF.Reg) & 0xfc000) >> 14
}
func (o *I2S_Type) SetCLKM_CONF_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.CLKM_CONF.Reg, volatile.LoadUint32(&o.CLKM_CONF.Reg)&^(0x100000)|value<<20)
}
func (o *I2S_Type) GetCLKM_CONF_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.CLKM_CONF.Reg) & 0x100000) >> 20
}
func (o *I2S_Type) SetCLKM_CONF_CLK_SEL(value uint32) {
	volatile.StoreUint32(&o.CLKM_CONF.Reg, volatile.LoadUint32(&o.CLKM_CONF.Reg)&^(0x600000)|value<<21)
}
func (o *I2S_Type) GetCLKM_CONF_CLK_SEL() uint32 {
	return (volatile.LoadUint32(&o.CLKM_CONF.Reg) & 0x600000) >> 21
}

// I2S.SAMPLE_RATE_CONF: I2S sample rate register
func (o *I2S_Type) SetSAMPLE_RATE_CONF_TX_BCK_DIV_NUM(value uint32) {
	volatile.StoreUint32(&o.SAMPLE_RATE_CONF.Reg, volatile.LoadUint32(&o.SAMPLE_RATE_CONF.Reg)&^(0x3f)|value)
}
func (o *I2S_Type) GetSAMPLE_RATE_CONF_TX_BCK_DIV_NUM() uint32 {
	return volatile.LoadUint32(&o.SAMPLE_RATE_CONF.Reg) & 0x3f
}
func (o *I2S_Type) SetSAMPLE_RATE_CONF_RX_BCK_DIV_NUM(value uint32) {
	volatile.StoreUint32(&o.SAMPLE_RATE_CONF.Reg, volatile.LoadUint32(&o.SAMPLE_RATE_CONF.Reg)&^(0xfc0)|value<<6)
}
func (o *I2S_Type) GetSAMPLE_RATE_CONF_RX_BCK_DIV_NUM() uint32 {
	return (volatile.LoadUint32(&o.SAMPLE_RATE_CONF.Reg) & 0xfc0) >> 6
}
func (o *I2S_Type) SetSAMPLE_RATE_CONF_TX_BITS_MOD(value uint32) {
	volatile.StoreUint32(&o.SAMPLE_RATE_CONF.Reg, volatile.LoadUint32(&o.SAMPLE_RATE_CONF.Reg)&^(0x3f000)|value<<12)
}
func (o *I2S_Type) GetSAMPLE_RATE_CONF_TX_BITS_MOD() uint32 {
	return (volatile.LoadUint32(&o.SAMPLE_RATE_CONF.Reg) & 0x3f000) >> 12
}
func (o *I2S_Type) SetSAMPLE_RATE_CONF_RX_BITS_MOD(value uint32) {
	volatile.StoreUint32(&o.SAMPLE_RATE_CONF.Reg, volatile.LoadUint32(&o.SAMPLE_RATE_CONF.Reg)&^(0xfc0000)|value<<18)
}
func (o *I2S_Type) GetSAMPLE_RATE_CONF_RX_BITS_MOD() uint32 {
	return (volatile.LoadUint32(&o.SAMPLE_RATE_CONF.Reg) & 0xfc0000) >> 18
}

// I2S.STATE: I2S TX status register
func (o *I2S_Type) SetSTATE_TX_IDLE(value uint32) {
	volatile.StoreUint32(&o.STATE.Reg, volatile.LoadUint32(&o.STATE.Reg)&^(0x1)|value)
}
func (o *I2S_Type) GetSTATE_TX_IDLE() uint32 {
	return volatile.LoadUint32(&o.STATE.Reg) & 0x1
}

// I2S.DATE: Version control register
func (o *I2S_Type) SetDATE(value uint32) {
	volatile.StoreUint32(&o.DATE.Reg, value)
}
func (o *I2S_Type) GetDATE() uint32 {
	return volatile.LoadUint32(&o.DATE.Reg)
}

// Peripheral INTERRUPT
type INTERRUPT_Type struct {
	PRO_MAC_INTR_MAP               volatile.Register32 // 0x0
	PRO_MAC_NMI_MAP                volatile.Register32 // 0x4
	PRO_PWR_INTR_MAP               volatile.Register32 // 0x8
	PRO_BB_INT_MAP                 volatile.Register32 // 0xC
	PRO_BT_MAC_INT_MAP             volatile.Register32 // 0x10
	PRO_BT_BB_INT_MAP              volatile.Register32 // 0x14
	PRO_BT_BB_NMI_MAP              volatile.Register32 // 0x18
	PRO_RWBT_IRQ_MAP               volatile.Register32 // 0x1C
	PRO_RWBLE_IRQ_MAP              volatile.Register32 // 0x20
	PRO_RWBT_NMI_MAP               volatile.Register32 // 0x24
	PRO_RWBLE_NMI_MAP              volatile.Register32 // 0x28
	PRO_SLC0_INTR_MAP              volatile.Register32 // 0x2C
	PRO_SLC1_INTR_MAP              volatile.Register32 // 0x30
	PRO_UHCI0_INTR_MAP             volatile.Register32 // 0x34
	PRO_UHCI1_INTR_MAP             volatile.Register32 // 0x38
	PRO_TG_T0_LEVEL_INT_MAP        volatile.Register32 // 0x3C
	PRO_TG_T1_LEVEL_INT_MAP        volatile.Register32 // 0x40
	PRO_TG_WDT_LEVEL_INT_MAP       volatile.Register32 // 0x44
	PRO_TG_LACT_LEVEL_INT_MAP      volatile.Register32 // 0x48
	PRO_TG1_T0_LEVEL_INT_MAP       volatile.Register32 // 0x4C
	PRO_TG1_T1_LEVEL_INT_MAP       volatile.Register32 // 0x50
	PRO_TG1_WDT_LEVEL_INT_MAP      volatile.Register32 // 0x54
	PRO_TG1_LACT_LEVEL_INT_MAP     volatile.Register32 // 0x58
	PRO_GPIO_INTERRUPT_PRO_MAP     volatile.Register32 // 0x5C
	PRO_GPIO_INTERRUPT_PRO_NMI_MAP volatile.Register32 // 0x60
	PRO_GPIO_INTERRUPT_APP_MAP     volatile.Register32 // 0x64
	PRO_GPIO_INTERRUPT_APP_NMI_MAP volatile.Register32 // 0x68
	PRO_DEDICATED_GPIO_IN_INTR_MAP volatile.Register32 // 0x6C
	PRO_CPU_INTR_FROM_CPU_0_MAP    volatile.Register32 // 0x70
	PRO_CPU_INTR_FROM_CPU_1_MAP    volatile.Register32 // 0x74
	PRO_CPU_INTR_FROM_CPU_2_MAP    volatile.Register32 // 0x78
	PRO_CPU_INTR_FROM_CPU_3_MAP    volatile.Register32 // 0x7C
	PRO_SPI_INTR_1_MAP             volatile.Register32 // 0x80
	PRO_SPI_INTR_2_MAP             volatile.Register32 // 0x84
	PRO_SPI_INTR_3_MAP             volatile.Register32 // 0x88
	PRO_I2S0_INT_MAP               volatile.Register32 // 0x8C
	PRO_I2S1_INT_MAP               volatile.Register32 // 0x90
	PRO_UART_INTR_MAP              volatile.Register32 // 0x94
	PRO_UART1_INTR_MAP             volatile.Register32 // 0x98
	PRO_UART2_INTR_MAP             volatile.Register32 // 0x9C
	PRO_SDIO_HOST_INTERRUPT_MAP    volatile.Register32 // 0xA0
	PRO_PWM0_INTR_MAP              volatile.Register32 // 0xA4
	PRO_PWM1_INTR_MAP              volatile.Register32 // 0xA8
	PRO_PWM2_INTR_MAP              volatile.Register32 // 0xAC
	PRO_PWM3_INTR_MAP              volatile.Register32 // 0xB0
	PRO_LEDC_INT_MAP               volatile.Register32 // 0xB4
	PRO_EFUSE_INT_MAP              volatile.Register32 // 0xB8
	PRO_CAN_INT_MAP                volatile.Register32 // 0xBC
	PRO_USB_INTR_MAP               volatile.Register32 // 0xC0
	PRO_RTC_CORE_INTR_MAP          volatile.Register32 // 0xC4
	PRO_RMT_INTR_MAP               volatile.Register32 // 0xC8
	PRO_PCNT_INTR_MAP              volatile.Register32 // 0xCC
	PRO_I2C_EXT0_INTR_MAP          volatile.Register32 // 0xD0
	PRO_I2C_EXT1_INTR_MAP          volatile.Register32 // 0xD4
	PRO_RSA_INTR_MAP               volatile.Register32 // 0xD8
	PRO_SHA_INTR_MAP               volatile.Register32 // 0xDC
	PRO_AES_INTR_MAP               volatile.Register32 // 0xE0
	PRO_SPI2_DMA_INT_MAP           volatile.Register32 // 0xE4
	PRO_SPI3_DMA_INT_MAP           volatile.Register32 // 0xE8
	PRO_WDG_INT_MAP                volatile.Register32 // 0xEC
	PRO_TIMER_INT1_MAP             volatile.Register32 // 0xF0
	PRO_TIMER_INT2_MAP             volatile.Register32 // 0xF4
	PRO_TG_T0_EDGE_INT_MAP         volatile.Register32 // 0xF8
	PRO_TG_T1_EDGE_INT_MAP         volatile.Register32 // 0xFC
	PRO_TG_WDT_EDGE_INT_MAP        volatile.Register32 // 0x100
	PRO_TG_LACT_EDGE_INT_MAP       volatile.Register32 // 0x104
	PRO_TG1_T0_EDGE_INT_MAP        volatile.Register32 // 0x108
	PRO_TG1_T1_EDGE_INT_MAP        volatile.Register32 // 0x10C
	PRO_TG1_WDT_EDGE_INT_MAP       volatile.Register32 // 0x110
	PRO_TG1_LACT_EDGE_INT_MAP      volatile.Register32 // 0x114
	PRO_CACHE_IA_INT_MAP           volatile.Register32 // 0x118
	PRO_SYSTIMER_TARGET0_INT_MAP   volatile.Register32 // 0x11C
	PRO_SYSTIMER_TARGET1_INT_MAP   volatile.Register32 // 0x120
	PRO_SYSTIMER_TARGET2_INT_MAP   volatile.Register32 // 0x124
	PRO_ASSIST_DEBUG_INTR_MAP      volatile.Register32 // 0x128
	PRO_PMS_PRO_IRAM0_ILG_INTR_MAP volatile.Register32 // 0x12C
	PRO_PMS_PRO_DRAM0_ILG_INTR_MAP volatile.Register32 // 0x130
	PRO_PMS_PRO_DPORT_ILG_INTR_MAP volatile.Register32 // 0x134
	PRO_PMS_PRO_AHB_ILG_INTR_MAP   volatile.Register32 // 0x138
	PRO_PMS_PRO_CACHE_ILG_INTR_MAP volatile.Register32 // 0x13C
	PRO_PMS_DMA_APB_I_ILG_INTR_MAP volatile.Register32 // 0x140
	PRO_PMS_DMA_RX_I_ILG_INTR_MAP  volatile.Register32 // 0x144
	PRO_PMS_DMA_TX_I_ILG_INTR_MAP  volatile.Register32 // 0x148
	PRO_SPI_MEM_REJECT_INTR_MAP    volatile.Register32 // 0x14C
	PRO_DMA_COPY_INTR_MAP          volatile.Register32 // 0x150
	PRO_SPI4_DMA_INT_MAP           volatile.Register32 // 0x154
	PRO_SPI_INTR_4_MAP             volatile.Register32 // 0x158
	PRO_DCACHE_PRELOAD_INT_MAP     volatile.Register32 // 0x15C
	PRO_ICACHE_PRELOAD_INT_MAP     volatile.Register32 // 0x160
	PRO_APB_ADC_INT_MAP            volatile.Register32 // 0x164
	PRO_CRYPTO_DMA_INT_MAP         volatile.Register32 // 0x168
	PRO_CPU_PERI_ERROR_INT_MAP     volatile.Register32 // 0x16C
	PRO_APB_PERI_ERROR_INT_MAP     volatile.Register32 // 0x170
	PRO_DCACHE_SYNC_INT_MAP        volatile.Register32 // 0x174
	PRO_ICACHE_SYNC_INT_MAP        volatile.Register32 // 0x178
	PRO_INTR_STATUS_REG_0          volatile.Register32 // 0x17C
	PRO_INTR_STATUS_REG_1          volatile.Register32 // 0x180
	PRO_INTR_STATUS_REG_2          volatile.Register32 // 0x184
	CLOCK_GATE                     volatile.Register32 // 0x188
	_                              [3696]byte
	REG_DATE                       volatile.Register32 // 0xFFC
}

// INTERRUPT.PRO_MAC_INTR_MAP: MAC_INTR interrupt configuration register
func (o *INTERRUPT_Type) SetPRO_MAC_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_MAC_INTR_MAP.Reg, volatile.LoadUint32(&o.PRO_MAC_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_Type) GetPRO_MAC_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_MAC_INTR_MAP.Reg) & 0x1f
}

// INTERRUPT.PRO_MAC_NMI_MAP: MAC_NMI interrupt configuration register
func (o *INTERRUPT_Type) SetPRO_MAC_NMI_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_MAC_NMI_MAP.Reg, volatile.LoadUint32(&o.PRO_MAC_NMI_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_Type) GetPRO_MAC_NMI_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_MAC_NMI_MAP.Reg) & 0x1f
}

// INTERRUPT.PRO_PWR_INTR_MAP: PWR_INTR interrupt configuration register
func (o *INTERRUPT_Type) SetPRO_PWR_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_PWR_INTR_MAP.Reg, volatile.LoadUint32(&o.PRO_PWR_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_Type) GetPRO_PWR_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_PWR_INTR_MAP.Reg) & 0x1f
}

// INTERRUPT.PRO_BB_INT_MAP: BB_INT interrupt configuration register
func (o *INTERRUPT_Type) SetPRO_BB_INT_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_BB_INT_MAP.Reg, volatile.LoadUint32(&o.PRO_BB_INT_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_Type) GetPRO_BB_INT_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_BB_INT_MAP.Reg) & 0x1f
}

// INTERRUPT.PRO_BT_MAC_INT_MAP: BT_MAC_INT interrupt configuration register
func (o *INTERRUPT_Type) SetPRO_BT_MAC_INT_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_BT_MAC_INT_MAP.Reg, volatile.LoadUint32(&o.PRO_BT_MAC_INT_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_Type) GetPRO_BT_MAC_INT_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_BT_MAC_INT_MAP.Reg) & 0x1f
}

// INTERRUPT.PRO_BT_BB_INT_MAP: BT_BB_INT interrupt configuration register
func (o *INTERRUPT_Type) SetPRO_BT_BB_INT_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_BT_BB_INT_MAP.Reg, volatile.LoadUint32(&o.PRO_BT_BB_INT_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_Type) GetPRO_BT_BB_INT_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_BT_BB_INT_MAP.Reg) & 0x1f
}

// INTERRUPT.PRO_BT_BB_NMI_MAP: BT_BB_NMI interrupt configuration register
func (o *INTERRUPT_Type) SetPRO_BT_BB_NMI_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_BT_BB_NMI_MAP.Reg, volatile.LoadUint32(&o.PRO_BT_BB_NMI_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_Type) GetPRO_BT_BB_NMI_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_BT_BB_NMI_MAP.Reg) & 0x1f
}

// INTERRUPT.PRO_RWBT_IRQ_MAP: RWBT_IRQ interrupt configuration register
func (o *INTERRUPT_Type) SetPRO_RWBT_IRQ_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_RWBT_IRQ_MAP.Reg, volatile.LoadUint32(&o.PRO_RWBT_IRQ_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_Type) GetPRO_RWBT_IRQ_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_RWBT_IRQ_MAP.Reg) & 0x1f
}

// INTERRUPT.PRO_RWBLE_IRQ_MAP: RWBLE_IRQ interrupt configuration register
func (o *INTERRUPT_Type) SetPRO_RWBLE_IRQ_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_RWBLE_IRQ_MAP.Reg, volatile.LoadUint32(&o.PRO_RWBLE_IRQ_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_Type) GetPRO_RWBLE_IRQ_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_RWBLE_IRQ_MAP.Reg) & 0x1f
}

// INTERRUPT.PRO_RWBT_NMI_MAP: RWBT_NMI interrupt configuration register
func (o *INTERRUPT_Type) SetPRO_RWBT_NMI_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_RWBT_NMI_MAP.Reg, volatile.LoadUint32(&o.PRO_RWBT_NMI_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_Type) GetPRO_RWBT_NMI_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_RWBT_NMI_MAP.Reg) & 0x1f
}

// INTERRUPT.PRO_RWBLE_NMI_MAP: RWBLE_NMI interrupt configuration register
func (o *INTERRUPT_Type) SetPRO_RWBLE_NMI_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_RWBLE_NMI_MAP.Reg, volatile.LoadUint32(&o.PRO_RWBLE_NMI_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_Type) GetPRO_RWBLE_NMI_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_RWBLE_NMI_MAP.Reg) & 0x1f
}

// INTERRUPT.PRO_SLC0_INTR_MAP: SLC0_INTR interrupt configuration register
func (o *INTERRUPT_Type) SetPRO_SLC0_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_SLC0_INTR_MAP.Reg, volatile.LoadUint32(&o.PRO_SLC0_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_Type) GetPRO_SLC0_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_SLC0_INTR_MAP.Reg) & 0x1f
}

// INTERRUPT.PRO_SLC1_INTR_MAP: SLC1_INTR interrupt configuration register
func (o *INTERRUPT_Type) SetPRO_SLC1_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_SLC1_INTR_MAP.Reg, volatile.LoadUint32(&o.PRO_SLC1_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_Type) GetPRO_SLC1_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_SLC1_INTR_MAP.Reg) & 0x1f
}

// INTERRUPT.PRO_UHCI0_INTR_MAP: UHCI0_INTR interrupt configuration register
func (o *INTERRUPT_Type) SetPRO_UHCI0_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_UHCI0_INTR_MAP.Reg, volatile.LoadUint32(&o.PRO_UHCI0_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_Type) GetPRO_UHCI0_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_UHCI0_INTR_MAP.Reg) & 0x1f
}

// INTERRUPT.PRO_UHCI1_INTR_MAP: UHCI1_INTR interrupt configuration register
func (o *INTERRUPT_Type) SetPRO_UHCI1_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_UHCI1_INTR_MAP.Reg, volatile.LoadUint32(&o.PRO_UHCI1_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_Type) GetPRO_UHCI1_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_UHCI1_INTR_MAP.Reg) & 0x1f
}

// INTERRUPT.PRO_TG_T0_LEVEL_INT_MAP: TG_T0_LEVEL_INT interrupt configuration register
func (o *INTERRUPT_Type) SetPRO_TG_T0_LEVEL_INT_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_TG_T0_LEVEL_INT_MAP.Reg, volatile.LoadUint32(&o.PRO_TG_T0_LEVEL_INT_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_Type) GetPRO_TG_T0_LEVEL_INT_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_TG_T0_LEVEL_INT_MAP.Reg) & 0x1f
}

// INTERRUPT.PRO_TG_T1_LEVEL_INT_MAP: TG_T1_LEVEL_INT interrupt configuration register
func (o *INTERRUPT_Type) SetPRO_TG_T1_LEVEL_INT_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_TG_T1_LEVEL_INT_MAP.Reg, volatile.LoadUint32(&o.PRO_TG_T1_LEVEL_INT_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_Type) GetPRO_TG_T1_LEVEL_INT_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_TG_T1_LEVEL_INT_MAP.Reg) & 0x1f
}

// INTERRUPT.PRO_TG_WDT_LEVEL_INT_MAP: TG_WDT_LEVEL_INT interrupt configuration register
func (o *INTERRUPT_Type) SetPRO_TG_WDT_LEVEL_INT_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_TG_WDT_LEVEL_INT_MAP.Reg, volatile.LoadUint32(&o.PRO_TG_WDT_LEVEL_INT_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_Type) GetPRO_TG_WDT_LEVEL_INT_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_TG_WDT_LEVEL_INT_MAP.Reg) & 0x1f
}

// INTERRUPT.PRO_TG_LACT_LEVEL_INT_MAP: TG_LACT_LEVEL_INT interrupt configuration register
func (o *INTERRUPT_Type) SetPRO_TG_LACT_LEVEL_INT_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_TG_LACT_LEVEL_INT_MAP.Reg, volatile.LoadUint32(&o.PRO_TG_LACT_LEVEL_INT_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_Type) GetPRO_TG_LACT_LEVEL_INT_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_TG_LACT_LEVEL_INT_MAP.Reg) & 0x1f
}

// INTERRUPT.PRO_TG1_T0_LEVEL_INT_MAP: TG1_T0_LEVEL_INT interrupt configuration register
func (o *INTERRUPT_Type) SetPRO_TG1_T0_LEVEL_INT_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_TG1_T0_LEVEL_INT_MAP.Reg, volatile.LoadUint32(&o.PRO_TG1_T0_LEVEL_INT_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_Type) GetPRO_TG1_T0_LEVEL_INT_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_TG1_T0_LEVEL_INT_MAP.Reg) & 0x1f
}

// INTERRUPT.PRO_TG1_T1_LEVEL_INT_MAP: TG1_T1_LEVEL_INT interrupt configuration register
func (o *INTERRUPT_Type) SetPRO_TG1_T1_LEVEL_INT_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_TG1_T1_LEVEL_INT_MAP.Reg, volatile.LoadUint32(&o.PRO_TG1_T1_LEVEL_INT_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_Type) GetPRO_TG1_T1_LEVEL_INT_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_TG1_T1_LEVEL_INT_MAP.Reg) & 0x1f
}

// INTERRUPT.PRO_TG1_WDT_LEVEL_INT_MAP: TG1_WDT_LEVEL_INT interrupt configuration register
func (o *INTERRUPT_Type) SetPRO_TG1_WDT_LEVEL_INT_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_TG1_WDT_LEVEL_INT_MAP.Reg, volatile.LoadUint32(&o.PRO_TG1_WDT_LEVEL_INT_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_Type) GetPRO_TG1_WDT_LEVEL_INT_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_TG1_WDT_LEVEL_INT_MAP.Reg) & 0x1f
}

// INTERRUPT.PRO_TG1_LACT_LEVEL_INT_MAP: TG1_LACT_LEVEL_INT interrupt configuration register
func (o *INTERRUPT_Type) SetPRO_TG1_LACT_LEVEL_INT_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_TG1_LACT_LEVEL_INT_MAP.Reg, volatile.LoadUint32(&o.PRO_TG1_LACT_LEVEL_INT_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_Type) GetPRO_TG1_LACT_LEVEL_INT_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_TG1_LACT_LEVEL_INT_MAP.Reg) & 0x1f
}

// INTERRUPT.PRO_GPIO_INTERRUPT_PRO_MAP: GPIO_INTERRUPT_PRO interrupt configuration register
func (o *INTERRUPT_Type) SetPRO_GPIO_INTERRUPT_PRO_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_GPIO_INTERRUPT_PRO_MAP.Reg, volatile.LoadUint32(&o.PRO_GPIO_INTERRUPT_PRO_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_Type) GetPRO_GPIO_INTERRUPT_PRO_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_GPIO_INTERRUPT_PRO_MAP.Reg) & 0x1f
}

// INTERRUPT.PRO_GPIO_INTERRUPT_PRO_NMI_MAP: GPIO_INTERRUPT_PRO_NMI interrupt configuration register
func (o *INTERRUPT_Type) SetPRO_GPIO_INTERRUPT_PRO_NMI_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_GPIO_INTERRUPT_PRO_NMI_MAP.Reg, volatile.LoadUint32(&o.PRO_GPIO_INTERRUPT_PRO_NMI_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_Type) GetPRO_GPIO_INTERRUPT_PRO_NMI_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_GPIO_INTERRUPT_PRO_NMI_MAP.Reg) & 0x1f
}

// INTERRUPT.PRO_GPIO_INTERRUPT_APP_MAP: GPIO_INTERRUPT_APP interrupt configuration register
func (o *INTERRUPT_Type) SetPRO_GPIO_INTERRUPT_APP_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_GPIO_INTERRUPT_APP_MAP.Reg, volatile.LoadUint32(&o.PRO_GPIO_INTERRUPT_APP_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_Type) GetPRO_GPIO_INTERRUPT_APP_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_GPIO_INTERRUPT_APP_MAP.Reg) & 0x1f
}

// INTERRUPT.PRO_GPIO_INTERRUPT_APP_NMI_MAP: GPIO_INTERRUPT_APP_NMI interrupt configuration register
func (o *INTERRUPT_Type) SetPRO_GPIO_INTERRUPT_APP_NMI_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_GPIO_INTERRUPT_APP_NMI_MAP.Reg, volatile.LoadUint32(&o.PRO_GPIO_INTERRUPT_APP_NMI_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_Type) GetPRO_GPIO_INTERRUPT_APP_NMI_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_GPIO_INTERRUPT_APP_NMI_MAP.Reg) & 0x1f
}

// INTERRUPT.PRO_DEDICATED_GPIO_IN_INTR_MAP: DEDICATED_GPIO_IN_INTR interrupt configuration register
func (o *INTERRUPT_Type) SetPRO_DEDICATED_GPIO_IN_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_DEDICATED_GPIO_IN_INTR_MAP.Reg, volatile.LoadUint32(&o.PRO_DEDICATED_GPIO_IN_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_Type) GetPRO_DEDICATED_GPIO_IN_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_DEDICATED_GPIO_IN_INTR_MAP.Reg) & 0x1f
}

// INTERRUPT.PRO_CPU_INTR_FROM_CPU_0_MAP: CPU_INTR_FROM_CPU_0 interrupt configuration register
func (o *INTERRUPT_Type) SetPRO_CPU_INTR_FROM_CPU_0_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_CPU_INTR_FROM_CPU_0_MAP.Reg, volatile.LoadUint32(&o.PRO_CPU_INTR_FROM_CPU_0_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_Type) GetPRO_CPU_INTR_FROM_CPU_0_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_CPU_INTR_FROM_CPU_0_MAP.Reg) & 0x1f
}

// INTERRUPT.PRO_CPU_INTR_FROM_CPU_1_MAP: CPU_INTR_FROM_CPU_1 interrupt configuration register
func (o *INTERRUPT_Type) SetPRO_CPU_INTR_FROM_CPU_1_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_CPU_INTR_FROM_CPU_1_MAP.Reg, volatile.LoadUint32(&o.PRO_CPU_INTR_FROM_CPU_1_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_Type) GetPRO_CPU_INTR_FROM_CPU_1_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_CPU_INTR_FROM_CPU_1_MAP.Reg) & 0x1f
}

// INTERRUPT.PRO_CPU_INTR_FROM_CPU_2_MAP: CPU_INTR_FROM_CPU_2 interrupt configuration register
func (o *INTERRUPT_Type) SetPRO_CPU_INTR_FROM_CPU_2_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_CPU_INTR_FROM_CPU_2_MAP.Reg, volatile.LoadUint32(&o.PRO_CPU_INTR_FROM_CPU_2_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_Type) GetPRO_CPU_INTR_FROM_CPU_2_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_CPU_INTR_FROM_CPU_2_MAP.Reg) & 0x1f
}

// INTERRUPT.PRO_CPU_INTR_FROM_CPU_3_MAP: CPU_INTR_FROM_CPU_3 interrupt configuration register
func (o *INTERRUPT_Type) SetPRO_CPU_INTR_FROM_CPU_3_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_CPU_INTR_FROM_CPU_3_MAP.Reg, volatile.LoadUint32(&o.PRO_CPU_INTR_FROM_CPU_3_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_Type) GetPRO_CPU_INTR_FROM_CPU_3_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_CPU_INTR_FROM_CPU_3_MAP.Reg) & 0x1f
}

// INTERRUPT.PRO_SPI_INTR_1_MAP: SPI_INTR_1 interrupt configuration register
func (o *INTERRUPT_Type) SetPRO_SPI_INTR_1_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_SPI_INTR_1_MAP.Reg, volatile.LoadUint32(&o.PRO_SPI_INTR_1_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_Type) GetPRO_SPI_INTR_1_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_SPI_INTR_1_MAP.Reg) & 0x1f
}

// INTERRUPT.PRO_SPI_INTR_2_MAP: SPI_INTR_2 interrupt configuration register
func (o *INTERRUPT_Type) SetPRO_SPI_INTR_2_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_SPI_INTR_2_MAP.Reg, volatile.LoadUint32(&o.PRO_SPI_INTR_2_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_Type) GetPRO_SPI_INTR_2_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_SPI_INTR_2_MAP.Reg) & 0x1f
}

// INTERRUPT.PRO_SPI_INTR_3_MAP: SPI_INTR_3 interrupt configuration register
func (o *INTERRUPT_Type) SetPRO_SPI_INTR_3_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_SPI_INTR_3_MAP.Reg, volatile.LoadUint32(&o.PRO_SPI_INTR_3_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_Type) GetPRO_SPI_INTR_3_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_SPI_INTR_3_MAP.Reg) & 0x1f
}

// INTERRUPT.PRO_I2S0_INT_MAP: I2S0_INT interrupt configuration register
func (o *INTERRUPT_Type) SetPRO_I2S0_INT_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_I2S0_INT_MAP.Reg, volatile.LoadUint32(&o.PRO_I2S0_INT_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_Type) GetPRO_I2S0_INT_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_I2S0_INT_MAP.Reg) & 0x1f
}

// INTERRUPT.PRO_I2S1_INT_MAP: I2S1_INT interrupt configuration register
func (o *INTERRUPT_Type) SetPRO_I2S1_INT_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_I2S1_INT_MAP.Reg, volatile.LoadUint32(&o.PRO_I2S1_INT_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_Type) GetPRO_I2S1_INT_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_I2S1_INT_MAP.Reg) & 0x1f
}

// INTERRUPT.PRO_UART_INTR_MAP: UART_INT interrupt configuration register
func (o *INTERRUPT_Type) SetPRO_UART_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_UART_INTR_MAP.Reg, volatile.LoadUint32(&o.PRO_UART_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_Type) GetPRO_UART_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_UART_INTR_MAP.Reg) & 0x1f
}

// INTERRUPT.PRO_UART1_INTR_MAP: UART1_INT interrupt configuration register
func (o *INTERRUPT_Type) SetPRO_UART1_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_UART1_INTR_MAP.Reg, volatile.LoadUint32(&o.PRO_UART1_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_Type) GetPRO_UART1_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_UART1_INTR_MAP.Reg) & 0x1f
}

// INTERRUPT.PRO_UART2_INTR_MAP: UART2_INT interrupt configuration register
func (o *INTERRUPT_Type) SetPRO_UART2_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_UART2_INTR_MAP.Reg, volatile.LoadUint32(&o.PRO_UART2_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_Type) GetPRO_UART2_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_UART2_INTR_MAP.Reg) & 0x1f
}

// INTERRUPT.PRO_SDIO_HOST_INTERRUPT_MAP: SDIO_HOST_INTERRUPT configuration register
func (o *INTERRUPT_Type) SetPRO_SDIO_HOST_INTERRUPT_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_SDIO_HOST_INTERRUPT_MAP.Reg, volatile.LoadUint32(&o.PRO_SDIO_HOST_INTERRUPT_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_Type) GetPRO_SDIO_HOST_INTERRUPT_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_SDIO_HOST_INTERRUPT_MAP.Reg) & 0x1f
}

// INTERRUPT.PRO_PWM0_INTR_MAP: PWM0_INTR interrupt configuration register
func (o *INTERRUPT_Type) SetPRO_PWM0_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_PWM0_INTR_MAP.Reg, volatile.LoadUint32(&o.PRO_PWM0_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_Type) GetPRO_PWM0_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_PWM0_INTR_MAP.Reg) & 0x1f
}

// INTERRUPT.PRO_PWM1_INTR_MAP: PWM1_INTR interrupt configuration register
func (o *INTERRUPT_Type) SetPRO_PWM1_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_PWM1_INTR_MAP.Reg, volatile.LoadUint32(&o.PRO_PWM1_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_Type) GetPRO_PWM1_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_PWM1_INTR_MAP.Reg) & 0x1f
}

// INTERRUPT.PRO_PWM2_INTR_MAP: PWM2_INTR interrupt configuration register
func (o *INTERRUPT_Type) SetPRO_PWM2_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_PWM2_INTR_MAP.Reg, volatile.LoadUint32(&o.PRO_PWM2_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_Type) GetPRO_PWM2_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_PWM2_INTR_MAP.Reg) & 0x1f
}

// INTERRUPT.PRO_PWM3_INTR_MAP: PWM3_INTR interrupt configuration register
func (o *INTERRUPT_Type) SetPRO_PWM3_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_PWM3_INTR_MAP.Reg, volatile.LoadUint32(&o.PRO_PWM3_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_Type) GetPRO_PWM3_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_PWM3_INTR_MAP.Reg) & 0x1f
}

// INTERRUPT.PRO_LEDC_INT_MAP: LEDC_INTR interrupt configuration register
func (o *INTERRUPT_Type) SetPRO_LEDC_INT_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_LEDC_INT_MAP.Reg, volatile.LoadUint32(&o.PRO_LEDC_INT_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_Type) GetPRO_LEDC_INT_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_LEDC_INT_MAP.Reg) & 0x1f
}

// INTERRUPT.PRO_EFUSE_INT_MAP: EFUSE_INT interrupt configuration register
func (o *INTERRUPT_Type) SetPRO_EFUSE_INT_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_EFUSE_INT_MAP.Reg, volatile.LoadUint32(&o.PRO_EFUSE_INT_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_Type) GetPRO_EFUSE_INT_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_EFUSE_INT_MAP.Reg) & 0x1f
}

// INTERRUPT.PRO_CAN_INT_MAP: CAN_INT interrupt configuration register
func (o *INTERRUPT_Type) SetPRO_CAN_INT_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_CAN_INT_MAP.Reg, volatile.LoadUint32(&o.PRO_CAN_INT_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_Type) GetPRO_CAN_INT_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_CAN_INT_MAP.Reg) & 0x1f
}

// INTERRUPT.PRO_USB_INTR_MAP: USB_INT interrupt configuration register
func (o *INTERRUPT_Type) SetPRO_USB_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_USB_INTR_MAP.Reg, volatile.LoadUint32(&o.PRO_USB_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_Type) GetPRO_USB_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_USB_INTR_MAP.Reg) & 0x1f
}

// INTERRUPT.PRO_RTC_CORE_INTR_MAP: RTC_CORE_INTR interrupt configuration register
func (o *INTERRUPT_Type) SetPRO_RTC_CORE_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_RTC_CORE_INTR_MAP.Reg, volatile.LoadUint32(&o.PRO_RTC_CORE_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_Type) GetPRO_RTC_CORE_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_RTC_CORE_INTR_MAP.Reg) & 0x1f
}

// INTERRUPT.PRO_RMT_INTR_MAP: RMT_INTR interrupt configuration register
func (o *INTERRUPT_Type) SetPRO_RMT_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_RMT_INTR_MAP.Reg, volatile.LoadUint32(&o.PRO_RMT_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_Type) GetPRO_RMT_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_RMT_INTR_MAP.Reg) & 0x1f
}

// INTERRUPT.PRO_PCNT_INTR_MAP: PCNT_INTR interrupt configuration register
func (o *INTERRUPT_Type) SetPRO_PCNT_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_PCNT_INTR_MAP.Reg, volatile.LoadUint32(&o.PRO_PCNT_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_Type) GetPRO_PCNT_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_PCNT_INTR_MAP.Reg) & 0x1f
}

// INTERRUPT.PRO_I2C_EXT0_INTR_MAP: I2C_EXT0_INTR interrupt configuration register
func (o *INTERRUPT_Type) SetPRO_I2C_EXT0_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_I2C_EXT0_INTR_MAP.Reg, volatile.LoadUint32(&o.PRO_I2C_EXT0_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_Type) GetPRO_I2C_EXT0_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_I2C_EXT0_INTR_MAP.Reg) & 0x1f
}

// INTERRUPT.PRO_I2C_EXT1_INTR_MAP: I2C_EXT1_INTR interrupt configuration register
func (o *INTERRUPT_Type) SetPRO_I2C_EXT1_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_I2C_EXT1_INTR_MAP.Reg, volatile.LoadUint32(&o.PRO_I2C_EXT1_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_Type) GetPRO_I2C_EXT1_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_I2C_EXT1_INTR_MAP.Reg) & 0x1f
}

// INTERRUPT.PRO_RSA_INTR_MAP: RSA_INTR interrupt configuration register
func (o *INTERRUPT_Type) SetPRO_RSA_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_RSA_INTR_MAP.Reg, volatile.LoadUint32(&o.PRO_RSA_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_Type) GetPRO_RSA_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_RSA_INTR_MAP.Reg) & 0x1f
}

// INTERRUPT.PRO_SHA_INTR_MAP: SHA_INTR interrupt configuration register
func (o *INTERRUPT_Type) SetPRO_SHA_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_SHA_INTR_MAP.Reg, volatile.LoadUint32(&o.PRO_SHA_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_Type) GetPRO_SHA_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_SHA_INTR_MAP.Reg) & 0x1f
}

// INTERRUPT.PRO_AES_INTR_MAP: AES_INTR interrupt configuration register
func (o *INTERRUPT_Type) SetPRO_AES_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_AES_INTR_MAP.Reg, volatile.LoadUint32(&o.PRO_AES_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_Type) GetPRO_AES_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_AES_INTR_MAP.Reg) & 0x1f
}

// INTERRUPT.PRO_SPI2_DMA_INT_MAP: SPI2_DMA_INT interrupt configuration register
func (o *INTERRUPT_Type) SetPRO_SPI2_DMA_INT_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_SPI2_DMA_INT_MAP.Reg, volatile.LoadUint32(&o.PRO_SPI2_DMA_INT_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_Type) GetPRO_SPI2_DMA_INT_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_SPI2_DMA_INT_MAP.Reg) & 0x1f
}

// INTERRUPT.PRO_SPI3_DMA_INT_MAP: SPI3_DMA_INT interrupt configuration register
func (o *INTERRUPT_Type) SetPRO_SPI3_DMA_INT_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_SPI3_DMA_INT_MAP.Reg, volatile.LoadUint32(&o.PRO_SPI3_DMA_INT_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_Type) GetPRO_SPI3_DMA_INT_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_SPI3_DMA_INT_MAP.Reg) & 0x1f
}

// INTERRUPT.PRO_WDG_INT_MAP: WDG_INT interrupt configuration register
func (o *INTERRUPT_Type) SetPRO_WDG_INT_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_WDG_INT_MAP.Reg, volatile.LoadUint32(&o.PRO_WDG_INT_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_Type) GetPRO_WDG_INT_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_WDG_INT_MAP.Reg) & 0x1f
}

// INTERRUPT.PRO_TIMER_INT1_MAP: TIMER_INT1 interrupt configuration register
func (o *INTERRUPT_Type) SetPRO_TIMER_INT1_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_TIMER_INT1_MAP.Reg, volatile.LoadUint32(&o.PRO_TIMER_INT1_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_Type) GetPRO_TIMER_INT1_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_TIMER_INT1_MAP.Reg) & 0x1f
}

// INTERRUPT.PRO_TIMER_INT2_MAP: TIMER_INT2 interrupt configuration register
func (o *INTERRUPT_Type) SetPRO_TIMER_INT2_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_TIMER_INT2_MAP.Reg, volatile.LoadUint32(&o.PRO_TIMER_INT2_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_Type) GetPRO_TIMER_INT2_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_TIMER_INT2_MAP.Reg) & 0x1f
}

// INTERRUPT.PRO_TG_T0_EDGE_INT_MAP: TG_T0_EDGE_INT interrupt configuration register
func (o *INTERRUPT_Type) SetPRO_TG_T0_EDGE_INT_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_TG_T0_EDGE_INT_MAP.Reg, volatile.LoadUint32(&o.PRO_TG_T0_EDGE_INT_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_Type) GetPRO_TG_T0_EDGE_INT_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_TG_T0_EDGE_INT_MAP.Reg) & 0x1f
}

// INTERRUPT.PRO_TG_T1_EDGE_INT_MAP: TG_T1_EDGE_INT interrupt configuration register
func (o *INTERRUPT_Type) SetPRO_TG_T1_EDGE_INT_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_TG_T1_EDGE_INT_MAP.Reg, volatile.LoadUint32(&o.PRO_TG_T1_EDGE_INT_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_Type) GetPRO_TG_T1_EDGE_INT_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_TG_T1_EDGE_INT_MAP.Reg) & 0x1f
}

// INTERRUPT.PRO_TG_WDT_EDGE_INT_MAP: TG_WDT_EDGE_INT interrupt configuration register
func (o *INTERRUPT_Type) SetPRO_TG_WDT_EDGE_INT_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_TG_WDT_EDGE_INT_MAP.Reg, volatile.LoadUint32(&o.PRO_TG_WDT_EDGE_INT_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_Type) GetPRO_TG_WDT_EDGE_INT_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_TG_WDT_EDGE_INT_MAP.Reg) & 0x1f
}

// INTERRUPT.PRO_TG_LACT_EDGE_INT_MAP: TG_LACT_EDGE_INT interrupt configuration register
func (o *INTERRUPT_Type) SetPRO_TG_LACT_EDGE_INT_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_TG_LACT_EDGE_INT_MAP.Reg, volatile.LoadUint32(&o.PRO_TG_LACT_EDGE_INT_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_Type) GetPRO_TG_LACT_EDGE_INT_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_TG_LACT_EDGE_INT_MAP.Reg) & 0x1f
}

// INTERRUPT.PRO_TG1_T0_EDGE_INT_MAP: TG1_T0_EDGE_INT interrupt configuration register
func (o *INTERRUPT_Type) SetPRO_TG1_T0_EDGE_INT_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_TG1_T0_EDGE_INT_MAP.Reg, volatile.LoadUint32(&o.PRO_TG1_T0_EDGE_INT_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_Type) GetPRO_TG1_T0_EDGE_INT_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_TG1_T0_EDGE_INT_MAP.Reg) & 0x1f
}

// INTERRUPT.PRO_TG1_T1_EDGE_INT_MAP: TG1_T1_EDGE_INT interrupt configuration register
func (o *INTERRUPT_Type) SetPRO_TG1_T1_EDGE_INT_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_TG1_T1_EDGE_INT_MAP.Reg, volatile.LoadUint32(&o.PRO_TG1_T1_EDGE_INT_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_Type) GetPRO_TG1_T1_EDGE_INT_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_TG1_T1_EDGE_INT_MAP.Reg) & 0x1f
}

// INTERRUPT.PRO_TG1_WDT_EDGE_INT_MAP: TG1_WDT_EDGE_INT interrupt configuration register
func (o *INTERRUPT_Type) SetPRO_TG1_WDT_EDGE_INT_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_TG1_WDT_EDGE_INT_MAP.Reg, volatile.LoadUint32(&o.PRO_TG1_WDT_EDGE_INT_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_Type) GetPRO_TG1_WDT_EDGE_INT_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_TG1_WDT_EDGE_INT_MAP.Reg) & 0x1f
}

// INTERRUPT.PRO_TG1_LACT_EDGE_INT_MAP: TG1_LACT_EDGE_INT interrupt configuration register
func (o *INTERRUPT_Type) SetPRO_TG1_LACT_EDGE_INT_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_TG1_LACT_EDGE_INT_MAP.Reg, volatile.LoadUint32(&o.PRO_TG1_LACT_EDGE_INT_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_Type) GetPRO_TG1_LACT_EDGE_INT_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_TG1_LACT_EDGE_INT_MAP.Reg) & 0x1f
}

// INTERRUPT.PRO_CACHE_IA_INT_MAP: CACHE_IA_INT interrupt configuration register
func (o *INTERRUPT_Type) SetPRO_CACHE_IA_INT_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_CACHE_IA_INT_MAP.Reg, volatile.LoadUint32(&o.PRO_CACHE_IA_INT_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_Type) GetPRO_CACHE_IA_INT_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_CACHE_IA_INT_MAP.Reg) & 0x1f
}

// INTERRUPT.PRO_SYSTIMER_TARGET0_INT_MAP: SYSTIMER_TARGET0_INT interrupt configuration register
func (o *INTERRUPT_Type) SetPRO_SYSTIMER_TARGET0_INT_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_SYSTIMER_TARGET0_INT_MAP.Reg, volatile.LoadUint32(&o.PRO_SYSTIMER_TARGET0_INT_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_Type) GetPRO_SYSTIMER_TARGET0_INT_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_SYSTIMER_TARGET0_INT_MAP.Reg) & 0x1f
}

// INTERRUPT.PRO_SYSTIMER_TARGET1_INT_MAP: SYSTIMER_TARGET1_INT interrupt configuration register
func (o *INTERRUPT_Type) SetPRO_SYSTIMER_TARGET1_INT_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_SYSTIMER_TARGET1_INT_MAP.Reg, volatile.LoadUint32(&o.PRO_SYSTIMER_TARGET1_INT_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_Type) GetPRO_SYSTIMER_TARGET1_INT_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_SYSTIMER_TARGET1_INT_MAP.Reg) & 0x1f
}

// INTERRUPT.PRO_SYSTIMER_TARGET2_INT_MAP: SYSTIMER_TARGET2_INT interrupt configuration register
func (o *INTERRUPT_Type) SetPRO_SYSTIMER_TARGET2_INT_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_SYSTIMER_TARGET2_INT_MAP.Reg, volatile.LoadUint32(&o.PRO_SYSTIMER_TARGET2_INT_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_Type) GetPRO_SYSTIMER_TARGET2_INT_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_SYSTIMER_TARGET2_INT_MAP.Reg) & 0x1f
}

// INTERRUPT.PRO_ASSIST_DEBUG_INTR_MAP: ASSIST_DEBUG_INTR interrupt configuration register
func (o *INTERRUPT_Type) SetPRO_ASSIST_DEBUG_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_ASSIST_DEBUG_INTR_MAP.Reg, volatile.LoadUint32(&o.PRO_ASSIST_DEBUG_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_Type) GetPRO_ASSIST_DEBUG_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_ASSIST_DEBUG_INTR_MAP.Reg) & 0x1f
}

// INTERRUPT.PRO_PMS_PRO_IRAM0_ILG_INTR_MAP: PMS_PRO_IRAM0_ILG interrupt configuration register
func (o *INTERRUPT_Type) SetPRO_PMS_PRO_IRAM0_ILG_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_PMS_PRO_IRAM0_ILG_INTR_MAP.Reg, volatile.LoadUint32(&o.PRO_PMS_PRO_IRAM0_ILG_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_Type) GetPRO_PMS_PRO_IRAM0_ILG_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_PMS_PRO_IRAM0_ILG_INTR_MAP.Reg) & 0x1f
}

// INTERRUPT.PRO_PMS_PRO_DRAM0_ILG_INTR_MAP: PMS_PRO_DRAM0_ILG interrupt configuration register
func (o *INTERRUPT_Type) SetPRO_PMS_PRO_DRAM0_ILG_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_PMS_PRO_DRAM0_ILG_INTR_MAP.Reg, volatile.LoadUint32(&o.PRO_PMS_PRO_DRAM0_ILG_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_Type) GetPRO_PMS_PRO_DRAM0_ILG_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_PMS_PRO_DRAM0_ILG_INTR_MAP.Reg) & 0x1f
}

// INTERRUPT.PRO_PMS_PRO_DPORT_ILG_INTR_MAP: PMS_PRO_DPORT_ILG interrupt configuration register
func (o *INTERRUPT_Type) SetPRO_PMS_PRO_DPORT_ILG_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_PMS_PRO_DPORT_ILG_INTR_MAP.Reg, volatile.LoadUint32(&o.PRO_PMS_PRO_DPORT_ILG_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_Type) GetPRO_PMS_PRO_DPORT_ILG_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_PMS_PRO_DPORT_ILG_INTR_MAP.Reg) & 0x1f
}

// INTERRUPT.PRO_PMS_PRO_AHB_ILG_INTR_MAP: PMS_PRO_AHB_ILG interrupt configuration register
func (o *INTERRUPT_Type) SetPRO_PMS_PRO_AHB_ILG_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_PMS_PRO_AHB_ILG_INTR_MAP.Reg, volatile.LoadUint32(&o.PRO_PMS_PRO_AHB_ILG_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_Type) GetPRO_PMS_PRO_AHB_ILG_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_PMS_PRO_AHB_ILG_INTR_MAP.Reg) & 0x1f
}

// INTERRUPT.PRO_PMS_PRO_CACHE_ILG_INTR_MAP: PMS_PRO_CACHE_ILG interrupt configuration register
func (o *INTERRUPT_Type) SetPRO_PMS_PRO_CACHE_ILG_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_PMS_PRO_CACHE_ILG_INTR_MAP.Reg, volatile.LoadUint32(&o.PRO_PMS_PRO_CACHE_ILG_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_Type) GetPRO_PMS_PRO_CACHE_ILG_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_PMS_PRO_CACHE_ILG_INTR_MAP.Reg) & 0x1f
}

// INTERRUPT.PRO_PMS_DMA_APB_I_ILG_INTR_MAP: PMS_DMA_APB_I_ILG interrupt configuration register
func (o *INTERRUPT_Type) SetPRO_PMS_DMA_APB_I_ILG_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_PMS_DMA_APB_I_ILG_INTR_MAP.Reg, volatile.LoadUint32(&o.PRO_PMS_DMA_APB_I_ILG_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_Type) GetPRO_PMS_DMA_APB_I_ILG_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_PMS_DMA_APB_I_ILG_INTR_MAP.Reg) & 0x1f
}

// INTERRUPT.PRO_PMS_DMA_RX_I_ILG_INTR_MAP: PMS_DMA_RX_I_ILG interrupt configuration register
func (o *INTERRUPT_Type) SetPRO_PMS_DMA_RX_I_ILG_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_PMS_DMA_RX_I_ILG_INTR_MAP.Reg, volatile.LoadUint32(&o.PRO_PMS_DMA_RX_I_ILG_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_Type) GetPRO_PMS_DMA_RX_I_ILG_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_PMS_DMA_RX_I_ILG_INTR_MAP.Reg) & 0x1f
}

// INTERRUPT.PRO_PMS_DMA_TX_I_ILG_INTR_MAP: PMS_DMA_TX_I_ILG interrupt configuration register
func (o *INTERRUPT_Type) SetPRO_PMS_DMA_TX_I_ILG_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_PMS_DMA_TX_I_ILG_INTR_MAP.Reg, volatile.LoadUint32(&o.PRO_PMS_DMA_TX_I_ILG_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_Type) GetPRO_PMS_DMA_TX_I_ILG_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_PMS_DMA_TX_I_ILG_INTR_MAP.Reg) & 0x1f
}

// INTERRUPT.PRO_SPI_MEM_REJECT_INTR_MAP: SPI_MEM_REJECT_INTR interrupt configuration register
func (o *INTERRUPT_Type) SetPRO_SPI_MEM_REJECT_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_SPI_MEM_REJECT_INTR_MAP.Reg, volatile.LoadUint32(&o.PRO_SPI_MEM_REJECT_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_Type) GetPRO_SPI_MEM_REJECT_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_SPI_MEM_REJECT_INTR_MAP.Reg) & 0x1f
}

// INTERRUPT.PRO_DMA_COPY_INTR_MAP: DMA_COPY_INTR interrupt configuration register
func (o *INTERRUPT_Type) SetPRO_DMA_COPY_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_DMA_COPY_INTR_MAP.Reg, volatile.LoadUint32(&o.PRO_DMA_COPY_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_Type) GetPRO_DMA_COPY_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_DMA_COPY_INTR_MAP.Reg) & 0x1f
}

// INTERRUPT.PRO_SPI4_DMA_INT_MAP: SPI4_DMA_INT interrupt configuration register
func (o *INTERRUPT_Type) SetPRO_SPI4_DMA_INT_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_SPI4_DMA_INT_MAP.Reg, volatile.LoadUint32(&o.PRO_SPI4_DMA_INT_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_Type) GetPRO_SPI4_DMA_INT_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_SPI4_DMA_INT_MAP.Reg) & 0x1f
}

// INTERRUPT.PRO_SPI_INTR_4_MAP: SPI_INTR_4 interrupt configuration register
func (o *INTERRUPT_Type) SetPRO_SPI_INTR_4_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_SPI_INTR_4_MAP.Reg, volatile.LoadUint32(&o.PRO_SPI_INTR_4_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_Type) GetPRO_SPI_INTR_4_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_SPI_INTR_4_MAP.Reg) & 0x1f
}

// INTERRUPT.PRO_DCACHE_PRELOAD_INT_MAP: DCACHE_PRELOAD_INT interrupt configuration register
func (o *INTERRUPT_Type) SetPRO_DCACHE_PRELOAD_INT_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_DCACHE_PRELOAD_INT_MAP.Reg, volatile.LoadUint32(&o.PRO_DCACHE_PRELOAD_INT_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_Type) GetPRO_DCACHE_PRELOAD_INT_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_DCACHE_PRELOAD_INT_MAP.Reg) & 0x1f
}

// INTERRUPT.PRO_ICACHE_PRELOAD_INT_MAP: ICACHE_PRELOAD_INT interrupt configuration register
func (o *INTERRUPT_Type) SetPRO_ICACHE_PRELOAD_INT_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_ICACHE_PRELOAD_INT_MAP.Reg, volatile.LoadUint32(&o.PRO_ICACHE_PRELOAD_INT_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_Type) GetPRO_ICACHE_PRELOAD_INT_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_ICACHE_PRELOAD_INT_MAP.Reg) & 0x1f
}

// INTERRUPT.PRO_APB_ADC_INT_MAP: APB_ADC_INT interrupt configuration register
func (o *INTERRUPT_Type) SetPRO_APB_ADC_INT_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_APB_ADC_INT_MAP.Reg, volatile.LoadUint32(&o.PRO_APB_ADC_INT_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_Type) GetPRO_APB_ADC_INT_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_APB_ADC_INT_MAP.Reg) & 0x1f
}

// INTERRUPT.PRO_CRYPTO_DMA_INT_MAP: CRYPTO_DMA_INT interrupt configuration register
func (o *INTERRUPT_Type) SetPRO_CRYPTO_DMA_INT_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_CRYPTO_DMA_INT_MAP.Reg, volatile.LoadUint32(&o.PRO_CRYPTO_DMA_INT_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_Type) GetPRO_CRYPTO_DMA_INT_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_CRYPTO_DMA_INT_MAP.Reg) & 0x1f
}

// INTERRUPT.PRO_CPU_PERI_ERROR_INT_MAP: CPU_PERI_ERROR_INT interrupt configuration register
func (o *INTERRUPT_Type) SetPRO_CPU_PERI_ERROR_INT_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_CPU_PERI_ERROR_INT_MAP.Reg, volatile.LoadUint32(&o.PRO_CPU_PERI_ERROR_INT_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_Type) GetPRO_CPU_PERI_ERROR_INT_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_CPU_PERI_ERROR_INT_MAP.Reg) & 0x1f
}

// INTERRUPT.PRO_APB_PERI_ERROR_INT_MAP: APB_PERI_ERROR_INT interrupt configuration register
func (o *INTERRUPT_Type) SetPRO_APB_PERI_ERROR_INT_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_APB_PERI_ERROR_INT_MAP.Reg, volatile.LoadUint32(&o.PRO_APB_PERI_ERROR_INT_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_Type) GetPRO_APB_PERI_ERROR_INT_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_APB_PERI_ERROR_INT_MAP.Reg) & 0x1f
}

// INTERRUPT.PRO_DCACHE_SYNC_INT_MAP: DCACHE_SYNC_INT interrupt configuration register
func (o *INTERRUPT_Type) SetPRO_DCACHE_SYNC_INT_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_DCACHE_SYNC_INT_MAP.Reg, volatile.LoadUint32(&o.PRO_DCACHE_SYNC_INT_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_Type) GetPRO_DCACHE_SYNC_INT_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_DCACHE_SYNC_INT_MAP.Reg) & 0x1f
}

// INTERRUPT.PRO_ICACHE_SYNC_INT_MAP: ICACHE_SYNC_INT interrupt configuration register
func (o *INTERRUPT_Type) SetPRO_ICACHE_SYNC_INT_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_ICACHE_SYNC_INT_MAP.Reg, volatile.LoadUint32(&o.PRO_ICACHE_SYNC_INT_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_Type) GetPRO_ICACHE_SYNC_INT_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_ICACHE_SYNC_INT_MAP.Reg) & 0x1f
}

// INTERRUPT.PRO_INTR_STATUS_REG_0: Interrupt status register 0
func (o *INTERRUPT_Type) SetPRO_INTR_STATUS_REG_0(value uint32) {
	volatile.StoreUint32(&o.PRO_INTR_STATUS_REG_0.Reg, value)
}
func (o *INTERRUPT_Type) GetPRO_INTR_STATUS_REG_0() uint32 {
	return volatile.LoadUint32(&o.PRO_INTR_STATUS_REG_0.Reg)
}

// INTERRUPT.PRO_INTR_STATUS_REG_1: Interrupt status register 1
func (o *INTERRUPT_Type) SetPRO_INTR_STATUS_REG_1(value uint32) {
	volatile.StoreUint32(&o.PRO_INTR_STATUS_REG_1.Reg, value)
}
func (o *INTERRUPT_Type) GetPRO_INTR_STATUS_REG_1() uint32 {
	return volatile.LoadUint32(&o.PRO_INTR_STATUS_REG_1.Reg)
}

// INTERRUPT.PRO_INTR_STATUS_REG_2: Interrupt status register 2
func (o *INTERRUPT_Type) SetPRO_INTR_STATUS_REG_2(value uint32) {
	volatile.StoreUint32(&o.PRO_INTR_STATUS_REG_2.Reg, value)
}
func (o *INTERRUPT_Type) GetPRO_INTR_STATUS_REG_2() uint32 {
	return volatile.LoadUint32(&o.PRO_INTR_STATUS_REG_2.Reg)
}

// INTERRUPT.CLOCK_GATE: NMI interrupt signals mask register
func (o *INTERRUPT_Type) SetCLOCK_GATE_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.CLOCK_GATE.Reg, volatile.LoadUint32(&o.CLOCK_GATE.Reg)&^(0x1)|value)
}
func (o *INTERRUPT_Type) GetCLOCK_GATE_CLK_EN() uint32 {
	return volatile.LoadUint32(&o.CLOCK_GATE.Reg) & 0x1
}
func (o *INTERRUPT_Type) SetCLOCK_GATE_PRO_NMI_MASK_HW(value uint32) {
	volatile.StoreUint32(&o.CLOCK_GATE.Reg, volatile.LoadUint32(&o.CLOCK_GATE.Reg)&^(0x2)|value<<1)
}
func (o *INTERRUPT_Type) GetCLOCK_GATE_PRO_NMI_MASK_HW() uint32 {
	return (volatile.LoadUint32(&o.CLOCK_GATE.Reg) & 0x2) >> 1
}

// INTERRUPT.REG_DATE: Version control register
func (o *INTERRUPT_Type) SetREG_DATE_INTERRUPT_REG_DATE(value uint32) {
	volatile.StoreUint32(&o.REG_DATE.Reg, volatile.LoadUint32(&o.REG_DATE.Reg)&^(0xfffffff)|value)
}
func (o *INTERRUPT_Type) GetREG_DATE_INTERRUPT_REG_DATE() uint32 {
	return volatile.LoadUint32(&o.REG_DATE.Reg) & 0xfffffff
}

// Peripheral IO_MUX
type IO_MUX_Type struct {
	PIN_CTRL   volatile.Register32 // 0x0
	GPIO0      volatile.Register32 // 0x4
	GPIO1      volatile.Register32 // 0x8
	GPIO2      volatile.Register32 // 0xC
	GPIO3      volatile.Register32 // 0x10
	GPIO4      volatile.Register32 // 0x14
	GPIO5      volatile.Register32 // 0x18
	GPIO6      volatile.Register32 // 0x1C
	GPIO7      volatile.Register32 // 0x20
	GPIO8      volatile.Register32 // 0x24
	GPIO9      volatile.Register32 // 0x28
	GPIO10     volatile.Register32 // 0x2C
	GPIO11     volatile.Register32 // 0x30
	GPIO12     volatile.Register32 // 0x34
	GPIO13     volatile.Register32 // 0x38
	GPIO14     volatile.Register32 // 0x3C
	XTAL_32K_P volatile.Register32 // 0x40
	XTAL_32K_N volatile.Register32 // 0x44
	DAC_1      volatile.Register32 // 0x48
	DAC_2      volatile.Register32 // 0x4C
	GPIO19     volatile.Register32 // 0x50
	GPIO20     volatile.Register32 // 0x54
	GPIO21     volatile.Register32 // 0x58
	_          [16]byte
	SPICS1     volatile.Register32 // 0x6C
	SPIHD      volatile.Register32 // 0x70
	SPIWP      volatile.Register32 // 0x74
	SPICS0     volatile.Register32 // 0x78
	SPICLK     volatile.Register32 // 0x7C
	SPIQ       volatile.Register32 // 0x80
	SPID       volatile.Register32 // 0x84
	GPIO_33    volatile.Register32 // 0x88
	GPIO_34    volatile.Register32 // 0x8C
	GPIO_35    volatile.Register32 // 0x90
	GPIO_36    volatile.Register32 // 0x94
	GPIO_37    volatile.Register32 // 0x98
	GPIO_38    volatile.Register32 // 0x9C
	MTCK       volatile.Register32 // 0xA0
	MTDO       volatile.Register32 // 0xA4
	MTDI       volatile.Register32 // 0xA8
	MTMS       volatile.Register32 // 0xAC
	U0TXD      volatile.Register32 // 0xB0
	U0RXD      volatile.Register32 // 0xB4
	GPIO_45    volatile.Register32 // 0xB8
	GPIO_46    volatile.Register32 // 0xBC
	_          [60]byte
	DATE       volatile.Register32 // 0xFC
}

// IO_MUX.PIN_CTRL: Clock output configuration register
func (o *IO_MUX_Type) SetPIN_CTRL_PIN_CLK_OUT1(value uint32) {
	volatile.StoreUint32(&o.PIN_CTRL.Reg, volatile.LoadUint32(&o.PIN_CTRL.Reg)&^(0xf)|value)
}
func (o *IO_MUX_Type) GetPIN_CTRL_PIN_CLK_OUT1() uint32 {
	return volatile.LoadUint32(&o.PIN_CTRL.Reg) & 0xf
}
func (o *IO_MUX_Type) SetPIN_CTRL_PIN_CLK_OUT2(value uint32) {
	volatile.StoreUint32(&o.PIN_CTRL.Reg, volatile.LoadUint32(&o.PIN_CTRL.Reg)&^(0xf0)|value<<4)
}
func (o *IO_MUX_Type) GetPIN_CTRL_PIN_CLK_OUT2() uint32 {
	return (volatile.LoadUint32(&o.PIN_CTRL.Reg) & 0xf0) >> 4
}
func (o *IO_MUX_Type) SetPIN_CTRL_PIN_CLK_OUT3(value uint32) {
	volatile.StoreUint32(&o.PIN_CTRL.Reg, volatile.LoadUint32(&o.PIN_CTRL.Reg)&^(0xf00)|value<<8)
}
func (o *IO_MUX_Type) GetPIN_CTRL_PIN_CLK_OUT3() uint32 {
	return (volatile.LoadUint32(&o.PIN_CTRL.Reg) & 0xf00) >> 8
}
func (o *IO_MUX_Type) SetPIN_CTRL_SWITCH_PRT_NUM(value uint32) {
	volatile.StoreUint32(&o.PIN_CTRL.Reg, volatile.LoadUint32(&o.PIN_CTRL.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetPIN_CTRL_SWITCH_PRT_NUM() uint32 {
	return (volatile.LoadUint32(&o.PIN_CTRL.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetPIN_CTRL_PAD_POWER_CTRL(value uint32) {
	volatile.StoreUint32(&o.PIN_CTRL.Reg, volatile.LoadUint32(&o.PIN_CTRL.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetPIN_CTRL_PAD_POWER_CTRL() uint32 {
	return (volatile.LoadUint32(&o.PIN_CTRL.Reg) & 0x8000) >> 15
}

// IO_MUX.GPIO0: Configuration register for pad GPIO0
func (o *IO_MUX_Type) SetGPIO0_MCU_OE(value uint32) {
	volatile.StoreUint32(&o.GPIO0.Reg, volatile.LoadUint32(&o.GPIO0.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetGPIO0_MCU_OE() uint32 {
	return volatile.LoadUint32(&o.GPIO0.Reg) & 0x1
}
func (o *IO_MUX_Type) SetGPIO0_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO0.Reg, volatile.LoadUint32(&o.GPIO0.Reg)&^(0x2)|value<<1)
}
func (o *IO_MUX_Type) GetGPIO0_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO0.Reg) & 0x2) >> 1
}
func (o *IO_MUX_Type) SetGPIO0_MCU_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO0.Reg, volatile.LoadUint32(&o.GPIO0.Reg)&^(0x4)|value<<2)
}
func (o *IO_MUX_Type) GetGPIO0_MCU_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO0.Reg) & 0x4) >> 2
}
func (o *IO_MUX_Type) SetGPIO0_MCU_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO0.Reg, volatile.LoadUint32(&o.GPIO0.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetGPIO0_MCU_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO0.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetGPIO0_MCU_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO0.Reg, volatile.LoadUint32(&o.GPIO0.Reg)&^(0x10)|value<<4)
}
func (o *IO_MUX_Type) GetGPIO0_MCU_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO0.Reg) & 0x10) >> 4
}
func (o *IO_MUX_Type) SetGPIO0_FUN_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO0.Reg, volatile.LoadUint32(&o.GPIO0.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetGPIO0_FUN_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO0.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetGPIO0_FUN_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO0.Reg, volatile.LoadUint32(&o.GPIO0.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetGPIO0_FUN_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO0.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetGPIO0_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO0.Reg, volatile.LoadUint32(&o.GPIO0.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetGPIO0_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO0.Reg) & 0x200) >> 9
}
func (o *IO_MUX_Type) SetGPIO0_FUN_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO0.Reg, volatile.LoadUint32(&o.GPIO0.Reg)&^(0xc00)|value<<10)
}
func (o *IO_MUX_Type) GetGPIO0_FUN_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO0.Reg) & 0xc00) >> 10
}
func (o *IO_MUX_Type) SetGPIO0_MCU_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO0.Reg, volatile.LoadUint32(&o.GPIO0.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetGPIO0_MCU_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO0.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetGPIO0_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO0.Reg, volatile.LoadUint32(&o.GPIO0.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetGPIO0_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO0.Reg) & 0x8000) >> 15
}

// IO_MUX.GPIO1: Configuration register for pad GPIO1
func (o *IO_MUX_Type) SetGPIO1_MCU_OE(value uint32) {
	volatile.StoreUint32(&o.GPIO1.Reg, volatile.LoadUint32(&o.GPIO1.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetGPIO1_MCU_OE() uint32 {
	return volatile.LoadUint32(&o.GPIO1.Reg) & 0x1
}
func (o *IO_MUX_Type) SetGPIO1_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO1.Reg, volatile.LoadUint32(&o.GPIO1.Reg)&^(0x2)|value<<1)
}
func (o *IO_MUX_Type) GetGPIO1_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO1.Reg) & 0x2) >> 1
}
func (o *IO_MUX_Type) SetGPIO1_MCU_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO1.Reg, volatile.LoadUint32(&o.GPIO1.Reg)&^(0x4)|value<<2)
}
func (o *IO_MUX_Type) GetGPIO1_MCU_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO1.Reg) & 0x4) >> 2
}
func (o *IO_MUX_Type) SetGPIO1_MCU_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO1.Reg, volatile.LoadUint32(&o.GPIO1.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetGPIO1_MCU_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO1.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetGPIO1_MCU_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO1.Reg, volatile.LoadUint32(&o.GPIO1.Reg)&^(0x10)|value<<4)
}
func (o *IO_MUX_Type) GetGPIO1_MCU_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO1.Reg) & 0x10) >> 4
}
func (o *IO_MUX_Type) SetGPIO1_FUN_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO1.Reg, volatile.LoadUint32(&o.GPIO1.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetGPIO1_FUN_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO1.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetGPIO1_FUN_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO1.Reg, volatile.LoadUint32(&o.GPIO1.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetGPIO1_FUN_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO1.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetGPIO1_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO1.Reg, volatile.LoadUint32(&o.GPIO1.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetGPIO1_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO1.Reg) & 0x200) >> 9
}
func (o *IO_MUX_Type) SetGPIO1_FUN_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO1.Reg, volatile.LoadUint32(&o.GPIO1.Reg)&^(0xc00)|value<<10)
}
func (o *IO_MUX_Type) GetGPIO1_FUN_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO1.Reg) & 0xc00) >> 10
}
func (o *IO_MUX_Type) SetGPIO1_MCU_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO1.Reg, volatile.LoadUint32(&o.GPIO1.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetGPIO1_MCU_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO1.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetGPIO1_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO1.Reg, volatile.LoadUint32(&o.GPIO1.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetGPIO1_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO1.Reg) & 0x8000) >> 15
}

// IO_MUX.GPIO2: Configuration register for pad GPIO2
func (o *IO_MUX_Type) SetGPIO2_MCU_OE(value uint32) {
	volatile.StoreUint32(&o.GPIO2.Reg, volatile.LoadUint32(&o.GPIO2.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetGPIO2_MCU_OE() uint32 {
	return volatile.LoadUint32(&o.GPIO2.Reg) & 0x1
}
func (o *IO_MUX_Type) SetGPIO2_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO2.Reg, volatile.LoadUint32(&o.GPIO2.Reg)&^(0x2)|value<<1)
}
func (o *IO_MUX_Type) GetGPIO2_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO2.Reg) & 0x2) >> 1
}
func (o *IO_MUX_Type) SetGPIO2_MCU_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO2.Reg, volatile.LoadUint32(&o.GPIO2.Reg)&^(0x4)|value<<2)
}
func (o *IO_MUX_Type) GetGPIO2_MCU_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO2.Reg) & 0x4) >> 2
}
func (o *IO_MUX_Type) SetGPIO2_MCU_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO2.Reg, volatile.LoadUint32(&o.GPIO2.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetGPIO2_MCU_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO2.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetGPIO2_MCU_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO2.Reg, volatile.LoadUint32(&o.GPIO2.Reg)&^(0x10)|value<<4)
}
func (o *IO_MUX_Type) GetGPIO2_MCU_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO2.Reg) & 0x10) >> 4
}
func (o *IO_MUX_Type) SetGPIO2_FUN_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO2.Reg, volatile.LoadUint32(&o.GPIO2.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetGPIO2_FUN_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO2.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetGPIO2_FUN_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO2.Reg, volatile.LoadUint32(&o.GPIO2.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetGPIO2_FUN_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO2.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetGPIO2_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO2.Reg, volatile.LoadUint32(&o.GPIO2.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetGPIO2_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO2.Reg) & 0x200) >> 9
}
func (o *IO_MUX_Type) SetGPIO2_FUN_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO2.Reg, volatile.LoadUint32(&o.GPIO2.Reg)&^(0xc00)|value<<10)
}
func (o *IO_MUX_Type) GetGPIO2_FUN_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO2.Reg) & 0xc00) >> 10
}
func (o *IO_MUX_Type) SetGPIO2_MCU_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO2.Reg, volatile.LoadUint32(&o.GPIO2.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetGPIO2_MCU_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO2.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetGPIO2_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO2.Reg, volatile.LoadUint32(&o.GPIO2.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetGPIO2_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO2.Reg) & 0x8000) >> 15
}

// IO_MUX.GPIO3: Configuration register for pad GPIO3
func (o *IO_MUX_Type) SetGPIO3_MCU_OE(value uint32) {
	volatile.StoreUint32(&o.GPIO3.Reg, volatile.LoadUint32(&o.GPIO3.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetGPIO3_MCU_OE() uint32 {
	return volatile.LoadUint32(&o.GPIO3.Reg) & 0x1
}
func (o *IO_MUX_Type) SetGPIO3_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO3.Reg, volatile.LoadUint32(&o.GPIO3.Reg)&^(0x2)|value<<1)
}
func (o *IO_MUX_Type) GetGPIO3_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO3.Reg) & 0x2) >> 1
}
func (o *IO_MUX_Type) SetGPIO3_MCU_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO3.Reg, volatile.LoadUint32(&o.GPIO3.Reg)&^(0x4)|value<<2)
}
func (o *IO_MUX_Type) GetGPIO3_MCU_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO3.Reg) & 0x4) >> 2
}
func (o *IO_MUX_Type) SetGPIO3_MCU_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO3.Reg, volatile.LoadUint32(&o.GPIO3.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetGPIO3_MCU_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO3.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetGPIO3_MCU_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO3.Reg, volatile.LoadUint32(&o.GPIO3.Reg)&^(0x10)|value<<4)
}
func (o *IO_MUX_Type) GetGPIO3_MCU_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO3.Reg) & 0x10) >> 4
}
func (o *IO_MUX_Type) SetGPIO3_FUN_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO3.Reg, volatile.LoadUint32(&o.GPIO3.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetGPIO3_FUN_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO3.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetGPIO3_FUN_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO3.Reg, volatile.LoadUint32(&o.GPIO3.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetGPIO3_FUN_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO3.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetGPIO3_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO3.Reg, volatile.LoadUint32(&o.GPIO3.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetGPIO3_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO3.Reg) & 0x200) >> 9
}
func (o *IO_MUX_Type) SetGPIO3_FUN_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO3.Reg, volatile.LoadUint32(&o.GPIO3.Reg)&^(0xc00)|value<<10)
}
func (o *IO_MUX_Type) GetGPIO3_FUN_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO3.Reg) & 0xc00) >> 10
}
func (o *IO_MUX_Type) SetGPIO3_MCU_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO3.Reg, volatile.LoadUint32(&o.GPIO3.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetGPIO3_MCU_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO3.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetGPIO3_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO3.Reg, volatile.LoadUint32(&o.GPIO3.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetGPIO3_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO3.Reg) & 0x8000) >> 15
}

// IO_MUX.GPIO4: Configuration register for pad GPIO4
func (o *IO_MUX_Type) SetGPIO4_MCU_OE(value uint32) {
	volatile.StoreUint32(&o.GPIO4.Reg, volatile.LoadUint32(&o.GPIO4.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetGPIO4_MCU_OE() uint32 {
	return volatile.LoadUint32(&o.GPIO4.Reg) & 0x1
}
func (o *IO_MUX_Type) SetGPIO4_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO4.Reg, volatile.LoadUint32(&o.GPIO4.Reg)&^(0x2)|value<<1)
}
func (o *IO_MUX_Type) GetGPIO4_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO4.Reg) & 0x2) >> 1
}
func (o *IO_MUX_Type) SetGPIO4_MCU_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO4.Reg, volatile.LoadUint32(&o.GPIO4.Reg)&^(0x4)|value<<2)
}
func (o *IO_MUX_Type) GetGPIO4_MCU_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO4.Reg) & 0x4) >> 2
}
func (o *IO_MUX_Type) SetGPIO4_MCU_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO4.Reg, volatile.LoadUint32(&o.GPIO4.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetGPIO4_MCU_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO4.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetGPIO4_MCU_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO4.Reg, volatile.LoadUint32(&o.GPIO4.Reg)&^(0x10)|value<<4)
}
func (o *IO_MUX_Type) GetGPIO4_MCU_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO4.Reg) & 0x10) >> 4
}
func (o *IO_MUX_Type) SetGPIO4_FUN_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO4.Reg, volatile.LoadUint32(&o.GPIO4.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetGPIO4_FUN_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO4.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetGPIO4_FUN_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO4.Reg, volatile.LoadUint32(&o.GPIO4.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetGPIO4_FUN_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO4.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetGPIO4_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO4.Reg, volatile.LoadUint32(&o.GPIO4.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetGPIO4_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO4.Reg) & 0x200) >> 9
}
func (o *IO_MUX_Type) SetGPIO4_FUN_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO4.Reg, volatile.LoadUint32(&o.GPIO4.Reg)&^(0xc00)|value<<10)
}
func (o *IO_MUX_Type) GetGPIO4_FUN_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO4.Reg) & 0xc00) >> 10
}
func (o *IO_MUX_Type) SetGPIO4_MCU_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO4.Reg, volatile.LoadUint32(&o.GPIO4.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetGPIO4_MCU_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO4.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetGPIO4_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO4.Reg, volatile.LoadUint32(&o.GPIO4.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetGPIO4_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO4.Reg) & 0x8000) >> 15
}

// IO_MUX.GPIO5: Configuration register for pad GPIO5
func (o *IO_MUX_Type) SetGPIO5_MCU_OE(value uint32) {
	volatile.StoreUint32(&o.GPIO5.Reg, volatile.LoadUint32(&o.GPIO5.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetGPIO5_MCU_OE() uint32 {
	return volatile.LoadUint32(&o.GPIO5.Reg) & 0x1
}
func (o *IO_MUX_Type) SetGPIO5_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO5.Reg, volatile.LoadUint32(&o.GPIO5.Reg)&^(0x2)|value<<1)
}
func (o *IO_MUX_Type) GetGPIO5_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO5.Reg) & 0x2) >> 1
}
func (o *IO_MUX_Type) SetGPIO5_MCU_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO5.Reg, volatile.LoadUint32(&o.GPIO5.Reg)&^(0x4)|value<<2)
}
func (o *IO_MUX_Type) GetGPIO5_MCU_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO5.Reg) & 0x4) >> 2
}
func (o *IO_MUX_Type) SetGPIO5_MCU_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO5.Reg, volatile.LoadUint32(&o.GPIO5.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetGPIO5_MCU_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO5.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetGPIO5_MCU_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO5.Reg, volatile.LoadUint32(&o.GPIO5.Reg)&^(0x10)|value<<4)
}
func (o *IO_MUX_Type) GetGPIO5_MCU_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO5.Reg) & 0x10) >> 4
}
func (o *IO_MUX_Type) SetGPIO5_FUN_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO5.Reg, volatile.LoadUint32(&o.GPIO5.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetGPIO5_FUN_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO5.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetGPIO5_FUN_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO5.Reg, volatile.LoadUint32(&o.GPIO5.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetGPIO5_FUN_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO5.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetGPIO5_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO5.Reg, volatile.LoadUint32(&o.GPIO5.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetGPIO5_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO5.Reg) & 0x200) >> 9
}
func (o *IO_MUX_Type) SetGPIO5_FUN_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO5.Reg, volatile.LoadUint32(&o.GPIO5.Reg)&^(0xc00)|value<<10)
}
func (o *IO_MUX_Type) GetGPIO5_FUN_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO5.Reg) & 0xc00) >> 10
}
func (o *IO_MUX_Type) SetGPIO5_MCU_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO5.Reg, volatile.LoadUint32(&o.GPIO5.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetGPIO5_MCU_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO5.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetGPIO5_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO5.Reg, volatile.LoadUint32(&o.GPIO5.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetGPIO5_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO5.Reg) & 0x8000) >> 15
}

// IO_MUX.GPIO6: Configuration register for pad GPIO6
func (o *IO_MUX_Type) SetGPIO6_MCU_OE(value uint32) {
	volatile.StoreUint32(&o.GPIO6.Reg, volatile.LoadUint32(&o.GPIO6.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetGPIO6_MCU_OE() uint32 {
	return volatile.LoadUint32(&o.GPIO6.Reg) & 0x1
}
func (o *IO_MUX_Type) SetGPIO6_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO6.Reg, volatile.LoadUint32(&o.GPIO6.Reg)&^(0x2)|value<<1)
}
func (o *IO_MUX_Type) GetGPIO6_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO6.Reg) & 0x2) >> 1
}
func (o *IO_MUX_Type) SetGPIO6_MCU_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO6.Reg, volatile.LoadUint32(&o.GPIO6.Reg)&^(0x4)|value<<2)
}
func (o *IO_MUX_Type) GetGPIO6_MCU_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO6.Reg) & 0x4) >> 2
}
func (o *IO_MUX_Type) SetGPIO6_MCU_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO6.Reg, volatile.LoadUint32(&o.GPIO6.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetGPIO6_MCU_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO6.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetGPIO6_MCU_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO6.Reg, volatile.LoadUint32(&o.GPIO6.Reg)&^(0x10)|value<<4)
}
func (o *IO_MUX_Type) GetGPIO6_MCU_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO6.Reg) & 0x10) >> 4
}
func (o *IO_MUX_Type) SetGPIO6_FUN_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO6.Reg, volatile.LoadUint32(&o.GPIO6.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetGPIO6_FUN_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO6.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetGPIO6_FUN_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO6.Reg, volatile.LoadUint32(&o.GPIO6.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetGPIO6_FUN_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO6.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetGPIO6_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO6.Reg, volatile.LoadUint32(&o.GPIO6.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetGPIO6_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO6.Reg) & 0x200) >> 9
}
func (o *IO_MUX_Type) SetGPIO6_FUN_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO6.Reg, volatile.LoadUint32(&o.GPIO6.Reg)&^(0xc00)|value<<10)
}
func (o *IO_MUX_Type) GetGPIO6_FUN_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO6.Reg) & 0xc00) >> 10
}
func (o *IO_MUX_Type) SetGPIO6_MCU_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO6.Reg, volatile.LoadUint32(&o.GPIO6.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetGPIO6_MCU_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO6.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetGPIO6_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO6.Reg, volatile.LoadUint32(&o.GPIO6.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetGPIO6_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO6.Reg) & 0x8000) >> 15
}

// IO_MUX.GPIO7: Configuration register for pad GPIO7
func (o *IO_MUX_Type) SetGPIO7_MCU_OE(value uint32) {
	volatile.StoreUint32(&o.GPIO7.Reg, volatile.LoadUint32(&o.GPIO7.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetGPIO7_MCU_OE() uint32 {
	return volatile.LoadUint32(&o.GPIO7.Reg) & 0x1
}
func (o *IO_MUX_Type) SetGPIO7_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO7.Reg, volatile.LoadUint32(&o.GPIO7.Reg)&^(0x2)|value<<1)
}
func (o *IO_MUX_Type) GetGPIO7_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO7.Reg) & 0x2) >> 1
}
func (o *IO_MUX_Type) SetGPIO7_MCU_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO7.Reg, volatile.LoadUint32(&o.GPIO7.Reg)&^(0x4)|value<<2)
}
func (o *IO_MUX_Type) GetGPIO7_MCU_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO7.Reg) & 0x4) >> 2
}
func (o *IO_MUX_Type) SetGPIO7_MCU_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO7.Reg, volatile.LoadUint32(&o.GPIO7.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetGPIO7_MCU_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO7.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetGPIO7_MCU_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO7.Reg, volatile.LoadUint32(&o.GPIO7.Reg)&^(0x10)|value<<4)
}
func (o *IO_MUX_Type) GetGPIO7_MCU_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO7.Reg) & 0x10) >> 4
}
func (o *IO_MUX_Type) SetGPIO7_FUN_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO7.Reg, volatile.LoadUint32(&o.GPIO7.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetGPIO7_FUN_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO7.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetGPIO7_FUN_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO7.Reg, volatile.LoadUint32(&o.GPIO7.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetGPIO7_FUN_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO7.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetGPIO7_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO7.Reg, volatile.LoadUint32(&o.GPIO7.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetGPIO7_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO7.Reg) & 0x200) >> 9
}
func (o *IO_MUX_Type) SetGPIO7_FUN_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO7.Reg, volatile.LoadUint32(&o.GPIO7.Reg)&^(0xc00)|value<<10)
}
func (o *IO_MUX_Type) GetGPIO7_FUN_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO7.Reg) & 0xc00) >> 10
}
func (o *IO_MUX_Type) SetGPIO7_MCU_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO7.Reg, volatile.LoadUint32(&o.GPIO7.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetGPIO7_MCU_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO7.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetGPIO7_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO7.Reg, volatile.LoadUint32(&o.GPIO7.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetGPIO7_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO7.Reg) & 0x8000) >> 15
}

// IO_MUX.GPIO8: Configuration register for pad GPIO8
func (o *IO_MUX_Type) SetGPIO8_MCU_OE(value uint32) {
	volatile.StoreUint32(&o.GPIO8.Reg, volatile.LoadUint32(&o.GPIO8.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetGPIO8_MCU_OE() uint32 {
	return volatile.LoadUint32(&o.GPIO8.Reg) & 0x1
}
func (o *IO_MUX_Type) SetGPIO8_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO8.Reg, volatile.LoadUint32(&o.GPIO8.Reg)&^(0x2)|value<<1)
}
func (o *IO_MUX_Type) GetGPIO8_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO8.Reg) & 0x2) >> 1
}
func (o *IO_MUX_Type) SetGPIO8_MCU_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO8.Reg, volatile.LoadUint32(&o.GPIO8.Reg)&^(0x4)|value<<2)
}
func (o *IO_MUX_Type) GetGPIO8_MCU_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO8.Reg) & 0x4) >> 2
}
func (o *IO_MUX_Type) SetGPIO8_MCU_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO8.Reg, volatile.LoadUint32(&o.GPIO8.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetGPIO8_MCU_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO8.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetGPIO8_MCU_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO8.Reg, volatile.LoadUint32(&o.GPIO8.Reg)&^(0x10)|value<<4)
}
func (o *IO_MUX_Type) GetGPIO8_MCU_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO8.Reg) & 0x10) >> 4
}
func (o *IO_MUX_Type) SetGPIO8_FUN_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO8.Reg, volatile.LoadUint32(&o.GPIO8.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetGPIO8_FUN_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO8.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetGPIO8_FUN_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO8.Reg, volatile.LoadUint32(&o.GPIO8.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetGPIO8_FUN_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO8.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetGPIO8_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO8.Reg, volatile.LoadUint32(&o.GPIO8.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetGPIO8_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO8.Reg) & 0x200) >> 9
}
func (o *IO_MUX_Type) SetGPIO8_FUN_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO8.Reg, volatile.LoadUint32(&o.GPIO8.Reg)&^(0xc00)|value<<10)
}
func (o *IO_MUX_Type) GetGPIO8_FUN_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO8.Reg) & 0xc00) >> 10
}
func (o *IO_MUX_Type) SetGPIO8_MCU_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO8.Reg, volatile.LoadUint32(&o.GPIO8.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetGPIO8_MCU_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO8.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetGPIO8_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO8.Reg, volatile.LoadUint32(&o.GPIO8.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetGPIO8_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO8.Reg) & 0x8000) >> 15
}

// IO_MUX.GPIO9: Configuration register for pad GPIO9
func (o *IO_MUX_Type) SetGPIO9_MCU_OE(value uint32) {
	volatile.StoreUint32(&o.GPIO9.Reg, volatile.LoadUint32(&o.GPIO9.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetGPIO9_MCU_OE() uint32 {
	return volatile.LoadUint32(&o.GPIO9.Reg) & 0x1
}
func (o *IO_MUX_Type) SetGPIO9_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO9.Reg, volatile.LoadUint32(&o.GPIO9.Reg)&^(0x2)|value<<1)
}
func (o *IO_MUX_Type) GetGPIO9_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO9.Reg) & 0x2) >> 1
}
func (o *IO_MUX_Type) SetGPIO9_MCU_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO9.Reg, volatile.LoadUint32(&o.GPIO9.Reg)&^(0x4)|value<<2)
}
func (o *IO_MUX_Type) GetGPIO9_MCU_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO9.Reg) & 0x4) >> 2
}
func (o *IO_MUX_Type) SetGPIO9_MCU_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO9.Reg, volatile.LoadUint32(&o.GPIO9.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetGPIO9_MCU_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO9.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetGPIO9_MCU_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO9.Reg, volatile.LoadUint32(&o.GPIO9.Reg)&^(0x10)|value<<4)
}
func (o *IO_MUX_Type) GetGPIO9_MCU_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO9.Reg) & 0x10) >> 4
}
func (o *IO_MUX_Type) SetGPIO9_FUN_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO9.Reg, volatile.LoadUint32(&o.GPIO9.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetGPIO9_FUN_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO9.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetGPIO9_FUN_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO9.Reg, volatile.LoadUint32(&o.GPIO9.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetGPIO9_FUN_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO9.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetGPIO9_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO9.Reg, volatile.LoadUint32(&o.GPIO9.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetGPIO9_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO9.Reg) & 0x200) >> 9
}
func (o *IO_MUX_Type) SetGPIO9_FUN_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO9.Reg, volatile.LoadUint32(&o.GPIO9.Reg)&^(0xc00)|value<<10)
}
func (o *IO_MUX_Type) GetGPIO9_FUN_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO9.Reg) & 0xc00) >> 10
}
func (o *IO_MUX_Type) SetGPIO9_MCU_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO9.Reg, volatile.LoadUint32(&o.GPIO9.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetGPIO9_MCU_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO9.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetGPIO9_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO9.Reg, volatile.LoadUint32(&o.GPIO9.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetGPIO9_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO9.Reg) & 0x8000) >> 15
}

// IO_MUX.GPIO10: Configuration register for pad GPIO10
func (o *IO_MUX_Type) SetGPIO10_MCU_OE(value uint32) {
	volatile.StoreUint32(&o.GPIO10.Reg, volatile.LoadUint32(&o.GPIO10.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetGPIO10_MCU_OE() uint32 {
	return volatile.LoadUint32(&o.GPIO10.Reg) & 0x1
}
func (o *IO_MUX_Type) SetGPIO10_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO10.Reg, volatile.LoadUint32(&o.GPIO10.Reg)&^(0x2)|value<<1)
}
func (o *IO_MUX_Type) GetGPIO10_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO10.Reg) & 0x2) >> 1
}
func (o *IO_MUX_Type) SetGPIO10_MCU_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO10.Reg, volatile.LoadUint32(&o.GPIO10.Reg)&^(0x4)|value<<2)
}
func (o *IO_MUX_Type) GetGPIO10_MCU_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO10.Reg) & 0x4) >> 2
}
func (o *IO_MUX_Type) SetGPIO10_MCU_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO10.Reg, volatile.LoadUint32(&o.GPIO10.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetGPIO10_MCU_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO10.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetGPIO10_MCU_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO10.Reg, volatile.LoadUint32(&o.GPIO10.Reg)&^(0x10)|value<<4)
}
func (o *IO_MUX_Type) GetGPIO10_MCU_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO10.Reg) & 0x10) >> 4
}
func (o *IO_MUX_Type) SetGPIO10_FUN_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO10.Reg, volatile.LoadUint32(&o.GPIO10.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetGPIO10_FUN_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO10.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetGPIO10_FUN_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO10.Reg, volatile.LoadUint32(&o.GPIO10.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetGPIO10_FUN_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO10.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetGPIO10_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO10.Reg, volatile.LoadUint32(&o.GPIO10.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetGPIO10_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO10.Reg) & 0x200) >> 9
}
func (o *IO_MUX_Type) SetGPIO10_FUN_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO10.Reg, volatile.LoadUint32(&o.GPIO10.Reg)&^(0xc00)|value<<10)
}
func (o *IO_MUX_Type) GetGPIO10_FUN_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO10.Reg) & 0xc00) >> 10
}
func (o *IO_MUX_Type) SetGPIO10_MCU_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO10.Reg, volatile.LoadUint32(&o.GPIO10.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetGPIO10_MCU_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO10.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetGPIO10_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO10.Reg, volatile.LoadUint32(&o.GPIO10.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetGPIO10_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO10.Reg) & 0x8000) >> 15
}

// IO_MUX.GPIO11: Configuration register for pad GPIO11
func (o *IO_MUX_Type) SetGPIO11_MCU_OE(value uint32) {
	volatile.StoreUint32(&o.GPIO11.Reg, volatile.LoadUint32(&o.GPIO11.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetGPIO11_MCU_OE() uint32 {
	return volatile.LoadUint32(&o.GPIO11.Reg) & 0x1
}
func (o *IO_MUX_Type) SetGPIO11_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO11.Reg, volatile.LoadUint32(&o.GPIO11.Reg)&^(0x2)|value<<1)
}
func (o *IO_MUX_Type) GetGPIO11_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO11.Reg) & 0x2) >> 1
}
func (o *IO_MUX_Type) SetGPIO11_MCU_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO11.Reg, volatile.LoadUint32(&o.GPIO11.Reg)&^(0x4)|value<<2)
}
func (o *IO_MUX_Type) GetGPIO11_MCU_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO11.Reg) & 0x4) >> 2
}
func (o *IO_MUX_Type) SetGPIO11_MCU_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO11.Reg, volatile.LoadUint32(&o.GPIO11.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetGPIO11_MCU_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO11.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetGPIO11_MCU_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO11.Reg, volatile.LoadUint32(&o.GPIO11.Reg)&^(0x10)|value<<4)
}
func (o *IO_MUX_Type) GetGPIO11_MCU_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO11.Reg) & 0x10) >> 4
}
func (o *IO_MUX_Type) SetGPIO11_FUN_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO11.Reg, volatile.LoadUint32(&o.GPIO11.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetGPIO11_FUN_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO11.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetGPIO11_FUN_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO11.Reg, volatile.LoadUint32(&o.GPIO11.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetGPIO11_FUN_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO11.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetGPIO11_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO11.Reg, volatile.LoadUint32(&o.GPIO11.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetGPIO11_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO11.Reg) & 0x200) >> 9
}
func (o *IO_MUX_Type) SetGPIO11_FUN_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO11.Reg, volatile.LoadUint32(&o.GPIO11.Reg)&^(0xc00)|value<<10)
}
func (o *IO_MUX_Type) GetGPIO11_FUN_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO11.Reg) & 0xc00) >> 10
}
func (o *IO_MUX_Type) SetGPIO11_MCU_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO11.Reg, volatile.LoadUint32(&o.GPIO11.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetGPIO11_MCU_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO11.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetGPIO11_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO11.Reg, volatile.LoadUint32(&o.GPIO11.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetGPIO11_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO11.Reg) & 0x8000) >> 15
}

// IO_MUX.GPIO12: Configuration register for pad GPIO12
func (o *IO_MUX_Type) SetGPIO12_MCU_OE(value uint32) {
	volatile.StoreUint32(&o.GPIO12.Reg, volatile.LoadUint32(&o.GPIO12.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetGPIO12_MCU_OE() uint32 {
	return volatile.LoadUint32(&o.GPIO12.Reg) & 0x1
}
func (o *IO_MUX_Type) SetGPIO12_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO12.Reg, volatile.LoadUint32(&o.GPIO12.Reg)&^(0x2)|value<<1)
}
func (o *IO_MUX_Type) GetGPIO12_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO12.Reg) & 0x2) >> 1
}
func (o *IO_MUX_Type) SetGPIO12_MCU_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO12.Reg, volatile.LoadUint32(&o.GPIO12.Reg)&^(0x4)|value<<2)
}
func (o *IO_MUX_Type) GetGPIO12_MCU_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO12.Reg) & 0x4) >> 2
}
func (o *IO_MUX_Type) SetGPIO12_MCU_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO12.Reg, volatile.LoadUint32(&o.GPIO12.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetGPIO12_MCU_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO12.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetGPIO12_MCU_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO12.Reg, volatile.LoadUint32(&o.GPIO12.Reg)&^(0x10)|value<<4)
}
func (o *IO_MUX_Type) GetGPIO12_MCU_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO12.Reg) & 0x10) >> 4
}
func (o *IO_MUX_Type) SetGPIO12_FUN_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO12.Reg, volatile.LoadUint32(&o.GPIO12.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetGPIO12_FUN_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO12.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetGPIO12_FUN_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO12.Reg, volatile.LoadUint32(&o.GPIO12.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetGPIO12_FUN_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO12.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetGPIO12_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO12.Reg, volatile.LoadUint32(&o.GPIO12.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetGPIO12_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO12.Reg) & 0x200) >> 9
}
func (o *IO_MUX_Type) SetGPIO12_FUN_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO12.Reg, volatile.LoadUint32(&o.GPIO12.Reg)&^(0xc00)|value<<10)
}
func (o *IO_MUX_Type) GetGPIO12_FUN_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO12.Reg) & 0xc00) >> 10
}
func (o *IO_MUX_Type) SetGPIO12_MCU_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO12.Reg, volatile.LoadUint32(&o.GPIO12.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetGPIO12_MCU_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO12.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetGPIO12_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO12.Reg, volatile.LoadUint32(&o.GPIO12.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetGPIO12_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO12.Reg) & 0x8000) >> 15
}

// IO_MUX.GPIO13: Configuration register for pad GPIO13
func (o *IO_MUX_Type) SetGPIO13_MCU_OE(value uint32) {
	volatile.StoreUint32(&o.GPIO13.Reg, volatile.LoadUint32(&o.GPIO13.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetGPIO13_MCU_OE() uint32 {
	return volatile.LoadUint32(&o.GPIO13.Reg) & 0x1
}
func (o *IO_MUX_Type) SetGPIO13_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO13.Reg, volatile.LoadUint32(&o.GPIO13.Reg)&^(0x2)|value<<1)
}
func (o *IO_MUX_Type) GetGPIO13_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO13.Reg) & 0x2) >> 1
}
func (o *IO_MUX_Type) SetGPIO13_MCU_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO13.Reg, volatile.LoadUint32(&o.GPIO13.Reg)&^(0x4)|value<<2)
}
func (o *IO_MUX_Type) GetGPIO13_MCU_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO13.Reg) & 0x4) >> 2
}
func (o *IO_MUX_Type) SetGPIO13_MCU_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO13.Reg, volatile.LoadUint32(&o.GPIO13.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetGPIO13_MCU_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO13.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetGPIO13_MCU_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO13.Reg, volatile.LoadUint32(&o.GPIO13.Reg)&^(0x10)|value<<4)
}
func (o *IO_MUX_Type) GetGPIO13_MCU_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO13.Reg) & 0x10) >> 4
}
func (o *IO_MUX_Type) SetGPIO13_FUN_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO13.Reg, volatile.LoadUint32(&o.GPIO13.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetGPIO13_FUN_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO13.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetGPIO13_FUN_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO13.Reg, volatile.LoadUint32(&o.GPIO13.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetGPIO13_FUN_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO13.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetGPIO13_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO13.Reg, volatile.LoadUint32(&o.GPIO13.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetGPIO13_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO13.Reg) & 0x200) >> 9
}
func (o *IO_MUX_Type) SetGPIO13_FUN_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO13.Reg, volatile.LoadUint32(&o.GPIO13.Reg)&^(0xc00)|value<<10)
}
func (o *IO_MUX_Type) GetGPIO13_FUN_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO13.Reg) & 0xc00) >> 10
}
func (o *IO_MUX_Type) SetGPIO13_MCU_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO13.Reg, volatile.LoadUint32(&o.GPIO13.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetGPIO13_MCU_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO13.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetGPIO13_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO13.Reg, volatile.LoadUint32(&o.GPIO13.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetGPIO13_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO13.Reg) & 0x8000) >> 15
}

// IO_MUX.GPIO14: Configuration register for pad GPIO14
func (o *IO_MUX_Type) SetGPIO14_MCU_OE(value uint32) {
	volatile.StoreUint32(&o.GPIO14.Reg, volatile.LoadUint32(&o.GPIO14.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetGPIO14_MCU_OE() uint32 {
	return volatile.LoadUint32(&o.GPIO14.Reg) & 0x1
}
func (o *IO_MUX_Type) SetGPIO14_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO14.Reg, volatile.LoadUint32(&o.GPIO14.Reg)&^(0x2)|value<<1)
}
func (o *IO_MUX_Type) GetGPIO14_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO14.Reg) & 0x2) >> 1
}
func (o *IO_MUX_Type) SetGPIO14_MCU_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO14.Reg, volatile.LoadUint32(&o.GPIO14.Reg)&^(0x4)|value<<2)
}
func (o *IO_MUX_Type) GetGPIO14_MCU_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO14.Reg) & 0x4) >> 2
}
func (o *IO_MUX_Type) SetGPIO14_MCU_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO14.Reg, volatile.LoadUint32(&o.GPIO14.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetGPIO14_MCU_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO14.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetGPIO14_MCU_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO14.Reg, volatile.LoadUint32(&o.GPIO14.Reg)&^(0x10)|value<<4)
}
func (o *IO_MUX_Type) GetGPIO14_MCU_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO14.Reg) & 0x10) >> 4
}
func (o *IO_MUX_Type) SetGPIO14_FUN_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO14.Reg, volatile.LoadUint32(&o.GPIO14.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetGPIO14_FUN_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO14.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetGPIO14_FUN_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO14.Reg, volatile.LoadUint32(&o.GPIO14.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetGPIO14_FUN_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO14.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetGPIO14_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO14.Reg, volatile.LoadUint32(&o.GPIO14.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetGPIO14_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO14.Reg) & 0x200) >> 9
}
func (o *IO_MUX_Type) SetGPIO14_FUN_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO14.Reg, volatile.LoadUint32(&o.GPIO14.Reg)&^(0xc00)|value<<10)
}
func (o *IO_MUX_Type) GetGPIO14_FUN_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO14.Reg) & 0xc00) >> 10
}
func (o *IO_MUX_Type) SetGPIO14_MCU_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO14.Reg, volatile.LoadUint32(&o.GPIO14.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetGPIO14_MCU_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO14.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetGPIO14_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO14.Reg, volatile.LoadUint32(&o.GPIO14.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetGPIO14_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO14.Reg) & 0x8000) >> 15
}

// IO_MUX.XTAL_32K_P: Configuration register for pad XTAL_32K_P
func (o *IO_MUX_Type) SetXTAL_32K_P_MCU_OE(value uint32) {
	volatile.StoreUint32(&o.XTAL_32K_P.Reg, volatile.LoadUint32(&o.XTAL_32K_P.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetXTAL_32K_P_MCU_OE() uint32 {
	return volatile.LoadUint32(&o.XTAL_32K_P.Reg) & 0x1
}
func (o *IO_MUX_Type) SetXTAL_32K_P_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.XTAL_32K_P.Reg, volatile.LoadUint32(&o.XTAL_32K_P.Reg)&^(0x2)|value<<1)
}
func (o *IO_MUX_Type) GetXTAL_32K_P_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.XTAL_32K_P.Reg) & 0x2) >> 1
}
func (o *IO_MUX_Type) SetXTAL_32K_P_MCU_WPD(value uint32) {
	volatile.StoreUint32(&o.XTAL_32K_P.Reg, volatile.LoadUint32(&o.XTAL_32K_P.Reg)&^(0x4)|value<<2)
}
func (o *IO_MUX_Type) GetXTAL_32K_P_MCU_WPD() uint32 {
	return (volatile.LoadUint32(&o.XTAL_32K_P.Reg) & 0x4) >> 2
}
func (o *IO_MUX_Type) SetXTAL_32K_P_MCU_WPU(value uint32) {
	volatile.StoreUint32(&o.XTAL_32K_P.Reg, volatile.LoadUint32(&o.XTAL_32K_P.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetXTAL_32K_P_MCU_WPU() uint32 {
	return (volatile.LoadUint32(&o.XTAL_32K_P.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetXTAL_32K_P_MCU_IE(value uint32) {
	volatile.StoreUint32(&o.XTAL_32K_P.Reg, volatile.LoadUint32(&o.XTAL_32K_P.Reg)&^(0x10)|value<<4)
}
func (o *IO_MUX_Type) GetXTAL_32K_P_MCU_IE() uint32 {
	return (volatile.LoadUint32(&o.XTAL_32K_P.Reg) & 0x10) >> 4
}
func (o *IO_MUX_Type) SetXTAL_32K_P_FUN_WPD(value uint32) {
	volatile.StoreUint32(&o.XTAL_32K_P.Reg, volatile.LoadUint32(&o.XTAL_32K_P.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetXTAL_32K_P_FUN_WPD() uint32 {
	return (volatile.LoadUint32(&o.XTAL_32K_P.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetXTAL_32K_P_FUN_WPU(value uint32) {
	volatile.StoreUint32(&o.XTAL_32K_P.Reg, volatile.LoadUint32(&o.XTAL_32K_P.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetXTAL_32K_P_FUN_WPU() uint32 {
	return (volatile.LoadUint32(&o.XTAL_32K_P.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetXTAL_32K_P_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.XTAL_32K_P.Reg, volatile.LoadUint32(&o.XTAL_32K_P.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetXTAL_32K_P_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.XTAL_32K_P.Reg) & 0x200) >> 9
}
func (o *IO_MUX_Type) SetXTAL_32K_P_FUN_DRV(value uint32) {
	volatile.StoreUint32(&o.XTAL_32K_P.Reg, volatile.LoadUint32(&o.XTAL_32K_P.Reg)&^(0xc00)|value<<10)
}
func (o *IO_MUX_Type) GetXTAL_32K_P_FUN_DRV() uint32 {
	return (volatile.LoadUint32(&o.XTAL_32K_P.Reg) & 0xc00) >> 10
}
func (o *IO_MUX_Type) SetXTAL_32K_P_MCU_SEL(value uint32) {
	volatile.StoreUint32(&o.XTAL_32K_P.Reg, volatile.LoadUint32(&o.XTAL_32K_P.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetXTAL_32K_P_MCU_SEL() uint32 {
	return (volatile.LoadUint32(&o.XTAL_32K_P.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetXTAL_32K_P_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.XTAL_32K_P.Reg, volatile.LoadUint32(&o.XTAL_32K_P.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetXTAL_32K_P_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.XTAL_32K_P.Reg) & 0x8000) >> 15
}

// IO_MUX.XTAL_32K_N: Configuration register for pad XTAL_32K_N
func (o *IO_MUX_Type) SetXTAL_32K_N_MCU_OE(value uint32) {
	volatile.StoreUint32(&o.XTAL_32K_N.Reg, volatile.LoadUint32(&o.XTAL_32K_N.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetXTAL_32K_N_MCU_OE() uint32 {
	return volatile.LoadUint32(&o.XTAL_32K_N.Reg) & 0x1
}
func (o *IO_MUX_Type) SetXTAL_32K_N_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.XTAL_32K_N.Reg, volatile.LoadUint32(&o.XTAL_32K_N.Reg)&^(0x2)|value<<1)
}
func (o *IO_MUX_Type) GetXTAL_32K_N_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.XTAL_32K_N.Reg) & 0x2) >> 1
}
func (o *IO_MUX_Type) SetXTAL_32K_N_MCU_WPD(value uint32) {
	volatile.StoreUint32(&o.XTAL_32K_N.Reg, volatile.LoadUint32(&o.XTAL_32K_N.Reg)&^(0x4)|value<<2)
}
func (o *IO_MUX_Type) GetXTAL_32K_N_MCU_WPD() uint32 {
	return (volatile.LoadUint32(&o.XTAL_32K_N.Reg) & 0x4) >> 2
}
func (o *IO_MUX_Type) SetXTAL_32K_N_MCU_WPU(value uint32) {
	volatile.StoreUint32(&o.XTAL_32K_N.Reg, volatile.LoadUint32(&o.XTAL_32K_N.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetXTAL_32K_N_MCU_WPU() uint32 {
	return (volatile.LoadUint32(&o.XTAL_32K_N.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetXTAL_32K_N_MCU_IE(value uint32) {
	volatile.StoreUint32(&o.XTAL_32K_N.Reg, volatile.LoadUint32(&o.XTAL_32K_N.Reg)&^(0x10)|value<<4)
}
func (o *IO_MUX_Type) GetXTAL_32K_N_MCU_IE() uint32 {
	return (volatile.LoadUint32(&o.XTAL_32K_N.Reg) & 0x10) >> 4
}
func (o *IO_MUX_Type) SetXTAL_32K_N_FUN_WPD(value uint32) {
	volatile.StoreUint32(&o.XTAL_32K_N.Reg, volatile.LoadUint32(&o.XTAL_32K_N.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetXTAL_32K_N_FUN_WPD() uint32 {
	return (volatile.LoadUint32(&o.XTAL_32K_N.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetXTAL_32K_N_FUN_WPU(value uint32) {
	volatile.StoreUint32(&o.XTAL_32K_N.Reg, volatile.LoadUint32(&o.XTAL_32K_N.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetXTAL_32K_N_FUN_WPU() uint32 {
	return (volatile.LoadUint32(&o.XTAL_32K_N.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetXTAL_32K_N_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.XTAL_32K_N.Reg, volatile.LoadUint32(&o.XTAL_32K_N.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetXTAL_32K_N_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.XTAL_32K_N.Reg) & 0x200) >> 9
}
func (o *IO_MUX_Type) SetXTAL_32K_N_FUN_DRV(value uint32) {
	volatile.StoreUint32(&o.XTAL_32K_N.Reg, volatile.LoadUint32(&o.XTAL_32K_N.Reg)&^(0xc00)|value<<10)
}
func (o *IO_MUX_Type) GetXTAL_32K_N_FUN_DRV() uint32 {
	return (volatile.LoadUint32(&o.XTAL_32K_N.Reg) & 0xc00) >> 10
}
func (o *IO_MUX_Type) SetXTAL_32K_N_MCU_SEL(value uint32) {
	volatile.StoreUint32(&o.XTAL_32K_N.Reg, volatile.LoadUint32(&o.XTAL_32K_N.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetXTAL_32K_N_MCU_SEL() uint32 {
	return (volatile.LoadUint32(&o.XTAL_32K_N.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetXTAL_32K_N_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.XTAL_32K_N.Reg, volatile.LoadUint32(&o.XTAL_32K_N.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetXTAL_32K_N_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.XTAL_32K_N.Reg) & 0x8000) >> 15
}

// IO_MUX.DAC_1: Configuration register for pad DAC_1
func (o *IO_MUX_Type) SetDAC_1_MCU_OE(value uint32) {
	volatile.StoreUint32(&o.DAC_1.Reg, volatile.LoadUint32(&o.DAC_1.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetDAC_1_MCU_OE() uint32 {
	return volatile.LoadUint32(&o.DAC_1.Reg) & 0x1
}
func (o *IO_MUX_Type) SetDAC_1_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.DAC_1.Reg, volatile.LoadUint32(&o.DAC_1.Reg)&^(0x2)|value<<1)
}
func (o *IO_MUX_Type) GetDAC_1_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.DAC_1.Reg) & 0x2) >> 1
}
func (o *IO_MUX_Type) SetDAC_1_MCU_WPD(value uint32) {
	volatile.StoreUint32(&o.DAC_1.Reg, volatile.LoadUint32(&o.DAC_1.Reg)&^(0x4)|value<<2)
}
func (o *IO_MUX_Type) GetDAC_1_MCU_WPD() uint32 {
	return (volatile.LoadUint32(&o.DAC_1.Reg) & 0x4) >> 2
}
func (o *IO_MUX_Type) SetDAC_1_MCU_WPU(value uint32) {
	volatile.StoreUint32(&o.DAC_1.Reg, volatile.LoadUint32(&o.DAC_1.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetDAC_1_MCU_WPU() uint32 {
	return (volatile.LoadUint32(&o.DAC_1.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetDAC_1_MCU_IE(value uint32) {
	volatile.StoreUint32(&o.DAC_1.Reg, volatile.LoadUint32(&o.DAC_1.Reg)&^(0x10)|value<<4)
}
func (o *IO_MUX_Type) GetDAC_1_MCU_IE() uint32 {
	return (volatile.LoadUint32(&o.DAC_1.Reg) & 0x10) >> 4
}
func (o *IO_MUX_Type) SetDAC_1_FUN_WPD(value uint32) {
	volatile.StoreUint32(&o.DAC_1.Reg, volatile.LoadUint32(&o.DAC_1.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetDAC_1_FUN_WPD() uint32 {
	return (volatile.LoadUint32(&o.DAC_1.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetDAC_1_FUN_WPU(value uint32) {
	volatile.StoreUint32(&o.DAC_1.Reg, volatile.LoadUint32(&o.DAC_1.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetDAC_1_FUN_WPU() uint32 {
	return (volatile.LoadUint32(&o.DAC_1.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetDAC_1_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.DAC_1.Reg, volatile.LoadUint32(&o.DAC_1.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetDAC_1_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.DAC_1.Reg) & 0x200) >> 9
}
func (o *IO_MUX_Type) SetDAC_1_FUN_DRV(value uint32) {
	volatile.StoreUint32(&o.DAC_1.Reg, volatile.LoadUint32(&o.DAC_1.Reg)&^(0xc00)|value<<10)
}
func (o *IO_MUX_Type) GetDAC_1_FUN_DRV() uint32 {
	return (volatile.LoadUint32(&o.DAC_1.Reg) & 0xc00) >> 10
}
func (o *IO_MUX_Type) SetDAC_1_MCU_SEL(value uint32) {
	volatile.StoreUint32(&o.DAC_1.Reg, volatile.LoadUint32(&o.DAC_1.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetDAC_1_MCU_SEL() uint32 {
	return (volatile.LoadUint32(&o.DAC_1.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetDAC_1_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.DAC_1.Reg, volatile.LoadUint32(&o.DAC_1.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetDAC_1_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.DAC_1.Reg) & 0x8000) >> 15
}

// IO_MUX.DAC_2: Configuration register for pad DAC_2
func (o *IO_MUX_Type) SetDAC_2_MCU_OE(value uint32) {
	volatile.StoreUint32(&o.DAC_2.Reg, volatile.LoadUint32(&o.DAC_2.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetDAC_2_MCU_OE() uint32 {
	return volatile.LoadUint32(&o.DAC_2.Reg) & 0x1
}
func (o *IO_MUX_Type) SetDAC_2_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.DAC_2.Reg, volatile.LoadUint32(&o.DAC_2.Reg)&^(0x2)|value<<1)
}
func (o *IO_MUX_Type) GetDAC_2_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.DAC_2.Reg) & 0x2) >> 1
}
func (o *IO_MUX_Type) SetDAC_2_MCU_WPD(value uint32) {
	volatile.StoreUint32(&o.DAC_2.Reg, volatile.LoadUint32(&o.DAC_2.Reg)&^(0x4)|value<<2)
}
func (o *IO_MUX_Type) GetDAC_2_MCU_WPD() uint32 {
	return (volatile.LoadUint32(&o.DAC_2.Reg) & 0x4) >> 2
}
func (o *IO_MUX_Type) SetDAC_2_MCU_WPU(value uint32) {
	volatile.StoreUint32(&o.DAC_2.Reg, volatile.LoadUint32(&o.DAC_2.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetDAC_2_MCU_WPU() uint32 {
	return (volatile.LoadUint32(&o.DAC_2.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetDAC_2_MCU_IE(value uint32) {
	volatile.StoreUint32(&o.DAC_2.Reg, volatile.LoadUint32(&o.DAC_2.Reg)&^(0x10)|value<<4)
}
func (o *IO_MUX_Type) GetDAC_2_MCU_IE() uint32 {
	return (volatile.LoadUint32(&o.DAC_2.Reg) & 0x10) >> 4
}
func (o *IO_MUX_Type) SetDAC_2_FUN_WPD(value uint32) {
	volatile.StoreUint32(&o.DAC_2.Reg, volatile.LoadUint32(&o.DAC_2.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetDAC_2_FUN_WPD() uint32 {
	return (volatile.LoadUint32(&o.DAC_2.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetDAC_2_FUN_WPU(value uint32) {
	volatile.StoreUint32(&o.DAC_2.Reg, volatile.LoadUint32(&o.DAC_2.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetDAC_2_FUN_WPU() uint32 {
	return (volatile.LoadUint32(&o.DAC_2.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetDAC_2_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.DAC_2.Reg, volatile.LoadUint32(&o.DAC_2.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetDAC_2_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.DAC_2.Reg) & 0x200) >> 9
}
func (o *IO_MUX_Type) SetDAC_2_FUN_DRV(value uint32) {
	volatile.StoreUint32(&o.DAC_2.Reg, volatile.LoadUint32(&o.DAC_2.Reg)&^(0xc00)|value<<10)
}
func (o *IO_MUX_Type) GetDAC_2_FUN_DRV() uint32 {
	return (volatile.LoadUint32(&o.DAC_2.Reg) & 0xc00) >> 10
}
func (o *IO_MUX_Type) SetDAC_2_MCU_SEL(value uint32) {
	volatile.StoreUint32(&o.DAC_2.Reg, volatile.LoadUint32(&o.DAC_2.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetDAC_2_MCU_SEL() uint32 {
	return (volatile.LoadUint32(&o.DAC_2.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetDAC_2_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.DAC_2.Reg, volatile.LoadUint32(&o.DAC_2.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetDAC_2_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.DAC_2.Reg) & 0x8000) >> 15
}

// IO_MUX.GPIO19: Configuration register for pad GPIO19
func (o *IO_MUX_Type) SetGPIO19_MCU_OE(value uint32) {
	volatile.StoreUint32(&o.GPIO19.Reg, volatile.LoadUint32(&o.GPIO19.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetGPIO19_MCU_OE() uint32 {
	return volatile.LoadUint32(&o.GPIO19.Reg) & 0x1
}
func (o *IO_MUX_Type) SetGPIO19_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO19.Reg, volatile.LoadUint32(&o.GPIO19.Reg)&^(0x2)|value<<1)
}
func (o *IO_MUX_Type) GetGPIO19_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO19.Reg) & 0x2) >> 1
}
func (o *IO_MUX_Type) SetGPIO19_MCU_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO19.Reg, volatile.LoadUint32(&o.GPIO19.Reg)&^(0x4)|value<<2)
}
func (o *IO_MUX_Type) GetGPIO19_MCU_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO19.Reg) & 0x4) >> 2
}
func (o *IO_MUX_Type) SetGPIO19_MCU_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO19.Reg, volatile.LoadUint32(&o.GPIO19.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetGPIO19_MCU_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO19.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetGPIO19_MCU_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO19.Reg, volatile.LoadUint32(&o.GPIO19.Reg)&^(0x10)|value<<4)
}
func (o *IO_MUX_Type) GetGPIO19_MCU_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO19.Reg) & 0x10) >> 4
}
func (o *IO_MUX_Type) SetGPIO19_FUN_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO19.Reg, volatile.LoadUint32(&o.GPIO19.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetGPIO19_FUN_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO19.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetGPIO19_FUN_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO19.Reg, volatile.LoadUint32(&o.GPIO19.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetGPIO19_FUN_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO19.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetGPIO19_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO19.Reg, volatile.LoadUint32(&o.GPIO19.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetGPIO19_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO19.Reg) & 0x200) >> 9
}
func (o *IO_MUX_Type) SetGPIO19_FUN_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO19.Reg, volatile.LoadUint32(&o.GPIO19.Reg)&^(0xc00)|value<<10)
}
func (o *IO_MUX_Type) GetGPIO19_FUN_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO19.Reg) & 0xc00) >> 10
}
func (o *IO_MUX_Type) SetGPIO19_MCU_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO19.Reg, volatile.LoadUint32(&o.GPIO19.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetGPIO19_MCU_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO19.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetGPIO19_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO19.Reg, volatile.LoadUint32(&o.GPIO19.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetGPIO19_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO19.Reg) & 0x8000) >> 15
}

// IO_MUX.GPIO20: Configuration register for pad GPIO20
func (o *IO_MUX_Type) SetGPIO20_MCU_OE(value uint32) {
	volatile.StoreUint32(&o.GPIO20.Reg, volatile.LoadUint32(&o.GPIO20.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetGPIO20_MCU_OE() uint32 {
	return volatile.LoadUint32(&o.GPIO20.Reg) & 0x1
}
func (o *IO_MUX_Type) SetGPIO20_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO20.Reg, volatile.LoadUint32(&o.GPIO20.Reg)&^(0x2)|value<<1)
}
func (o *IO_MUX_Type) GetGPIO20_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO20.Reg) & 0x2) >> 1
}
func (o *IO_MUX_Type) SetGPIO20_MCU_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO20.Reg, volatile.LoadUint32(&o.GPIO20.Reg)&^(0x4)|value<<2)
}
func (o *IO_MUX_Type) GetGPIO20_MCU_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO20.Reg) & 0x4) >> 2
}
func (o *IO_MUX_Type) SetGPIO20_MCU_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO20.Reg, volatile.LoadUint32(&o.GPIO20.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetGPIO20_MCU_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO20.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetGPIO20_MCU_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO20.Reg, volatile.LoadUint32(&o.GPIO20.Reg)&^(0x10)|value<<4)
}
func (o *IO_MUX_Type) GetGPIO20_MCU_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO20.Reg) & 0x10) >> 4
}
func (o *IO_MUX_Type) SetGPIO20_FUN_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO20.Reg, volatile.LoadUint32(&o.GPIO20.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetGPIO20_FUN_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO20.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetGPIO20_FUN_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO20.Reg, volatile.LoadUint32(&o.GPIO20.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetGPIO20_FUN_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO20.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetGPIO20_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO20.Reg, volatile.LoadUint32(&o.GPIO20.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetGPIO20_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO20.Reg) & 0x200) >> 9
}
func (o *IO_MUX_Type) SetGPIO20_FUN_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO20.Reg, volatile.LoadUint32(&o.GPIO20.Reg)&^(0xc00)|value<<10)
}
func (o *IO_MUX_Type) GetGPIO20_FUN_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO20.Reg) & 0xc00) >> 10
}
func (o *IO_MUX_Type) SetGPIO20_MCU_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO20.Reg, volatile.LoadUint32(&o.GPIO20.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetGPIO20_MCU_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO20.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetGPIO20_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO20.Reg, volatile.LoadUint32(&o.GPIO20.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetGPIO20_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO20.Reg) & 0x8000) >> 15
}

// IO_MUX.GPIO21: Configuration register for pad GPIO21
func (o *IO_MUX_Type) SetGPIO21_MCU_OE(value uint32) {
	volatile.StoreUint32(&o.GPIO21.Reg, volatile.LoadUint32(&o.GPIO21.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetGPIO21_MCU_OE() uint32 {
	return volatile.LoadUint32(&o.GPIO21.Reg) & 0x1
}
func (o *IO_MUX_Type) SetGPIO21_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO21.Reg, volatile.LoadUint32(&o.GPIO21.Reg)&^(0x2)|value<<1)
}
func (o *IO_MUX_Type) GetGPIO21_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO21.Reg) & 0x2) >> 1
}
func (o *IO_MUX_Type) SetGPIO21_MCU_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO21.Reg, volatile.LoadUint32(&o.GPIO21.Reg)&^(0x4)|value<<2)
}
func (o *IO_MUX_Type) GetGPIO21_MCU_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO21.Reg) & 0x4) >> 2
}
func (o *IO_MUX_Type) SetGPIO21_MCU_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO21.Reg, volatile.LoadUint32(&o.GPIO21.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetGPIO21_MCU_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO21.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetGPIO21_MCU_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO21.Reg, volatile.LoadUint32(&o.GPIO21.Reg)&^(0x10)|value<<4)
}
func (o *IO_MUX_Type) GetGPIO21_MCU_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO21.Reg) & 0x10) >> 4
}
func (o *IO_MUX_Type) SetGPIO21_FUN_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO21.Reg, volatile.LoadUint32(&o.GPIO21.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetGPIO21_FUN_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO21.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetGPIO21_FUN_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO21.Reg, volatile.LoadUint32(&o.GPIO21.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetGPIO21_FUN_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO21.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetGPIO21_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO21.Reg, volatile.LoadUint32(&o.GPIO21.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetGPIO21_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO21.Reg) & 0x200) >> 9
}
func (o *IO_MUX_Type) SetGPIO21_FUN_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO21.Reg, volatile.LoadUint32(&o.GPIO21.Reg)&^(0xc00)|value<<10)
}
func (o *IO_MUX_Type) GetGPIO21_FUN_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO21.Reg) & 0xc00) >> 10
}
func (o *IO_MUX_Type) SetGPIO21_MCU_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO21.Reg, volatile.LoadUint32(&o.GPIO21.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetGPIO21_MCU_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO21.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetGPIO21_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO21.Reg, volatile.LoadUint32(&o.GPIO21.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetGPIO21_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO21.Reg) & 0x8000) >> 15
}

// IO_MUX.SPICS1: Configuration register for pad SPICS1
func (o *IO_MUX_Type) SetSPICS1_MCU_OE(value uint32) {
	volatile.StoreUint32(&o.SPICS1.Reg, volatile.LoadUint32(&o.SPICS1.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetSPICS1_MCU_OE() uint32 {
	return volatile.LoadUint32(&o.SPICS1.Reg) & 0x1
}
func (o *IO_MUX_Type) SetSPICS1_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.SPICS1.Reg, volatile.LoadUint32(&o.SPICS1.Reg)&^(0x2)|value<<1)
}
func (o *IO_MUX_Type) GetSPICS1_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.SPICS1.Reg) & 0x2) >> 1
}
func (o *IO_MUX_Type) SetSPICS1_MCU_WPD(value uint32) {
	volatile.StoreUint32(&o.SPICS1.Reg, volatile.LoadUint32(&o.SPICS1.Reg)&^(0x4)|value<<2)
}
func (o *IO_MUX_Type) GetSPICS1_MCU_WPD() uint32 {
	return (volatile.LoadUint32(&o.SPICS1.Reg) & 0x4) >> 2
}
func (o *IO_MUX_Type) SetSPICS1_MCU_WPU(value uint32) {
	volatile.StoreUint32(&o.SPICS1.Reg, volatile.LoadUint32(&o.SPICS1.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetSPICS1_MCU_WPU() uint32 {
	return (volatile.LoadUint32(&o.SPICS1.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetSPICS1_MCU_IE(value uint32) {
	volatile.StoreUint32(&o.SPICS1.Reg, volatile.LoadUint32(&o.SPICS1.Reg)&^(0x10)|value<<4)
}
func (o *IO_MUX_Type) GetSPICS1_MCU_IE() uint32 {
	return (volatile.LoadUint32(&o.SPICS1.Reg) & 0x10) >> 4
}
func (o *IO_MUX_Type) SetSPICS1_FUN_WPD(value uint32) {
	volatile.StoreUint32(&o.SPICS1.Reg, volatile.LoadUint32(&o.SPICS1.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetSPICS1_FUN_WPD() uint32 {
	return (volatile.LoadUint32(&o.SPICS1.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetSPICS1_FUN_WPU(value uint32) {
	volatile.StoreUint32(&o.SPICS1.Reg, volatile.LoadUint32(&o.SPICS1.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetSPICS1_FUN_WPU() uint32 {
	return (volatile.LoadUint32(&o.SPICS1.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetSPICS1_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.SPICS1.Reg, volatile.LoadUint32(&o.SPICS1.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetSPICS1_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.SPICS1.Reg) & 0x200) >> 9
}
func (o *IO_MUX_Type) SetSPICS1_FUN_DRV(value uint32) {
	volatile.StoreUint32(&o.SPICS1.Reg, volatile.LoadUint32(&o.SPICS1.Reg)&^(0xc00)|value<<10)
}
func (o *IO_MUX_Type) GetSPICS1_FUN_DRV() uint32 {
	return (volatile.LoadUint32(&o.SPICS1.Reg) & 0xc00) >> 10
}
func (o *IO_MUX_Type) SetSPICS1_MCU_SEL(value uint32) {
	volatile.StoreUint32(&o.SPICS1.Reg, volatile.LoadUint32(&o.SPICS1.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetSPICS1_MCU_SEL() uint32 {
	return (volatile.LoadUint32(&o.SPICS1.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetSPICS1_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.SPICS1.Reg, volatile.LoadUint32(&o.SPICS1.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetSPICS1_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.SPICS1.Reg) & 0x8000) >> 15
}

// IO_MUX.SPIHD: Configuration register for pad SPIHD
func (o *IO_MUX_Type) SetSPIHD_MCU_OE(value uint32) {
	volatile.StoreUint32(&o.SPIHD.Reg, volatile.LoadUint32(&o.SPIHD.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetSPIHD_MCU_OE() uint32 {
	return volatile.LoadUint32(&o.SPIHD.Reg) & 0x1
}
func (o *IO_MUX_Type) SetSPIHD_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.SPIHD.Reg, volatile.LoadUint32(&o.SPIHD.Reg)&^(0x2)|value<<1)
}
func (o *IO_MUX_Type) GetSPIHD_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.SPIHD.Reg) & 0x2) >> 1
}
func (o *IO_MUX_Type) SetSPIHD_MCU_WPD(value uint32) {
	volatile.StoreUint32(&o.SPIHD.Reg, volatile.LoadUint32(&o.SPIHD.Reg)&^(0x4)|value<<2)
}
func (o *IO_MUX_Type) GetSPIHD_MCU_WPD() uint32 {
	return (volatile.LoadUint32(&o.SPIHD.Reg) & 0x4) >> 2
}
func (o *IO_MUX_Type) SetSPIHD_MCU_WPU(value uint32) {
	volatile.StoreUint32(&o.SPIHD.Reg, volatile.LoadUint32(&o.SPIHD.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetSPIHD_MCU_WPU() uint32 {
	return (volatile.LoadUint32(&o.SPIHD.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetSPIHD_MCU_IE(value uint32) {
	volatile.StoreUint32(&o.SPIHD.Reg, volatile.LoadUint32(&o.SPIHD.Reg)&^(0x10)|value<<4)
}
func (o *IO_MUX_Type) GetSPIHD_MCU_IE() uint32 {
	return (volatile.LoadUint32(&o.SPIHD.Reg) & 0x10) >> 4
}
func (o *IO_MUX_Type) SetSPIHD_FUN_WPD(value uint32) {
	volatile.StoreUint32(&o.SPIHD.Reg, volatile.LoadUint32(&o.SPIHD.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetSPIHD_FUN_WPD() uint32 {
	return (volatile.LoadUint32(&o.SPIHD.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetSPIHD_FUN_WPU(value uint32) {
	volatile.StoreUint32(&o.SPIHD.Reg, volatile.LoadUint32(&o.SPIHD.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetSPIHD_FUN_WPU() uint32 {
	return (volatile.LoadUint32(&o.SPIHD.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetSPIHD_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.SPIHD.Reg, volatile.LoadUint32(&o.SPIHD.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetSPIHD_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.SPIHD.Reg) & 0x200) >> 9
}
func (o *IO_MUX_Type) SetSPIHD_FUN_DRV(value uint32) {
	volatile.StoreUint32(&o.SPIHD.Reg, volatile.LoadUint32(&o.SPIHD.Reg)&^(0xc00)|value<<10)
}
func (o *IO_MUX_Type) GetSPIHD_FUN_DRV() uint32 {
	return (volatile.LoadUint32(&o.SPIHD.Reg) & 0xc00) >> 10
}
func (o *IO_MUX_Type) SetSPIHD_MCU_SEL(value uint32) {
	volatile.StoreUint32(&o.SPIHD.Reg, volatile.LoadUint32(&o.SPIHD.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetSPIHD_MCU_SEL() uint32 {
	return (volatile.LoadUint32(&o.SPIHD.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetSPIHD_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.SPIHD.Reg, volatile.LoadUint32(&o.SPIHD.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetSPIHD_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.SPIHD.Reg) & 0x8000) >> 15
}

// IO_MUX.SPIWP: Configuration register for pad SPIWP
func (o *IO_MUX_Type) SetSPIWP_MCU_OE(value uint32) {
	volatile.StoreUint32(&o.SPIWP.Reg, volatile.LoadUint32(&o.SPIWP.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetSPIWP_MCU_OE() uint32 {
	return volatile.LoadUint32(&o.SPIWP.Reg) & 0x1
}
func (o *IO_MUX_Type) SetSPIWP_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.SPIWP.Reg, volatile.LoadUint32(&o.SPIWP.Reg)&^(0x2)|value<<1)
}
func (o *IO_MUX_Type) GetSPIWP_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.SPIWP.Reg) & 0x2) >> 1
}
func (o *IO_MUX_Type) SetSPIWP_MCU_WPD(value uint32) {
	volatile.StoreUint32(&o.SPIWP.Reg, volatile.LoadUint32(&o.SPIWP.Reg)&^(0x4)|value<<2)
}
func (o *IO_MUX_Type) GetSPIWP_MCU_WPD() uint32 {
	return (volatile.LoadUint32(&o.SPIWP.Reg) & 0x4) >> 2
}
func (o *IO_MUX_Type) SetSPIWP_MCU_WPU(value uint32) {
	volatile.StoreUint32(&o.SPIWP.Reg, volatile.LoadUint32(&o.SPIWP.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetSPIWP_MCU_WPU() uint32 {
	return (volatile.LoadUint32(&o.SPIWP.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetSPIWP_MCU_IE(value uint32) {
	volatile.StoreUint32(&o.SPIWP.Reg, volatile.LoadUint32(&o.SPIWP.Reg)&^(0x10)|value<<4)
}
func (o *IO_MUX_Type) GetSPIWP_MCU_IE() uint32 {
	return (volatile.LoadUint32(&o.SPIWP.Reg) & 0x10) >> 4
}
func (o *IO_MUX_Type) SetSPIWP_FUN_WPD(value uint32) {
	volatile.StoreUint32(&o.SPIWP.Reg, volatile.LoadUint32(&o.SPIWP.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetSPIWP_FUN_WPD() uint32 {
	return (volatile.LoadUint32(&o.SPIWP.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetSPIWP_FUN_WPU(value uint32) {
	volatile.StoreUint32(&o.SPIWP.Reg, volatile.LoadUint32(&o.SPIWP.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetSPIWP_FUN_WPU() uint32 {
	return (volatile.LoadUint32(&o.SPIWP.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetSPIWP_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.SPIWP.Reg, volatile.LoadUint32(&o.SPIWP.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetSPIWP_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.SPIWP.Reg) & 0x200) >> 9
}
func (o *IO_MUX_Type) SetSPIWP_FUN_DRV(value uint32) {
	volatile.StoreUint32(&o.SPIWP.Reg, volatile.LoadUint32(&o.SPIWP.Reg)&^(0xc00)|value<<10)
}
func (o *IO_MUX_Type) GetSPIWP_FUN_DRV() uint32 {
	return (volatile.LoadUint32(&o.SPIWP.Reg) & 0xc00) >> 10
}
func (o *IO_MUX_Type) SetSPIWP_MCU_SEL(value uint32) {
	volatile.StoreUint32(&o.SPIWP.Reg, volatile.LoadUint32(&o.SPIWP.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetSPIWP_MCU_SEL() uint32 {
	return (volatile.LoadUint32(&o.SPIWP.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetSPIWP_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.SPIWP.Reg, volatile.LoadUint32(&o.SPIWP.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetSPIWP_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.SPIWP.Reg) & 0x8000) >> 15
}

// IO_MUX.SPICS0: Configuration register for pad SPICS0
func (o *IO_MUX_Type) SetSPICS0_MCU_OE(value uint32) {
	volatile.StoreUint32(&o.SPICS0.Reg, volatile.LoadUint32(&o.SPICS0.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetSPICS0_MCU_OE() uint32 {
	return volatile.LoadUint32(&o.SPICS0.Reg) & 0x1
}
func (o *IO_MUX_Type) SetSPICS0_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.SPICS0.Reg, volatile.LoadUint32(&o.SPICS0.Reg)&^(0x2)|value<<1)
}
func (o *IO_MUX_Type) GetSPICS0_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.SPICS0.Reg) & 0x2) >> 1
}
func (o *IO_MUX_Type) SetSPICS0_MCU_WPD(value uint32) {
	volatile.StoreUint32(&o.SPICS0.Reg, volatile.LoadUint32(&o.SPICS0.Reg)&^(0x4)|value<<2)
}
func (o *IO_MUX_Type) GetSPICS0_MCU_WPD() uint32 {
	return (volatile.LoadUint32(&o.SPICS0.Reg) & 0x4) >> 2
}
func (o *IO_MUX_Type) SetSPICS0_MCU_WPU(value uint32) {
	volatile.StoreUint32(&o.SPICS0.Reg, volatile.LoadUint32(&o.SPICS0.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetSPICS0_MCU_WPU() uint32 {
	return (volatile.LoadUint32(&o.SPICS0.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetSPICS0_MCU_IE(value uint32) {
	volatile.StoreUint32(&o.SPICS0.Reg, volatile.LoadUint32(&o.SPICS0.Reg)&^(0x10)|value<<4)
}
func (o *IO_MUX_Type) GetSPICS0_MCU_IE() uint32 {
	return (volatile.LoadUint32(&o.SPICS0.Reg) & 0x10) >> 4
}
func (o *IO_MUX_Type) SetSPICS0_FUN_WPD(value uint32) {
	volatile.StoreUint32(&o.SPICS0.Reg, volatile.LoadUint32(&o.SPICS0.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetSPICS0_FUN_WPD() uint32 {
	return (volatile.LoadUint32(&o.SPICS0.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetSPICS0_FUN_WPU(value uint32) {
	volatile.StoreUint32(&o.SPICS0.Reg, volatile.LoadUint32(&o.SPICS0.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetSPICS0_FUN_WPU() uint32 {
	return (volatile.LoadUint32(&o.SPICS0.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetSPICS0_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.SPICS0.Reg, volatile.LoadUint32(&o.SPICS0.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetSPICS0_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.SPICS0.Reg) & 0x200) >> 9
}
func (o *IO_MUX_Type) SetSPICS0_FUN_DRV(value uint32) {
	volatile.StoreUint32(&o.SPICS0.Reg, volatile.LoadUint32(&o.SPICS0.Reg)&^(0xc00)|value<<10)
}
func (o *IO_MUX_Type) GetSPICS0_FUN_DRV() uint32 {
	return (volatile.LoadUint32(&o.SPICS0.Reg) & 0xc00) >> 10
}
func (o *IO_MUX_Type) SetSPICS0_MCU_SEL(value uint32) {
	volatile.StoreUint32(&o.SPICS0.Reg, volatile.LoadUint32(&o.SPICS0.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetSPICS0_MCU_SEL() uint32 {
	return (volatile.LoadUint32(&o.SPICS0.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetSPICS0_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.SPICS0.Reg, volatile.LoadUint32(&o.SPICS0.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetSPICS0_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.SPICS0.Reg) & 0x8000) >> 15
}

// IO_MUX.SPICLK: Configuration register for pad SPICLK
func (o *IO_MUX_Type) SetSPICLK_MCU_OE(value uint32) {
	volatile.StoreUint32(&o.SPICLK.Reg, volatile.LoadUint32(&o.SPICLK.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetSPICLK_MCU_OE() uint32 {
	return volatile.LoadUint32(&o.SPICLK.Reg) & 0x1
}
func (o *IO_MUX_Type) SetSPICLK_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.SPICLK.Reg, volatile.LoadUint32(&o.SPICLK.Reg)&^(0x2)|value<<1)
}
func (o *IO_MUX_Type) GetSPICLK_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.SPICLK.Reg) & 0x2) >> 1
}
func (o *IO_MUX_Type) SetSPICLK_MCU_WPD(value uint32) {
	volatile.StoreUint32(&o.SPICLK.Reg, volatile.LoadUint32(&o.SPICLK.Reg)&^(0x4)|value<<2)
}
func (o *IO_MUX_Type) GetSPICLK_MCU_WPD() uint32 {
	return (volatile.LoadUint32(&o.SPICLK.Reg) & 0x4) >> 2
}
func (o *IO_MUX_Type) SetSPICLK_MCU_WPU(value uint32) {
	volatile.StoreUint32(&o.SPICLK.Reg, volatile.LoadUint32(&o.SPICLK.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetSPICLK_MCU_WPU() uint32 {
	return (volatile.LoadUint32(&o.SPICLK.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetSPICLK_MCU_IE(value uint32) {
	volatile.StoreUint32(&o.SPICLK.Reg, volatile.LoadUint32(&o.SPICLK.Reg)&^(0x10)|value<<4)
}
func (o *IO_MUX_Type) GetSPICLK_MCU_IE() uint32 {
	return (volatile.LoadUint32(&o.SPICLK.Reg) & 0x10) >> 4
}
func (o *IO_MUX_Type) SetSPICLK_FUN_WPD(value uint32) {
	volatile.StoreUint32(&o.SPICLK.Reg, volatile.LoadUint32(&o.SPICLK.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetSPICLK_FUN_WPD() uint32 {
	return (volatile.LoadUint32(&o.SPICLK.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetSPICLK_FUN_WPU(value uint32) {
	volatile.StoreUint32(&o.SPICLK.Reg, volatile.LoadUint32(&o.SPICLK.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetSPICLK_FUN_WPU() uint32 {
	return (volatile.LoadUint32(&o.SPICLK.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetSPICLK_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.SPICLK.Reg, volatile.LoadUint32(&o.SPICLK.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetSPICLK_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.SPICLK.Reg) & 0x200) >> 9
}
func (o *IO_MUX_Type) SetSPICLK_FUN_DRV(value uint32) {
	volatile.StoreUint32(&o.SPICLK.Reg, volatile.LoadUint32(&o.SPICLK.Reg)&^(0xc00)|value<<10)
}
func (o *IO_MUX_Type) GetSPICLK_FUN_DRV() uint32 {
	return (volatile.LoadUint32(&o.SPICLK.Reg) & 0xc00) >> 10
}
func (o *IO_MUX_Type) SetSPICLK_MCU_SEL(value uint32) {
	volatile.StoreUint32(&o.SPICLK.Reg, volatile.LoadUint32(&o.SPICLK.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetSPICLK_MCU_SEL() uint32 {
	return (volatile.LoadUint32(&o.SPICLK.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetSPICLK_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.SPICLK.Reg, volatile.LoadUint32(&o.SPICLK.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetSPICLK_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.SPICLK.Reg) & 0x8000) >> 15
}

// IO_MUX.SPIQ: Configuration register for pad SPIQ
func (o *IO_MUX_Type) SetSPIQ_MCU_OE(value uint32) {
	volatile.StoreUint32(&o.SPIQ.Reg, volatile.LoadUint32(&o.SPIQ.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetSPIQ_MCU_OE() uint32 {
	return volatile.LoadUint32(&o.SPIQ.Reg) & 0x1
}
func (o *IO_MUX_Type) SetSPIQ_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.SPIQ.Reg, volatile.LoadUint32(&o.SPIQ.Reg)&^(0x2)|value<<1)
}
func (o *IO_MUX_Type) GetSPIQ_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.SPIQ.Reg) & 0x2) >> 1
}
func (o *IO_MUX_Type) SetSPIQ_MCU_WPD(value uint32) {
	volatile.StoreUint32(&o.SPIQ.Reg, volatile.LoadUint32(&o.SPIQ.Reg)&^(0x4)|value<<2)
}
func (o *IO_MUX_Type) GetSPIQ_MCU_WPD() uint32 {
	return (volatile.LoadUint32(&o.SPIQ.Reg) & 0x4) >> 2
}
func (o *IO_MUX_Type) SetSPIQ_MCU_WPU(value uint32) {
	volatile.StoreUint32(&o.SPIQ.Reg, volatile.LoadUint32(&o.SPIQ.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetSPIQ_MCU_WPU() uint32 {
	return (volatile.LoadUint32(&o.SPIQ.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetSPIQ_MCU_IE(value uint32) {
	volatile.StoreUint32(&o.SPIQ.Reg, volatile.LoadUint32(&o.SPIQ.Reg)&^(0x10)|value<<4)
}
func (o *IO_MUX_Type) GetSPIQ_MCU_IE() uint32 {
	return (volatile.LoadUint32(&o.SPIQ.Reg) & 0x10) >> 4
}
func (o *IO_MUX_Type) SetSPIQ_FUN_WPD(value uint32) {
	volatile.StoreUint32(&o.SPIQ.Reg, volatile.LoadUint32(&o.SPIQ.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetSPIQ_FUN_WPD() uint32 {
	return (volatile.LoadUint32(&o.SPIQ.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetSPIQ_FUN_WPU(value uint32) {
	volatile.StoreUint32(&o.SPIQ.Reg, volatile.LoadUint32(&o.SPIQ.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetSPIQ_FUN_WPU() uint32 {
	return (volatile.LoadUint32(&o.SPIQ.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetSPIQ_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.SPIQ.Reg, volatile.LoadUint32(&o.SPIQ.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetSPIQ_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.SPIQ.Reg) & 0x200) >> 9
}
func (o *IO_MUX_Type) SetSPIQ_FUN_DRV(value uint32) {
	volatile.StoreUint32(&o.SPIQ.Reg, volatile.LoadUint32(&o.SPIQ.Reg)&^(0xc00)|value<<10)
}
func (o *IO_MUX_Type) GetSPIQ_FUN_DRV() uint32 {
	return (volatile.LoadUint32(&o.SPIQ.Reg) & 0xc00) >> 10
}
func (o *IO_MUX_Type) SetSPIQ_MCU_SEL(value uint32) {
	volatile.StoreUint32(&o.SPIQ.Reg, volatile.LoadUint32(&o.SPIQ.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetSPIQ_MCU_SEL() uint32 {
	return (volatile.LoadUint32(&o.SPIQ.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetSPIQ_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.SPIQ.Reg, volatile.LoadUint32(&o.SPIQ.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetSPIQ_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.SPIQ.Reg) & 0x8000) >> 15
}

// IO_MUX.SPID: Configuration register for pad SPID
func (o *IO_MUX_Type) SetSPID_MCU_OE(value uint32) {
	volatile.StoreUint32(&o.SPID.Reg, volatile.LoadUint32(&o.SPID.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetSPID_MCU_OE() uint32 {
	return volatile.LoadUint32(&o.SPID.Reg) & 0x1
}
func (o *IO_MUX_Type) SetSPID_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.SPID.Reg, volatile.LoadUint32(&o.SPID.Reg)&^(0x2)|value<<1)
}
func (o *IO_MUX_Type) GetSPID_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.SPID.Reg) & 0x2) >> 1
}
func (o *IO_MUX_Type) SetSPID_MCU_WPD(value uint32) {
	volatile.StoreUint32(&o.SPID.Reg, volatile.LoadUint32(&o.SPID.Reg)&^(0x4)|value<<2)
}
func (o *IO_MUX_Type) GetSPID_MCU_WPD() uint32 {
	return (volatile.LoadUint32(&o.SPID.Reg) & 0x4) >> 2
}
func (o *IO_MUX_Type) SetSPID_MCU_WPU(value uint32) {
	volatile.StoreUint32(&o.SPID.Reg, volatile.LoadUint32(&o.SPID.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetSPID_MCU_WPU() uint32 {
	return (volatile.LoadUint32(&o.SPID.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetSPID_MCU_IE(value uint32) {
	volatile.StoreUint32(&o.SPID.Reg, volatile.LoadUint32(&o.SPID.Reg)&^(0x10)|value<<4)
}
func (o *IO_MUX_Type) GetSPID_MCU_IE() uint32 {
	return (volatile.LoadUint32(&o.SPID.Reg) & 0x10) >> 4
}
func (o *IO_MUX_Type) SetSPID_FUN_WPD(value uint32) {
	volatile.StoreUint32(&o.SPID.Reg, volatile.LoadUint32(&o.SPID.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetSPID_FUN_WPD() uint32 {
	return (volatile.LoadUint32(&o.SPID.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetSPID_FUN_WPU(value uint32) {
	volatile.StoreUint32(&o.SPID.Reg, volatile.LoadUint32(&o.SPID.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetSPID_FUN_WPU() uint32 {
	return (volatile.LoadUint32(&o.SPID.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetSPID_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.SPID.Reg, volatile.LoadUint32(&o.SPID.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetSPID_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.SPID.Reg) & 0x200) >> 9
}
func (o *IO_MUX_Type) SetSPID_FUN_DRV(value uint32) {
	volatile.StoreUint32(&o.SPID.Reg, volatile.LoadUint32(&o.SPID.Reg)&^(0xc00)|value<<10)
}
func (o *IO_MUX_Type) GetSPID_FUN_DRV() uint32 {
	return (volatile.LoadUint32(&o.SPID.Reg) & 0xc00) >> 10
}
func (o *IO_MUX_Type) SetSPID_MCU_SEL(value uint32) {
	volatile.StoreUint32(&o.SPID.Reg, volatile.LoadUint32(&o.SPID.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetSPID_MCU_SEL() uint32 {
	return (volatile.LoadUint32(&o.SPID.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetSPID_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.SPID.Reg, volatile.LoadUint32(&o.SPID.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetSPID_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.SPID.Reg) & 0x8000) >> 15
}

// IO_MUX.GPIO_33: Configuration register for pad GPIO33
func (o *IO_MUX_Type) SetGPIO_33_MCU_OE(value uint32) {
	volatile.StoreUint32(&o.GPIO_33.Reg, volatile.LoadUint32(&o.GPIO_33.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetGPIO_33_MCU_OE() uint32 {
	return volatile.LoadUint32(&o.GPIO_33.Reg) & 0x1
}
func (o *IO_MUX_Type) SetGPIO_33_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO_33.Reg, volatile.LoadUint32(&o.GPIO_33.Reg)&^(0x2)|value<<1)
}
func (o *IO_MUX_Type) GetGPIO_33_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO_33.Reg) & 0x2) >> 1
}
func (o *IO_MUX_Type) SetGPIO_33_MCU_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO_33.Reg, volatile.LoadUint32(&o.GPIO_33.Reg)&^(0x4)|value<<2)
}
func (o *IO_MUX_Type) GetGPIO_33_MCU_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO_33.Reg) & 0x4) >> 2
}
func (o *IO_MUX_Type) SetGPIO_33_MCU_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO_33.Reg, volatile.LoadUint32(&o.GPIO_33.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetGPIO_33_MCU_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO_33.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetGPIO_33_MCU_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO_33.Reg, volatile.LoadUint32(&o.GPIO_33.Reg)&^(0x10)|value<<4)
}
func (o *IO_MUX_Type) GetGPIO_33_MCU_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO_33.Reg) & 0x10) >> 4
}
func (o *IO_MUX_Type) SetGPIO_33_FUN_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO_33.Reg, volatile.LoadUint32(&o.GPIO_33.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetGPIO_33_FUN_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO_33.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetGPIO_33_FUN_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO_33.Reg, volatile.LoadUint32(&o.GPIO_33.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetGPIO_33_FUN_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO_33.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetGPIO_33_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO_33.Reg, volatile.LoadUint32(&o.GPIO_33.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetGPIO_33_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO_33.Reg) & 0x200) >> 9
}
func (o *IO_MUX_Type) SetGPIO_33_FUN_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO_33.Reg, volatile.LoadUint32(&o.GPIO_33.Reg)&^(0xc00)|value<<10)
}
func (o *IO_MUX_Type) GetGPIO_33_FUN_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO_33.Reg) & 0xc00) >> 10
}
func (o *IO_MUX_Type) SetGPIO_33_MCU_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO_33.Reg, volatile.LoadUint32(&o.GPIO_33.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetGPIO_33_MCU_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO_33.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetGPIO_33_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO_33.Reg, volatile.LoadUint32(&o.GPIO_33.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetGPIO_33_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO_33.Reg) & 0x8000) >> 15
}

// IO_MUX.GPIO_34: Configuration register for pad GPIO34
func (o *IO_MUX_Type) SetGPIO_34_MCU_OE(value uint32) {
	volatile.StoreUint32(&o.GPIO_34.Reg, volatile.LoadUint32(&o.GPIO_34.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetGPIO_34_MCU_OE() uint32 {
	return volatile.LoadUint32(&o.GPIO_34.Reg) & 0x1
}
func (o *IO_MUX_Type) SetGPIO_34_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO_34.Reg, volatile.LoadUint32(&o.GPIO_34.Reg)&^(0x2)|value<<1)
}
func (o *IO_MUX_Type) GetGPIO_34_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO_34.Reg) & 0x2) >> 1
}
func (o *IO_MUX_Type) SetGPIO_34_MCU_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO_34.Reg, volatile.LoadUint32(&o.GPIO_34.Reg)&^(0x4)|value<<2)
}
func (o *IO_MUX_Type) GetGPIO_34_MCU_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO_34.Reg) & 0x4) >> 2
}
func (o *IO_MUX_Type) SetGPIO_34_MCU_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO_34.Reg, volatile.LoadUint32(&o.GPIO_34.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetGPIO_34_MCU_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO_34.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetGPIO_34_MCU_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO_34.Reg, volatile.LoadUint32(&o.GPIO_34.Reg)&^(0x10)|value<<4)
}
func (o *IO_MUX_Type) GetGPIO_34_MCU_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO_34.Reg) & 0x10) >> 4
}
func (o *IO_MUX_Type) SetGPIO_34_FUN_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO_34.Reg, volatile.LoadUint32(&o.GPIO_34.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetGPIO_34_FUN_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO_34.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetGPIO_34_FUN_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO_34.Reg, volatile.LoadUint32(&o.GPIO_34.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetGPIO_34_FUN_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO_34.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetGPIO_34_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO_34.Reg, volatile.LoadUint32(&o.GPIO_34.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetGPIO_34_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO_34.Reg) & 0x200) >> 9
}
func (o *IO_MUX_Type) SetGPIO_34_FUN_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO_34.Reg, volatile.LoadUint32(&o.GPIO_34.Reg)&^(0xc00)|value<<10)
}
func (o *IO_MUX_Type) GetGPIO_34_FUN_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO_34.Reg) & 0xc00) >> 10
}
func (o *IO_MUX_Type) SetGPIO_34_MCU_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO_34.Reg, volatile.LoadUint32(&o.GPIO_34.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetGPIO_34_MCU_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO_34.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetGPIO_34_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO_34.Reg, volatile.LoadUint32(&o.GPIO_34.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetGPIO_34_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO_34.Reg) & 0x8000) >> 15
}

// IO_MUX.GPIO_35: Configuration register for pad GPIO35
func (o *IO_MUX_Type) SetGPIO_35_MCU_OE(value uint32) {
	volatile.StoreUint32(&o.GPIO_35.Reg, volatile.LoadUint32(&o.GPIO_35.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetGPIO_35_MCU_OE() uint32 {
	return volatile.LoadUint32(&o.GPIO_35.Reg) & 0x1
}
func (o *IO_MUX_Type) SetGPIO_35_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO_35.Reg, volatile.LoadUint32(&o.GPIO_35.Reg)&^(0x2)|value<<1)
}
func (o *IO_MUX_Type) GetGPIO_35_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO_35.Reg) & 0x2) >> 1
}
func (o *IO_MUX_Type) SetGPIO_35_MCU_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO_35.Reg, volatile.LoadUint32(&o.GPIO_35.Reg)&^(0x4)|value<<2)
}
func (o *IO_MUX_Type) GetGPIO_35_MCU_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO_35.Reg) & 0x4) >> 2
}
func (o *IO_MUX_Type) SetGPIO_35_MCU_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO_35.Reg, volatile.LoadUint32(&o.GPIO_35.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetGPIO_35_MCU_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO_35.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetGPIO_35_MCU_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO_35.Reg, volatile.LoadUint32(&o.GPIO_35.Reg)&^(0x10)|value<<4)
}
func (o *IO_MUX_Type) GetGPIO_35_MCU_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO_35.Reg) & 0x10) >> 4
}
func (o *IO_MUX_Type) SetGPIO_35_FUN_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO_35.Reg, volatile.LoadUint32(&o.GPIO_35.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetGPIO_35_FUN_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO_35.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetGPIO_35_FUN_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO_35.Reg, volatile.LoadUint32(&o.GPIO_35.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetGPIO_35_FUN_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO_35.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetGPIO_35_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO_35.Reg, volatile.LoadUint32(&o.GPIO_35.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetGPIO_35_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO_35.Reg) & 0x200) >> 9
}
func (o *IO_MUX_Type) SetGPIO_35_FUN_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO_35.Reg, volatile.LoadUint32(&o.GPIO_35.Reg)&^(0xc00)|value<<10)
}
func (o *IO_MUX_Type) GetGPIO_35_FUN_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO_35.Reg) & 0xc00) >> 10
}
func (o *IO_MUX_Type) SetGPIO_35_MCU_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO_35.Reg, volatile.LoadUint32(&o.GPIO_35.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetGPIO_35_MCU_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO_35.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetGPIO_35_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO_35.Reg, volatile.LoadUint32(&o.GPIO_35.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetGPIO_35_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO_35.Reg) & 0x8000) >> 15
}

// IO_MUX.GPIO_36: Configuration register for pad GPIO36
func (o *IO_MUX_Type) SetGPIO_36_MCU_OE(value uint32) {
	volatile.StoreUint32(&o.GPIO_36.Reg, volatile.LoadUint32(&o.GPIO_36.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetGPIO_36_MCU_OE() uint32 {
	return volatile.LoadUint32(&o.GPIO_36.Reg) & 0x1
}
func (o *IO_MUX_Type) SetGPIO_36_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO_36.Reg, volatile.LoadUint32(&o.GPIO_36.Reg)&^(0x2)|value<<1)
}
func (o *IO_MUX_Type) GetGPIO_36_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO_36.Reg) & 0x2) >> 1
}
func (o *IO_MUX_Type) SetGPIO_36_MCU_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO_36.Reg, volatile.LoadUint32(&o.GPIO_36.Reg)&^(0x4)|value<<2)
}
func (o *IO_MUX_Type) GetGPIO_36_MCU_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO_36.Reg) & 0x4) >> 2
}
func (o *IO_MUX_Type) SetGPIO_36_MCU_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO_36.Reg, volatile.LoadUint32(&o.GPIO_36.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetGPIO_36_MCU_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO_36.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetGPIO_36_MCU_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO_36.Reg, volatile.LoadUint32(&o.GPIO_36.Reg)&^(0x10)|value<<4)
}
func (o *IO_MUX_Type) GetGPIO_36_MCU_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO_36.Reg) & 0x10) >> 4
}
func (o *IO_MUX_Type) SetGPIO_36_FUN_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO_36.Reg, volatile.LoadUint32(&o.GPIO_36.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetGPIO_36_FUN_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO_36.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetGPIO_36_FUN_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO_36.Reg, volatile.LoadUint32(&o.GPIO_36.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetGPIO_36_FUN_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO_36.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetGPIO_36_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO_36.Reg, volatile.LoadUint32(&o.GPIO_36.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetGPIO_36_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO_36.Reg) & 0x200) >> 9
}
func (o *IO_MUX_Type) SetGPIO_36_FUN_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO_36.Reg, volatile.LoadUint32(&o.GPIO_36.Reg)&^(0xc00)|value<<10)
}
func (o *IO_MUX_Type) GetGPIO_36_FUN_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO_36.Reg) & 0xc00) >> 10
}
func (o *IO_MUX_Type) SetGPIO_36_MCU_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO_36.Reg, volatile.LoadUint32(&o.GPIO_36.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetGPIO_36_MCU_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO_36.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetGPIO_36_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO_36.Reg, volatile.LoadUint32(&o.GPIO_36.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetGPIO_36_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO_36.Reg) & 0x8000) >> 15
}

// IO_MUX.GPIO_37: Configuration register for pad GPIO37
func (o *IO_MUX_Type) SetGPIO_37_MCU_OE(value uint32) {
	volatile.StoreUint32(&o.GPIO_37.Reg, volatile.LoadUint32(&o.GPIO_37.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetGPIO_37_MCU_OE() uint32 {
	return volatile.LoadUint32(&o.GPIO_37.Reg) & 0x1
}
func (o *IO_MUX_Type) SetGPIO_37_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO_37.Reg, volatile.LoadUint32(&o.GPIO_37.Reg)&^(0x2)|value<<1)
}
func (o *IO_MUX_Type) GetGPIO_37_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO_37.Reg) & 0x2) >> 1
}
func (o *IO_MUX_Type) SetGPIO_37_MCU_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO_37.Reg, volatile.LoadUint32(&o.GPIO_37.Reg)&^(0x4)|value<<2)
}
func (o *IO_MUX_Type) GetGPIO_37_MCU_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO_37.Reg) & 0x4) >> 2
}
func (o *IO_MUX_Type) SetGPIO_37_MCU_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO_37.Reg, volatile.LoadUint32(&o.GPIO_37.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetGPIO_37_MCU_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO_37.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetGPIO_37_MCU_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO_37.Reg, volatile.LoadUint32(&o.GPIO_37.Reg)&^(0x10)|value<<4)
}
func (o *IO_MUX_Type) GetGPIO_37_MCU_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO_37.Reg) & 0x10) >> 4
}
func (o *IO_MUX_Type) SetGPIO_37_FUN_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO_37.Reg, volatile.LoadUint32(&o.GPIO_37.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetGPIO_37_FUN_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO_37.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetGPIO_37_FUN_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO_37.Reg, volatile.LoadUint32(&o.GPIO_37.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetGPIO_37_FUN_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO_37.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetGPIO_37_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO_37.Reg, volatile.LoadUint32(&o.GPIO_37.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetGPIO_37_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO_37.Reg) & 0x200) >> 9
}
func (o *IO_MUX_Type) SetGPIO_37_FUN_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO_37.Reg, volatile.LoadUint32(&o.GPIO_37.Reg)&^(0xc00)|value<<10)
}
func (o *IO_MUX_Type) GetGPIO_37_FUN_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO_37.Reg) & 0xc00) >> 10
}
func (o *IO_MUX_Type) SetGPIO_37_MCU_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO_37.Reg, volatile.LoadUint32(&o.GPIO_37.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetGPIO_37_MCU_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO_37.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetGPIO_37_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO_37.Reg, volatile.LoadUint32(&o.GPIO_37.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetGPIO_37_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO_37.Reg) & 0x8000) >> 15
}

// IO_MUX.GPIO_38: Configuration register for pad GPIO38
func (o *IO_MUX_Type) SetGPIO_38_MCU_OE(value uint32) {
	volatile.StoreUint32(&o.GPIO_38.Reg, volatile.LoadUint32(&o.GPIO_38.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetGPIO_38_MCU_OE() uint32 {
	return volatile.LoadUint32(&o.GPIO_38.Reg) & 0x1
}
func (o *IO_MUX_Type) SetGPIO_38_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO_38.Reg, volatile.LoadUint32(&o.GPIO_38.Reg)&^(0x2)|value<<1)
}
func (o *IO_MUX_Type) GetGPIO_38_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO_38.Reg) & 0x2) >> 1
}
func (o *IO_MUX_Type) SetGPIO_38_MCU_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO_38.Reg, volatile.LoadUint32(&o.GPIO_38.Reg)&^(0x4)|value<<2)
}
func (o *IO_MUX_Type) GetGPIO_38_MCU_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO_38.Reg) & 0x4) >> 2
}
func (o *IO_MUX_Type) SetGPIO_38_MCU_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO_38.Reg, volatile.LoadUint32(&o.GPIO_38.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetGPIO_38_MCU_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO_38.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetGPIO_38_MCU_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO_38.Reg, volatile.LoadUint32(&o.GPIO_38.Reg)&^(0x10)|value<<4)
}
func (o *IO_MUX_Type) GetGPIO_38_MCU_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO_38.Reg) & 0x10) >> 4
}
func (o *IO_MUX_Type) SetGPIO_38_FUN_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO_38.Reg, volatile.LoadUint32(&o.GPIO_38.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetGPIO_38_FUN_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO_38.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetGPIO_38_FUN_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO_38.Reg, volatile.LoadUint32(&o.GPIO_38.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetGPIO_38_FUN_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO_38.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetGPIO_38_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO_38.Reg, volatile.LoadUint32(&o.GPIO_38.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetGPIO_38_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO_38.Reg) & 0x200) >> 9
}
func (o *IO_MUX_Type) SetGPIO_38_FUN_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO_38.Reg, volatile.LoadUint32(&o.GPIO_38.Reg)&^(0xc00)|value<<10)
}
func (o *IO_MUX_Type) GetGPIO_38_FUN_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO_38.Reg) & 0xc00) >> 10
}
func (o *IO_MUX_Type) SetGPIO_38_MCU_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO_38.Reg, volatile.LoadUint32(&o.GPIO_38.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetGPIO_38_MCU_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO_38.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetGPIO_38_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO_38.Reg, volatile.LoadUint32(&o.GPIO_38.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetGPIO_38_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO_38.Reg) & 0x8000) >> 15
}

// IO_MUX.MTCK: Configuration register for pad MTCK
func (o *IO_MUX_Type) SetMTCK_MCU_OE(value uint32) {
	volatile.StoreUint32(&o.MTCK.Reg, volatile.LoadUint32(&o.MTCK.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetMTCK_MCU_OE() uint32 {
	return volatile.LoadUint32(&o.MTCK.Reg) & 0x1
}
func (o *IO_MUX_Type) SetMTCK_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.MTCK.Reg, volatile.LoadUint32(&o.MTCK.Reg)&^(0x2)|value<<1)
}
func (o *IO_MUX_Type) GetMTCK_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.MTCK.Reg) & 0x2) >> 1
}
func (o *IO_MUX_Type) SetMTCK_MCU_WPD(value uint32) {
	volatile.StoreUint32(&o.MTCK.Reg, volatile.LoadUint32(&o.MTCK.Reg)&^(0x4)|value<<2)
}
func (o *IO_MUX_Type) GetMTCK_MCU_WPD() uint32 {
	return (volatile.LoadUint32(&o.MTCK.Reg) & 0x4) >> 2
}
func (o *IO_MUX_Type) SetMTCK_MCU_WPU(value uint32) {
	volatile.StoreUint32(&o.MTCK.Reg, volatile.LoadUint32(&o.MTCK.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetMTCK_MCU_WPU() uint32 {
	return (volatile.LoadUint32(&o.MTCK.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetMTCK_MCU_IE(value uint32) {
	volatile.StoreUint32(&o.MTCK.Reg, volatile.LoadUint32(&o.MTCK.Reg)&^(0x10)|value<<4)
}
func (o *IO_MUX_Type) GetMTCK_MCU_IE() uint32 {
	return (volatile.LoadUint32(&o.MTCK.Reg) & 0x10) >> 4
}
func (o *IO_MUX_Type) SetMTCK_FUN_WPD(value uint32) {
	volatile.StoreUint32(&o.MTCK.Reg, volatile.LoadUint32(&o.MTCK.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetMTCK_FUN_WPD() uint32 {
	return (volatile.LoadUint32(&o.MTCK.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetMTCK_FUN_WPU(value uint32) {
	volatile.StoreUint32(&o.MTCK.Reg, volatile.LoadUint32(&o.MTCK.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetMTCK_FUN_WPU() uint32 {
	return (volatile.LoadUint32(&o.MTCK.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetMTCK_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.MTCK.Reg, volatile.LoadUint32(&o.MTCK.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetMTCK_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.MTCK.Reg) & 0x200) >> 9
}
func (o *IO_MUX_Type) SetMTCK_FUN_DRV(value uint32) {
	volatile.StoreUint32(&o.MTCK.Reg, volatile.LoadUint32(&o.MTCK.Reg)&^(0xc00)|value<<10)
}
func (o *IO_MUX_Type) GetMTCK_FUN_DRV() uint32 {
	return (volatile.LoadUint32(&o.MTCK.Reg) & 0xc00) >> 10
}
func (o *IO_MUX_Type) SetMTCK_MCU_SEL(value uint32) {
	volatile.StoreUint32(&o.MTCK.Reg, volatile.LoadUint32(&o.MTCK.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetMTCK_MCU_SEL() uint32 {
	return (volatile.LoadUint32(&o.MTCK.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetMTCK_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.MTCK.Reg, volatile.LoadUint32(&o.MTCK.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetMTCK_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.MTCK.Reg) & 0x8000) >> 15
}

// IO_MUX.MTDO: Configuration register for pad MTDO
func (o *IO_MUX_Type) SetMTDO_MCU_OE(value uint32) {
	volatile.StoreUint32(&o.MTDO.Reg, volatile.LoadUint32(&o.MTDO.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetMTDO_MCU_OE() uint32 {
	return volatile.LoadUint32(&o.MTDO.Reg) & 0x1
}
func (o *IO_MUX_Type) SetMTDO_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.MTDO.Reg, volatile.LoadUint32(&o.MTDO.Reg)&^(0x2)|value<<1)
}
func (o *IO_MUX_Type) GetMTDO_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.MTDO.Reg) & 0x2) >> 1
}
func (o *IO_MUX_Type) SetMTDO_MCU_WPD(value uint32) {
	volatile.StoreUint32(&o.MTDO.Reg, volatile.LoadUint32(&o.MTDO.Reg)&^(0x4)|value<<2)
}
func (o *IO_MUX_Type) GetMTDO_MCU_WPD() uint32 {
	return (volatile.LoadUint32(&o.MTDO.Reg) & 0x4) >> 2
}
func (o *IO_MUX_Type) SetMTDO_MCU_WPU(value uint32) {
	volatile.StoreUint32(&o.MTDO.Reg, volatile.LoadUint32(&o.MTDO.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetMTDO_MCU_WPU() uint32 {
	return (volatile.LoadUint32(&o.MTDO.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetMTDO_MCU_IE(value uint32) {
	volatile.StoreUint32(&o.MTDO.Reg, volatile.LoadUint32(&o.MTDO.Reg)&^(0x10)|value<<4)
}
func (o *IO_MUX_Type) GetMTDO_MCU_IE() uint32 {
	return (volatile.LoadUint32(&o.MTDO.Reg) & 0x10) >> 4
}
func (o *IO_MUX_Type) SetMTDO_FUN_WPD(value uint32) {
	volatile.StoreUint32(&o.MTDO.Reg, volatile.LoadUint32(&o.MTDO.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetMTDO_FUN_WPD() uint32 {
	return (volatile.LoadUint32(&o.MTDO.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetMTDO_FUN_WPU(value uint32) {
	volatile.StoreUint32(&o.MTDO.Reg, volatile.LoadUint32(&o.MTDO.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetMTDO_FUN_WPU() uint32 {
	return (volatile.LoadUint32(&o.MTDO.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetMTDO_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.MTDO.Reg, volatile.LoadUint32(&o.MTDO.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetMTDO_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.MTDO.Reg) & 0x200) >> 9
}
func (o *IO_MUX_Type) SetMTDO_FUN_DRV(value uint32) {
	volatile.StoreUint32(&o.MTDO.Reg, volatile.LoadUint32(&o.MTDO.Reg)&^(0xc00)|value<<10)
}
func (o *IO_MUX_Type) GetMTDO_FUN_DRV() uint32 {
	return (volatile.LoadUint32(&o.MTDO.Reg) & 0xc00) >> 10
}
func (o *IO_MUX_Type) SetMTDO_MCU_SEL(value uint32) {
	volatile.StoreUint32(&o.MTDO.Reg, volatile.LoadUint32(&o.MTDO.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetMTDO_MCU_SEL() uint32 {
	return (volatile.LoadUint32(&o.MTDO.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetMTDO_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.MTDO.Reg, volatile.LoadUint32(&o.MTDO.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetMTDO_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.MTDO.Reg) & 0x8000) >> 15
}

// IO_MUX.MTDI: Configuration register for pad MTDI
func (o *IO_MUX_Type) SetMTDI_MCU_OE(value uint32) {
	volatile.StoreUint32(&o.MTDI.Reg, volatile.LoadUint32(&o.MTDI.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetMTDI_MCU_OE() uint32 {
	return volatile.LoadUint32(&o.MTDI.Reg) & 0x1
}
func (o *IO_MUX_Type) SetMTDI_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.MTDI.Reg, volatile.LoadUint32(&o.MTDI.Reg)&^(0x2)|value<<1)
}
func (o *IO_MUX_Type) GetMTDI_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.MTDI.Reg) & 0x2) >> 1
}
func (o *IO_MUX_Type) SetMTDI_MCU_WPD(value uint32) {
	volatile.StoreUint32(&o.MTDI.Reg, volatile.LoadUint32(&o.MTDI.Reg)&^(0x4)|value<<2)
}
func (o *IO_MUX_Type) GetMTDI_MCU_WPD() uint32 {
	return (volatile.LoadUint32(&o.MTDI.Reg) & 0x4) >> 2
}
func (o *IO_MUX_Type) SetMTDI_MCU_WPU(value uint32) {
	volatile.StoreUint32(&o.MTDI.Reg, volatile.LoadUint32(&o.MTDI.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetMTDI_MCU_WPU() uint32 {
	return (volatile.LoadUint32(&o.MTDI.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetMTDI_MCU_IE(value uint32) {
	volatile.StoreUint32(&o.MTDI.Reg, volatile.LoadUint32(&o.MTDI.Reg)&^(0x10)|value<<4)
}
func (o *IO_MUX_Type) GetMTDI_MCU_IE() uint32 {
	return (volatile.LoadUint32(&o.MTDI.Reg) & 0x10) >> 4
}
func (o *IO_MUX_Type) SetMTDI_FUN_WPD(value uint32) {
	volatile.StoreUint32(&o.MTDI.Reg, volatile.LoadUint32(&o.MTDI.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetMTDI_FUN_WPD() uint32 {
	return (volatile.LoadUint32(&o.MTDI.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetMTDI_FUN_WPU(value uint32) {
	volatile.StoreUint32(&o.MTDI.Reg, volatile.LoadUint32(&o.MTDI.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetMTDI_FUN_WPU() uint32 {
	return (volatile.LoadUint32(&o.MTDI.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetMTDI_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.MTDI.Reg, volatile.LoadUint32(&o.MTDI.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetMTDI_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.MTDI.Reg) & 0x200) >> 9
}
func (o *IO_MUX_Type) SetMTDI_FUN_DRV(value uint32) {
	volatile.StoreUint32(&o.MTDI.Reg, volatile.LoadUint32(&o.MTDI.Reg)&^(0xc00)|value<<10)
}
func (o *IO_MUX_Type) GetMTDI_FUN_DRV() uint32 {
	return (volatile.LoadUint32(&o.MTDI.Reg) & 0xc00) >> 10
}
func (o *IO_MUX_Type) SetMTDI_MCU_SEL(value uint32) {
	volatile.StoreUint32(&o.MTDI.Reg, volatile.LoadUint32(&o.MTDI.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetMTDI_MCU_SEL() uint32 {
	return (volatile.LoadUint32(&o.MTDI.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetMTDI_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.MTDI.Reg, volatile.LoadUint32(&o.MTDI.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetMTDI_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.MTDI.Reg) & 0x8000) >> 15
}

// IO_MUX.MTMS: Configuration register for pad MTMS
func (o *IO_MUX_Type) SetMTMS_MCU_OE(value uint32) {
	volatile.StoreUint32(&o.MTMS.Reg, volatile.LoadUint32(&o.MTMS.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetMTMS_MCU_OE() uint32 {
	return volatile.LoadUint32(&o.MTMS.Reg) & 0x1
}
func (o *IO_MUX_Type) SetMTMS_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.MTMS.Reg, volatile.LoadUint32(&o.MTMS.Reg)&^(0x2)|value<<1)
}
func (o *IO_MUX_Type) GetMTMS_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.MTMS.Reg) & 0x2) >> 1
}
func (o *IO_MUX_Type) SetMTMS_MCU_WPD(value uint32) {
	volatile.StoreUint32(&o.MTMS.Reg, volatile.LoadUint32(&o.MTMS.Reg)&^(0x4)|value<<2)
}
func (o *IO_MUX_Type) GetMTMS_MCU_WPD() uint32 {
	return (volatile.LoadUint32(&o.MTMS.Reg) & 0x4) >> 2
}
func (o *IO_MUX_Type) SetMTMS_MCU_WPU(value uint32) {
	volatile.StoreUint32(&o.MTMS.Reg, volatile.LoadUint32(&o.MTMS.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetMTMS_MCU_WPU() uint32 {
	return (volatile.LoadUint32(&o.MTMS.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetMTMS_MCU_IE(value uint32) {
	volatile.StoreUint32(&o.MTMS.Reg, volatile.LoadUint32(&o.MTMS.Reg)&^(0x10)|value<<4)
}
func (o *IO_MUX_Type) GetMTMS_MCU_IE() uint32 {
	return (volatile.LoadUint32(&o.MTMS.Reg) & 0x10) >> 4
}
func (o *IO_MUX_Type) SetMTMS_FUN_WPD(value uint32) {
	volatile.StoreUint32(&o.MTMS.Reg, volatile.LoadUint32(&o.MTMS.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetMTMS_FUN_WPD() uint32 {
	return (volatile.LoadUint32(&o.MTMS.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetMTMS_FUN_WPU(value uint32) {
	volatile.StoreUint32(&o.MTMS.Reg, volatile.LoadUint32(&o.MTMS.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetMTMS_FUN_WPU() uint32 {
	return (volatile.LoadUint32(&o.MTMS.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetMTMS_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.MTMS.Reg, volatile.LoadUint32(&o.MTMS.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetMTMS_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.MTMS.Reg) & 0x200) >> 9
}
func (o *IO_MUX_Type) SetMTMS_FUN_DRV(value uint32) {
	volatile.StoreUint32(&o.MTMS.Reg, volatile.LoadUint32(&o.MTMS.Reg)&^(0xc00)|value<<10)
}
func (o *IO_MUX_Type) GetMTMS_FUN_DRV() uint32 {
	return (volatile.LoadUint32(&o.MTMS.Reg) & 0xc00) >> 10
}
func (o *IO_MUX_Type) SetMTMS_MCU_SEL(value uint32) {
	volatile.StoreUint32(&o.MTMS.Reg, volatile.LoadUint32(&o.MTMS.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetMTMS_MCU_SEL() uint32 {
	return (volatile.LoadUint32(&o.MTMS.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetMTMS_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.MTMS.Reg, volatile.LoadUint32(&o.MTMS.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetMTMS_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.MTMS.Reg) & 0x8000) >> 15
}

// IO_MUX.U0TXD: Configuration register for pad U0TXD
func (o *IO_MUX_Type) SetU0TXD_MCU_OE(value uint32) {
	volatile.StoreUint32(&o.U0TXD.Reg, volatile.LoadUint32(&o.U0TXD.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetU0TXD_MCU_OE() uint32 {
	return volatile.LoadUint32(&o.U0TXD.Reg) & 0x1
}
func (o *IO_MUX_Type) SetU0TXD_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.U0TXD.Reg, volatile.LoadUint32(&o.U0TXD.Reg)&^(0x2)|value<<1)
}
func (o *IO_MUX_Type) GetU0TXD_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.U0TXD.Reg) & 0x2) >> 1
}
func (o *IO_MUX_Type) SetU0TXD_MCU_WPD(value uint32) {
	volatile.StoreUint32(&o.U0TXD.Reg, volatile.LoadUint32(&o.U0TXD.Reg)&^(0x4)|value<<2)
}
func (o *IO_MUX_Type) GetU0TXD_MCU_WPD() uint32 {
	return (volatile.LoadUint32(&o.U0TXD.Reg) & 0x4) >> 2
}
func (o *IO_MUX_Type) SetU0TXD_MCU_WPU(value uint32) {
	volatile.StoreUint32(&o.U0TXD.Reg, volatile.LoadUint32(&o.U0TXD.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetU0TXD_MCU_WPU() uint32 {
	return (volatile.LoadUint32(&o.U0TXD.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetU0TXD_MCU_IE(value uint32) {
	volatile.StoreUint32(&o.U0TXD.Reg, volatile.LoadUint32(&o.U0TXD.Reg)&^(0x10)|value<<4)
}
func (o *IO_MUX_Type) GetU0TXD_MCU_IE() uint32 {
	return (volatile.LoadUint32(&o.U0TXD.Reg) & 0x10) >> 4
}
func (o *IO_MUX_Type) SetU0TXD_FUN_WPD(value uint32) {
	volatile.StoreUint32(&o.U0TXD.Reg, volatile.LoadUint32(&o.U0TXD.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetU0TXD_FUN_WPD() uint32 {
	return (volatile.LoadUint32(&o.U0TXD.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetU0TXD_FUN_WPU(value uint32) {
	volatile.StoreUint32(&o.U0TXD.Reg, volatile.LoadUint32(&o.U0TXD.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetU0TXD_FUN_WPU() uint32 {
	return (volatile.LoadUint32(&o.U0TXD.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetU0TXD_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.U0TXD.Reg, volatile.LoadUint32(&o.U0TXD.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetU0TXD_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.U0TXD.Reg) & 0x200) >> 9
}
func (o *IO_MUX_Type) SetU0TXD_FUN_DRV(value uint32) {
	volatile.StoreUint32(&o.U0TXD.Reg, volatile.LoadUint32(&o.U0TXD.Reg)&^(0xc00)|value<<10)
}
func (o *IO_MUX_Type) GetU0TXD_FUN_DRV() uint32 {
	return (volatile.LoadUint32(&o.U0TXD.Reg) & 0xc00) >> 10
}
func (o *IO_MUX_Type) SetU0TXD_MCU_SEL(value uint32) {
	volatile.StoreUint32(&o.U0TXD.Reg, volatile.LoadUint32(&o.U0TXD.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetU0TXD_MCU_SEL() uint32 {
	return (volatile.LoadUint32(&o.U0TXD.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetU0TXD_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.U0TXD.Reg, volatile.LoadUint32(&o.U0TXD.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetU0TXD_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.U0TXD.Reg) & 0x8000) >> 15
}

// IO_MUX.U0RXD: Configuration register for pad U0RXD
func (o *IO_MUX_Type) SetU0RXD_MCU_OE(value uint32) {
	volatile.StoreUint32(&o.U0RXD.Reg, volatile.LoadUint32(&o.U0RXD.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetU0RXD_MCU_OE() uint32 {
	return volatile.LoadUint32(&o.U0RXD.Reg) & 0x1
}
func (o *IO_MUX_Type) SetU0RXD_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.U0RXD.Reg, volatile.LoadUint32(&o.U0RXD.Reg)&^(0x2)|value<<1)
}
func (o *IO_MUX_Type) GetU0RXD_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.U0RXD.Reg) & 0x2) >> 1
}
func (o *IO_MUX_Type) SetU0RXD_MCU_WPD(value uint32) {
	volatile.StoreUint32(&o.U0RXD.Reg, volatile.LoadUint32(&o.U0RXD.Reg)&^(0x4)|value<<2)
}
func (o *IO_MUX_Type) GetU0RXD_MCU_WPD() uint32 {
	return (volatile.LoadUint32(&o.U0RXD.Reg) & 0x4) >> 2
}
func (o *IO_MUX_Type) SetU0RXD_MCU_WPU(value uint32) {
	volatile.StoreUint32(&o.U0RXD.Reg, volatile.LoadUint32(&o.U0RXD.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetU0RXD_MCU_WPU() uint32 {
	return (volatile.LoadUint32(&o.U0RXD.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetU0RXD_MCU_IE(value uint32) {
	volatile.StoreUint32(&o.U0RXD.Reg, volatile.LoadUint32(&o.U0RXD.Reg)&^(0x10)|value<<4)
}
func (o *IO_MUX_Type) GetU0RXD_MCU_IE() uint32 {
	return (volatile.LoadUint32(&o.U0RXD.Reg) & 0x10) >> 4
}
func (o *IO_MUX_Type) SetU0RXD_FUN_WPD(value uint32) {
	volatile.StoreUint32(&o.U0RXD.Reg, volatile.LoadUint32(&o.U0RXD.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetU0RXD_FUN_WPD() uint32 {
	return (volatile.LoadUint32(&o.U0RXD.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetU0RXD_FUN_WPU(value uint32) {
	volatile.StoreUint32(&o.U0RXD.Reg, volatile.LoadUint32(&o.U0RXD.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetU0RXD_FUN_WPU() uint32 {
	return (volatile.LoadUint32(&o.U0RXD.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetU0RXD_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.U0RXD.Reg, volatile.LoadUint32(&o.U0RXD.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetU0RXD_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.U0RXD.Reg) & 0x200) >> 9
}
func (o *IO_MUX_Type) SetU0RXD_FUN_DRV(value uint32) {
	volatile.StoreUint32(&o.U0RXD.Reg, volatile.LoadUint32(&o.U0RXD.Reg)&^(0xc00)|value<<10)
}
func (o *IO_MUX_Type) GetU0RXD_FUN_DRV() uint32 {
	return (volatile.LoadUint32(&o.U0RXD.Reg) & 0xc00) >> 10
}
func (o *IO_MUX_Type) SetU0RXD_MCU_SEL(value uint32) {
	volatile.StoreUint32(&o.U0RXD.Reg, volatile.LoadUint32(&o.U0RXD.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetU0RXD_MCU_SEL() uint32 {
	return (volatile.LoadUint32(&o.U0RXD.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetU0RXD_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.U0RXD.Reg, volatile.LoadUint32(&o.U0RXD.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetU0RXD_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.U0RXD.Reg) & 0x8000) >> 15
}

// IO_MUX.GPIO_45: Configuration register for pad GPIO45
func (o *IO_MUX_Type) SetGPIO_45_MCU_OE(value uint32) {
	volatile.StoreUint32(&o.GPIO_45.Reg, volatile.LoadUint32(&o.GPIO_45.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetGPIO_45_MCU_OE() uint32 {
	return volatile.LoadUint32(&o.GPIO_45.Reg) & 0x1
}
func (o *IO_MUX_Type) SetGPIO_45_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO_45.Reg, volatile.LoadUint32(&o.GPIO_45.Reg)&^(0x2)|value<<1)
}
func (o *IO_MUX_Type) GetGPIO_45_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO_45.Reg) & 0x2) >> 1
}
func (o *IO_MUX_Type) SetGPIO_45_MCU_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO_45.Reg, volatile.LoadUint32(&o.GPIO_45.Reg)&^(0x4)|value<<2)
}
func (o *IO_MUX_Type) GetGPIO_45_MCU_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO_45.Reg) & 0x4) >> 2
}
func (o *IO_MUX_Type) SetGPIO_45_MCU_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO_45.Reg, volatile.LoadUint32(&o.GPIO_45.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetGPIO_45_MCU_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO_45.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetGPIO_45_MCU_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO_45.Reg, volatile.LoadUint32(&o.GPIO_45.Reg)&^(0x10)|value<<4)
}
func (o *IO_MUX_Type) GetGPIO_45_MCU_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO_45.Reg) & 0x10) >> 4
}
func (o *IO_MUX_Type) SetGPIO_45_FUN_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO_45.Reg, volatile.LoadUint32(&o.GPIO_45.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetGPIO_45_FUN_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO_45.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetGPIO_45_FUN_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO_45.Reg, volatile.LoadUint32(&o.GPIO_45.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetGPIO_45_FUN_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO_45.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetGPIO_45_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO_45.Reg, volatile.LoadUint32(&o.GPIO_45.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetGPIO_45_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO_45.Reg) & 0x200) >> 9
}
func (o *IO_MUX_Type) SetGPIO_45_FUN_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO_45.Reg, volatile.LoadUint32(&o.GPIO_45.Reg)&^(0xc00)|value<<10)
}
func (o *IO_MUX_Type) GetGPIO_45_FUN_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO_45.Reg) & 0xc00) >> 10
}
func (o *IO_MUX_Type) SetGPIO_45_MCU_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO_45.Reg, volatile.LoadUint32(&o.GPIO_45.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetGPIO_45_MCU_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO_45.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetGPIO_45_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO_45.Reg, volatile.LoadUint32(&o.GPIO_45.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetGPIO_45_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO_45.Reg) & 0x8000) >> 15
}

// IO_MUX.GPIO_46: Configuration register for pad GPIO46
func (o *IO_MUX_Type) SetGPIO_46_MCU_OE(value uint32) {
	volatile.StoreUint32(&o.GPIO_46.Reg, volatile.LoadUint32(&o.GPIO_46.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetGPIO_46_MCU_OE() uint32 {
	return volatile.LoadUint32(&o.GPIO_46.Reg) & 0x1
}
func (o *IO_MUX_Type) SetGPIO_46_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO_46.Reg, volatile.LoadUint32(&o.GPIO_46.Reg)&^(0x2)|value<<1)
}
func (o *IO_MUX_Type) GetGPIO_46_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO_46.Reg) & 0x2) >> 1
}
func (o *IO_MUX_Type) SetGPIO_46_MCU_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO_46.Reg, volatile.LoadUint32(&o.GPIO_46.Reg)&^(0x4)|value<<2)
}
func (o *IO_MUX_Type) GetGPIO_46_MCU_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO_46.Reg) & 0x4) >> 2
}
func (o *IO_MUX_Type) SetGPIO_46_MCU_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO_46.Reg, volatile.LoadUint32(&o.GPIO_46.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetGPIO_46_MCU_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO_46.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetGPIO_46_MCU_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO_46.Reg, volatile.LoadUint32(&o.GPIO_46.Reg)&^(0x10)|value<<4)
}
func (o *IO_MUX_Type) GetGPIO_46_MCU_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO_46.Reg) & 0x10) >> 4
}
func (o *IO_MUX_Type) SetGPIO_46_FUN_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO_46.Reg, volatile.LoadUint32(&o.GPIO_46.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetGPIO_46_FUN_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO_46.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetGPIO_46_FUN_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO_46.Reg, volatile.LoadUint32(&o.GPIO_46.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetGPIO_46_FUN_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO_46.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetGPIO_46_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO_46.Reg, volatile.LoadUint32(&o.GPIO_46.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetGPIO_46_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO_46.Reg) & 0x200) >> 9
}
func (o *IO_MUX_Type) SetGPIO_46_FUN_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO_46.Reg, volatile.LoadUint32(&o.GPIO_46.Reg)&^(0xc00)|value<<10)
}
func (o *IO_MUX_Type) GetGPIO_46_FUN_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO_46.Reg) & 0xc00) >> 10
}
func (o *IO_MUX_Type) SetGPIO_46_MCU_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO_46.Reg, volatile.LoadUint32(&o.GPIO_46.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetGPIO_46_MCU_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO_46.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetGPIO_46_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO_46.Reg, volatile.LoadUint32(&o.GPIO_46.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetGPIO_46_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO_46.Reg) & 0x8000) >> 15
}

// IO_MUX.DATE: Version control register
func (o *IO_MUX_Type) SetDATE_VERSION(value uint32) {
	volatile.StoreUint32(&o.DATE.Reg, volatile.LoadUint32(&o.DATE.Reg)&^(0xfffffff)|value)
}
func (o *IO_MUX_Type) GetDATE_VERSION() uint32 {
	return volatile.LoadUint32(&o.DATE.Reg) & 0xfffffff
}

// Peripheral LEDC
type LEDC_Type struct {
	CH0_CONF0    volatile.Register32 // 0x0
	CH0_HPOINT   volatile.Register32 // 0x4
	CH0_DUTY     volatile.Register32 // 0x8
	CH0_CONF1    volatile.Register32 // 0xC
	CH0_DUTY_R   volatile.Register32 // 0x10
	CH1_CONF0    volatile.Register32 // 0x14
	CH1_HPOINT   volatile.Register32 // 0x18
	CH1_DUTY     volatile.Register32 // 0x1C
	CH1_CONF1    volatile.Register32 // 0x20
	CH1_DUTY_R   volatile.Register32 // 0x24
	CH2_CONF0    volatile.Register32 // 0x28
	CH2_HPOINT   volatile.Register32 // 0x2C
	CH2_DUTY     volatile.Register32 // 0x30
	CH2_CONF1    volatile.Register32 // 0x34
	CH2_DUTY_R   volatile.Register32 // 0x38
	CH3_CONF0    volatile.Register32 // 0x3C
	CH3_HPOINT   volatile.Register32 // 0x40
	CH3_DUTY     volatile.Register32 // 0x44
	CH3_CONF1    volatile.Register32 // 0x48
	CH3_DUTY_R   volatile.Register32 // 0x4C
	CH4_CONF0    volatile.Register32 // 0x50
	CH4_HPOINT   volatile.Register32 // 0x54
	CH4_DUTY     volatile.Register32 // 0x58
	CH4_CONF1    volatile.Register32 // 0x5C
	CH4_DUTY_R   volatile.Register32 // 0x60
	CH5_CONF0    volatile.Register32 // 0x64
	CH5_HPOINT   volatile.Register32 // 0x68
	CH5_DUTY     volatile.Register32 // 0x6C
	CH5_CONF1    volatile.Register32 // 0x70
	CH5_DUTY_R   volatile.Register32 // 0x74
	CH6_CONF0    volatile.Register32 // 0x78
	CH6_HPOINT   volatile.Register32 // 0x7C
	CH6_DUTY     volatile.Register32 // 0x80
	CH6_CONF1    volatile.Register32 // 0x84
	CH6_DUTY_R   volatile.Register32 // 0x88
	CH7_CONF0    volatile.Register32 // 0x8C
	CH7_HPOINT   volatile.Register32 // 0x90
	CH7_DUTY     volatile.Register32 // 0x94
	CH7_CONF1    volatile.Register32 // 0x98
	CH7_DUTY_R   volatile.Register32 // 0x9C
	TIMER0_CONF  volatile.Register32 // 0xA0
	TIMER0_VALUE volatile.Register32 // 0xA4
	TIMER1_CONF  volatile.Register32 // 0xA8
	TIMER1_VALUE volatile.Register32 // 0xAC
	TIMER2_CONF  volatile.Register32 // 0xB0
	TIMER2_VALUE volatile.Register32 // 0xB4
	TIMER3_CONF  volatile.Register32 // 0xB8
	TIMER3_VALUE volatile.Register32 // 0xBC
	INT_RAW      volatile.Register32 // 0xC0
	INT_ST       volatile.Register32 // 0xC4
	INT_ENA      volatile.Register32 // 0xC8
	INT_CLR      volatile.Register32 // 0xCC
	CONF         volatile.Register32 // 0xD0
	_            [40]byte
	DATE         volatile.Register32 // 0xFC
}

// LEDC.CH0_CONF0: Configuration register 0 for channel %s
func (o *LEDC_Type) SetCH0_CONF0_TIMER_SEL_CH0(value uint32) {
	volatile.StoreUint32(&o.CH0_CONF0.Reg, volatile.LoadUint32(&o.CH0_CONF0.Reg)&^(0x3)|value)
}
func (o *LEDC_Type) GetCH0_CONF0_TIMER_SEL_CH0() uint32 {
	return volatile.LoadUint32(&o.CH0_CONF0.Reg) & 0x3
}
func (o *LEDC_Type) SetCH0_CONF0_SIG_OUT_EN_CH0(value uint32) {
	volatile.StoreUint32(&o.CH0_CONF0.Reg, volatile.LoadUint32(&o.CH0_CONF0.Reg)&^(0x4)|value<<2)
}
func (o *LEDC_Type) GetCH0_CONF0_SIG_OUT_EN_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH0_CONF0.Reg) & 0x4) >> 2
}
func (o *LEDC_Type) SetCH0_CONF0_IDLE_LV_CH0(value uint32) {
	volatile.StoreUint32(&o.CH0_CONF0.Reg, volatile.LoadUint32(&o.CH0_CONF0.Reg)&^(0x8)|value<<3)
}
func (o *LEDC_Type) GetCH0_CONF0_IDLE_LV_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH0_CONF0.Reg) & 0x8) >> 3
}
func (o *LEDC_Type) SetCH0_CONF0_PARA_UP_CH0(value uint32) {
	volatile.StoreUint32(&o.CH0_CONF0.Reg, volatile.LoadUint32(&o.CH0_CONF0.Reg)&^(0x10)|value<<4)
}
func (o *LEDC_Type) GetCH0_CONF0_PARA_UP_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH0_CONF0.Reg) & 0x10) >> 4
}
func (o *LEDC_Type) SetCH0_CONF0_OVF_NUM_CH0(value uint32) {
	volatile.StoreUint32(&o.CH0_CONF0.Reg, volatile.LoadUint32(&o.CH0_CONF0.Reg)&^(0x7fe0)|value<<5)
}
func (o *LEDC_Type) GetCH0_CONF0_OVF_NUM_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH0_CONF0.Reg) & 0x7fe0) >> 5
}
func (o *LEDC_Type) SetCH0_CONF0_OVF_CNT_EN_CH0(value uint32) {
	volatile.StoreUint32(&o.CH0_CONF0.Reg, volatile.LoadUint32(&o.CH0_CONF0.Reg)&^(0x8000)|value<<15)
}
func (o *LEDC_Type) GetCH0_CONF0_OVF_CNT_EN_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH0_CONF0.Reg) & 0x8000) >> 15
}
func (o *LEDC_Type) SetCH0_CONF0_OVF_CNT_RESET_CH0(value uint32) {
	volatile.StoreUint32(&o.CH0_CONF0.Reg, volatile.LoadUint32(&o.CH0_CONF0.Reg)&^(0x10000)|value<<16)
}
func (o *LEDC_Type) GetCH0_CONF0_OVF_CNT_RESET_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH0_CONF0.Reg) & 0x10000) >> 16
}
func (o *LEDC_Type) SetCH0_CONF0_OVF_CNT_RESET_ST_CH0(value uint32) {
	volatile.StoreUint32(&o.CH0_CONF0.Reg, volatile.LoadUint32(&o.CH0_CONF0.Reg)&^(0x20000)|value<<17)
}
func (o *LEDC_Type) GetCH0_CONF0_OVF_CNT_RESET_ST_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH0_CONF0.Reg) & 0x20000) >> 17
}

// LEDC.CH0_HPOINT: High point register for channel %s
func (o *LEDC_Type) SetCH0_HPOINT_HPOINT_CH0(value uint32) {
	volatile.StoreUint32(&o.CH0_HPOINT.Reg, volatile.LoadUint32(&o.CH0_HPOINT.Reg)&^(0x3fff)|value)
}
func (o *LEDC_Type) GetCH0_HPOINT_HPOINT_CH0() uint32 {
	return volatile.LoadUint32(&o.CH0_HPOINT.Reg) & 0x3fff
}

// LEDC.CH0_DUTY: Initial duty cycle for channel %s
func (o *LEDC_Type) SetCH0_DUTY_DUTY_CH0(value uint32) {
	volatile.StoreUint32(&o.CH0_DUTY.Reg, volatile.LoadUint32(&o.CH0_DUTY.Reg)&^(0x7ffff)|value)
}
func (o *LEDC_Type) GetCH0_DUTY_DUTY_CH0() uint32 {
	return volatile.LoadUint32(&o.CH0_DUTY.Reg) & 0x7ffff
}

// LEDC.CH0_CONF1: Configuration register 1 for channel %s
func (o *LEDC_Type) SetCH0_CONF1_DUTY_SCALE_CH0(value uint32) {
	volatile.StoreUint32(&o.CH0_CONF1.Reg, volatile.LoadUint32(&o.CH0_CONF1.Reg)&^(0x3ff)|value)
}
func (o *LEDC_Type) GetCH0_CONF1_DUTY_SCALE_CH0() uint32 {
	return volatile.LoadUint32(&o.CH0_CONF1.Reg) & 0x3ff
}
func (o *LEDC_Type) SetCH0_CONF1_DUTY_CYCLE_CH0(value uint32) {
	volatile.StoreUint32(&o.CH0_CONF1.Reg, volatile.LoadUint32(&o.CH0_CONF1.Reg)&^(0xffc00)|value<<10)
}
func (o *LEDC_Type) GetCH0_CONF1_DUTY_CYCLE_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH0_CONF1.Reg) & 0xffc00) >> 10
}
func (o *LEDC_Type) SetCH0_CONF1_DUTY_NUM_CH0(value uint32) {
	volatile.StoreUint32(&o.CH0_CONF1.Reg, volatile.LoadUint32(&o.CH0_CONF1.Reg)&^(0x3ff00000)|value<<20)
}
func (o *LEDC_Type) GetCH0_CONF1_DUTY_NUM_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH0_CONF1.Reg) & 0x3ff00000) >> 20
}
func (o *LEDC_Type) SetCH0_CONF1_DUTY_INC_CH0(value uint32) {
	volatile.StoreUint32(&o.CH0_CONF1.Reg, volatile.LoadUint32(&o.CH0_CONF1.Reg)&^(0x40000000)|value<<30)
}
func (o *LEDC_Type) GetCH0_CONF1_DUTY_INC_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH0_CONF1.Reg) & 0x40000000) >> 30
}
func (o *LEDC_Type) SetCH0_CONF1_DUTY_START_CH0(value uint32) {
	volatile.StoreUint32(&o.CH0_CONF1.Reg, volatile.LoadUint32(&o.CH0_CONF1.Reg)&^(0x80000000)|value<<31)
}
func (o *LEDC_Type) GetCH0_CONF1_DUTY_START_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH0_CONF1.Reg) & 0x80000000) >> 31
}

// LEDC.CH0_DUTY_R: Current duty cycle for channel %s
func (o *LEDC_Type) SetCH0_DUTY_R_DUTY_R_CH0(value uint32) {
	volatile.StoreUint32(&o.CH0_DUTY_R.Reg, volatile.LoadUint32(&o.CH0_DUTY_R.Reg)&^(0x7ffff)|value)
}
func (o *LEDC_Type) GetCH0_DUTY_R_DUTY_R_CH0() uint32 {
	return volatile.LoadUint32(&o.CH0_DUTY_R.Reg) & 0x7ffff
}

// LEDC.CH1_CONF0: Configuration register 0 for channel %s
func (o *LEDC_Type) SetCH1_CONF0_TIMER_SEL_CH0(value uint32) {
	volatile.StoreUint32(&o.CH1_CONF0.Reg, volatile.LoadUint32(&o.CH1_CONF0.Reg)&^(0x3)|value)
}
func (o *LEDC_Type) GetCH1_CONF0_TIMER_SEL_CH0() uint32 {
	return volatile.LoadUint32(&o.CH1_CONF0.Reg) & 0x3
}
func (o *LEDC_Type) SetCH1_CONF0_SIG_OUT_EN_CH0(value uint32) {
	volatile.StoreUint32(&o.CH1_CONF0.Reg, volatile.LoadUint32(&o.CH1_CONF0.Reg)&^(0x4)|value<<2)
}
func (o *LEDC_Type) GetCH1_CONF0_SIG_OUT_EN_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH1_CONF0.Reg) & 0x4) >> 2
}
func (o *LEDC_Type) SetCH1_CONF0_IDLE_LV_CH0(value uint32) {
	volatile.StoreUint32(&o.CH1_CONF0.Reg, volatile.LoadUint32(&o.CH1_CONF0.Reg)&^(0x8)|value<<3)
}
func (o *LEDC_Type) GetCH1_CONF0_IDLE_LV_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH1_CONF0.Reg) & 0x8) >> 3
}
func (o *LEDC_Type) SetCH1_CONF0_PARA_UP_CH0(value uint32) {
	volatile.StoreUint32(&o.CH1_CONF0.Reg, volatile.LoadUint32(&o.CH1_CONF0.Reg)&^(0x10)|value<<4)
}
func (o *LEDC_Type) GetCH1_CONF0_PARA_UP_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH1_CONF0.Reg) & 0x10) >> 4
}
func (o *LEDC_Type) SetCH1_CONF0_OVF_NUM_CH0(value uint32) {
	volatile.StoreUint32(&o.CH1_CONF0.Reg, volatile.LoadUint32(&o.CH1_CONF0.Reg)&^(0x7fe0)|value<<5)
}
func (o *LEDC_Type) GetCH1_CONF0_OVF_NUM_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH1_CONF0.Reg) & 0x7fe0) >> 5
}
func (o *LEDC_Type) SetCH1_CONF0_OVF_CNT_EN_CH0(value uint32) {
	volatile.StoreUint32(&o.CH1_CONF0.Reg, volatile.LoadUint32(&o.CH1_CONF0.Reg)&^(0x8000)|value<<15)
}
func (o *LEDC_Type) GetCH1_CONF0_OVF_CNT_EN_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH1_CONF0.Reg) & 0x8000) >> 15
}
func (o *LEDC_Type) SetCH1_CONF0_OVF_CNT_RESET_CH0(value uint32) {
	volatile.StoreUint32(&o.CH1_CONF0.Reg, volatile.LoadUint32(&o.CH1_CONF0.Reg)&^(0x10000)|value<<16)
}
func (o *LEDC_Type) GetCH1_CONF0_OVF_CNT_RESET_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH1_CONF0.Reg) & 0x10000) >> 16
}
func (o *LEDC_Type) SetCH1_CONF0_OVF_CNT_RESET_ST_CH0(value uint32) {
	volatile.StoreUint32(&o.CH1_CONF0.Reg, volatile.LoadUint32(&o.CH1_CONF0.Reg)&^(0x20000)|value<<17)
}
func (o *LEDC_Type) GetCH1_CONF0_OVF_CNT_RESET_ST_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH1_CONF0.Reg) & 0x20000) >> 17
}

// LEDC.CH1_HPOINT: High point register for channel %s
func (o *LEDC_Type) SetCH1_HPOINT_HPOINT_CH0(value uint32) {
	volatile.StoreUint32(&o.CH1_HPOINT.Reg, volatile.LoadUint32(&o.CH1_HPOINT.Reg)&^(0x3fff)|value)
}
func (o *LEDC_Type) GetCH1_HPOINT_HPOINT_CH0() uint32 {
	return volatile.LoadUint32(&o.CH1_HPOINT.Reg) & 0x3fff
}

// LEDC.CH1_DUTY: Initial duty cycle for channel %s
func (o *LEDC_Type) SetCH1_DUTY_DUTY_CH0(value uint32) {
	volatile.StoreUint32(&o.CH1_DUTY.Reg, volatile.LoadUint32(&o.CH1_DUTY.Reg)&^(0x7ffff)|value)
}
func (o *LEDC_Type) GetCH1_DUTY_DUTY_CH0() uint32 {
	return volatile.LoadUint32(&o.CH1_DUTY.Reg) & 0x7ffff
}

// LEDC.CH1_CONF1: Configuration register 1 for channel %s
func (o *LEDC_Type) SetCH1_CONF1_DUTY_SCALE_CH0(value uint32) {
	volatile.StoreUint32(&o.CH1_CONF1.Reg, volatile.LoadUint32(&o.CH1_CONF1.Reg)&^(0x3ff)|value)
}
func (o *LEDC_Type) GetCH1_CONF1_DUTY_SCALE_CH0() uint32 {
	return volatile.LoadUint32(&o.CH1_CONF1.Reg) & 0x3ff
}
func (o *LEDC_Type) SetCH1_CONF1_DUTY_CYCLE_CH0(value uint32) {
	volatile.StoreUint32(&o.CH1_CONF1.Reg, volatile.LoadUint32(&o.CH1_CONF1.Reg)&^(0xffc00)|value<<10)
}
func (o *LEDC_Type) GetCH1_CONF1_DUTY_CYCLE_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH1_CONF1.Reg) & 0xffc00) >> 10
}
func (o *LEDC_Type) SetCH1_CONF1_DUTY_NUM_CH0(value uint32) {
	volatile.StoreUint32(&o.CH1_CONF1.Reg, volatile.LoadUint32(&o.CH1_CONF1.Reg)&^(0x3ff00000)|value<<20)
}
func (o *LEDC_Type) GetCH1_CONF1_DUTY_NUM_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH1_CONF1.Reg) & 0x3ff00000) >> 20
}
func (o *LEDC_Type) SetCH1_CONF1_DUTY_INC_CH0(value uint32) {
	volatile.StoreUint32(&o.CH1_CONF1.Reg, volatile.LoadUint32(&o.CH1_CONF1.Reg)&^(0x40000000)|value<<30)
}
func (o *LEDC_Type) GetCH1_CONF1_DUTY_INC_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH1_CONF1.Reg) & 0x40000000) >> 30
}
func (o *LEDC_Type) SetCH1_CONF1_DUTY_START_CH0(value uint32) {
	volatile.StoreUint32(&o.CH1_CONF1.Reg, volatile.LoadUint32(&o.CH1_CONF1.Reg)&^(0x80000000)|value<<31)
}
func (o *LEDC_Type) GetCH1_CONF1_DUTY_START_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH1_CONF1.Reg) & 0x80000000) >> 31
}

// LEDC.CH1_DUTY_R: Current duty cycle for channel %s
func (o *LEDC_Type) SetCH1_DUTY_R_DUTY_R_CH0(value uint32) {
	volatile.StoreUint32(&o.CH1_DUTY_R.Reg, volatile.LoadUint32(&o.CH1_DUTY_R.Reg)&^(0x7ffff)|value)
}
func (o *LEDC_Type) GetCH1_DUTY_R_DUTY_R_CH0() uint32 {
	return volatile.LoadUint32(&o.CH1_DUTY_R.Reg) & 0x7ffff
}

// LEDC.CH2_CONF0: Configuration register 0 for channel %s
func (o *LEDC_Type) SetCH2_CONF0_TIMER_SEL_CH0(value uint32) {
	volatile.StoreUint32(&o.CH2_CONF0.Reg, volatile.LoadUint32(&o.CH2_CONF0.Reg)&^(0x3)|value)
}
func (o *LEDC_Type) GetCH2_CONF0_TIMER_SEL_CH0() uint32 {
	return volatile.LoadUint32(&o.CH2_CONF0.Reg) & 0x3
}
func (o *LEDC_Type) SetCH2_CONF0_SIG_OUT_EN_CH0(value uint32) {
	volatile.StoreUint32(&o.CH2_CONF0.Reg, volatile.LoadUint32(&o.CH2_CONF0.Reg)&^(0x4)|value<<2)
}
func (o *LEDC_Type) GetCH2_CONF0_SIG_OUT_EN_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH2_CONF0.Reg) & 0x4) >> 2
}
func (o *LEDC_Type) SetCH2_CONF0_IDLE_LV_CH0(value uint32) {
	volatile.StoreUint32(&o.CH2_CONF0.Reg, volatile.LoadUint32(&o.CH2_CONF0.Reg)&^(0x8)|value<<3)
}
func (o *LEDC_Type) GetCH2_CONF0_IDLE_LV_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH2_CONF0.Reg) & 0x8) >> 3
}
func (o *LEDC_Type) SetCH2_CONF0_PARA_UP_CH0(value uint32) {
	volatile.StoreUint32(&o.CH2_CONF0.Reg, volatile.LoadUint32(&o.CH2_CONF0.Reg)&^(0x10)|value<<4)
}
func (o *LEDC_Type) GetCH2_CONF0_PARA_UP_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH2_CONF0.Reg) & 0x10) >> 4
}
func (o *LEDC_Type) SetCH2_CONF0_OVF_NUM_CH0(value uint32) {
	volatile.StoreUint32(&o.CH2_CONF0.Reg, volatile.LoadUint32(&o.CH2_CONF0.Reg)&^(0x7fe0)|value<<5)
}
func (o *LEDC_Type) GetCH2_CONF0_OVF_NUM_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH2_CONF0.Reg) & 0x7fe0) >> 5
}
func (o *LEDC_Type) SetCH2_CONF0_OVF_CNT_EN_CH0(value uint32) {
	volatile.StoreUint32(&o.CH2_CONF0.Reg, volatile.LoadUint32(&o.CH2_CONF0.Reg)&^(0x8000)|value<<15)
}
func (o *LEDC_Type) GetCH2_CONF0_OVF_CNT_EN_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH2_CONF0.Reg) & 0x8000) >> 15
}
func (o *LEDC_Type) SetCH2_CONF0_OVF_CNT_RESET_CH0(value uint32) {
	volatile.StoreUint32(&o.CH2_CONF0.Reg, volatile.LoadUint32(&o.CH2_CONF0.Reg)&^(0x10000)|value<<16)
}
func (o *LEDC_Type) GetCH2_CONF0_OVF_CNT_RESET_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH2_CONF0.Reg) & 0x10000) >> 16
}
func (o *LEDC_Type) SetCH2_CONF0_OVF_CNT_RESET_ST_CH0(value uint32) {
	volatile.StoreUint32(&o.CH2_CONF0.Reg, volatile.LoadUint32(&o.CH2_CONF0.Reg)&^(0x20000)|value<<17)
}
func (o *LEDC_Type) GetCH2_CONF0_OVF_CNT_RESET_ST_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH2_CONF0.Reg) & 0x20000) >> 17
}

// LEDC.CH2_HPOINT: High point register for channel %s
func (o *LEDC_Type) SetCH2_HPOINT_HPOINT_CH0(value uint32) {
	volatile.StoreUint32(&o.CH2_HPOINT.Reg, volatile.LoadUint32(&o.CH2_HPOINT.Reg)&^(0x3fff)|value)
}
func (o *LEDC_Type) GetCH2_HPOINT_HPOINT_CH0() uint32 {
	return volatile.LoadUint32(&o.CH2_HPOINT.Reg) & 0x3fff
}

// LEDC.CH2_DUTY: Initial duty cycle for channel %s
func (o *LEDC_Type) SetCH2_DUTY_DUTY_CH0(value uint32) {
	volatile.StoreUint32(&o.CH2_DUTY.Reg, volatile.LoadUint32(&o.CH2_DUTY.Reg)&^(0x7ffff)|value)
}
func (o *LEDC_Type) GetCH2_DUTY_DUTY_CH0() uint32 {
	return volatile.LoadUint32(&o.CH2_DUTY.Reg) & 0x7ffff
}

// LEDC.CH2_CONF1: Configuration register 1 for channel %s
func (o *LEDC_Type) SetCH2_CONF1_DUTY_SCALE_CH0(value uint32) {
	volatile.StoreUint32(&o.CH2_CONF1.Reg, volatile.LoadUint32(&o.CH2_CONF1.Reg)&^(0x3ff)|value)
}
func (o *LEDC_Type) GetCH2_CONF1_DUTY_SCALE_CH0() uint32 {
	return volatile.LoadUint32(&o.CH2_CONF1.Reg) & 0x3ff
}
func (o *LEDC_Type) SetCH2_CONF1_DUTY_CYCLE_CH0(value uint32) {
	volatile.StoreUint32(&o.CH2_CONF1.Reg, volatile.LoadUint32(&o.CH2_CONF1.Reg)&^(0xffc00)|value<<10)
}
func (o *LEDC_Type) GetCH2_CONF1_DUTY_CYCLE_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH2_CONF1.Reg) & 0xffc00) >> 10
}
func (o *LEDC_Type) SetCH2_CONF1_DUTY_NUM_CH0(value uint32) {
	volatile.StoreUint32(&o.CH2_CONF1.Reg, volatile.LoadUint32(&o.CH2_CONF1.Reg)&^(0x3ff00000)|value<<20)
}
func (o *LEDC_Type) GetCH2_CONF1_DUTY_NUM_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH2_CONF1.Reg) & 0x3ff00000) >> 20
}
func (o *LEDC_Type) SetCH2_CONF1_DUTY_INC_CH0(value uint32) {
	volatile.StoreUint32(&o.CH2_CONF1.Reg, volatile.LoadUint32(&o.CH2_CONF1.Reg)&^(0x40000000)|value<<30)
}
func (o *LEDC_Type) GetCH2_CONF1_DUTY_INC_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH2_CONF1.Reg) & 0x40000000) >> 30
}
func (o *LEDC_Type) SetCH2_CONF1_DUTY_START_CH0(value uint32) {
	volatile.StoreUint32(&o.CH2_CONF1.Reg, volatile.LoadUint32(&o.CH2_CONF1.Reg)&^(0x80000000)|value<<31)
}
func (o *LEDC_Type) GetCH2_CONF1_DUTY_START_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH2_CONF1.Reg) & 0x80000000) >> 31
}

// LEDC.CH2_DUTY_R: Current duty cycle for channel %s
func (o *LEDC_Type) SetCH2_DUTY_R_DUTY_R_CH0(value uint32) {
	volatile.StoreUint32(&o.CH2_DUTY_R.Reg, volatile.LoadUint32(&o.CH2_DUTY_R.Reg)&^(0x7ffff)|value)
}
func (o *LEDC_Type) GetCH2_DUTY_R_DUTY_R_CH0() uint32 {
	return volatile.LoadUint32(&o.CH2_DUTY_R.Reg) & 0x7ffff
}

// LEDC.CH3_CONF0: Configuration register 0 for channel %s
func (o *LEDC_Type) SetCH3_CONF0_TIMER_SEL_CH0(value uint32) {
	volatile.StoreUint32(&o.CH3_CONF0.Reg, volatile.LoadUint32(&o.CH3_CONF0.Reg)&^(0x3)|value)
}
func (o *LEDC_Type) GetCH3_CONF0_TIMER_SEL_CH0() uint32 {
	return volatile.LoadUint32(&o.CH3_CONF0.Reg) & 0x3
}
func (o *LEDC_Type) SetCH3_CONF0_SIG_OUT_EN_CH0(value uint32) {
	volatile.StoreUint32(&o.CH3_CONF0.Reg, volatile.LoadUint32(&o.CH3_CONF0.Reg)&^(0x4)|value<<2)
}
func (o *LEDC_Type) GetCH3_CONF0_SIG_OUT_EN_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH3_CONF0.Reg) & 0x4) >> 2
}
func (o *LEDC_Type) SetCH3_CONF0_IDLE_LV_CH0(value uint32) {
	volatile.StoreUint32(&o.CH3_CONF0.Reg, volatile.LoadUint32(&o.CH3_CONF0.Reg)&^(0x8)|value<<3)
}
func (o *LEDC_Type) GetCH3_CONF0_IDLE_LV_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH3_CONF0.Reg) & 0x8) >> 3
}
func (o *LEDC_Type) SetCH3_CONF0_PARA_UP_CH0(value uint32) {
	volatile.StoreUint32(&o.CH3_CONF0.Reg, volatile.LoadUint32(&o.CH3_CONF0.Reg)&^(0x10)|value<<4)
}
func (o *LEDC_Type) GetCH3_CONF0_PARA_UP_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH3_CONF0.Reg) & 0x10) >> 4
}
func (o *LEDC_Type) SetCH3_CONF0_OVF_NUM_CH0(value uint32) {
	volatile.StoreUint32(&o.CH3_CONF0.Reg, volatile.LoadUint32(&o.CH3_CONF0.Reg)&^(0x7fe0)|value<<5)
}
func (o *LEDC_Type) GetCH3_CONF0_OVF_NUM_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH3_CONF0.Reg) & 0x7fe0) >> 5
}
func (o *LEDC_Type) SetCH3_CONF0_OVF_CNT_EN_CH0(value uint32) {
	volatile.StoreUint32(&o.CH3_CONF0.Reg, volatile.LoadUint32(&o.CH3_CONF0.Reg)&^(0x8000)|value<<15)
}
func (o *LEDC_Type) GetCH3_CONF0_OVF_CNT_EN_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH3_CONF0.Reg) & 0x8000) >> 15
}
func (o *LEDC_Type) SetCH3_CONF0_OVF_CNT_RESET_CH0(value uint32) {
	volatile.StoreUint32(&o.CH3_CONF0.Reg, volatile.LoadUint32(&o.CH3_CONF0.Reg)&^(0x10000)|value<<16)
}
func (o *LEDC_Type) GetCH3_CONF0_OVF_CNT_RESET_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH3_CONF0.Reg) & 0x10000) >> 16
}
func (o *LEDC_Type) SetCH3_CONF0_OVF_CNT_RESET_ST_CH0(value uint32) {
	volatile.StoreUint32(&o.CH3_CONF0.Reg, volatile.LoadUint32(&o.CH3_CONF0.Reg)&^(0x20000)|value<<17)
}
func (o *LEDC_Type) GetCH3_CONF0_OVF_CNT_RESET_ST_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH3_CONF0.Reg) & 0x20000) >> 17
}

// LEDC.CH3_HPOINT: High point register for channel %s
func (o *LEDC_Type) SetCH3_HPOINT_HPOINT_CH0(value uint32) {
	volatile.StoreUint32(&o.CH3_HPOINT.Reg, volatile.LoadUint32(&o.CH3_HPOINT.Reg)&^(0x3fff)|value)
}
func (o *LEDC_Type) GetCH3_HPOINT_HPOINT_CH0() uint32 {
	return volatile.LoadUint32(&o.CH3_HPOINT.Reg) & 0x3fff
}

// LEDC.CH3_DUTY: Initial duty cycle for channel %s
func (o *LEDC_Type) SetCH3_DUTY_DUTY_CH0(value uint32) {
	volatile.StoreUint32(&o.CH3_DUTY.Reg, volatile.LoadUint32(&o.CH3_DUTY.Reg)&^(0x7ffff)|value)
}
func (o *LEDC_Type) GetCH3_DUTY_DUTY_CH0() uint32 {
	return volatile.LoadUint32(&o.CH3_DUTY.Reg) & 0x7ffff
}

// LEDC.CH3_CONF1: Configuration register 1 for channel %s
func (o *LEDC_Type) SetCH3_CONF1_DUTY_SCALE_CH0(value uint32) {
	volatile.StoreUint32(&o.CH3_CONF1.Reg, volatile.LoadUint32(&o.CH3_CONF1.Reg)&^(0x3ff)|value)
}
func (o *LEDC_Type) GetCH3_CONF1_DUTY_SCALE_CH0() uint32 {
	return volatile.LoadUint32(&o.CH3_CONF1.Reg) & 0x3ff
}
func (o *LEDC_Type) SetCH3_CONF1_DUTY_CYCLE_CH0(value uint32) {
	volatile.StoreUint32(&o.CH3_CONF1.Reg, volatile.LoadUint32(&o.CH3_CONF1.Reg)&^(0xffc00)|value<<10)
}
func (o *LEDC_Type) GetCH3_CONF1_DUTY_CYCLE_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH3_CONF1.Reg) & 0xffc00) >> 10
}
func (o *LEDC_Type) SetCH3_CONF1_DUTY_NUM_CH0(value uint32) {
	volatile.StoreUint32(&o.CH3_CONF1.Reg, volatile.LoadUint32(&o.CH3_CONF1.Reg)&^(0x3ff00000)|value<<20)
}
func (o *LEDC_Type) GetCH3_CONF1_DUTY_NUM_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH3_CONF1.Reg) & 0x3ff00000) >> 20
}
func (o *LEDC_Type) SetCH3_CONF1_DUTY_INC_CH0(value uint32) {
	volatile.StoreUint32(&o.CH3_CONF1.Reg, volatile.LoadUint32(&o.CH3_CONF1.Reg)&^(0x40000000)|value<<30)
}
func (o *LEDC_Type) GetCH3_CONF1_DUTY_INC_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH3_CONF1.Reg) & 0x40000000) >> 30
}
func (o *LEDC_Type) SetCH3_CONF1_DUTY_START_CH0(value uint32) {
	volatile.StoreUint32(&o.CH3_CONF1.Reg, volatile.LoadUint32(&o.CH3_CONF1.Reg)&^(0x80000000)|value<<31)
}
func (o *LEDC_Type) GetCH3_CONF1_DUTY_START_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH3_CONF1.Reg) & 0x80000000) >> 31
}

// LEDC.CH3_DUTY_R: Current duty cycle for channel %s
func (o *LEDC_Type) SetCH3_DUTY_R_DUTY_R_CH0(value uint32) {
	volatile.StoreUint32(&o.CH3_DUTY_R.Reg, volatile.LoadUint32(&o.CH3_DUTY_R.Reg)&^(0x7ffff)|value)
}
func (o *LEDC_Type) GetCH3_DUTY_R_DUTY_R_CH0() uint32 {
	return volatile.LoadUint32(&o.CH3_DUTY_R.Reg) & 0x7ffff
}

// LEDC.CH4_CONF0: Configuration register 0 for channel %s
func (o *LEDC_Type) SetCH4_CONF0_TIMER_SEL_CH0(value uint32) {
	volatile.StoreUint32(&o.CH4_CONF0.Reg, volatile.LoadUint32(&o.CH4_CONF0.Reg)&^(0x3)|value)
}
func (o *LEDC_Type) GetCH4_CONF0_TIMER_SEL_CH0() uint32 {
	return volatile.LoadUint32(&o.CH4_CONF0.Reg) & 0x3
}
func (o *LEDC_Type) SetCH4_CONF0_SIG_OUT_EN_CH0(value uint32) {
	volatile.StoreUint32(&o.CH4_CONF0.Reg, volatile.LoadUint32(&o.CH4_CONF0.Reg)&^(0x4)|value<<2)
}
func (o *LEDC_Type) GetCH4_CONF0_SIG_OUT_EN_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH4_CONF0.Reg) & 0x4) >> 2
}
func (o *LEDC_Type) SetCH4_CONF0_IDLE_LV_CH0(value uint32) {
	volatile.StoreUint32(&o.CH4_CONF0.Reg, volatile.LoadUint32(&o.CH4_CONF0.Reg)&^(0x8)|value<<3)
}
func (o *LEDC_Type) GetCH4_CONF0_IDLE_LV_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH4_CONF0.Reg) & 0x8) >> 3
}
func (o *LEDC_Type) SetCH4_CONF0_PARA_UP_CH0(value uint32) {
	volatile.StoreUint32(&o.CH4_CONF0.Reg, volatile.LoadUint32(&o.CH4_CONF0.Reg)&^(0x10)|value<<4)
}
func (o *LEDC_Type) GetCH4_CONF0_PARA_UP_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH4_CONF0.Reg) & 0x10) >> 4
}
func (o *LEDC_Type) SetCH4_CONF0_OVF_NUM_CH0(value uint32) {
	volatile.StoreUint32(&o.CH4_CONF0.Reg, volatile.LoadUint32(&o.CH4_CONF0.Reg)&^(0x7fe0)|value<<5)
}
func (o *LEDC_Type) GetCH4_CONF0_OVF_NUM_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH4_CONF0.Reg) & 0x7fe0) >> 5
}
func (o *LEDC_Type) SetCH4_CONF0_OVF_CNT_EN_CH0(value uint32) {
	volatile.StoreUint32(&o.CH4_CONF0.Reg, volatile.LoadUint32(&o.CH4_CONF0.Reg)&^(0x8000)|value<<15)
}
func (o *LEDC_Type) GetCH4_CONF0_OVF_CNT_EN_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH4_CONF0.Reg) & 0x8000) >> 15
}
func (o *LEDC_Type) SetCH4_CONF0_OVF_CNT_RESET_CH0(value uint32) {
	volatile.StoreUint32(&o.CH4_CONF0.Reg, volatile.LoadUint32(&o.CH4_CONF0.Reg)&^(0x10000)|value<<16)
}
func (o *LEDC_Type) GetCH4_CONF0_OVF_CNT_RESET_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH4_CONF0.Reg) & 0x10000) >> 16
}
func (o *LEDC_Type) SetCH4_CONF0_OVF_CNT_RESET_ST_CH0(value uint32) {
	volatile.StoreUint32(&o.CH4_CONF0.Reg, volatile.LoadUint32(&o.CH4_CONF0.Reg)&^(0x20000)|value<<17)
}
func (o *LEDC_Type) GetCH4_CONF0_OVF_CNT_RESET_ST_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH4_CONF0.Reg) & 0x20000) >> 17
}

// LEDC.CH4_HPOINT: High point register for channel %s
func (o *LEDC_Type) SetCH4_HPOINT_HPOINT_CH0(value uint32) {
	volatile.StoreUint32(&o.CH4_HPOINT.Reg, volatile.LoadUint32(&o.CH4_HPOINT.Reg)&^(0x3fff)|value)
}
func (o *LEDC_Type) GetCH4_HPOINT_HPOINT_CH0() uint32 {
	return volatile.LoadUint32(&o.CH4_HPOINT.Reg) & 0x3fff
}

// LEDC.CH4_DUTY: Initial duty cycle for channel %s
func (o *LEDC_Type) SetCH4_DUTY_DUTY_CH0(value uint32) {
	volatile.StoreUint32(&o.CH4_DUTY.Reg, volatile.LoadUint32(&o.CH4_DUTY.Reg)&^(0x7ffff)|value)
}
func (o *LEDC_Type) GetCH4_DUTY_DUTY_CH0() uint32 {
	return volatile.LoadUint32(&o.CH4_DUTY.Reg) & 0x7ffff
}

// LEDC.CH4_CONF1: Configuration register 1 for channel %s
func (o *LEDC_Type) SetCH4_CONF1_DUTY_SCALE_CH0(value uint32) {
	volatile.StoreUint32(&o.CH4_CONF1.Reg, volatile.LoadUint32(&o.CH4_CONF1.Reg)&^(0x3ff)|value)
}
func (o *LEDC_Type) GetCH4_CONF1_DUTY_SCALE_CH0() uint32 {
	return volatile.LoadUint32(&o.CH4_CONF1.Reg) & 0x3ff
}
func (o *LEDC_Type) SetCH4_CONF1_DUTY_CYCLE_CH0(value uint32) {
	volatile.StoreUint32(&o.CH4_CONF1.Reg, volatile.LoadUint32(&o.CH4_CONF1.Reg)&^(0xffc00)|value<<10)
}
func (o *LEDC_Type) GetCH4_CONF1_DUTY_CYCLE_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH4_CONF1.Reg) & 0xffc00) >> 10
}
func (o *LEDC_Type) SetCH4_CONF1_DUTY_NUM_CH0(value uint32) {
	volatile.StoreUint32(&o.CH4_CONF1.Reg, volatile.LoadUint32(&o.CH4_CONF1.Reg)&^(0x3ff00000)|value<<20)
}
func (o *LEDC_Type) GetCH4_CONF1_DUTY_NUM_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH4_CONF1.Reg) & 0x3ff00000) >> 20
}
func (o *LEDC_Type) SetCH4_CONF1_DUTY_INC_CH0(value uint32) {
	volatile.StoreUint32(&o.CH4_CONF1.Reg, volatile.LoadUint32(&o.CH4_CONF1.Reg)&^(0x40000000)|value<<30)
}
func (o *LEDC_Type) GetCH4_CONF1_DUTY_INC_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH4_CONF1.Reg) & 0x40000000) >> 30
}
func (o *LEDC_Type) SetCH4_CONF1_DUTY_START_CH0(value uint32) {
	volatile.StoreUint32(&o.CH4_CONF1.Reg, volatile.LoadUint32(&o.CH4_CONF1.Reg)&^(0x80000000)|value<<31)
}
func (o *LEDC_Type) GetCH4_CONF1_DUTY_START_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH4_CONF1.Reg) & 0x80000000) >> 31
}

// LEDC.CH4_DUTY_R: Current duty cycle for channel %s
func (o *LEDC_Type) SetCH4_DUTY_R_DUTY_R_CH0(value uint32) {
	volatile.StoreUint32(&o.CH4_DUTY_R.Reg, volatile.LoadUint32(&o.CH4_DUTY_R.Reg)&^(0x7ffff)|value)
}
func (o *LEDC_Type) GetCH4_DUTY_R_DUTY_R_CH0() uint32 {
	return volatile.LoadUint32(&o.CH4_DUTY_R.Reg) & 0x7ffff
}

// LEDC.CH5_CONF0: Configuration register 0 for channel %s
func (o *LEDC_Type) SetCH5_CONF0_TIMER_SEL_CH0(value uint32) {
	volatile.StoreUint32(&o.CH5_CONF0.Reg, volatile.LoadUint32(&o.CH5_CONF0.Reg)&^(0x3)|value)
}
func (o *LEDC_Type) GetCH5_CONF0_TIMER_SEL_CH0() uint32 {
	return volatile.LoadUint32(&o.CH5_CONF0.Reg) & 0x3
}
func (o *LEDC_Type) SetCH5_CONF0_SIG_OUT_EN_CH0(value uint32) {
	volatile.StoreUint32(&o.CH5_CONF0.Reg, volatile.LoadUint32(&o.CH5_CONF0.Reg)&^(0x4)|value<<2)
}
func (o *LEDC_Type) GetCH5_CONF0_SIG_OUT_EN_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH5_CONF0.Reg) & 0x4) >> 2
}
func (o *LEDC_Type) SetCH5_CONF0_IDLE_LV_CH0(value uint32) {
	volatile.StoreUint32(&o.CH5_CONF0.Reg, volatile.LoadUint32(&o.CH5_CONF0.Reg)&^(0x8)|value<<3)
}
func (o *LEDC_Type) GetCH5_CONF0_IDLE_LV_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH5_CONF0.Reg) & 0x8) >> 3
}
func (o *LEDC_Type) SetCH5_CONF0_PARA_UP_CH0(value uint32) {
	volatile.StoreUint32(&o.CH5_CONF0.Reg, volatile.LoadUint32(&o.CH5_CONF0.Reg)&^(0x10)|value<<4)
}
func (o *LEDC_Type) GetCH5_CONF0_PARA_UP_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH5_CONF0.Reg) & 0x10) >> 4
}
func (o *LEDC_Type) SetCH5_CONF0_OVF_NUM_CH0(value uint32) {
	volatile.StoreUint32(&o.CH5_CONF0.Reg, volatile.LoadUint32(&o.CH5_CONF0.Reg)&^(0x7fe0)|value<<5)
}
func (o *LEDC_Type) GetCH5_CONF0_OVF_NUM_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH5_CONF0.Reg) & 0x7fe0) >> 5
}
func (o *LEDC_Type) SetCH5_CONF0_OVF_CNT_EN_CH0(value uint32) {
	volatile.StoreUint32(&o.CH5_CONF0.Reg, volatile.LoadUint32(&o.CH5_CONF0.Reg)&^(0x8000)|value<<15)
}
func (o *LEDC_Type) GetCH5_CONF0_OVF_CNT_EN_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH5_CONF0.Reg) & 0x8000) >> 15
}
func (o *LEDC_Type) SetCH5_CONF0_OVF_CNT_RESET_CH0(value uint32) {
	volatile.StoreUint32(&o.CH5_CONF0.Reg, volatile.LoadUint32(&o.CH5_CONF0.Reg)&^(0x10000)|value<<16)
}
func (o *LEDC_Type) GetCH5_CONF0_OVF_CNT_RESET_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH5_CONF0.Reg) & 0x10000) >> 16
}
func (o *LEDC_Type) SetCH5_CONF0_OVF_CNT_RESET_ST_CH0(value uint32) {
	volatile.StoreUint32(&o.CH5_CONF0.Reg, volatile.LoadUint32(&o.CH5_CONF0.Reg)&^(0x20000)|value<<17)
}
func (o *LEDC_Type) GetCH5_CONF0_OVF_CNT_RESET_ST_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH5_CONF0.Reg) & 0x20000) >> 17
}

// LEDC.CH5_HPOINT: High point register for channel %s
func (o *LEDC_Type) SetCH5_HPOINT_HPOINT_CH0(value uint32) {
	volatile.StoreUint32(&o.CH5_HPOINT.Reg, volatile.LoadUint32(&o.CH5_HPOINT.Reg)&^(0x3fff)|value)
}
func (o *LEDC_Type) GetCH5_HPOINT_HPOINT_CH0() uint32 {
	return volatile.LoadUint32(&o.CH5_HPOINT.Reg) & 0x3fff
}

// LEDC.CH5_DUTY: Initial duty cycle for channel %s
func (o *LEDC_Type) SetCH5_DUTY_DUTY_CH0(value uint32) {
	volatile.StoreUint32(&o.CH5_DUTY.Reg, volatile.LoadUint32(&o.CH5_DUTY.Reg)&^(0x7ffff)|value)
}
func (o *LEDC_Type) GetCH5_DUTY_DUTY_CH0() uint32 {
	return volatile.LoadUint32(&o.CH5_DUTY.Reg) & 0x7ffff
}

// LEDC.CH5_CONF1: Configuration register 1 for channel %s
func (o *LEDC_Type) SetCH5_CONF1_DUTY_SCALE_CH0(value uint32) {
	volatile.StoreUint32(&o.CH5_CONF1.Reg, volatile.LoadUint32(&o.CH5_CONF1.Reg)&^(0x3ff)|value)
}
func (o *LEDC_Type) GetCH5_CONF1_DUTY_SCALE_CH0() uint32 {
	return volatile.LoadUint32(&o.CH5_CONF1.Reg) & 0x3ff
}
func (o *LEDC_Type) SetCH5_CONF1_DUTY_CYCLE_CH0(value uint32) {
	volatile.StoreUint32(&o.CH5_CONF1.Reg, volatile.LoadUint32(&o.CH5_CONF1.Reg)&^(0xffc00)|value<<10)
}
func (o *LEDC_Type) GetCH5_CONF1_DUTY_CYCLE_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH5_CONF1.Reg) & 0xffc00) >> 10
}
func (o *LEDC_Type) SetCH5_CONF1_DUTY_NUM_CH0(value uint32) {
	volatile.StoreUint32(&o.CH5_CONF1.Reg, volatile.LoadUint32(&o.CH5_CONF1.Reg)&^(0x3ff00000)|value<<20)
}
func (o *LEDC_Type) GetCH5_CONF1_DUTY_NUM_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH5_CONF1.Reg) & 0x3ff00000) >> 20
}
func (o *LEDC_Type) SetCH5_CONF1_DUTY_INC_CH0(value uint32) {
	volatile.StoreUint32(&o.CH5_CONF1.Reg, volatile.LoadUint32(&o.CH5_CONF1.Reg)&^(0x40000000)|value<<30)
}
func (o *LEDC_Type) GetCH5_CONF1_DUTY_INC_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH5_CONF1.Reg) & 0x40000000) >> 30
}
func (o *LEDC_Type) SetCH5_CONF1_DUTY_START_CH0(value uint32) {
	volatile.StoreUint32(&o.CH5_CONF1.Reg, volatile.LoadUint32(&o.CH5_CONF1.Reg)&^(0x80000000)|value<<31)
}
func (o *LEDC_Type) GetCH5_CONF1_DUTY_START_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH5_CONF1.Reg) & 0x80000000) >> 31
}

// LEDC.CH5_DUTY_R: Current duty cycle for channel %s
func (o *LEDC_Type) SetCH5_DUTY_R_DUTY_R_CH0(value uint32) {
	volatile.StoreUint32(&o.CH5_DUTY_R.Reg, volatile.LoadUint32(&o.CH5_DUTY_R.Reg)&^(0x7ffff)|value)
}
func (o *LEDC_Type) GetCH5_DUTY_R_DUTY_R_CH0() uint32 {
	return volatile.LoadUint32(&o.CH5_DUTY_R.Reg) & 0x7ffff
}

// LEDC.CH6_CONF0: Configuration register 0 for channel %s
func (o *LEDC_Type) SetCH6_CONF0_TIMER_SEL_CH0(value uint32) {
	volatile.StoreUint32(&o.CH6_CONF0.Reg, volatile.LoadUint32(&o.CH6_CONF0.Reg)&^(0x3)|value)
}
func (o *LEDC_Type) GetCH6_CONF0_TIMER_SEL_CH0() uint32 {
	return volatile.LoadUint32(&o.CH6_CONF0.Reg) & 0x3
}
func (o *LEDC_Type) SetCH6_CONF0_SIG_OUT_EN_CH0(value uint32) {
	volatile.StoreUint32(&o.CH6_CONF0.Reg, volatile.LoadUint32(&o.CH6_CONF0.Reg)&^(0x4)|value<<2)
}
func (o *LEDC_Type) GetCH6_CONF0_SIG_OUT_EN_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH6_CONF0.Reg) & 0x4) >> 2
}
func (o *LEDC_Type) SetCH6_CONF0_IDLE_LV_CH0(value uint32) {
	volatile.StoreUint32(&o.CH6_CONF0.Reg, volatile.LoadUint32(&o.CH6_CONF0.Reg)&^(0x8)|value<<3)
}
func (o *LEDC_Type) GetCH6_CONF0_IDLE_LV_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH6_CONF0.Reg) & 0x8) >> 3
}
func (o *LEDC_Type) SetCH6_CONF0_PARA_UP_CH0(value uint32) {
	volatile.StoreUint32(&o.CH6_CONF0.Reg, volatile.LoadUint32(&o.CH6_CONF0.Reg)&^(0x10)|value<<4)
}
func (o *LEDC_Type) GetCH6_CONF0_PARA_UP_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH6_CONF0.Reg) & 0x10) >> 4
}
func (o *LEDC_Type) SetCH6_CONF0_OVF_NUM_CH0(value uint32) {
	volatile.StoreUint32(&o.CH6_CONF0.Reg, volatile.LoadUint32(&o.CH6_CONF0.Reg)&^(0x7fe0)|value<<5)
}
func (o *LEDC_Type) GetCH6_CONF0_OVF_NUM_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH6_CONF0.Reg) & 0x7fe0) >> 5
}
func (o *LEDC_Type) SetCH6_CONF0_OVF_CNT_EN_CH0(value uint32) {
	volatile.StoreUint32(&o.CH6_CONF0.Reg, volatile.LoadUint32(&o.CH6_CONF0.Reg)&^(0x8000)|value<<15)
}
func (o *LEDC_Type) GetCH6_CONF0_OVF_CNT_EN_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH6_CONF0.Reg) & 0x8000) >> 15
}
func (o *LEDC_Type) SetCH6_CONF0_OVF_CNT_RESET_CH0(value uint32) {
	volatile.StoreUint32(&o.CH6_CONF0.Reg, volatile.LoadUint32(&o.CH6_CONF0.Reg)&^(0x10000)|value<<16)
}
func (o *LEDC_Type) GetCH6_CONF0_OVF_CNT_RESET_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH6_CONF0.Reg) & 0x10000) >> 16
}
func (o *LEDC_Type) SetCH6_CONF0_OVF_CNT_RESET_ST_CH0(value uint32) {
	volatile.StoreUint32(&o.CH6_CONF0.Reg, volatile.LoadUint32(&o.CH6_CONF0.Reg)&^(0x20000)|value<<17)
}
func (o *LEDC_Type) GetCH6_CONF0_OVF_CNT_RESET_ST_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH6_CONF0.Reg) & 0x20000) >> 17
}

// LEDC.CH6_HPOINT: High point register for channel %s
func (o *LEDC_Type) SetCH6_HPOINT_HPOINT_CH0(value uint32) {
	volatile.StoreUint32(&o.CH6_HPOINT.Reg, volatile.LoadUint32(&o.CH6_HPOINT.Reg)&^(0x3fff)|value)
}
func (o *LEDC_Type) GetCH6_HPOINT_HPOINT_CH0() uint32 {
	return volatile.LoadUint32(&o.CH6_HPOINT.Reg) & 0x3fff
}

// LEDC.CH6_DUTY: Initial duty cycle for channel %s
func (o *LEDC_Type) SetCH6_DUTY_DUTY_CH0(value uint32) {
	volatile.StoreUint32(&o.CH6_DUTY.Reg, volatile.LoadUint32(&o.CH6_DUTY.Reg)&^(0x7ffff)|value)
}
func (o *LEDC_Type) GetCH6_DUTY_DUTY_CH0() uint32 {
	return volatile.LoadUint32(&o.CH6_DUTY.Reg) & 0x7ffff
}

// LEDC.CH6_CONF1: Configuration register 1 for channel %s
func (o *LEDC_Type) SetCH6_CONF1_DUTY_SCALE_CH0(value uint32) {
	volatile.StoreUint32(&o.CH6_CONF1.Reg, volatile.LoadUint32(&o.CH6_CONF1.Reg)&^(0x3ff)|value)
}
func (o *LEDC_Type) GetCH6_CONF1_DUTY_SCALE_CH0() uint32 {
	return volatile.LoadUint32(&o.CH6_CONF1.Reg) & 0x3ff
}
func (o *LEDC_Type) SetCH6_CONF1_DUTY_CYCLE_CH0(value uint32) {
	volatile.StoreUint32(&o.CH6_CONF1.Reg, volatile.LoadUint32(&o.CH6_CONF1.Reg)&^(0xffc00)|value<<10)
}
func (o *LEDC_Type) GetCH6_CONF1_DUTY_CYCLE_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH6_CONF1.Reg) & 0xffc00) >> 10
}
func (o *LEDC_Type) SetCH6_CONF1_DUTY_NUM_CH0(value uint32) {
	volatile.StoreUint32(&o.CH6_CONF1.Reg, volatile.LoadUint32(&o.CH6_CONF1.Reg)&^(0x3ff00000)|value<<20)
}
func (o *LEDC_Type) GetCH6_CONF1_DUTY_NUM_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH6_CONF1.Reg) & 0x3ff00000) >> 20
}
func (o *LEDC_Type) SetCH6_CONF1_DUTY_INC_CH0(value uint32) {
	volatile.StoreUint32(&o.CH6_CONF1.Reg, volatile.LoadUint32(&o.CH6_CONF1.Reg)&^(0x40000000)|value<<30)
}
func (o *LEDC_Type) GetCH6_CONF1_DUTY_INC_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH6_CONF1.Reg) & 0x40000000) >> 30
}
func (o *LEDC_Type) SetCH6_CONF1_DUTY_START_CH0(value uint32) {
	volatile.StoreUint32(&o.CH6_CONF1.Reg, volatile.LoadUint32(&o.CH6_CONF1.Reg)&^(0x80000000)|value<<31)
}
func (o *LEDC_Type) GetCH6_CONF1_DUTY_START_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH6_CONF1.Reg) & 0x80000000) >> 31
}

// LEDC.CH6_DUTY_R: Current duty cycle for channel %s
func (o *LEDC_Type) SetCH6_DUTY_R_DUTY_R_CH0(value uint32) {
	volatile.StoreUint32(&o.CH6_DUTY_R.Reg, volatile.LoadUint32(&o.CH6_DUTY_R.Reg)&^(0x7ffff)|value)
}
func (o *LEDC_Type) GetCH6_DUTY_R_DUTY_R_CH0() uint32 {
	return volatile.LoadUint32(&o.CH6_DUTY_R.Reg) & 0x7ffff
}

// LEDC.CH7_CONF0: Configuration register 0 for channel %s
func (o *LEDC_Type) SetCH7_CONF0_TIMER_SEL_CH0(value uint32) {
	volatile.StoreUint32(&o.CH7_CONF0.Reg, volatile.LoadUint32(&o.CH7_CONF0.Reg)&^(0x3)|value)
}
func (o *LEDC_Type) GetCH7_CONF0_TIMER_SEL_CH0() uint32 {
	return volatile.LoadUint32(&o.CH7_CONF0.Reg) & 0x3
}
func (o *LEDC_Type) SetCH7_CONF0_SIG_OUT_EN_CH0(value uint32) {
	volatile.StoreUint32(&o.CH7_CONF0.Reg, volatile.LoadUint32(&o.CH7_CONF0.Reg)&^(0x4)|value<<2)
}
func (o *LEDC_Type) GetCH7_CONF0_SIG_OUT_EN_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH7_CONF0.Reg) & 0x4) >> 2
}
func (o *LEDC_Type) SetCH7_CONF0_IDLE_LV_CH0(value uint32) {
	volatile.StoreUint32(&o.CH7_CONF0.Reg, volatile.LoadUint32(&o.CH7_CONF0.Reg)&^(0x8)|value<<3)
}
func (o *LEDC_Type) GetCH7_CONF0_IDLE_LV_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH7_CONF0.Reg) & 0x8) >> 3
}
func (o *LEDC_Type) SetCH7_CONF0_PARA_UP_CH0(value uint32) {
	volatile.StoreUint32(&o.CH7_CONF0.Reg, volatile.LoadUint32(&o.CH7_CONF0.Reg)&^(0x10)|value<<4)
}
func (o *LEDC_Type) GetCH7_CONF0_PARA_UP_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH7_CONF0.Reg) & 0x10) >> 4
}
func (o *LEDC_Type) SetCH7_CONF0_OVF_NUM_CH0(value uint32) {
	volatile.StoreUint32(&o.CH7_CONF0.Reg, volatile.LoadUint32(&o.CH7_CONF0.Reg)&^(0x7fe0)|value<<5)
}
func (o *LEDC_Type) GetCH7_CONF0_OVF_NUM_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH7_CONF0.Reg) & 0x7fe0) >> 5
}
func (o *LEDC_Type) SetCH7_CONF0_OVF_CNT_EN_CH0(value uint32) {
	volatile.StoreUint32(&o.CH7_CONF0.Reg, volatile.LoadUint32(&o.CH7_CONF0.Reg)&^(0x8000)|value<<15)
}
func (o *LEDC_Type) GetCH7_CONF0_OVF_CNT_EN_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH7_CONF0.Reg) & 0x8000) >> 15
}
func (o *LEDC_Type) SetCH7_CONF0_OVF_CNT_RESET_CH0(value uint32) {
	volatile.StoreUint32(&o.CH7_CONF0.Reg, volatile.LoadUint32(&o.CH7_CONF0.Reg)&^(0x10000)|value<<16)
}
func (o *LEDC_Type) GetCH7_CONF0_OVF_CNT_RESET_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH7_CONF0.Reg) & 0x10000) >> 16
}
func (o *LEDC_Type) SetCH7_CONF0_OVF_CNT_RESET_ST_CH0(value uint32) {
	volatile.StoreUint32(&o.CH7_CONF0.Reg, volatile.LoadUint32(&o.CH7_CONF0.Reg)&^(0x20000)|value<<17)
}
func (o *LEDC_Type) GetCH7_CONF0_OVF_CNT_RESET_ST_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH7_CONF0.Reg) & 0x20000) >> 17
}

// LEDC.CH7_HPOINT: High point register for channel %s
func (o *LEDC_Type) SetCH7_HPOINT_HPOINT_CH0(value uint32) {
	volatile.StoreUint32(&o.CH7_HPOINT.Reg, volatile.LoadUint32(&o.CH7_HPOINT.Reg)&^(0x3fff)|value)
}
func (o *LEDC_Type) GetCH7_HPOINT_HPOINT_CH0() uint32 {
	return volatile.LoadUint32(&o.CH7_HPOINT.Reg) & 0x3fff
}

// LEDC.CH7_DUTY: Initial duty cycle for channel %s
func (o *LEDC_Type) SetCH7_DUTY_DUTY_CH0(value uint32) {
	volatile.StoreUint32(&o.CH7_DUTY.Reg, volatile.LoadUint32(&o.CH7_DUTY.Reg)&^(0x7ffff)|value)
}
func (o *LEDC_Type) GetCH7_DUTY_DUTY_CH0() uint32 {
	return volatile.LoadUint32(&o.CH7_DUTY.Reg) & 0x7ffff
}

// LEDC.CH7_CONF1: Configuration register 1 for channel %s
func (o *LEDC_Type) SetCH7_CONF1_DUTY_SCALE_CH0(value uint32) {
	volatile.StoreUint32(&o.CH7_CONF1.Reg, volatile.LoadUint32(&o.CH7_CONF1.Reg)&^(0x3ff)|value)
}
func (o *LEDC_Type) GetCH7_CONF1_DUTY_SCALE_CH0() uint32 {
	return volatile.LoadUint32(&o.CH7_CONF1.Reg) & 0x3ff
}
func (o *LEDC_Type) SetCH7_CONF1_DUTY_CYCLE_CH0(value uint32) {
	volatile.StoreUint32(&o.CH7_CONF1.Reg, volatile.LoadUint32(&o.CH7_CONF1.Reg)&^(0xffc00)|value<<10)
}
func (o *LEDC_Type) GetCH7_CONF1_DUTY_CYCLE_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH7_CONF1.Reg) & 0xffc00) >> 10
}
func (o *LEDC_Type) SetCH7_CONF1_DUTY_NUM_CH0(value uint32) {
	volatile.StoreUint32(&o.CH7_CONF1.Reg, volatile.LoadUint32(&o.CH7_CONF1.Reg)&^(0x3ff00000)|value<<20)
}
func (o *LEDC_Type) GetCH7_CONF1_DUTY_NUM_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH7_CONF1.Reg) & 0x3ff00000) >> 20
}
func (o *LEDC_Type) SetCH7_CONF1_DUTY_INC_CH0(value uint32) {
	volatile.StoreUint32(&o.CH7_CONF1.Reg, volatile.LoadUint32(&o.CH7_CONF1.Reg)&^(0x40000000)|value<<30)
}
func (o *LEDC_Type) GetCH7_CONF1_DUTY_INC_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH7_CONF1.Reg) & 0x40000000) >> 30
}
func (o *LEDC_Type) SetCH7_CONF1_DUTY_START_CH0(value uint32) {
	volatile.StoreUint32(&o.CH7_CONF1.Reg, volatile.LoadUint32(&o.CH7_CONF1.Reg)&^(0x80000000)|value<<31)
}
func (o *LEDC_Type) GetCH7_CONF1_DUTY_START_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH7_CONF1.Reg) & 0x80000000) >> 31
}

// LEDC.CH7_DUTY_R: Current duty cycle for channel %s
func (o *LEDC_Type) SetCH7_DUTY_R_DUTY_R_CH0(value uint32) {
	volatile.StoreUint32(&o.CH7_DUTY_R.Reg, volatile.LoadUint32(&o.CH7_DUTY_R.Reg)&^(0x7ffff)|value)
}
func (o *LEDC_Type) GetCH7_DUTY_R_DUTY_R_CH0() uint32 {
	return volatile.LoadUint32(&o.CH7_DUTY_R.Reg) & 0x7ffff
}

// LEDC.TIMER0_CONF: Timer %s configuration
func (o *LEDC_Type) SetTIMER0_CONF_TIMER0_DUTY_RES(value uint32) {
	volatile.StoreUint32(&o.TIMER0_CONF.Reg, volatile.LoadUint32(&o.TIMER0_CONF.Reg)&^(0xf)|value)
}
func (o *LEDC_Type) GetTIMER0_CONF_TIMER0_DUTY_RES() uint32 {
	return volatile.LoadUint32(&o.TIMER0_CONF.Reg) & 0xf
}
func (o *LEDC_Type) SetTIMER0_CONF_CLK_DIV_TIMER0(value uint32) {
	volatile.StoreUint32(&o.TIMER0_CONF.Reg, volatile.LoadUint32(&o.TIMER0_CONF.Reg)&^(0x3ffff0)|value<<4)
}
func (o *LEDC_Type) GetTIMER0_CONF_CLK_DIV_TIMER0() uint32 {
	return (volatile.LoadUint32(&o.TIMER0_CONF.Reg) & 0x3ffff0) >> 4
}
func (o *LEDC_Type) SetTIMER0_CONF_TIMER0_PAUSE(value uint32) {
	volatile.StoreUint32(&o.TIMER0_CONF.Reg, volatile.LoadUint32(&o.TIMER0_CONF.Reg)&^(0x400000)|value<<22)
}
func (o *LEDC_Type) GetTIMER0_CONF_TIMER0_PAUSE() uint32 {
	return (volatile.LoadUint32(&o.TIMER0_CONF.Reg) & 0x400000) >> 22
}
func (o *LEDC_Type) SetTIMER0_CONF_TIMER0_RST(value uint32) {
	volatile.StoreUint32(&o.TIMER0_CONF.Reg, volatile.LoadUint32(&o.TIMER0_CONF.Reg)&^(0x800000)|value<<23)
}
func (o *LEDC_Type) GetTIMER0_CONF_TIMER0_RST() uint32 {
	return (volatile.LoadUint32(&o.TIMER0_CONF.Reg) & 0x800000) >> 23
}
func (o *LEDC_Type) SetTIMER0_CONF_TICK_SEL_TIMER0(value uint32) {
	volatile.StoreUint32(&o.TIMER0_CONF.Reg, volatile.LoadUint32(&o.TIMER0_CONF.Reg)&^(0x1000000)|value<<24)
}
func (o *LEDC_Type) GetTIMER0_CONF_TICK_SEL_TIMER0() uint32 {
	return (volatile.LoadUint32(&o.TIMER0_CONF.Reg) & 0x1000000) >> 24
}
func (o *LEDC_Type) SetTIMER0_CONF_TIMER0_PARA_UP(value uint32) {
	volatile.StoreUint32(&o.TIMER0_CONF.Reg, volatile.LoadUint32(&o.TIMER0_CONF.Reg)&^(0x2000000)|value<<25)
}
func (o *LEDC_Type) GetTIMER0_CONF_TIMER0_PARA_UP() uint32 {
	return (volatile.LoadUint32(&o.TIMER0_CONF.Reg) & 0x2000000) >> 25
}

// LEDC.TIMER0_VALUE: Timer %s current counter value
func (o *LEDC_Type) SetTIMER0_VALUE_TIMER0_CNT(value uint32) {
	volatile.StoreUint32(&o.TIMER0_VALUE.Reg, volatile.LoadUint32(&o.TIMER0_VALUE.Reg)&^(0x3fff)|value)
}
func (o *LEDC_Type) GetTIMER0_VALUE_TIMER0_CNT() uint32 {
	return volatile.LoadUint32(&o.TIMER0_VALUE.Reg) & 0x3fff
}

// LEDC.TIMER1_CONF: Timer %s configuration
func (o *LEDC_Type) SetTIMER1_CONF_TIMER0_DUTY_RES(value uint32) {
	volatile.StoreUint32(&o.TIMER1_CONF.Reg, volatile.LoadUint32(&o.TIMER1_CONF.Reg)&^(0xf)|value)
}
func (o *LEDC_Type) GetTIMER1_CONF_TIMER0_DUTY_RES() uint32 {
	return volatile.LoadUint32(&o.TIMER1_CONF.Reg) & 0xf
}
func (o *LEDC_Type) SetTIMER1_CONF_CLK_DIV_TIMER0(value uint32) {
	volatile.StoreUint32(&o.TIMER1_CONF.Reg, volatile.LoadUint32(&o.TIMER1_CONF.Reg)&^(0x3ffff0)|value<<4)
}
func (o *LEDC_Type) GetTIMER1_CONF_CLK_DIV_TIMER0() uint32 {
	return (volatile.LoadUint32(&o.TIMER1_CONF.Reg) & 0x3ffff0) >> 4
}
func (o *LEDC_Type) SetTIMER1_CONF_TIMER0_PAUSE(value uint32) {
	volatile.StoreUint32(&o.TIMER1_CONF.Reg, volatile.LoadUint32(&o.TIMER1_CONF.Reg)&^(0x400000)|value<<22)
}
func (o *LEDC_Type) GetTIMER1_CONF_TIMER0_PAUSE() uint32 {
	return (volatile.LoadUint32(&o.TIMER1_CONF.Reg) & 0x400000) >> 22
}
func (o *LEDC_Type) SetTIMER1_CONF_TIMER0_RST(value uint32) {
	volatile.StoreUint32(&o.TIMER1_CONF.Reg, volatile.LoadUint32(&o.TIMER1_CONF.Reg)&^(0x800000)|value<<23)
}
func (o *LEDC_Type) GetTIMER1_CONF_TIMER0_RST() uint32 {
	return (volatile.LoadUint32(&o.TIMER1_CONF.Reg) & 0x800000) >> 23
}
func (o *LEDC_Type) SetTIMER1_CONF_TICK_SEL_TIMER0(value uint32) {
	volatile.StoreUint32(&o.TIMER1_CONF.Reg, volatile.LoadUint32(&o.TIMER1_CONF.Reg)&^(0x1000000)|value<<24)
}
func (o *LEDC_Type) GetTIMER1_CONF_TICK_SEL_TIMER0() uint32 {
	return (volatile.LoadUint32(&o.TIMER1_CONF.Reg) & 0x1000000) >> 24
}
func (o *LEDC_Type) SetTIMER1_CONF_TIMER0_PARA_UP(value uint32) {
	volatile.StoreUint32(&o.TIMER1_CONF.Reg, volatile.LoadUint32(&o.TIMER1_CONF.Reg)&^(0x2000000)|value<<25)
}
func (o *LEDC_Type) GetTIMER1_CONF_TIMER0_PARA_UP() uint32 {
	return (volatile.LoadUint32(&o.TIMER1_CONF.Reg) & 0x2000000) >> 25
}

// LEDC.TIMER1_VALUE: Timer %s current counter value
func (o *LEDC_Type) SetTIMER1_VALUE_TIMER0_CNT(value uint32) {
	volatile.StoreUint32(&o.TIMER1_VALUE.Reg, volatile.LoadUint32(&o.TIMER1_VALUE.Reg)&^(0x3fff)|value)
}
func (o *LEDC_Type) GetTIMER1_VALUE_TIMER0_CNT() uint32 {
	return volatile.LoadUint32(&o.TIMER1_VALUE.Reg) & 0x3fff
}

// LEDC.TIMER2_CONF: Timer %s configuration
func (o *LEDC_Type) SetTIMER2_CONF_TIMER0_DUTY_RES(value uint32) {
	volatile.StoreUint32(&o.TIMER2_CONF.Reg, volatile.LoadUint32(&o.TIMER2_CONF.Reg)&^(0xf)|value)
}
func (o *LEDC_Type) GetTIMER2_CONF_TIMER0_DUTY_RES() uint32 {
	return volatile.LoadUint32(&o.TIMER2_CONF.Reg) & 0xf
}
func (o *LEDC_Type) SetTIMER2_CONF_CLK_DIV_TIMER0(value uint32) {
	volatile.StoreUint32(&o.TIMER2_CONF.Reg, volatile.LoadUint32(&o.TIMER2_CONF.Reg)&^(0x3ffff0)|value<<4)
}
func (o *LEDC_Type) GetTIMER2_CONF_CLK_DIV_TIMER0() uint32 {
	return (volatile.LoadUint32(&o.TIMER2_CONF.Reg) & 0x3ffff0) >> 4
}
func (o *LEDC_Type) SetTIMER2_CONF_TIMER0_PAUSE(value uint32) {
	volatile.StoreUint32(&o.TIMER2_CONF.Reg, volatile.LoadUint32(&o.TIMER2_CONF.Reg)&^(0x400000)|value<<22)
}
func (o *LEDC_Type) GetTIMER2_CONF_TIMER0_PAUSE() uint32 {
	return (volatile.LoadUint32(&o.TIMER2_CONF.Reg) & 0x400000) >> 22
}
func (o *LEDC_Type) SetTIMER2_CONF_TIMER0_RST(value uint32) {
	volatile.StoreUint32(&o.TIMER2_CONF.Reg, volatile.LoadUint32(&o.TIMER2_CONF.Reg)&^(0x800000)|value<<23)
}
func (o *LEDC_Type) GetTIMER2_CONF_TIMER0_RST() uint32 {
	return (volatile.LoadUint32(&o.TIMER2_CONF.Reg) & 0x800000) >> 23
}
func (o *LEDC_Type) SetTIMER2_CONF_TICK_SEL_TIMER0(value uint32) {
	volatile.StoreUint32(&o.TIMER2_CONF.Reg, volatile.LoadUint32(&o.TIMER2_CONF.Reg)&^(0x1000000)|value<<24)
}
func (o *LEDC_Type) GetTIMER2_CONF_TICK_SEL_TIMER0() uint32 {
	return (volatile.LoadUint32(&o.TIMER2_CONF.Reg) & 0x1000000) >> 24
}
func (o *LEDC_Type) SetTIMER2_CONF_TIMER0_PARA_UP(value uint32) {
	volatile.StoreUint32(&o.TIMER2_CONF.Reg, volatile.LoadUint32(&o.TIMER2_CONF.Reg)&^(0x2000000)|value<<25)
}
func (o *LEDC_Type) GetTIMER2_CONF_TIMER0_PARA_UP() uint32 {
	return (volatile.LoadUint32(&o.TIMER2_CONF.Reg) & 0x2000000) >> 25
}

// LEDC.TIMER2_VALUE: Timer %s current counter value
func (o *LEDC_Type) SetTIMER2_VALUE_TIMER0_CNT(value uint32) {
	volatile.StoreUint32(&o.TIMER2_VALUE.Reg, volatile.LoadUint32(&o.TIMER2_VALUE.Reg)&^(0x3fff)|value)
}
func (o *LEDC_Type) GetTIMER2_VALUE_TIMER0_CNT() uint32 {
	return volatile.LoadUint32(&o.TIMER2_VALUE.Reg) & 0x3fff
}

// LEDC.TIMER3_CONF: Timer %s configuration
func (o *LEDC_Type) SetTIMER3_CONF_TIMER0_DUTY_RES(value uint32) {
	volatile.StoreUint32(&o.TIMER3_CONF.Reg, volatile.LoadUint32(&o.TIMER3_CONF.Reg)&^(0xf)|value)
}
func (o *LEDC_Type) GetTIMER3_CONF_TIMER0_DUTY_RES() uint32 {
	return volatile.LoadUint32(&o.TIMER3_CONF.Reg) & 0xf
}
func (o *LEDC_Type) SetTIMER3_CONF_CLK_DIV_TIMER0(value uint32) {
	volatile.StoreUint32(&o.TIMER3_CONF.Reg, volatile.LoadUint32(&o.TIMER3_CONF.Reg)&^(0x3ffff0)|value<<4)
}
func (o *LEDC_Type) GetTIMER3_CONF_CLK_DIV_TIMER0() uint32 {
	return (volatile.LoadUint32(&o.TIMER3_CONF.Reg) & 0x3ffff0) >> 4
}
func (o *LEDC_Type) SetTIMER3_CONF_TIMER0_PAUSE(value uint32) {
	volatile.StoreUint32(&o.TIMER3_CONF.Reg, volatile.LoadUint32(&o.TIMER3_CONF.Reg)&^(0x400000)|value<<22)
}
func (o *LEDC_Type) GetTIMER3_CONF_TIMER0_PAUSE() uint32 {
	return (volatile.LoadUint32(&o.TIMER3_CONF.Reg) & 0x400000) >> 22
}
func (o *LEDC_Type) SetTIMER3_CONF_TIMER0_RST(value uint32) {
	volatile.StoreUint32(&o.TIMER3_CONF.Reg, volatile.LoadUint32(&o.TIMER3_CONF.Reg)&^(0x800000)|value<<23)
}
func (o *LEDC_Type) GetTIMER3_CONF_TIMER0_RST() uint32 {
	return (volatile.LoadUint32(&o.TIMER3_CONF.Reg) & 0x800000) >> 23
}
func (o *LEDC_Type) SetTIMER3_CONF_TICK_SEL_TIMER0(value uint32) {
	volatile.StoreUint32(&o.TIMER3_CONF.Reg, volatile.LoadUint32(&o.TIMER3_CONF.Reg)&^(0x1000000)|value<<24)
}
func (o *LEDC_Type) GetTIMER3_CONF_TICK_SEL_TIMER0() uint32 {
	return (volatile.LoadUint32(&o.TIMER3_CONF.Reg) & 0x1000000) >> 24
}
func (o *LEDC_Type) SetTIMER3_CONF_TIMER0_PARA_UP(value uint32) {
	volatile.StoreUint32(&o.TIMER3_CONF.Reg, volatile.LoadUint32(&o.TIMER3_CONF.Reg)&^(0x2000000)|value<<25)
}
func (o *LEDC_Type) GetTIMER3_CONF_TIMER0_PARA_UP() uint32 {
	return (volatile.LoadUint32(&o.TIMER3_CONF.Reg) & 0x2000000) >> 25
}

// LEDC.TIMER3_VALUE: Timer %s current counter value
func (o *LEDC_Type) SetTIMER3_VALUE_TIMER0_CNT(value uint32) {
	volatile.StoreUint32(&o.TIMER3_VALUE.Reg, volatile.LoadUint32(&o.TIMER3_VALUE.Reg)&^(0x3fff)|value)
}
func (o *LEDC_Type) GetTIMER3_VALUE_TIMER0_CNT() uint32 {
	return volatile.LoadUint32(&o.TIMER3_VALUE.Reg) & 0x3fff
}

// LEDC.INT_RAW: Raw interrupt status
func (o *LEDC_Type) SetINT_RAW_TIMER0_OVF_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x1)|value)
}
func (o *LEDC_Type) GetINT_RAW_TIMER0_OVF_INT_RAW() uint32 {
	return volatile.LoadUint32(&o.INT_RAW.Reg) & 0x1
}
func (o *LEDC_Type) SetINT_RAW_TIMER1_OVF_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x2)|value<<1)
}
func (o *LEDC_Type) GetINT_RAW_TIMER1_OVF_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x2) >> 1
}
func (o *LEDC_Type) SetINT_RAW_TIMER2_OVF_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x4)|value<<2)
}
func (o *LEDC_Type) GetINT_RAW_TIMER2_OVF_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x4) >> 2
}
func (o *LEDC_Type) SetINT_RAW_TIMER3_OVF_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x8)|value<<3)
}
func (o *LEDC_Type) GetINT_RAW_TIMER3_OVF_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x8) >> 3
}
func (o *LEDC_Type) SetINT_RAW_DUTY_CHNG_END_CH0_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x10)|value<<4)
}
func (o *LEDC_Type) GetINT_RAW_DUTY_CHNG_END_CH0_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x10) >> 4
}
func (o *LEDC_Type) SetINT_RAW_DUTY_CHNG_END_CH1_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x20)|value<<5)
}
func (o *LEDC_Type) GetINT_RAW_DUTY_CHNG_END_CH1_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x20) >> 5
}
func (o *LEDC_Type) SetINT_RAW_DUTY_CHNG_END_CH2_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x40)|value<<6)
}
func (o *LEDC_Type) GetINT_RAW_DUTY_CHNG_END_CH2_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x40) >> 6
}
func (o *LEDC_Type) SetINT_RAW_DUTY_CHNG_END_CH3_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x80)|value<<7)
}
func (o *LEDC_Type) GetINT_RAW_DUTY_CHNG_END_CH3_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x80) >> 7
}
func (o *LEDC_Type) SetINT_RAW_DUTY_CHNG_END_CH4_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x100)|value<<8)
}
func (o *LEDC_Type) GetINT_RAW_DUTY_CHNG_END_CH4_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x100) >> 8
}
func (o *LEDC_Type) SetINT_RAW_DUTY_CHNG_END_CH5_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x200)|value<<9)
}
func (o *LEDC_Type) GetINT_RAW_DUTY_CHNG_END_CH5_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x200) >> 9
}
func (o *LEDC_Type) SetINT_RAW_DUTY_CHNG_END_CH6_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x400)|value<<10)
}
func (o *LEDC_Type) GetINT_RAW_DUTY_CHNG_END_CH6_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x400) >> 10
}
func (o *LEDC_Type) SetINT_RAW_DUTY_CHNG_END_CH7_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x800)|value<<11)
}
func (o *LEDC_Type) GetINT_RAW_DUTY_CHNG_END_CH7_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x800) >> 11
}
func (o *LEDC_Type) SetINT_RAW_OVF_CNT_CH0_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x1000)|value<<12)
}
func (o *LEDC_Type) GetINT_RAW_OVF_CNT_CH0_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x1000) >> 12
}
func (o *LEDC_Type) SetINT_RAW_OVF_CNT_CH1_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x2000)|value<<13)
}
func (o *LEDC_Type) GetINT_RAW_OVF_CNT_CH1_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x2000) >> 13
}
func (o *LEDC_Type) SetINT_RAW_OVF_CNT_CH2_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x4000)|value<<14)
}
func (o *LEDC_Type) GetINT_RAW_OVF_CNT_CH2_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x4000) >> 14
}
func (o *LEDC_Type) SetINT_RAW_OVF_CNT_CH3_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x8000)|value<<15)
}
func (o *LEDC_Type) GetINT_RAW_OVF_CNT_CH3_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x8000) >> 15
}
func (o *LEDC_Type) SetINT_RAW_OVF_CNT_CH4_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x10000)|value<<16)
}
func (o *LEDC_Type) GetINT_RAW_OVF_CNT_CH4_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x10000) >> 16
}
func (o *LEDC_Type) SetINT_RAW_OVF_CNT_CH5_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x20000)|value<<17)
}
func (o *LEDC_Type) GetINT_RAW_OVF_CNT_CH5_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x20000) >> 17
}
func (o *LEDC_Type) SetINT_RAW_OVF_CNT_CH6_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x40000)|value<<18)
}
func (o *LEDC_Type) GetINT_RAW_OVF_CNT_CH6_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x40000) >> 18
}
func (o *LEDC_Type) SetINT_RAW_OVF_CNT_CH7_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x80000)|value<<19)
}
func (o *LEDC_Type) GetINT_RAW_OVF_CNT_CH7_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x80000) >> 19
}

// LEDC.INT_ST: Masked interrupt status
func (o *LEDC_Type) SetINT_ST_TIMER0_OVF_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x1)|value)
}
func (o *LEDC_Type) GetINT_ST_TIMER0_OVF_INT_ST() uint32 {
	return volatile.LoadUint32(&o.INT_ST.Reg) & 0x1
}
func (o *LEDC_Type) SetINT_ST_TIMER1_OVF_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x2)|value<<1)
}
func (o *LEDC_Type) GetINT_ST_TIMER1_OVF_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x2) >> 1
}
func (o *LEDC_Type) SetINT_ST_TIMER2_OVF_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x4)|value<<2)
}
func (o *LEDC_Type) GetINT_ST_TIMER2_OVF_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x4) >> 2
}
func (o *LEDC_Type) SetINT_ST_TIMER3_OVF_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x8)|value<<3)
}
func (o *LEDC_Type) GetINT_ST_TIMER3_OVF_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x8) >> 3
}
func (o *LEDC_Type) SetINT_ST_DUTY_CHNG_END_CH0_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x10)|value<<4)
}
func (o *LEDC_Type) GetINT_ST_DUTY_CHNG_END_CH0_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x10) >> 4
}
func (o *LEDC_Type) SetINT_ST_DUTY_CHNG_END_CH1_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x20)|value<<5)
}
func (o *LEDC_Type) GetINT_ST_DUTY_CHNG_END_CH1_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x20) >> 5
}
func (o *LEDC_Type) SetINT_ST_DUTY_CHNG_END_CH2_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x40)|value<<6)
}
func (o *LEDC_Type) GetINT_ST_DUTY_CHNG_END_CH2_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x40) >> 6
}
func (o *LEDC_Type) SetINT_ST_DUTY_CHNG_END_CH3_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x80)|value<<7)
}
func (o *LEDC_Type) GetINT_ST_DUTY_CHNG_END_CH3_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x80) >> 7
}
func (o *LEDC_Type) SetINT_ST_DUTY_CHNG_END_CH4_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x100)|value<<8)
}
func (o *LEDC_Type) GetINT_ST_DUTY_CHNG_END_CH4_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x100) >> 8
}
func (o *LEDC_Type) SetINT_ST_DUTY_CHNG_END_CH5_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x200)|value<<9)
}
func (o *LEDC_Type) GetINT_ST_DUTY_CHNG_END_CH5_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x200) >> 9
}
func (o *LEDC_Type) SetINT_ST_DUTY_CHNG_END_CH6_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x400)|value<<10)
}
func (o *LEDC_Type) GetINT_ST_DUTY_CHNG_END_CH6_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x400) >> 10
}
func (o *LEDC_Type) SetINT_ST_DUTY_CHNG_END_CH7_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x800)|value<<11)
}
func (o *LEDC_Type) GetINT_ST_DUTY_CHNG_END_CH7_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x800) >> 11
}
func (o *LEDC_Type) SetINT_ST_OVF_CNT_CH0_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x1000)|value<<12)
}
func (o *LEDC_Type) GetINT_ST_OVF_CNT_CH0_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x1000) >> 12
}
func (o *LEDC_Type) SetINT_ST_OVF_CNT_CH1_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x2000)|value<<13)
}
func (o *LEDC_Type) GetINT_ST_OVF_CNT_CH1_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x2000) >> 13
}
func (o *LEDC_Type) SetINT_ST_OVF_CNT_CH2_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x4000)|value<<14)
}
func (o *LEDC_Type) GetINT_ST_OVF_CNT_CH2_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x4000) >> 14
}
func (o *LEDC_Type) SetINT_ST_OVF_CNT_CH3_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x8000)|value<<15)
}
func (o *LEDC_Type) GetINT_ST_OVF_CNT_CH3_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x8000) >> 15
}
func (o *LEDC_Type) SetINT_ST_OVF_CNT_CH4_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x10000)|value<<16)
}
func (o *LEDC_Type) GetINT_ST_OVF_CNT_CH4_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x10000) >> 16
}
func (o *LEDC_Type) SetINT_ST_OVF_CNT_CH5_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x20000)|value<<17)
}
func (o *LEDC_Type) GetINT_ST_OVF_CNT_CH5_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x20000) >> 17
}
func (o *LEDC_Type) SetINT_ST_OVF_CNT_CH6_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x40000)|value<<18)
}
func (o *LEDC_Type) GetINT_ST_OVF_CNT_CH6_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x40000) >> 18
}
func (o *LEDC_Type) SetINT_ST_OVF_CNT_CH7_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x80000)|value<<19)
}
func (o *LEDC_Type) GetINT_ST_OVF_CNT_CH7_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x80000) >> 19
}

// LEDC.INT_ENA: Interrupt enable bits
func (o *LEDC_Type) SetINT_ENA_TIMER0_OVF_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x1)|value)
}
func (o *LEDC_Type) GetINT_ENA_TIMER0_OVF_INT_ENA() uint32 {
	return volatile.LoadUint32(&o.INT_ENA.Reg) & 0x1
}
func (o *LEDC_Type) SetINT_ENA_TIMER1_OVF_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x2)|value<<1)
}
func (o *LEDC_Type) GetINT_ENA_TIMER1_OVF_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x2) >> 1
}
func (o *LEDC_Type) SetINT_ENA_TIMER2_OVF_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x4)|value<<2)
}
func (o *LEDC_Type) GetINT_ENA_TIMER2_OVF_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x4) >> 2
}
func (o *LEDC_Type) SetINT_ENA_TIMER3_OVF_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x8)|value<<3)
}
func (o *LEDC_Type) GetINT_ENA_TIMER3_OVF_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x8) >> 3
}
func (o *LEDC_Type) SetINT_ENA_DUTY_CHNG_END_CH0_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x10)|value<<4)
}
func (o *LEDC_Type) GetINT_ENA_DUTY_CHNG_END_CH0_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x10) >> 4
}
func (o *LEDC_Type) SetINT_ENA_DUTY_CHNG_END_CH1_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x20)|value<<5)
}
func (o *LEDC_Type) GetINT_ENA_DUTY_CHNG_END_CH1_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x20) >> 5
}
func (o *LEDC_Type) SetINT_ENA_DUTY_CHNG_END_CH2_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x40)|value<<6)
}
func (o *LEDC_Type) GetINT_ENA_DUTY_CHNG_END_CH2_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x40) >> 6
}
func (o *LEDC_Type) SetINT_ENA_DUTY_CHNG_END_CH3_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x80)|value<<7)
}
func (o *LEDC_Type) GetINT_ENA_DUTY_CHNG_END_CH3_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x80) >> 7
}
func (o *LEDC_Type) SetINT_ENA_DUTY_CHNG_END_CH4_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x100)|value<<8)
}
func (o *LEDC_Type) GetINT_ENA_DUTY_CHNG_END_CH4_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x100) >> 8
}
func (o *LEDC_Type) SetINT_ENA_DUTY_CHNG_END_CH5_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x200)|value<<9)
}
func (o *LEDC_Type) GetINT_ENA_DUTY_CHNG_END_CH5_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x200) >> 9
}
func (o *LEDC_Type) SetINT_ENA_DUTY_CHNG_END_CH6_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x400)|value<<10)
}
func (o *LEDC_Type) GetINT_ENA_DUTY_CHNG_END_CH6_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x400) >> 10
}
func (o *LEDC_Type) SetINT_ENA_DUTY_CHNG_END_CH7_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x800)|value<<11)
}
func (o *LEDC_Type) GetINT_ENA_DUTY_CHNG_END_CH7_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x800) >> 11
}
func (o *LEDC_Type) SetINT_ENA_OVF_CNT_CH0_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x1000)|value<<12)
}
func (o *LEDC_Type) GetINT_ENA_OVF_CNT_CH0_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x1000) >> 12
}
func (o *LEDC_Type) SetINT_ENA_OVF_CNT_CH1_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x2000)|value<<13)
}
func (o *LEDC_Type) GetINT_ENA_OVF_CNT_CH1_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x2000) >> 13
}
func (o *LEDC_Type) SetINT_ENA_OVF_CNT_CH2_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x4000)|value<<14)
}
func (o *LEDC_Type) GetINT_ENA_OVF_CNT_CH2_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x4000) >> 14
}
func (o *LEDC_Type) SetINT_ENA_OVF_CNT_CH3_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x8000)|value<<15)
}
func (o *LEDC_Type) GetINT_ENA_OVF_CNT_CH3_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x8000) >> 15
}
func (o *LEDC_Type) SetINT_ENA_OVF_CNT_CH4_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x10000)|value<<16)
}
func (o *LEDC_Type) GetINT_ENA_OVF_CNT_CH4_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x10000) >> 16
}
func (o *LEDC_Type) SetINT_ENA_OVF_CNT_CH5_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x20000)|value<<17)
}
func (o *LEDC_Type) GetINT_ENA_OVF_CNT_CH5_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x20000) >> 17
}
func (o *LEDC_Type) SetINT_ENA_OVF_CNT_CH6_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x40000)|value<<18)
}
func (o *LEDC_Type) GetINT_ENA_OVF_CNT_CH6_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x40000) >> 18
}
func (o *LEDC_Type) SetINT_ENA_OVF_CNT_CH7_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x80000)|value<<19)
}
func (o *LEDC_Type) GetINT_ENA_OVF_CNT_CH7_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x80000) >> 19
}

// LEDC.INT_CLR: Interrupt clear bits
func (o *LEDC_Type) SetINT_CLR_TIMER0_OVF_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x1)|value)
}
func (o *LEDC_Type) GetINT_CLR_TIMER0_OVF_INT_CLR() uint32 {
	return volatile.LoadUint32(&o.INT_CLR.Reg) & 0x1
}
func (o *LEDC_Type) SetINT_CLR_TIMER1_OVF_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x2)|value<<1)
}
func (o *LEDC_Type) GetINT_CLR_TIMER1_OVF_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x2) >> 1
}
func (o *LEDC_Type) SetINT_CLR_TIMER2_OVF_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x4)|value<<2)
}
func (o *LEDC_Type) GetINT_CLR_TIMER2_OVF_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x4) >> 2
}
func (o *LEDC_Type) SetINT_CLR_TIMER3_OVF_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x8)|value<<3)
}
func (o *LEDC_Type) GetINT_CLR_TIMER3_OVF_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x8) >> 3
}
func (o *LEDC_Type) SetINT_CLR_DUTY_CHNG_END_CH0_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x10)|value<<4)
}
func (o *LEDC_Type) GetINT_CLR_DUTY_CHNG_END_CH0_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x10) >> 4
}
func (o *LEDC_Type) SetINT_CLR_DUTY_CHNG_END_CH1_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x20)|value<<5)
}
func (o *LEDC_Type) GetINT_CLR_DUTY_CHNG_END_CH1_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x20) >> 5
}
func (o *LEDC_Type) SetINT_CLR_DUTY_CHNG_END_CH2_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x40)|value<<6)
}
func (o *LEDC_Type) GetINT_CLR_DUTY_CHNG_END_CH2_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x40) >> 6
}
func (o *LEDC_Type) SetINT_CLR_DUTY_CHNG_END_CH3_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x80)|value<<7)
}
func (o *LEDC_Type) GetINT_CLR_DUTY_CHNG_END_CH3_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x80) >> 7
}
func (o *LEDC_Type) SetINT_CLR_DUTY_CHNG_END_CH4_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x100)|value<<8)
}
func (o *LEDC_Type) GetINT_CLR_DUTY_CHNG_END_CH4_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x100) >> 8
}
func (o *LEDC_Type) SetINT_CLR_DUTY_CHNG_END_CH5_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x200)|value<<9)
}
func (o *LEDC_Type) GetINT_CLR_DUTY_CHNG_END_CH5_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x200) >> 9
}
func (o *LEDC_Type) SetINT_CLR_DUTY_CHNG_END_CH6_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x400)|value<<10)
}
func (o *LEDC_Type) GetINT_CLR_DUTY_CHNG_END_CH6_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x400) >> 10
}
func (o *LEDC_Type) SetINT_CLR_DUTY_CHNG_END_CH7_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x800)|value<<11)
}
func (o *LEDC_Type) GetINT_CLR_DUTY_CHNG_END_CH7_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x800) >> 11
}
func (o *LEDC_Type) SetINT_CLR_OVF_CNT_CH0_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x1000)|value<<12)
}
func (o *LEDC_Type) GetINT_CLR_OVF_CNT_CH0_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x1000) >> 12
}
func (o *LEDC_Type) SetINT_CLR_OVF_CNT_CH1_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x2000)|value<<13)
}
func (o *LEDC_Type) GetINT_CLR_OVF_CNT_CH1_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x2000) >> 13
}
func (o *LEDC_Type) SetINT_CLR_OVF_CNT_CH2_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x4000)|value<<14)
}
func (o *LEDC_Type) GetINT_CLR_OVF_CNT_CH2_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x4000) >> 14
}
func (o *LEDC_Type) SetINT_CLR_OVF_CNT_CH3_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x8000)|value<<15)
}
func (o *LEDC_Type) GetINT_CLR_OVF_CNT_CH3_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x8000) >> 15
}
func (o *LEDC_Type) SetINT_CLR_OVF_CNT_CH4_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x10000)|value<<16)
}
func (o *LEDC_Type) GetINT_CLR_OVF_CNT_CH4_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x10000) >> 16
}
func (o *LEDC_Type) SetINT_CLR_OVF_CNT_CH5_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x20000)|value<<17)
}
func (o *LEDC_Type) GetINT_CLR_OVF_CNT_CH5_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x20000) >> 17
}
func (o *LEDC_Type) SetINT_CLR_OVF_CNT_CH6_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x40000)|value<<18)
}
func (o *LEDC_Type) GetINT_CLR_OVF_CNT_CH6_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x40000) >> 18
}
func (o *LEDC_Type) SetINT_CLR_OVF_CNT_CH7_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x80000)|value<<19)
}
func (o *LEDC_Type) GetINT_CLR_OVF_CNT_CH7_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x80000) >> 19
}

// LEDC.CONF: Global ledc configuration register
func (o *LEDC_Type) SetCONF_APB_CLK_SEL(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0x3)|value)
}
func (o *LEDC_Type) GetCONF_APB_CLK_SEL() uint32 {
	return volatile.LoadUint32(&o.CONF.Reg) & 0x3
}
func (o *LEDC_Type) SetCONF_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0x80000000)|value<<31)
}
func (o *LEDC_Type) GetCONF_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.CONF.Reg) & 0x80000000) >> 31
}

// LEDC.DATE: Version control register
func (o *LEDC_Type) SetDATE(value uint32) {
	volatile.StoreUint32(&o.DATE.Reg, value)
}
func (o *LEDC_Type) GetDATE() uint32 {
	return volatile.LoadUint32(&o.DATE.Reg)
}

// Peripheral PCNT
type PCNT_Type struct {
	U0_CONF0  volatile.Register32 // 0x0
	U0_CONF1  volatile.Register32 // 0x4
	U0_CONF2  volatile.Register32 // 0x8
	U1_CONF0  volatile.Register32 // 0xC
	U1_CONF1  volatile.Register32 // 0x10
	U1_CONF2  volatile.Register32 // 0x14
	U2_CONF0  volatile.Register32 // 0x18
	U2_CONF1  volatile.Register32 // 0x1C
	U2_CONF2  volatile.Register32 // 0x20
	U3_CONF0  volatile.Register32 // 0x24
	U3_CONF1  volatile.Register32 // 0x28
	U3_CONF2  volatile.Register32 // 0x2C
	U0_CNT    volatile.Register32 // 0x30
	U1_CNT    volatile.Register32 // 0x34
	U2_CNT    volatile.Register32 // 0x38
	U3_CNT    volatile.Register32 // 0x3C
	INT_RAW   volatile.Register32 // 0x40
	INT_ST    volatile.Register32 // 0x44
	INT_ENA   volatile.Register32 // 0x48
	INT_CLR   volatile.Register32 // 0x4C
	U0_STATUS volatile.Register32 // 0x50
	U1_STATUS volatile.Register32 // 0x54
	U2_STATUS volatile.Register32 // 0x58
	U3_STATUS volatile.Register32 // 0x5C
	CTRL      volatile.Register32 // 0x60
	_         [152]byte
	DATE      volatile.Register32 // 0xFC
}

// PCNT.U0_CONF0: Configuration register 0 for unit %s
func (o *PCNT_Type) SetU0_CONF0_FILTER_THRES_U(value uint32) {
	volatile.StoreUint32(&o.U0_CONF0.Reg, volatile.LoadUint32(&o.U0_CONF0.Reg)&^(0x3ff)|value)
}
func (o *PCNT_Type) GetU0_CONF0_FILTER_THRES_U() uint32 {
	return volatile.LoadUint32(&o.U0_CONF0.Reg) & 0x3ff
}
func (o *PCNT_Type) SetU0_CONF0_FILTER_EN_U(value uint32) {
	volatile.StoreUint32(&o.U0_CONF0.Reg, volatile.LoadUint32(&o.U0_CONF0.Reg)&^(0x400)|value<<10)
}
func (o *PCNT_Type) GetU0_CONF0_FILTER_EN_U() uint32 {
	return (volatile.LoadUint32(&o.U0_CONF0.Reg) & 0x400) >> 10
}
func (o *PCNT_Type) SetU0_CONF0_THR_ZERO_EN_U(value uint32) {
	volatile.StoreUint32(&o.U0_CONF0.Reg, volatile.LoadUint32(&o.U0_CONF0.Reg)&^(0x800)|value<<11)
}
func (o *PCNT_Type) GetU0_CONF0_THR_ZERO_EN_U() uint32 {
	return (volatile.LoadUint32(&o.U0_CONF0.Reg) & 0x800) >> 11
}
func (o *PCNT_Type) SetU0_CONF0_THR_H_LIM_EN_U(value uint32) {
	volatile.StoreUint32(&o.U0_CONF0.Reg, volatile.LoadUint32(&o.U0_CONF0.Reg)&^(0x1000)|value<<12)
}
func (o *PCNT_Type) GetU0_CONF0_THR_H_LIM_EN_U() uint32 {
	return (volatile.LoadUint32(&o.U0_CONF0.Reg) & 0x1000) >> 12
}
func (o *PCNT_Type) SetU0_CONF0_THR_L_LIM_EN_U(value uint32) {
	volatile.StoreUint32(&o.U0_CONF0.Reg, volatile.LoadUint32(&o.U0_CONF0.Reg)&^(0x2000)|value<<13)
}
func (o *PCNT_Type) GetU0_CONF0_THR_L_LIM_EN_U() uint32 {
	return (volatile.LoadUint32(&o.U0_CONF0.Reg) & 0x2000) >> 13
}
func (o *PCNT_Type) SetU0_CONF0_THR_THRES0_EN_U(value uint32) {
	volatile.StoreUint32(&o.U0_CONF0.Reg, volatile.LoadUint32(&o.U0_CONF0.Reg)&^(0x4000)|value<<14)
}
func (o *PCNT_Type) GetU0_CONF0_THR_THRES0_EN_U() uint32 {
	return (volatile.LoadUint32(&o.U0_CONF0.Reg) & 0x4000) >> 14
}
func (o *PCNT_Type) SetU0_CONF0_THR_THRES1_EN_U(value uint32) {
	volatile.StoreUint32(&o.U0_CONF0.Reg, volatile.LoadUint32(&o.U0_CONF0.Reg)&^(0x8000)|value<<15)
}
func (o *PCNT_Type) GetU0_CONF0_THR_THRES1_EN_U() uint32 {
	return (volatile.LoadUint32(&o.U0_CONF0.Reg) & 0x8000) >> 15
}
func (o *PCNT_Type) SetU0_CONF0_CH0_NEG_MODE_U(value uint32) {
	volatile.StoreUint32(&o.U0_CONF0.Reg, volatile.LoadUint32(&o.U0_CONF0.Reg)&^(0x30000)|value<<16)
}
func (o *PCNT_Type) GetU0_CONF0_CH0_NEG_MODE_U() uint32 {
	return (volatile.LoadUint32(&o.U0_CONF0.Reg) & 0x30000) >> 16
}
func (o *PCNT_Type) SetU0_CONF0_CH0_POS_MODE_U(value uint32) {
	volatile.StoreUint32(&o.U0_CONF0.Reg, volatile.LoadUint32(&o.U0_CONF0.Reg)&^(0xc0000)|value<<18)
}
func (o *PCNT_Type) GetU0_CONF0_CH0_POS_MODE_U() uint32 {
	return (volatile.LoadUint32(&o.U0_CONF0.Reg) & 0xc0000) >> 18
}
func (o *PCNT_Type) SetU0_CONF0_CH0_HCTRL_MODE_U(value uint32) {
	volatile.StoreUint32(&o.U0_CONF0.Reg, volatile.LoadUint32(&o.U0_CONF0.Reg)&^(0x300000)|value<<20)
}
func (o *PCNT_Type) GetU0_CONF0_CH0_HCTRL_MODE_U() uint32 {
	return (volatile.LoadUint32(&o.U0_CONF0.Reg) & 0x300000) >> 20
}
func (o *PCNT_Type) SetU0_CONF0_CH0_LCTRL_MODE_U(value uint32) {
	volatile.StoreUint32(&o.U0_CONF0.Reg, volatile.LoadUint32(&o.U0_CONF0.Reg)&^(0xc00000)|value<<22)
}
func (o *PCNT_Type) GetU0_CONF0_CH0_LCTRL_MODE_U() uint32 {
	return (volatile.LoadUint32(&o.U0_CONF0.Reg) & 0xc00000) >> 22
}
func (o *PCNT_Type) SetU0_CONF0_CH1_NEG_MODE_U(value uint32) {
	volatile.StoreUint32(&o.U0_CONF0.Reg, volatile.LoadUint32(&o.U0_CONF0.Reg)&^(0x3000000)|value<<24)
}
func (o *PCNT_Type) GetU0_CONF0_CH1_NEG_MODE_U() uint32 {
	return (volatile.LoadUint32(&o.U0_CONF0.Reg) & 0x3000000) >> 24
}
func (o *PCNT_Type) SetU0_CONF0_CH1_POS_MODE_U(value uint32) {
	volatile.StoreUint32(&o.U0_CONF0.Reg, volatile.LoadUint32(&o.U0_CONF0.Reg)&^(0xc000000)|value<<26)
}
func (o *PCNT_Type) GetU0_CONF0_CH1_POS_MODE_U() uint32 {
	return (volatile.LoadUint32(&o.U0_CONF0.Reg) & 0xc000000) >> 26
}
func (o *PCNT_Type) SetU0_CONF0_CH1_HCTRL_MODE_U(value uint32) {
	volatile.StoreUint32(&o.U0_CONF0.Reg, volatile.LoadUint32(&o.U0_CONF0.Reg)&^(0x30000000)|value<<28)
}
func (o *PCNT_Type) GetU0_CONF0_CH1_HCTRL_MODE_U() uint32 {
	return (volatile.LoadUint32(&o.U0_CONF0.Reg) & 0x30000000) >> 28
}
func (o *PCNT_Type) SetU0_CONF0_CH1_LCTRL_MODE_U(value uint32) {
	volatile.StoreUint32(&o.U0_CONF0.Reg, volatile.LoadUint32(&o.U0_CONF0.Reg)&^(0xc0000000)|value<<30)
}
func (o *PCNT_Type) GetU0_CONF0_CH1_LCTRL_MODE_U() uint32 {
	return (volatile.LoadUint32(&o.U0_CONF0.Reg) & 0xc0000000) >> 30
}

// PCNT.U0_CONF1: Configuration register 1 for unit %s
func (o *PCNT_Type) SetU0_CONF1_CNT_THRES0_U(value uint32) {
	volatile.StoreUint32(&o.U0_CONF1.Reg, volatile.LoadUint32(&o.U0_CONF1.Reg)&^(0xffff)|value)
}
func (o *PCNT_Type) GetU0_CONF1_CNT_THRES0_U() uint32 {
	return volatile.LoadUint32(&o.U0_CONF1.Reg) & 0xffff
}
func (o *PCNT_Type) SetU0_CONF1_CNT_THRES1_U(value uint32) {
	volatile.StoreUint32(&o.U0_CONF1.Reg, volatile.LoadUint32(&o.U0_CONF1.Reg)&^(0xffff0000)|value<<16)
}
func (o *PCNT_Type) GetU0_CONF1_CNT_THRES1_U() uint32 {
	return (volatile.LoadUint32(&o.U0_CONF1.Reg) & 0xffff0000) >> 16
}

// PCNT.U0_CONF2: Configuration register 2 for unit %s
func (o *PCNT_Type) SetU0_CONF2_CNT_H_LIM_U(value uint32) {
	volatile.StoreUint32(&o.U0_CONF2.Reg, volatile.LoadUint32(&o.U0_CONF2.Reg)&^(0xffff)|value)
}
func (o *PCNT_Type) GetU0_CONF2_CNT_H_LIM_U() uint32 {
	return volatile.LoadUint32(&o.U0_CONF2.Reg) & 0xffff
}
func (o *PCNT_Type) SetU0_CONF2_CNT_L_LIM_U(value uint32) {
	volatile.StoreUint32(&o.U0_CONF2.Reg, volatile.LoadUint32(&o.U0_CONF2.Reg)&^(0xffff0000)|value<<16)
}
func (o *PCNT_Type) GetU0_CONF2_CNT_L_LIM_U() uint32 {
	return (volatile.LoadUint32(&o.U0_CONF2.Reg) & 0xffff0000) >> 16
}

// PCNT.U1_CONF0: Configuration register 0 for unit %s
func (o *PCNT_Type) SetU1_CONF0_FILTER_THRES_U(value uint32) {
	volatile.StoreUint32(&o.U1_CONF0.Reg, volatile.LoadUint32(&o.U1_CONF0.Reg)&^(0x3ff)|value)
}
func (o *PCNT_Type) GetU1_CONF0_FILTER_THRES_U() uint32 {
	return volatile.LoadUint32(&o.U1_CONF0.Reg) & 0x3ff
}
func (o *PCNT_Type) SetU1_CONF0_FILTER_EN_U(value uint32) {
	volatile.StoreUint32(&o.U1_CONF0.Reg, volatile.LoadUint32(&o.U1_CONF0.Reg)&^(0x400)|value<<10)
}
func (o *PCNT_Type) GetU1_CONF0_FILTER_EN_U() uint32 {
	return (volatile.LoadUint32(&o.U1_CONF0.Reg) & 0x400) >> 10
}
func (o *PCNT_Type) SetU1_CONF0_THR_ZERO_EN_U(value uint32) {
	volatile.StoreUint32(&o.U1_CONF0.Reg, volatile.LoadUint32(&o.U1_CONF0.Reg)&^(0x800)|value<<11)
}
func (o *PCNT_Type) GetU1_CONF0_THR_ZERO_EN_U() uint32 {
	return (volatile.LoadUint32(&o.U1_CONF0.Reg) & 0x800) >> 11
}
func (o *PCNT_Type) SetU1_CONF0_THR_H_LIM_EN_U(value uint32) {
	volatile.StoreUint32(&o.U1_CONF0.Reg, volatile.LoadUint32(&o.U1_CONF0.Reg)&^(0x1000)|value<<12)
}
func (o *PCNT_Type) GetU1_CONF0_THR_H_LIM_EN_U() uint32 {
	return (volatile.LoadUint32(&o.U1_CONF0.Reg) & 0x1000) >> 12
}
func (o *PCNT_Type) SetU1_CONF0_THR_L_LIM_EN_U(value uint32) {
	volatile.StoreUint32(&o.U1_CONF0.Reg, volatile.LoadUint32(&o.U1_CONF0.Reg)&^(0x2000)|value<<13)
}
func (o *PCNT_Type) GetU1_CONF0_THR_L_LIM_EN_U() uint32 {
	return (volatile.LoadUint32(&o.U1_CONF0.Reg) & 0x2000) >> 13
}
func (o *PCNT_Type) SetU1_CONF0_THR_THRES0_EN_U(value uint32) {
	volatile.StoreUint32(&o.U1_CONF0.Reg, volatile.LoadUint32(&o.U1_CONF0.Reg)&^(0x4000)|value<<14)
}
func (o *PCNT_Type) GetU1_CONF0_THR_THRES0_EN_U() uint32 {
	return (volatile.LoadUint32(&o.U1_CONF0.Reg) & 0x4000) >> 14
}
func (o *PCNT_Type) SetU1_CONF0_THR_THRES1_EN_U(value uint32) {
	volatile.StoreUint32(&o.U1_CONF0.Reg, volatile.LoadUint32(&o.U1_CONF0.Reg)&^(0x8000)|value<<15)
}
func (o *PCNT_Type) GetU1_CONF0_THR_THRES1_EN_U() uint32 {
	return (volatile.LoadUint32(&o.U1_CONF0.Reg) & 0x8000) >> 15
}
func (o *PCNT_Type) SetU1_CONF0_CH0_NEG_MODE_U(value uint32) {
	volatile.StoreUint32(&o.U1_CONF0.Reg, volatile.LoadUint32(&o.U1_CONF0.Reg)&^(0x30000)|value<<16)
}
func (o *PCNT_Type) GetU1_CONF0_CH0_NEG_MODE_U() uint32 {
	return (volatile.LoadUint32(&o.U1_CONF0.Reg) & 0x30000) >> 16
}
func (o *PCNT_Type) SetU1_CONF0_CH0_POS_MODE_U(value uint32) {
	volatile.StoreUint32(&o.U1_CONF0.Reg, volatile.LoadUint32(&o.U1_CONF0.Reg)&^(0xc0000)|value<<18)
}
func (o *PCNT_Type) GetU1_CONF0_CH0_POS_MODE_U() uint32 {
	return (volatile.LoadUint32(&o.U1_CONF0.Reg) & 0xc0000) >> 18
}
func (o *PCNT_Type) SetU1_CONF0_CH0_HCTRL_MODE_U(value uint32) {
	volatile.StoreUint32(&o.U1_CONF0.Reg, volatile.LoadUint32(&o.U1_CONF0.Reg)&^(0x300000)|value<<20)
}
func (o *PCNT_Type) GetU1_CONF0_CH0_HCTRL_MODE_U() uint32 {
	return (volatile.LoadUint32(&o.U1_CONF0.Reg) & 0x300000) >> 20
}
func (o *PCNT_Type) SetU1_CONF0_CH0_LCTRL_MODE_U(value uint32) {
	volatile.StoreUint32(&o.U1_CONF0.Reg, volatile.LoadUint32(&o.U1_CONF0.Reg)&^(0xc00000)|value<<22)
}
func (o *PCNT_Type) GetU1_CONF0_CH0_LCTRL_MODE_U() uint32 {
	return (volatile.LoadUint32(&o.U1_CONF0.Reg) & 0xc00000) >> 22
}
func (o *PCNT_Type) SetU1_CONF0_CH1_NEG_MODE_U(value uint32) {
	volatile.StoreUint32(&o.U1_CONF0.Reg, volatile.LoadUint32(&o.U1_CONF0.Reg)&^(0x3000000)|value<<24)
}
func (o *PCNT_Type) GetU1_CONF0_CH1_NEG_MODE_U() uint32 {
	return (volatile.LoadUint32(&o.U1_CONF0.Reg) & 0x3000000) >> 24
}
func (o *PCNT_Type) SetU1_CONF0_CH1_POS_MODE_U(value uint32) {
	volatile.StoreUint32(&o.U1_CONF0.Reg, volatile.LoadUint32(&o.U1_CONF0.Reg)&^(0xc000000)|value<<26)
}
func (o *PCNT_Type) GetU1_CONF0_CH1_POS_MODE_U() uint32 {
	return (volatile.LoadUint32(&o.U1_CONF0.Reg) & 0xc000000) >> 26
}
func (o *PCNT_Type) SetU1_CONF0_CH1_HCTRL_MODE_U(value uint32) {
	volatile.StoreUint32(&o.U1_CONF0.Reg, volatile.LoadUint32(&o.U1_CONF0.Reg)&^(0x30000000)|value<<28)
}
func (o *PCNT_Type) GetU1_CONF0_CH1_HCTRL_MODE_U() uint32 {
	return (volatile.LoadUint32(&o.U1_CONF0.Reg) & 0x30000000) >> 28
}
func (o *PCNT_Type) SetU1_CONF0_CH1_LCTRL_MODE_U(value uint32) {
	volatile.StoreUint32(&o.U1_CONF0.Reg, volatile.LoadUint32(&o.U1_CONF0.Reg)&^(0xc0000000)|value<<30)
}
func (o *PCNT_Type) GetU1_CONF0_CH1_LCTRL_MODE_U() uint32 {
	return (volatile.LoadUint32(&o.U1_CONF0.Reg) & 0xc0000000) >> 30
}

// PCNT.U1_CONF1: Configuration register 1 for unit %s
func (o *PCNT_Type) SetU1_CONF1_CNT_THRES0_U(value uint32) {
	volatile.StoreUint32(&o.U1_CONF1.Reg, volatile.LoadUint32(&o.U1_CONF1.Reg)&^(0xffff)|value)
}
func (o *PCNT_Type) GetU1_CONF1_CNT_THRES0_U() uint32 {
	return volatile.LoadUint32(&o.U1_CONF1.Reg) & 0xffff
}
func (o *PCNT_Type) SetU1_CONF1_CNT_THRES1_U(value uint32) {
	volatile.StoreUint32(&o.U1_CONF1.Reg, volatile.LoadUint32(&o.U1_CONF1.Reg)&^(0xffff0000)|value<<16)
}
func (o *PCNT_Type) GetU1_CONF1_CNT_THRES1_U() uint32 {
	return (volatile.LoadUint32(&o.U1_CONF1.Reg) & 0xffff0000) >> 16
}

// PCNT.U1_CONF2: Configuration register 2 for unit %s
func (o *PCNT_Type) SetU1_CONF2_CNT_H_LIM_U(value uint32) {
	volatile.StoreUint32(&o.U1_CONF2.Reg, volatile.LoadUint32(&o.U1_CONF2.Reg)&^(0xffff)|value)
}
func (o *PCNT_Type) GetU1_CONF2_CNT_H_LIM_U() uint32 {
	return volatile.LoadUint32(&o.U1_CONF2.Reg) & 0xffff
}
func (o *PCNT_Type) SetU1_CONF2_CNT_L_LIM_U(value uint32) {
	volatile.StoreUint32(&o.U1_CONF2.Reg, volatile.LoadUint32(&o.U1_CONF2.Reg)&^(0xffff0000)|value<<16)
}
func (o *PCNT_Type) GetU1_CONF2_CNT_L_LIM_U() uint32 {
	return (volatile.LoadUint32(&o.U1_CONF2.Reg) & 0xffff0000) >> 16
}

// PCNT.U2_CONF0: Configuration register 0 for unit %s
func (o *PCNT_Type) SetU2_CONF0_FILTER_THRES_U(value uint32) {
	volatile.StoreUint32(&o.U2_CONF0.Reg, volatile.LoadUint32(&o.U2_CONF0.Reg)&^(0x3ff)|value)
}
func (o *PCNT_Type) GetU2_CONF0_FILTER_THRES_U() uint32 {
	return volatile.LoadUint32(&o.U2_CONF0.Reg) & 0x3ff
}
func (o *PCNT_Type) SetU2_CONF0_FILTER_EN_U(value uint32) {
	volatile.StoreUint32(&o.U2_CONF0.Reg, volatile.LoadUint32(&o.U2_CONF0.Reg)&^(0x400)|value<<10)
}
func (o *PCNT_Type) GetU2_CONF0_FILTER_EN_U() uint32 {
	return (volatile.LoadUint32(&o.U2_CONF0.Reg) & 0x400) >> 10
}
func (o *PCNT_Type) SetU2_CONF0_THR_ZERO_EN_U(value uint32) {
	volatile.StoreUint32(&o.U2_CONF0.Reg, volatile.LoadUint32(&o.U2_CONF0.Reg)&^(0x800)|value<<11)
}
func (o *PCNT_Type) GetU2_CONF0_THR_ZERO_EN_U() uint32 {
	return (volatile.LoadUint32(&o.U2_CONF0.Reg) & 0x800) >> 11
}
func (o *PCNT_Type) SetU2_CONF0_THR_H_LIM_EN_U(value uint32) {
	volatile.StoreUint32(&o.U2_CONF0.Reg, volatile.LoadUint32(&o.U2_CONF0.Reg)&^(0x1000)|value<<12)
}
func (o *PCNT_Type) GetU2_CONF0_THR_H_LIM_EN_U() uint32 {
	return (volatile.LoadUint32(&o.U2_CONF0.Reg) & 0x1000) >> 12
}
func (o *PCNT_Type) SetU2_CONF0_THR_L_LIM_EN_U(value uint32) {
	volatile.StoreUint32(&o.U2_CONF0.Reg, volatile.LoadUint32(&o.U2_CONF0.Reg)&^(0x2000)|value<<13)
}
func (o *PCNT_Type) GetU2_CONF0_THR_L_LIM_EN_U() uint32 {
	return (volatile.LoadUint32(&o.U2_CONF0.Reg) & 0x2000) >> 13
}
func (o *PCNT_Type) SetU2_CONF0_THR_THRES0_EN_U(value uint32) {
	volatile.StoreUint32(&o.U2_CONF0.Reg, volatile.LoadUint32(&o.U2_CONF0.Reg)&^(0x4000)|value<<14)
}
func (o *PCNT_Type) GetU2_CONF0_THR_THRES0_EN_U() uint32 {
	return (volatile.LoadUint32(&o.U2_CONF0.Reg) & 0x4000) >> 14
}
func (o *PCNT_Type) SetU2_CONF0_THR_THRES1_EN_U(value uint32) {
	volatile.StoreUint32(&o.U2_CONF0.Reg, volatile.LoadUint32(&o.U2_CONF0.Reg)&^(0x8000)|value<<15)
}
func (o *PCNT_Type) GetU2_CONF0_THR_THRES1_EN_U() uint32 {
	return (volatile.LoadUint32(&o.U2_CONF0.Reg) & 0x8000) >> 15
}
func (o *PCNT_Type) SetU2_CONF0_CH0_NEG_MODE_U(value uint32) {
	volatile.StoreUint32(&o.U2_CONF0.Reg, volatile.LoadUint32(&o.U2_CONF0.Reg)&^(0x30000)|value<<16)
}
func (o *PCNT_Type) GetU2_CONF0_CH0_NEG_MODE_U() uint32 {
	return (volatile.LoadUint32(&o.U2_CONF0.Reg) & 0x30000) >> 16
}
func (o *PCNT_Type) SetU2_CONF0_CH0_POS_MODE_U(value uint32) {
	volatile.StoreUint32(&o.U2_CONF0.Reg, volatile.LoadUint32(&o.U2_CONF0.Reg)&^(0xc0000)|value<<18)
}
func (o *PCNT_Type) GetU2_CONF0_CH0_POS_MODE_U() uint32 {
	return (volatile.LoadUint32(&o.U2_CONF0.Reg) & 0xc0000) >> 18
}
func (o *PCNT_Type) SetU2_CONF0_CH0_HCTRL_MODE_U(value uint32) {
	volatile.StoreUint32(&o.U2_CONF0.Reg, volatile.LoadUint32(&o.U2_CONF0.Reg)&^(0x300000)|value<<20)
}
func (o *PCNT_Type) GetU2_CONF0_CH0_HCTRL_MODE_U() uint32 {
	return (volatile.LoadUint32(&o.U2_CONF0.Reg) & 0x300000) >> 20
}
func (o *PCNT_Type) SetU2_CONF0_CH0_LCTRL_MODE_U(value uint32) {
	volatile.StoreUint32(&o.U2_CONF0.Reg, volatile.LoadUint32(&o.U2_CONF0.Reg)&^(0xc00000)|value<<22)
}
func (o *PCNT_Type) GetU2_CONF0_CH0_LCTRL_MODE_U() uint32 {
	return (volatile.LoadUint32(&o.U2_CONF0.Reg) & 0xc00000) >> 22
}
func (o *PCNT_Type) SetU2_CONF0_CH1_NEG_MODE_U(value uint32) {
	volatile.StoreUint32(&o.U2_CONF0.Reg, volatile.LoadUint32(&o.U2_CONF0.Reg)&^(0x3000000)|value<<24)
}
func (o *PCNT_Type) GetU2_CONF0_CH1_NEG_MODE_U() uint32 {
	return (volatile.LoadUint32(&o.U2_CONF0.Reg) & 0x3000000) >> 24
}
func (o *PCNT_Type) SetU2_CONF0_CH1_POS_MODE_U(value uint32) {
	volatile.StoreUint32(&o.U2_CONF0.Reg, volatile.LoadUint32(&o.U2_CONF0.Reg)&^(0xc000000)|value<<26)
}
func (o *PCNT_Type) GetU2_CONF0_CH1_POS_MODE_U() uint32 {
	return (volatile.LoadUint32(&o.U2_CONF0.Reg) & 0xc000000) >> 26
}
func (o *PCNT_Type) SetU2_CONF0_CH1_HCTRL_MODE_U(value uint32) {
	volatile.StoreUint32(&o.U2_CONF0.Reg, volatile.LoadUint32(&o.U2_CONF0.Reg)&^(0x30000000)|value<<28)
}
func (o *PCNT_Type) GetU2_CONF0_CH1_HCTRL_MODE_U() uint32 {
	return (volatile.LoadUint32(&o.U2_CONF0.Reg) & 0x30000000) >> 28
}
func (o *PCNT_Type) SetU2_CONF0_CH1_LCTRL_MODE_U(value uint32) {
	volatile.StoreUint32(&o.U2_CONF0.Reg, volatile.LoadUint32(&o.U2_CONF0.Reg)&^(0xc0000000)|value<<30)
}
func (o *PCNT_Type) GetU2_CONF0_CH1_LCTRL_MODE_U() uint32 {
	return (volatile.LoadUint32(&o.U2_CONF0.Reg) & 0xc0000000) >> 30
}

// PCNT.U2_CONF1: Configuration register 1 for unit %s
func (o *PCNT_Type) SetU2_CONF1_CNT_THRES0_U(value uint32) {
	volatile.StoreUint32(&o.U2_CONF1.Reg, volatile.LoadUint32(&o.U2_CONF1.Reg)&^(0xffff)|value)
}
func (o *PCNT_Type) GetU2_CONF1_CNT_THRES0_U() uint32 {
	return volatile.LoadUint32(&o.U2_CONF1.Reg) & 0xffff
}
func (o *PCNT_Type) SetU2_CONF1_CNT_THRES1_U(value uint32) {
	volatile.StoreUint32(&o.U2_CONF1.Reg, volatile.LoadUint32(&o.U2_CONF1.Reg)&^(0xffff0000)|value<<16)
}
func (o *PCNT_Type) GetU2_CONF1_CNT_THRES1_U() uint32 {
	return (volatile.LoadUint32(&o.U2_CONF1.Reg) & 0xffff0000) >> 16
}

// PCNT.U2_CONF2: Configuration register 2 for unit %s
func (o *PCNT_Type) SetU2_CONF2_CNT_H_LIM_U(value uint32) {
	volatile.StoreUint32(&o.U2_CONF2.Reg, volatile.LoadUint32(&o.U2_CONF2.Reg)&^(0xffff)|value)
}
func (o *PCNT_Type) GetU2_CONF2_CNT_H_LIM_U() uint32 {
	return volatile.LoadUint32(&o.U2_CONF2.Reg) & 0xffff
}
func (o *PCNT_Type) SetU2_CONF2_CNT_L_LIM_U(value uint32) {
	volatile.StoreUint32(&o.U2_CONF2.Reg, volatile.LoadUint32(&o.U2_CONF2.Reg)&^(0xffff0000)|value<<16)
}
func (o *PCNT_Type) GetU2_CONF2_CNT_L_LIM_U() uint32 {
	return (volatile.LoadUint32(&o.U2_CONF2.Reg) & 0xffff0000) >> 16
}

// PCNT.U3_CONF0: Configuration register 0 for unit %s
func (o *PCNT_Type) SetU3_CONF0_FILTER_THRES_U(value uint32) {
	volatile.StoreUint32(&o.U3_CONF0.Reg, volatile.LoadUint32(&o.U3_CONF0.Reg)&^(0x3ff)|value)
}
func (o *PCNT_Type) GetU3_CONF0_FILTER_THRES_U() uint32 {
	return volatile.LoadUint32(&o.U3_CONF0.Reg) & 0x3ff
}
func (o *PCNT_Type) SetU3_CONF0_FILTER_EN_U(value uint32) {
	volatile.StoreUint32(&o.U3_CONF0.Reg, volatile.LoadUint32(&o.U3_CONF0.Reg)&^(0x400)|value<<10)
}
func (o *PCNT_Type) GetU3_CONF0_FILTER_EN_U() uint32 {
	return (volatile.LoadUint32(&o.U3_CONF0.Reg) & 0x400) >> 10
}
func (o *PCNT_Type) SetU3_CONF0_THR_ZERO_EN_U(value uint32) {
	volatile.StoreUint32(&o.U3_CONF0.Reg, volatile.LoadUint32(&o.U3_CONF0.Reg)&^(0x800)|value<<11)
}
func (o *PCNT_Type) GetU3_CONF0_THR_ZERO_EN_U() uint32 {
	return (volatile.LoadUint32(&o.U3_CONF0.Reg) & 0x800) >> 11
}
func (o *PCNT_Type) SetU3_CONF0_THR_H_LIM_EN_U(value uint32) {
	volatile.StoreUint32(&o.U3_CONF0.Reg, volatile.LoadUint32(&o.U3_CONF0.Reg)&^(0x1000)|value<<12)
}
func (o *PCNT_Type) GetU3_CONF0_THR_H_LIM_EN_U() uint32 {
	return (volatile.LoadUint32(&o.U3_CONF0.Reg) & 0x1000) >> 12
}
func (o *PCNT_Type) SetU3_CONF0_THR_L_LIM_EN_U(value uint32) {
	volatile.StoreUint32(&o.U3_CONF0.Reg, volatile.LoadUint32(&o.U3_CONF0.Reg)&^(0x2000)|value<<13)
}
func (o *PCNT_Type) GetU3_CONF0_THR_L_LIM_EN_U() uint32 {
	return (volatile.LoadUint32(&o.U3_CONF0.Reg) & 0x2000) >> 13
}
func (o *PCNT_Type) SetU3_CONF0_THR_THRES0_EN_U(value uint32) {
	volatile.StoreUint32(&o.U3_CONF0.Reg, volatile.LoadUint32(&o.U3_CONF0.Reg)&^(0x4000)|value<<14)
}
func (o *PCNT_Type) GetU3_CONF0_THR_THRES0_EN_U() uint32 {
	return (volatile.LoadUint32(&o.U3_CONF0.Reg) & 0x4000) >> 14
}
func (o *PCNT_Type) SetU3_CONF0_THR_THRES1_EN_U(value uint32) {
	volatile.StoreUint32(&o.U3_CONF0.Reg, volatile.LoadUint32(&o.U3_CONF0.Reg)&^(0x8000)|value<<15)
}
func (o *PCNT_Type) GetU3_CONF0_THR_THRES1_EN_U() uint32 {
	return (volatile.LoadUint32(&o.U3_CONF0.Reg) & 0x8000) >> 15
}
func (o *PCNT_Type) SetU3_CONF0_CH0_NEG_MODE_U(value uint32) {
	volatile.StoreUint32(&o.U3_CONF0.Reg, volatile.LoadUint32(&o.U3_CONF0.Reg)&^(0x30000)|value<<16)
}
func (o *PCNT_Type) GetU3_CONF0_CH0_NEG_MODE_U() uint32 {
	return (volatile.LoadUint32(&o.U3_CONF0.Reg) & 0x30000) >> 16
}
func (o *PCNT_Type) SetU3_CONF0_CH0_POS_MODE_U(value uint32) {
	volatile.StoreUint32(&o.U3_CONF0.Reg, volatile.LoadUint32(&o.U3_CONF0.Reg)&^(0xc0000)|value<<18)
}
func (o *PCNT_Type) GetU3_CONF0_CH0_POS_MODE_U() uint32 {
	return (volatile.LoadUint32(&o.U3_CONF0.Reg) & 0xc0000) >> 18
}
func (o *PCNT_Type) SetU3_CONF0_CH0_HCTRL_MODE_U(value uint32) {
	volatile.StoreUint32(&o.U3_CONF0.Reg, volatile.LoadUint32(&o.U3_CONF0.Reg)&^(0x300000)|value<<20)
}
func (o *PCNT_Type) GetU3_CONF0_CH0_HCTRL_MODE_U() uint32 {
	return (volatile.LoadUint32(&o.U3_CONF0.Reg) & 0x300000) >> 20
}
func (o *PCNT_Type) SetU3_CONF0_CH0_LCTRL_MODE_U(value uint32) {
	volatile.StoreUint32(&o.U3_CONF0.Reg, volatile.LoadUint32(&o.U3_CONF0.Reg)&^(0xc00000)|value<<22)
}
func (o *PCNT_Type) GetU3_CONF0_CH0_LCTRL_MODE_U() uint32 {
	return (volatile.LoadUint32(&o.U3_CONF0.Reg) & 0xc00000) >> 22
}
func (o *PCNT_Type) SetU3_CONF0_CH1_NEG_MODE_U(value uint32) {
	volatile.StoreUint32(&o.U3_CONF0.Reg, volatile.LoadUint32(&o.U3_CONF0.Reg)&^(0x3000000)|value<<24)
}
func (o *PCNT_Type) GetU3_CONF0_CH1_NEG_MODE_U() uint32 {
	return (volatile.LoadUint32(&o.U3_CONF0.Reg) & 0x3000000) >> 24
}
func (o *PCNT_Type) SetU3_CONF0_CH1_POS_MODE_U(value uint32) {
	volatile.StoreUint32(&o.U3_CONF0.Reg, volatile.LoadUint32(&o.U3_CONF0.Reg)&^(0xc000000)|value<<26)
}
func (o *PCNT_Type) GetU3_CONF0_CH1_POS_MODE_U() uint32 {
	return (volatile.LoadUint32(&o.U3_CONF0.Reg) & 0xc000000) >> 26
}
func (o *PCNT_Type) SetU3_CONF0_CH1_HCTRL_MODE_U(value uint32) {
	volatile.StoreUint32(&o.U3_CONF0.Reg, volatile.LoadUint32(&o.U3_CONF0.Reg)&^(0x30000000)|value<<28)
}
func (o *PCNT_Type) GetU3_CONF0_CH1_HCTRL_MODE_U() uint32 {
	return (volatile.LoadUint32(&o.U3_CONF0.Reg) & 0x30000000) >> 28
}
func (o *PCNT_Type) SetU3_CONF0_CH1_LCTRL_MODE_U(value uint32) {
	volatile.StoreUint32(&o.U3_CONF0.Reg, volatile.LoadUint32(&o.U3_CONF0.Reg)&^(0xc0000000)|value<<30)
}
func (o *PCNT_Type) GetU3_CONF0_CH1_LCTRL_MODE_U() uint32 {
	return (volatile.LoadUint32(&o.U3_CONF0.Reg) & 0xc0000000) >> 30
}

// PCNT.U3_CONF1: Configuration register 1 for unit %s
func (o *PCNT_Type) SetU3_CONF1_CNT_THRES0_U(value uint32) {
	volatile.StoreUint32(&o.U3_CONF1.Reg, volatile.LoadUint32(&o.U3_CONF1.Reg)&^(0xffff)|value)
}
func (o *PCNT_Type) GetU3_CONF1_CNT_THRES0_U() uint32 {
	return volatile.LoadUint32(&o.U3_CONF1.Reg) & 0xffff
}
func (o *PCNT_Type) SetU3_CONF1_CNT_THRES1_U(value uint32) {
	volatile.StoreUint32(&o.U3_CONF1.Reg, volatile.LoadUint32(&o.U3_CONF1.Reg)&^(0xffff0000)|value<<16)
}
func (o *PCNT_Type) GetU3_CONF1_CNT_THRES1_U() uint32 {
	return (volatile.LoadUint32(&o.U3_CONF1.Reg) & 0xffff0000) >> 16
}

// PCNT.U3_CONF2: Configuration register 2 for unit %s
func (o *PCNT_Type) SetU3_CONF2_CNT_H_LIM_U(value uint32) {
	volatile.StoreUint32(&o.U3_CONF2.Reg, volatile.LoadUint32(&o.U3_CONF2.Reg)&^(0xffff)|value)
}
func (o *PCNT_Type) GetU3_CONF2_CNT_H_LIM_U() uint32 {
	return volatile.LoadUint32(&o.U3_CONF2.Reg) & 0xffff
}
func (o *PCNT_Type) SetU3_CONF2_CNT_L_LIM_U(value uint32) {
	volatile.StoreUint32(&o.U3_CONF2.Reg, volatile.LoadUint32(&o.U3_CONF2.Reg)&^(0xffff0000)|value<<16)
}
func (o *PCNT_Type) GetU3_CONF2_CNT_L_LIM_U() uint32 {
	return (volatile.LoadUint32(&o.U3_CONF2.Reg) & 0xffff0000) >> 16
}

// PCNT.U0_CNT: Counter value for unit %s
func (o *PCNT_Type) SetU0_CNT_PULSE_CNT_U(value uint32) {
	volatile.StoreUint32(&o.U0_CNT.Reg, volatile.LoadUint32(&o.U0_CNT.Reg)&^(0xffff)|value)
}
func (o *PCNT_Type) GetU0_CNT_PULSE_CNT_U() uint32 {
	return volatile.LoadUint32(&o.U0_CNT.Reg) & 0xffff
}

// PCNT.U1_CNT: Counter value for unit %s
func (o *PCNT_Type) SetU1_CNT_PULSE_CNT_U(value uint32) {
	volatile.StoreUint32(&o.U1_CNT.Reg, volatile.LoadUint32(&o.U1_CNT.Reg)&^(0xffff)|value)
}
func (o *PCNT_Type) GetU1_CNT_PULSE_CNT_U() uint32 {
	return volatile.LoadUint32(&o.U1_CNT.Reg) & 0xffff
}

// PCNT.U2_CNT: Counter value for unit %s
func (o *PCNT_Type) SetU2_CNT_PULSE_CNT_U(value uint32) {
	volatile.StoreUint32(&o.U2_CNT.Reg, volatile.LoadUint32(&o.U2_CNT.Reg)&^(0xffff)|value)
}
func (o *PCNT_Type) GetU2_CNT_PULSE_CNT_U() uint32 {
	return volatile.LoadUint32(&o.U2_CNT.Reg) & 0xffff
}

// PCNT.U3_CNT: Counter value for unit %s
func (o *PCNT_Type) SetU3_CNT_PULSE_CNT_U(value uint32) {
	volatile.StoreUint32(&o.U3_CNT.Reg, volatile.LoadUint32(&o.U3_CNT.Reg)&^(0xffff)|value)
}
func (o *PCNT_Type) GetU3_CNT_PULSE_CNT_U() uint32 {
	return volatile.LoadUint32(&o.U3_CNT.Reg) & 0xffff
}

// PCNT.INT_RAW: Interrupt raw status register
func (o *PCNT_Type) SetINT_RAW_CNT_THR_EVENT_U0_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x1)|value)
}
func (o *PCNT_Type) GetINT_RAW_CNT_THR_EVENT_U0_INT_RAW() uint32 {
	return volatile.LoadUint32(&o.INT_RAW.Reg) & 0x1
}
func (o *PCNT_Type) SetINT_RAW_CNT_THR_EVENT_U1_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x2)|value<<1)
}
func (o *PCNT_Type) GetINT_RAW_CNT_THR_EVENT_U1_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x2) >> 1
}
func (o *PCNT_Type) SetINT_RAW_CNT_THR_EVENT_U2_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x4)|value<<2)
}
func (o *PCNT_Type) GetINT_RAW_CNT_THR_EVENT_U2_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x4) >> 2
}
func (o *PCNT_Type) SetINT_RAW_CNT_THR_EVENT_U3_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x8)|value<<3)
}
func (o *PCNT_Type) GetINT_RAW_CNT_THR_EVENT_U3_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x8) >> 3
}

// PCNT.INT_ST: Interrupt status register
func (o *PCNT_Type) SetINT_ST_CNT_THR_EVENT_U0_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x1)|value)
}
func (o *PCNT_Type) GetINT_ST_CNT_THR_EVENT_U0_INT_ST() uint32 {
	return volatile.LoadUint32(&o.INT_ST.Reg) & 0x1
}
func (o *PCNT_Type) SetINT_ST_CNT_THR_EVENT_U1_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x2)|value<<1)
}
func (o *PCNT_Type) GetINT_ST_CNT_THR_EVENT_U1_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x2) >> 1
}
func (o *PCNT_Type) SetINT_ST_CNT_THR_EVENT_U2_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x4)|value<<2)
}
func (o *PCNT_Type) GetINT_ST_CNT_THR_EVENT_U2_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x4) >> 2
}
func (o *PCNT_Type) SetINT_ST_CNT_THR_EVENT_U3_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x8)|value<<3)
}
func (o *PCNT_Type) GetINT_ST_CNT_THR_EVENT_U3_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x8) >> 3
}

// PCNT.INT_ENA: Interrupt enable register
func (o *PCNT_Type) SetINT_ENA_CNT_THR_EVENT_U0_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x1)|value)
}
func (o *PCNT_Type) GetINT_ENA_CNT_THR_EVENT_U0_INT_ENA() uint32 {
	return volatile.LoadUint32(&o.INT_ENA.Reg) & 0x1
}
func (o *PCNT_Type) SetINT_ENA_CNT_THR_EVENT_U1_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x2)|value<<1)
}
func (o *PCNT_Type) GetINT_ENA_CNT_THR_EVENT_U1_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x2) >> 1
}
func (o *PCNT_Type) SetINT_ENA_CNT_THR_EVENT_U2_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x4)|value<<2)
}
func (o *PCNT_Type) GetINT_ENA_CNT_THR_EVENT_U2_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x4) >> 2
}
func (o *PCNT_Type) SetINT_ENA_CNT_THR_EVENT_U3_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x8)|value<<3)
}
func (o *PCNT_Type) GetINT_ENA_CNT_THR_EVENT_U3_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x8) >> 3
}

// PCNT.INT_CLR: Interrupt clear register
func (o *PCNT_Type) SetINT_CLR_CNT_THR_EVENT_U0_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x1)|value)
}
func (o *PCNT_Type) GetINT_CLR_CNT_THR_EVENT_U0_INT_CLR() uint32 {
	return volatile.LoadUint32(&o.INT_CLR.Reg) & 0x1
}
func (o *PCNT_Type) SetINT_CLR_CNT_THR_EVENT_U1_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x2)|value<<1)
}
func (o *PCNT_Type) GetINT_CLR_CNT_THR_EVENT_U1_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x2) >> 1
}
func (o *PCNT_Type) SetINT_CLR_CNT_THR_EVENT_U2_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x4)|value<<2)
}
func (o *PCNT_Type) GetINT_CLR_CNT_THR_EVENT_U2_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x4) >> 2
}
func (o *PCNT_Type) SetINT_CLR_CNT_THR_EVENT_U3_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x8)|value<<3)
}
func (o *PCNT_Type) GetINT_CLR_CNT_THR_EVENT_U3_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x8) >> 3
}

// PCNT.U0_STATUS: PNCT UNIT%s status register
func (o *PCNT_Type) SetU0_STATUS_CNT_THR_ZERO_MODE_U(value uint32) {
	volatile.StoreUint32(&o.U0_STATUS.Reg, volatile.LoadUint32(&o.U0_STATUS.Reg)&^(0x3)|value)
}
func (o *PCNT_Type) GetU0_STATUS_CNT_THR_ZERO_MODE_U() uint32 {
	return volatile.LoadUint32(&o.U0_STATUS.Reg) & 0x3
}
func (o *PCNT_Type) SetU0_STATUS_CNT_THR_THRES1_LAT_U(value uint32) {
	volatile.StoreUint32(&o.U0_STATUS.Reg, volatile.LoadUint32(&o.U0_STATUS.Reg)&^(0x4)|value<<2)
}
func (o *PCNT_Type) GetU0_STATUS_CNT_THR_THRES1_LAT_U() uint32 {
	return (volatile.LoadUint32(&o.U0_STATUS.Reg) & 0x4) >> 2
}
func (o *PCNT_Type) SetU0_STATUS_CNT_THR_THRES0_LAT_U(value uint32) {
	volatile.StoreUint32(&o.U0_STATUS.Reg, volatile.LoadUint32(&o.U0_STATUS.Reg)&^(0x8)|value<<3)
}
func (o *PCNT_Type) GetU0_STATUS_CNT_THR_THRES0_LAT_U() uint32 {
	return (volatile.LoadUint32(&o.U0_STATUS.Reg) & 0x8) >> 3
}
func (o *PCNT_Type) SetU0_STATUS_CNT_THR_L_LIM_LAT_U(value uint32) {
	volatile.StoreUint32(&o.U0_STATUS.Reg, volatile.LoadUint32(&o.U0_STATUS.Reg)&^(0x10)|value<<4)
}
func (o *PCNT_Type) GetU0_STATUS_CNT_THR_L_LIM_LAT_U() uint32 {
	return (volatile.LoadUint32(&o.U0_STATUS.Reg) & 0x10) >> 4
}
func (o *PCNT_Type) SetU0_STATUS_CNT_THR_H_LIM_LAT_U(value uint32) {
	volatile.StoreUint32(&o.U0_STATUS.Reg, volatile.LoadUint32(&o.U0_STATUS.Reg)&^(0x20)|value<<5)
}
func (o *PCNT_Type) GetU0_STATUS_CNT_THR_H_LIM_LAT_U() uint32 {
	return (volatile.LoadUint32(&o.U0_STATUS.Reg) & 0x20) >> 5
}
func (o *PCNT_Type) SetU0_STATUS_CNT_THR_ZERO_LAT_U(value uint32) {
	volatile.StoreUint32(&o.U0_STATUS.Reg, volatile.LoadUint32(&o.U0_STATUS.Reg)&^(0x40)|value<<6)
}
func (o *PCNT_Type) GetU0_STATUS_CNT_THR_ZERO_LAT_U() uint32 {
	return (volatile.LoadUint32(&o.U0_STATUS.Reg) & 0x40) >> 6
}

// PCNT.U1_STATUS: PNCT UNIT%s status register
func (o *PCNT_Type) SetU1_STATUS_CNT_THR_ZERO_MODE_U(value uint32) {
	volatile.StoreUint32(&o.U1_STATUS.Reg, volatile.LoadUint32(&o.U1_STATUS.Reg)&^(0x3)|value)
}
func (o *PCNT_Type) GetU1_STATUS_CNT_THR_ZERO_MODE_U() uint32 {
	return volatile.LoadUint32(&o.U1_STATUS.Reg) & 0x3
}
func (o *PCNT_Type) SetU1_STATUS_CNT_THR_THRES1_LAT_U(value uint32) {
	volatile.StoreUint32(&o.U1_STATUS.Reg, volatile.LoadUint32(&o.U1_STATUS.Reg)&^(0x4)|value<<2)
}
func (o *PCNT_Type) GetU1_STATUS_CNT_THR_THRES1_LAT_U() uint32 {
	return (volatile.LoadUint32(&o.U1_STATUS.Reg) & 0x4) >> 2
}
func (o *PCNT_Type) SetU1_STATUS_CNT_THR_THRES0_LAT_U(value uint32) {
	volatile.StoreUint32(&o.U1_STATUS.Reg, volatile.LoadUint32(&o.U1_STATUS.Reg)&^(0x8)|value<<3)
}
func (o *PCNT_Type) GetU1_STATUS_CNT_THR_THRES0_LAT_U() uint32 {
	return (volatile.LoadUint32(&o.U1_STATUS.Reg) & 0x8) >> 3
}
func (o *PCNT_Type) SetU1_STATUS_CNT_THR_L_LIM_LAT_U(value uint32) {
	volatile.StoreUint32(&o.U1_STATUS.Reg, volatile.LoadUint32(&o.U1_STATUS.Reg)&^(0x10)|value<<4)
}
func (o *PCNT_Type) GetU1_STATUS_CNT_THR_L_LIM_LAT_U() uint32 {
	return (volatile.LoadUint32(&o.U1_STATUS.Reg) & 0x10) >> 4
}
func (o *PCNT_Type) SetU1_STATUS_CNT_THR_H_LIM_LAT_U(value uint32) {
	volatile.StoreUint32(&o.U1_STATUS.Reg, volatile.LoadUint32(&o.U1_STATUS.Reg)&^(0x20)|value<<5)
}
func (o *PCNT_Type) GetU1_STATUS_CNT_THR_H_LIM_LAT_U() uint32 {
	return (volatile.LoadUint32(&o.U1_STATUS.Reg) & 0x20) >> 5
}
func (o *PCNT_Type) SetU1_STATUS_CNT_THR_ZERO_LAT_U(value uint32) {
	volatile.StoreUint32(&o.U1_STATUS.Reg, volatile.LoadUint32(&o.U1_STATUS.Reg)&^(0x40)|value<<6)
}
func (o *PCNT_Type) GetU1_STATUS_CNT_THR_ZERO_LAT_U() uint32 {
	return (volatile.LoadUint32(&o.U1_STATUS.Reg) & 0x40) >> 6
}

// PCNT.U2_STATUS: PNCT UNIT%s status register
func (o *PCNT_Type) SetU2_STATUS_CNT_THR_ZERO_MODE_U(value uint32) {
	volatile.StoreUint32(&o.U2_STATUS.Reg, volatile.LoadUint32(&o.U2_STATUS.Reg)&^(0x3)|value)
}
func (o *PCNT_Type) GetU2_STATUS_CNT_THR_ZERO_MODE_U() uint32 {
	return volatile.LoadUint32(&o.U2_STATUS.Reg) & 0x3
}
func (o *PCNT_Type) SetU2_STATUS_CNT_THR_THRES1_LAT_U(value uint32) {
	volatile.StoreUint32(&o.U2_STATUS.Reg, volatile.LoadUint32(&o.U2_STATUS.Reg)&^(0x4)|value<<2)
}
func (o *PCNT_Type) GetU2_STATUS_CNT_THR_THRES1_LAT_U() uint32 {
	return (volatile.LoadUint32(&o.U2_STATUS.Reg) & 0x4) >> 2
}
func (o *PCNT_Type) SetU2_STATUS_CNT_THR_THRES0_LAT_U(value uint32) {
	volatile.StoreUint32(&o.U2_STATUS.Reg, volatile.LoadUint32(&o.U2_STATUS.Reg)&^(0x8)|value<<3)
}
func (o *PCNT_Type) GetU2_STATUS_CNT_THR_THRES0_LAT_U() uint32 {
	return (volatile.LoadUint32(&o.U2_STATUS.Reg) & 0x8) >> 3
}
func (o *PCNT_Type) SetU2_STATUS_CNT_THR_L_LIM_LAT_U(value uint32) {
	volatile.StoreUint32(&o.U2_STATUS.Reg, volatile.LoadUint32(&o.U2_STATUS.Reg)&^(0x10)|value<<4)
}
func (o *PCNT_Type) GetU2_STATUS_CNT_THR_L_LIM_LAT_U() uint32 {
	return (volatile.LoadUint32(&o.U2_STATUS.Reg) & 0x10) >> 4
}
func (o *PCNT_Type) SetU2_STATUS_CNT_THR_H_LIM_LAT_U(value uint32) {
	volatile.StoreUint32(&o.U2_STATUS.Reg, volatile.LoadUint32(&o.U2_STATUS.Reg)&^(0x20)|value<<5)
}
func (o *PCNT_Type) GetU2_STATUS_CNT_THR_H_LIM_LAT_U() uint32 {
	return (volatile.LoadUint32(&o.U2_STATUS.Reg) & 0x20) >> 5
}
func (o *PCNT_Type) SetU2_STATUS_CNT_THR_ZERO_LAT_U(value uint32) {
	volatile.StoreUint32(&o.U2_STATUS.Reg, volatile.LoadUint32(&o.U2_STATUS.Reg)&^(0x40)|value<<6)
}
func (o *PCNT_Type) GetU2_STATUS_CNT_THR_ZERO_LAT_U() uint32 {
	return (volatile.LoadUint32(&o.U2_STATUS.Reg) & 0x40) >> 6
}

// PCNT.U3_STATUS: PNCT UNIT%s status register
func (o *PCNT_Type) SetU3_STATUS_CNT_THR_ZERO_MODE_U(value uint32) {
	volatile.StoreUint32(&o.U3_STATUS.Reg, volatile.LoadUint32(&o.U3_STATUS.Reg)&^(0x3)|value)
}
func (o *PCNT_Type) GetU3_STATUS_CNT_THR_ZERO_MODE_U() uint32 {
	return volatile.LoadUint32(&o.U3_STATUS.Reg) & 0x3
}
func (o *PCNT_Type) SetU3_STATUS_CNT_THR_THRES1_LAT_U(value uint32) {
	volatile.StoreUint32(&o.U3_STATUS.Reg, volatile.LoadUint32(&o.U3_STATUS.Reg)&^(0x4)|value<<2)
}
func (o *PCNT_Type) GetU3_STATUS_CNT_THR_THRES1_LAT_U() uint32 {
	return (volatile.LoadUint32(&o.U3_STATUS.Reg) & 0x4) >> 2
}
func (o *PCNT_Type) SetU3_STATUS_CNT_THR_THRES0_LAT_U(value uint32) {
	volatile.StoreUint32(&o.U3_STATUS.Reg, volatile.LoadUint32(&o.U3_STATUS.Reg)&^(0x8)|value<<3)
}
func (o *PCNT_Type) GetU3_STATUS_CNT_THR_THRES0_LAT_U() uint32 {
	return (volatile.LoadUint32(&o.U3_STATUS.Reg) & 0x8) >> 3
}
func (o *PCNT_Type) SetU3_STATUS_CNT_THR_L_LIM_LAT_U(value uint32) {
	volatile.StoreUint32(&o.U3_STATUS.Reg, volatile.LoadUint32(&o.U3_STATUS.Reg)&^(0x10)|value<<4)
}
func (o *PCNT_Type) GetU3_STATUS_CNT_THR_L_LIM_LAT_U() uint32 {
	return (volatile.LoadUint32(&o.U3_STATUS.Reg) & 0x10) >> 4
}
func (o *PCNT_Type) SetU3_STATUS_CNT_THR_H_LIM_LAT_U(value uint32) {
	volatile.StoreUint32(&o.U3_STATUS.Reg, volatile.LoadUint32(&o.U3_STATUS.Reg)&^(0x20)|value<<5)
}
func (o *PCNT_Type) GetU3_STATUS_CNT_THR_H_LIM_LAT_U() uint32 {
	return (volatile.LoadUint32(&o.U3_STATUS.Reg) & 0x20) >> 5
}
func (o *PCNT_Type) SetU3_STATUS_CNT_THR_ZERO_LAT_U(value uint32) {
	volatile.StoreUint32(&o.U3_STATUS.Reg, volatile.LoadUint32(&o.U3_STATUS.Reg)&^(0x40)|value<<6)
}
func (o *PCNT_Type) GetU3_STATUS_CNT_THR_ZERO_LAT_U() uint32 {
	return (volatile.LoadUint32(&o.U3_STATUS.Reg) & 0x40) >> 6
}

// PCNT.CTRL: Control register for all counters
func (o *PCNT_Type) SetCTRL_PULSE_CNT_RST_U0(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x1)|value)
}
func (o *PCNT_Type) GetCTRL_PULSE_CNT_RST_U0() uint32 {
	return volatile.LoadUint32(&o.CTRL.Reg) & 0x1
}
func (o *PCNT_Type) SetCTRL_CNT_PAUSE_U0(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x2)|value<<1)
}
func (o *PCNT_Type) GetCTRL_CNT_PAUSE_U0() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x2) >> 1
}
func (o *PCNT_Type) SetCTRL_PULSE_CNT_RST_U1(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x4)|value<<2)
}
func (o *PCNT_Type) GetCTRL_PULSE_CNT_RST_U1() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x4) >> 2
}
func (o *PCNT_Type) SetCTRL_CNT_PAUSE_U1(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x8)|value<<3)
}
func (o *PCNT_Type) GetCTRL_CNT_PAUSE_U1() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x8) >> 3
}
func (o *PCNT_Type) SetCTRL_PULSE_CNT_RST_U2(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x10)|value<<4)
}
func (o *PCNT_Type) GetCTRL_PULSE_CNT_RST_U2() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x10) >> 4
}
func (o *PCNT_Type) SetCTRL_CNT_PAUSE_U2(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x20)|value<<5)
}
func (o *PCNT_Type) GetCTRL_CNT_PAUSE_U2() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x20) >> 5
}
func (o *PCNT_Type) SetCTRL_PULSE_CNT_RST_U3(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x40)|value<<6)
}
func (o *PCNT_Type) GetCTRL_PULSE_CNT_RST_U3() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x40) >> 6
}
func (o *PCNT_Type) SetCTRL_CNT_PAUSE_U3(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x80)|value<<7)
}
func (o *PCNT_Type) GetCTRL_CNT_PAUSE_U3() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x80) >> 7
}
func (o *PCNT_Type) SetCTRL_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x10000)|value<<16)
}
func (o *PCNT_Type) GetCTRL_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x10000) >> 16
}

// PCNT.DATE: PCNT version control register
func (o *PCNT_Type) SetDATE(value uint32) {
	volatile.StoreUint32(&o.DATE.Reg, value)
}
func (o *PCNT_Type) GetDATE() uint32 {
	return volatile.LoadUint32(&o.DATE.Reg)
}

// Peripheral RMT
type RMT_Type struct {
	CH0DATA           volatile.Register32 // 0x0
	CH1DATA           volatile.Register32 // 0x4
	CH2DATA           volatile.Register32 // 0x8
	CH3DATA           volatile.Register32 // 0xC
	CH0CONF0          volatile.Register32 // 0x10
	CH0CONF1          volatile.Register32 // 0x14
	CH1CONF0          volatile.Register32 // 0x18
	CH1CONF1          volatile.Register32 // 0x1C
	CH2CONF0          volatile.Register32 // 0x20
	CH2CONF1          volatile.Register32 // 0x24
	CH3CONF0          volatile.Register32 // 0x28
	CH3CONF1          volatile.Register32 // 0x2C
	CH0STATUS         volatile.Register32 // 0x30
	CH1STATUS         volatile.Register32 // 0x34
	CH2STATUS         volatile.Register32 // 0x38
	CH3STATUS         volatile.Register32 // 0x3C
	CH0ADDR           volatile.Register32 // 0x40
	CH1ADDR           volatile.Register32 // 0x44
	CH2ADDR           volatile.Register32 // 0x48
	CH3ADDR           volatile.Register32 // 0x4C
	INT_RAW           volatile.Register32 // 0x50
	INT_ST            volatile.Register32 // 0x54
	INT_ENA           volatile.Register32 // 0x58
	INT_CLR           volatile.Register32 // 0x5C
	CH0CARRIER_DUTY   volatile.Register32 // 0x60
	CH1CARRIER_DUTY   volatile.Register32 // 0x64
	CH2CARRIER_DUTY   volatile.Register32 // 0x68
	CH3CARRIER_DUTY   volatile.Register32 // 0x6C
	CH0_TX_LIM        volatile.Register32 // 0x70
	CH1_TX_LIM        volatile.Register32 // 0x74
	CH2_TX_LIM        volatile.Register32 // 0x78
	CH3_TX_LIM        volatile.Register32 // 0x7C
	APB_CONF          volatile.Register32 // 0x80
	TX_SIM            volatile.Register32 // 0x84
	REF_CNT_RST       volatile.Register32 // 0x88
	CH0_RX_CARRIER_RM volatile.Register32 // 0x8C
	CH1_RX_CARRIER_RM volatile.Register32 // 0x90
	CH2_RX_CARRIER_RM volatile.Register32 // 0x94
	CH3_RX_CARRIER_RM volatile.Register32 // 0x98
	_                 [96]byte
	DATE              volatile.Register32 // 0xFC
}

// RMT.CH0DATA: The read and write data register for CHANNEL%s by apb fifo access.
func (o *RMT_Type) SetCH0DATA(value uint32) {
	volatile.StoreUint32(&o.CH0DATA.Reg, value)
}
func (o *RMT_Type) GetCH0DATA() uint32 {
	return volatile.LoadUint32(&o.CH0DATA.Reg)
}

// RMT.CH1DATA: The read and write data register for CHANNEL%s by apb fifo access.
func (o *RMT_Type) SetCH1DATA(value uint32) {
	volatile.StoreUint32(&o.CH1DATA.Reg, value)
}
func (o *RMT_Type) GetCH1DATA() uint32 {
	return volatile.LoadUint32(&o.CH1DATA.Reg)
}

// RMT.CH2DATA: The read and write data register for CHANNEL%s by apb fifo access.
func (o *RMT_Type) SetCH2DATA(value uint32) {
	volatile.StoreUint32(&o.CH2DATA.Reg, value)
}
func (o *RMT_Type) GetCH2DATA() uint32 {
	return volatile.LoadUint32(&o.CH2DATA.Reg)
}

// RMT.CH3DATA: The read and write data register for CHANNEL%s by apb fifo access.
func (o *RMT_Type) SetCH3DATA(value uint32) {
	volatile.StoreUint32(&o.CH3DATA.Reg, value)
}
func (o *RMT_Type) GetCH3DATA() uint32 {
	return volatile.LoadUint32(&o.CH3DATA.Reg)
}

// RMT.CH0CONF0: Channel %s configure register 0
func (o *RMT_Type) SetCH0CONF0_DIV_CNT_CH(value uint32) {
	volatile.StoreUint32(&o.CH0CONF0.Reg, volatile.LoadUint32(&o.CH0CONF0.Reg)&^(0xff)|value)
}
func (o *RMT_Type) GetCH0CONF0_DIV_CNT_CH() uint32 {
	return volatile.LoadUint32(&o.CH0CONF0.Reg) & 0xff
}
func (o *RMT_Type) SetCH0CONF0_IDLE_THRES_CH(value uint32) {
	volatile.StoreUint32(&o.CH0CONF0.Reg, volatile.LoadUint32(&o.CH0CONF0.Reg)&^(0xffff00)|value<<8)
}
func (o *RMT_Type) GetCH0CONF0_IDLE_THRES_CH() uint32 {
	return (volatile.LoadUint32(&o.CH0CONF0.Reg) & 0xffff00) >> 8
}
func (o *RMT_Type) SetCH0CONF0_MEM_SIZE_CH(value uint32) {
	volatile.StoreUint32(&o.CH0CONF0.Reg, volatile.LoadUint32(&o.CH0CONF0.Reg)&^(0x7000000)|value<<24)
}
func (o *RMT_Type) GetCH0CONF0_MEM_SIZE_CH() uint32 {
	return (volatile.LoadUint32(&o.CH0CONF0.Reg) & 0x7000000) >> 24
}
func (o *RMT_Type) SetCH0CONF0_CARRIER_EFF_EN_CH(value uint32) {
	volatile.StoreUint32(&o.CH0CONF0.Reg, volatile.LoadUint32(&o.CH0CONF0.Reg)&^(0x8000000)|value<<27)
}
func (o *RMT_Type) GetCH0CONF0_CARRIER_EFF_EN_CH() uint32 {
	return (volatile.LoadUint32(&o.CH0CONF0.Reg) & 0x8000000) >> 27
}
func (o *RMT_Type) SetCH0CONF0_CARRIER_EN_CH(value uint32) {
	volatile.StoreUint32(&o.CH0CONF0.Reg, volatile.LoadUint32(&o.CH0CONF0.Reg)&^(0x10000000)|value<<28)
}
func (o *RMT_Type) GetCH0CONF0_CARRIER_EN_CH() uint32 {
	return (volatile.LoadUint32(&o.CH0CONF0.Reg) & 0x10000000) >> 28
}
func (o *RMT_Type) SetCH0CONF0_CARRIER_OUT_LV_CH(value uint32) {
	volatile.StoreUint32(&o.CH0CONF0.Reg, volatile.LoadUint32(&o.CH0CONF0.Reg)&^(0x20000000)|value<<29)
}
func (o *RMT_Type) GetCH0CONF0_CARRIER_OUT_LV_CH() uint32 {
	return (volatile.LoadUint32(&o.CH0CONF0.Reg) & 0x20000000) >> 29
}

// RMT.CH0CONF1: Channel %s configure register 1
func (o *RMT_Type) SetCH0CONF1_TX_START_CH0(value uint32) {
	volatile.StoreUint32(&o.CH0CONF1.Reg, volatile.LoadUint32(&o.CH0CONF1.Reg)&^(0x1)|value)
}
func (o *RMT_Type) GetCH0CONF1_TX_START_CH0() uint32 {
	return volatile.LoadUint32(&o.CH0CONF1.Reg) & 0x1
}
func (o *RMT_Type) SetCH0CONF1_RX_EN_CH0(value uint32) {
	volatile.StoreUint32(&o.CH0CONF1.Reg, volatile.LoadUint32(&o.CH0CONF1.Reg)&^(0x2)|value<<1)
}
func (o *RMT_Type) GetCH0CONF1_RX_EN_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH0CONF1.Reg) & 0x2) >> 1
}
func (o *RMT_Type) SetCH0CONF1_MEM_WR_RST_CH0(value uint32) {
	volatile.StoreUint32(&o.CH0CONF1.Reg, volatile.LoadUint32(&o.CH0CONF1.Reg)&^(0x4)|value<<2)
}
func (o *RMT_Type) GetCH0CONF1_MEM_WR_RST_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH0CONF1.Reg) & 0x4) >> 2
}
func (o *RMT_Type) SetCH0CONF1_MEM_RD_RST_CH0(value uint32) {
	volatile.StoreUint32(&o.CH0CONF1.Reg, volatile.LoadUint32(&o.CH0CONF1.Reg)&^(0x8)|value<<3)
}
func (o *RMT_Type) GetCH0CONF1_MEM_RD_RST_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH0CONF1.Reg) & 0x8) >> 3
}
func (o *RMT_Type) SetCH0CONF1_APB_MEM_RST_CH0(value uint32) {
	volatile.StoreUint32(&o.CH0CONF1.Reg, volatile.LoadUint32(&o.CH0CONF1.Reg)&^(0x10)|value<<4)
}
func (o *RMT_Type) GetCH0CONF1_APB_MEM_RST_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH0CONF1.Reg) & 0x10) >> 4
}
func (o *RMT_Type) SetCH0CONF1_MEM_OWNER_CH0(value uint32) {
	volatile.StoreUint32(&o.CH0CONF1.Reg, volatile.LoadUint32(&o.CH0CONF1.Reg)&^(0x20)|value<<5)
}
func (o *RMT_Type) GetCH0CONF1_MEM_OWNER_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH0CONF1.Reg) & 0x20) >> 5
}
func (o *RMT_Type) SetCH0CONF1_TX_CONTI_MODE_CH0(value uint32) {
	volatile.StoreUint32(&o.CH0CONF1.Reg, volatile.LoadUint32(&o.CH0CONF1.Reg)&^(0x40)|value<<6)
}
func (o *RMT_Type) GetCH0CONF1_TX_CONTI_MODE_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH0CONF1.Reg) & 0x40) >> 6
}
func (o *RMT_Type) SetCH0CONF1_RX_FILTER_EN_CH0(value uint32) {
	volatile.StoreUint32(&o.CH0CONF1.Reg, volatile.LoadUint32(&o.CH0CONF1.Reg)&^(0x80)|value<<7)
}
func (o *RMT_Type) GetCH0CONF1_RX_FILTER_EN_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH0CONF1.Reg) & 0x80) >> 7
}
func (o *RMT_Type) SetCH0CONF1_RX_FILTER_THRES_CH0(value uint32) {
	volatile.StoreUint32(&o.CH0CONF1.Reg, volatile.LoadUint32(&o.CH0CONF1.Reg)&^(0xff00)|value<<8)
}
func (o *RMT_Type) GetCH0CONF1_RX_FILTER_THRES_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH0CONF1.Reg) & 0xff00) >> 8
}
func (o *RMT_Type) SetCH0CONF1_CHK_RX_CARRIER_EN_CH0(value uint32) {
	volatile.StoreUint32(&o.CH0CONF1.Reg, volatile.LoadUint32(&o.CH0CONF1.Reg)&^(0x10000)|value<<16)
}
func (o *RMT_Type) GetCH0CONF1_CHK_RX_CARRIER_EN_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH0CONF1.Reg) & 0x10000) >> 16
}
func (o *RMT_Type) SetCH0CONF1_REF_ALWAYS_ON_CH0(value uint32) {
	volatile.StoreUint32(&o.CH0CONF1.Reg, volatile.LoadUint32(&o.CH0CONF1.Reg)&^(0x20000)|value<<17)
}
func (o *RMT_Type) GetCH0CONF1_REF_ALWAYS_ON_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH0CONF1.Reg) & 0x20000) >> 17
}
func (o *RMT_Type) SetCH0CONF1_IDLE_OUT_LV_CH0(value uint32) {
	volatile.StoreUint32(&o.CH0CONF1.Reg, volatile.LoadUint32(&o.CH0CONF1.Reg)&^(0x40000)|value<<18)
}
func (o *RMT_Type) GetCH0CONF1_IDLE_OUT_LV_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH0CONF1.Reg) & 0x40000) >> 18
}
func (o *RMT_Type) SetCH0CONF1_IDLE_OUT_EN_CH0(value uint32) {
	volatile.StoreUint32(&o.CH0CONF1.Reg, volatile.LoadUint32(&o.CH0CONF1.Reg)&^(0x80000)|value<<19)
}
func (o *RMT_Type) GetCH0CONF1_IDLE_OUT_EN_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH0CONF1.Reg) & 0x80000) >> 19
}
func (o *RMT_Type) SetCH0CONF1_TX_STOP_CH0(value uint32) {
	volatile.StoreUint32(&o.CH0CONF1.Reg, volatile.LoadUint32(&o.CH0CONF1.Reg)&^(0x100000)|value<<20)
}
func (o *RMT_Type) GetCH0CONF1_TX_STOP_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH0CONF1.Reg) & 0x100000) >> 20
}

// RMT.CH1CONF0: Channel %s configure register 0
func (o *RMT_Type) SetCH1CONF0_DIV_CNT_CH(value uint32) {
	volatile.StoreUint32(&o.CH1CONF0.Reg, volatile.LoadUint32(&o.CH1CONF0.Reg)&^(0xff)|value)
}
func (o *RMT_Type) GetCH1CONF0_DIV_CNT_CH() uint32 {
	return volatile.LoadUint32(&o.CH1CONF0.Reg) & 0xff
}
func (o *RMT_Type) SetCH1CONF0_IDLE_THRES_CH(value uint32) {
	volatile.StoreUint32(&o.CH1CONF0.Reg, volatile.LoadUint32(&o.CH1CONF0.Reg)&^(0xffff00)|value<<8)
}
func (o *RMT_Type) GetCH1CONF0_IDLE_THRES_CH() uint32 {
	return (volatile.LoadUint32(&o.CH1CONF0.Reg) & 0xffff00) >> 8
}
func (o *RMT_Type) SetCH1CONF0_MEM_SIZE_CH(value uint32) {
	volatile.StoreUint32(&o.CH1CONF0.Reg, volatile.LoadUint32(&o.CH1CONF0.Reg)&^(0x7000000)|value<<24)
}
func (o *RMT_Type) GetCH1CONF0_MEM_SIZE_CH() uint32 {
	return (volatile.LoadUint32(&o.CH1CONF0.Reg) & 0x7000000) >> 24
}
func (o *RMT_Type) SetCH1CONF0_CARRIER_EFF_EN_CH(value uint32) {
	volatile.StoreUint32(&o.CH1CONF0.Reg, volatile.LoadUint32(&o.CH1CONF0.Reg)&^(0x8000000)|value<<27)
}
func (o *RMT_Type) GetCH1CONF0_CARRIER_EFF_EN_CH() uint32 {
	return (volatile.LoadUint32(&o.CH1CONF0.Reg) & 0x8000000) >> 27
}
func (o *RMT_Type) SetCH1CONF0_CARRIER_EN_CH(value uint32) {
	volatile.StoreUint32(&o.CH1CONF0.Reg, volatile.LoadUint32(&o.CH1CONF0.Reg)&^(0x10000000)|value<<28)
}
func (o *RMT_Type) GetCH1CONF0_CARRIER_EN_CH() uint32 {
	return (volatile.LoadUint32(&o.CH1CONF0.Reg) & 0x10000000) >> 28
}
func (o *RMT_Type) SetCH1CONF0_CARRIER_OUT_LV_CH(value uint32) {
	volatile.StoreUint32(&o.CH1CONF0.Reg, volatile.LoadUint32(&o.CH1CONF0.Reg)&^(0x20000000)|value<<29)
}
func (o *RMT_Type) GetCH1CONF0_CARRIER_OUT_LV_CH() uint32 {
	return (volatile.LoadUint32(&o.CH1CONF0.Reg) & 0x20000000) >> 29
}

// RMT.CH1CONF1: Channel %s configure register 1
func (o *RMT_Type) SetCH1CONF1_TX_START_CH0(value uint32) {
	volatile.StoreUint32(&o.CH1CONF1.Reg, volatile.LoadUint32(&o.CH1CONF1.Reg)&^(0x1)|value)
}
func (o *RMT_Type) GetCH1CONF1_TX_START_CH0() uint32 {
	return volatile.LoadUint32(&o.CH1CONF1.Reg) & 0x1
}
func (o *RMT_Type) SetCH1CONF1_RX_EN_CH0(value uint32) {
	volatile.StoreUint32(&o.CH1CONF1.Reg, volatile.LoadUint32(&o.CH1CONF1.Reg)&^(0x2)|value<<1)
}
func (o *RMT_Type) GetCH1CONF1_RX_EN_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH1CONF1.Reg) & 0x2) >> 1
}
func (o *RMT_Type) SetCH1CONF1_MEM_WR_RST_CH0(value uint32) {
	volatile.StoreUint32(&o.CH1CONF1.Reg, volatile.LoadUint32(&o.CH1CONF1.Reg)&^(0x4)|value<<2)
}
func (o *RMT_Type) GetCH1CONF1_MEM_WR_RST_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH1CONF1.Reg) & 0x4) >> 2
}
func (o *RMT_Type) SetCH1CONF1_MEM_RD_RST_CH0(value uint32) {
	volatile.StoreUint32(&o.CH1CONF1.Reg, volatile.LoadUint32(&o.CH1CONF1.Reg)&^(0x8)|value<<3)
}
func (o *RMT_Type) GetCH1CONF1_MEM_RD_RST_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH1CONF1.Reg) & 0x8) >> 3
}
func (o *RMT_Type) SetCH1CONF1_APB_MEM_RST_CH0(value uint32) {
	volatile.StoreUint32(&o.CH1CONF1.Reg, volatile.LoadUint32(&o.CH1CONF1.Reg)&^(0x10)|value<<4)
}
func (o *RMT_Type) GetCH1CONF1_APB_MEM_RST_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH1CONF1.Reg) & 0x10) >> 4
}
func (o *RMT_Type) SetCH1CONF1_MEM_OWNER_CH0(value uint32) {
	volatile.StoreUint32(&o.CH1CONF1.Reg, volatile.LoadUint32(&o.CH1CONF1.Reg)&^(0x20)|value<<5)
}
func (o *RMT_Type) GetCH1CONF1_MEM_OWNER_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH1CONF1.Reg) & 0x20) >> 5
}
func (o *RMT_Type) SetCH1CONF1_TX_CONTI_MODE_CH0(value uint32) {
	volatile.StoreUint32(&o.CH1CONF1.Reg, volatile.LoadUint32(&o.CH1CONF1.Reg)&^(0x40)|value<<6)
}
func (o *RMT_Type) GetCH1CONF1_TX_CONTI_MODE_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH1CONF1.Reg) & 0x40) >> 6
}
func (o *RMT_Type) SetCH1CONF1_RX_FILTER_EN_CH0(value uint32) {
	volatile.StoreUint32(&o.CH1CONF1.Reg, volatile.LoadUint32(&o.CH1CONF1.Reg)&^(0x80)|value<<7)
}
func (o *RMT_Type) GetCH1CONF1_RX_FILTER_EN_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH1CONF1.Reg) & 0x80) >> 7
}
func (o *RMT_Type) SetCH1CONF1_RX_FILTER_THRES_CH0(value uint32) {
	volatile.StoreUint32(&o.CH1CONF1.Reg, volatile.LoadUint32(&o.CH1CONF1.Reg)&^(0xff00)|value<<8)
}
func (o *RMT_Type) GetCH1CONF1_RX_FILTER_THRES_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH1CONF1.Reg) & 0xff00) >> 8
}
func (o *RMT_Type) SetCH1CONF1_CHK_RX_CARRIER_EN_CH0(value uint32) {
	volatile.StoreUint32(&o.CH1CONF1.Reg, volatile.LoadUint32(&o.CH1CONF1.Reg)&^(0x10000)|value<<16)
}
func (o *RMT_Type) GetCH1CONF1_CHK_RX_CARRIER_EN_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH1CONF1.Reg) & 0x10000) >> 16
}
func (o *RMT_Type) SetCH1CONF1_REF_ALWAYS_ON_CH0(value uint32) {
	volatile.StoreUint32(&o.CH1CONF1.Reg, volatile.LoadUint32(&o.CH1CONF1.Reg)&^(0x20000)|value<<17)
}
func (o *RMT_Type) GetCH1CONF1_REF_ALWAYS_ON_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH1CONF1.Reg) & 0x20000) >> 17
}
func (o *RMT_Type) SetCH1CONF1_IDLE_OUT_LV_CH0(value uint32) {
	volatile.StoreUint32(&o.CH1CONF1.Reg, volatile.LoadUint32(&o.CH1CONF1.Reg)&^(0x40000)|value<<18)
}
func (o *RMT_Type) GetCH1CONF1_IDLE_OUT_LV_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH1CONF1.Reg) & 0x40000) >> 18
}
func (o *RMT_Type) SetCH1CONF1_IDLE_OUT_EN_CH0(value uint32) {
	volatile.StoreUint32(&o.CH1CONF1.Reg, volatile.LoadUint32(&o.CH1CONF1.Reg)&^(0x80000)|value<<19)
}
func (o *RMT_Type) GetCH1CONF1_IDLE_OUT_EN_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH1CONF1.Reg) & 0x80000) >> 19
}
func (o *RMT_Type) SetCH1CONF1_TX_STOP_CH0(value uint32) {
	volatile.StoreUint32(&o.CH1CONF1.Reg, volatile.LoadUint32(&o.CH1CONF1.Reg)&^(0x100000)|value<<20)
}
func (o *RMT_Type) GetCH1CONF1_TX_STOP_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH1CONF1.Reg) & 0x100000) >> 20
}

// RMT.CH2CONF0: Channel %s configure register 0
func (o *RMT_Type) SetCH2CONF0_DIV_CNT_CH(value uint32) {
	volatile.StoreUint32(&o.CH2CONF0.Reg, volatile.LoadUint32(&o.CH2CONF0.Reg)&^(0xff)|value)
}
func (o *RMT_Type) GetCH2CONF0_DIV_CNT_CH() uint32 {
	return volatile.LoadUint32(&o.CH2CONF0.Reg) & 0xff
}
func (o *RMT_Type) SetCH2CONF0_IDLE_THRES_CH(value uint32) {
	volatile.StoreUint32(&o.CH2CONF0.Reg, volatile.LoadUint32(&o.CH2CONF0.Reg)&^(0xffff00)|value<<8)
}
func (o *RMT_Type) GetCH2CONF0_IDLE_THRES_CH() uint32 {
	return (volatile.LoadUint32(&o.CH2CONF0.Reg) & 0xffff00) >> 8
}
func (o *RMT_Type) SetCH2CONF0_MEM_SIZE_CH(value uint32) {
	volatile.StoreUint32(&o.CH2CONF0.Reg, volatile.LoadUint32(&o.CH2CONF0.Reg)&^(0x7000000)|value<<24)
}
func (o *RMT_Type) GetCH2CONF0_MEM_SIZE_CH() uint32 {
	return (volatile.LoadUint32(&o.CH2CONF0.Reg) & 0x7000000) >> 24
}
func (o *RMT_Type) SetCH2CONF0_CARRIER_EFF_EN_CH(value uint32) {
	volatile.StoreUint32(&o.CH2CONF0.Reg, volatile.LoadUint32(&o.CH2CONF0.Reg)&^(0x8000000)|value<<27)
}
func (o *RMT_Type) GetCH2CONF0_CARRIER_EFF_EN_CH() uint32 {
	return (volatile.LoadUint32(&o.CH2CONF0.Reg) & 0x8000000) >> 27
}
func (o *RMT_Type) SetCH2CONF0_CARRIER_EN_CH(value uint32) {
	volatile.StoreUint32(&o.CH2CONF0.Reg, volatile.LoadUint32(&o.CH2CONF0.Reg)&^(0x10000000)|value<<28)
}
func (o *RMT_Type) GetCH2CONF0_CARRIER_EN_CH() uint32 {
	return (volatile.LoadUint32(&o.CH2CONF0.Reg) & 0x10000000) >> 28
}
func (o *RMT_Type) SetCH2CONF0_CARRIER_OUT_LV_CH(value uint32) {
	volatile.StoreUint32(&o.CH2CONF0.Reg, volatile.LoadUint32(&o.CH2CONF0.Reg)&^(0x20000000)|value<<29)
}
func (o *RMT_Type) GetCH2CONF0_CARRIER_OUT_LV_CH() uint32 {
	return (volatile.LoadUint32(&o.CH2CONF0.Reg) & 0x20000000) >> 29
}

// RMT.CH2CONF1: Channel %s configure register 1
func (o *RMT_Type) SetCH2CONF1_TX_START_CH0(value uint32) {
	volatile.StoreUint32(&o.CH2CONF1.Reg, volatile.LoadUint32(&o.CH2CONF1.Reg)&^(0x1)|value)
}
func (o *RMT_Type) GetCH2CONF1_TX_START_CH0() uint32 {
	return volatile.LoadUint32(&o.CH2CONF1.Reg) & 0x1
}
func (o *RMT_Type) SetCH2CONF1_RX_EN_CH0(value uint32) {
	volatile.StoreUint32(&o.CH2CONF1.Reg, volatile.LoadUint32(&o.CH2CONF1.Reg)&^(0x2)|value<<1)
}
func (o *RMT_Type) GetCH2CONF1_RX_EN_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH2CONF1.Reg) & 0x2) >> 1
}
func (o *RMT_Type) SetCH2CONF1_MEM_WR_RST_CH0(value uint32) {
	volatile.StoreUint32(&o.CH2CONF1.Reg, volatile.LoadUint32(&o.CH2CONF1.Reg)&^(0x4)|value<<2)
}
func (o *RMT_Type) GetCH2CONF1_MEM_WR_RST_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH2CONF1.Reg) & 0x4) >> 2
}
func (o *RMT_Type) SetCH2CONF1_MEM_RD_RST_CH0(value uint32) {
	volatile.StoreUint32(&o.CH2CONF1.Reg, volatile.LoadUint32(&o.CH2CONF1.Reg)&^(0x8)|value<<3)
}
func (o *RMT_Type) GetCH2CONF1_MEM_RD_RST_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH2CONF1.Reg) & 0x8) >> 3
}
func (o *RMT_Type) SetCH2CONF1_APB_MEM_RST_CH0(value uint32) {
	volatile.StoreUint32(&o.CH2CONF1.Reg, volatile.LoadUint32(&o.CH2CONF1.Reg)&^(0x10)|value<<4)
}
func (o *RMT_Type) GetCH2CONF1_APB_MEM_RST_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH2CONF1.Reg) & 0x10) >> 4
}
func (o *RMT_Type) SetCH2CONF1_MEM_OWNER_CH0(value uint32) {
	volatile.StoreUint32(&o.CH2CONF1.Reg, volatile.LoadUint32(&o.CH2CONF1.Reg)&^(0x20)|value<<5)
}
func (o *RMT_Type) GetCH2CONF1_MEM_OWNER_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH2CONF1.Reg) & 0x20) >> 5
}
func (o *RMT_Type) SetCH2CONF1_TX_CONTI_MODE_CH0(value uint32) {
	volatile.StoreUint32(&o.CH2CONF1.Reg, volatile.LoadUint32(&o.CH2CONF1.Reg)&^(0x40)|value<<6)
}
func (o *RMT_Type) GetCH2CONF1_TX_CONTI_MODE_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH2CONF1.Reg) & 0x40) >> 6
}
func (o *RMT_Type) SetCH2CONF1_RX_FILTER_EN_CH0(value uint32) {
	volatile.StoreUint32(&o.CH2CONF1.Reg, volatile.LoadUint32(&o.CH2CONF1.Reg)&^(0x80)|value<<7)
}
func (o *RMT_Type) GetCH2CONF1_RX_FILTER_EN_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH2CONF1.Reg) & 0x80) >> 7
}
func (o *RMT_Type) SetCH2CONF1_RX_FILTER_THRES_CH0(value uint32) {
	volatile.StoreUint32(&o.CH2CONF1.Reg, volatile.LoadUint32(&o.CH2CONF1.Reg)&^(0xff00)|value<<8)
}
func (o *RMT_Type) GetCH2CONF1_RX_FILTER_THRES_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH2CONF1.Reg) & 0xff00) >> 8
}
func (o *RMT_Type) SetCH2CONF1_CHK_RX_CARRIER_EN_CH0(value uint32) {
	volatile.StoreUint32(&o.CH2CONF1.Reg, volatile.LoadUint32(&o.CH2CONF1.Reg)&^(0x10000)|value<<16)
}
func (o *RMT_Type) GetCH2CONF1_CHK_RX_CARRIER_EN_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH2CONF1.Reg) & 0x10000) >> 16
}
func (o *RMT_Type) SetCH2CONF1_REF_ALWAYS_ON_CH0(value uint32) {
	volatile.StoreUint32(&o.CH2CONF1.Reg, volatile.LoadUint32(&o.CH2CONF1.Reg)&^(0x20000)|value<<17)
}
func (o *RMT_Type) GetCH2CONF1_REF_ALWAYS_ON_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH2CONF1.Reg) & 0x20000) >> 17
}
func (o *RMT_Type) SetCH2CONF1_IDLE_OUT_LV_CH0(value uint32) {
	volatile.StoreUint32(&o.CH2CONF1.Reg, volatile.LoadUint32(&o.CH2CONF1.Reg)&^(0x40000)|value<<18)
}
func (o *RMT_Type) GetCH2CONF1_IDLE_OUT_LV_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH2CONF1.Reg) & 0x40000) >> 18
}
func (o *RMT_Type) SetCH2CONF1_IDLE_OUT_EN_CH0(value uint32) {
	volatile.StoreUint32(&o.CH2CONF1.Reg, volatile.LoadUint32(&o.CH2CONF1.Reg)&^(0x80000)|value<<19)
}
func (o *RMT_Type) GetCH2CONF1_IDLE_OUT_EN_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH2CONF1.Reg) & 0x80000) >> 19
}
func (o *RMT_Type) SetCH2CONF1_TX_STOP_CH0(value uint32) {
	volatile.StoreUint32(&o.CH2CONF1.Reg, volatile.LoadUint32(&o.CH2CONF1.Reg)&^(0x100000)|value<<20)
}
func (o *RMT_Type) GetCH2CONF1_TX_STOP_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH2CONF1.Reg) & 0x100000) >> 20
}

// RMT.CH3CONF0: Channel %s configure register 0
func (o *RMT_Type) SetCH3CONF0_DIV_CNT_CH(value uint32) {
	volatile.StoreUint32(&o.CH3CONF0.Reg, volatile.LoadUint32(&o.CH3CONF0.Reg)&^(0xff)|value)
}
func (o *RMT_Type) GetCH3CONF0_DIV_CNT_CH() uint32 {
	return volatile.LoadUint32(&o.CH3CONF0.Reg) & 0xff
}
func (o *RMT_Type) SetCH3CONF0_IDLE_THRES_CH(value uint32) {
	volatile.StoreUint32(&o.CH3CONF0.Reg, volatile.LoadUint32(&o.CH3CONF0.Reg)&^(0xffff00)|value<<8)
}
func (o *RMT_Type) GetCH3CONF0_IDLE_THRES_CH() uint32 {
	return (volatile.LoadUint32(&o.CH3CONF0.Reg) & 0xffff00) >> 8
}
func (o *RMT_Type) SetCH3CONF0_MEM_SIZE_CH(value uint32) {
	volatile.StoreUint32(&o.CH3CONF0.Reg, volatile.LoadUint32(&o.CH3CONF0.Reg)&^(0x7000000)|value<<24)
}
func (o *RMT_Type) GetCH3CONF0_MEM_SIZE_CH() uint32 {
	return (volatile.LoadUint32(&o.CH3CONF0.Reg) & 0x7000000) >> 24
}
func (o *RMT_Type) SetCH3CONF0_CARRIER_EFF_EN_CH(value uint32) {
	volatile.StoreUint32(&o.CH3CONF0.Reg, volatile.LoadUint32(&o.CH3CONF0.Reg)&^(0x8000000)|value<<27)
}
func (o *RMT_Type) GetCH3CONF0_CARRIER_EFF_EN_CH() uint32 {
	return (volatile.LoadUint32(&o.CH3CONF0.Reg) & 0x8000000) >> 27
}
func (o *RMT_Type) SetCH3CONF0_CARRIER_EN_CH(value uint32) {
	volatile.StoreUint32(&o.CH3CONF0.Reg, volatile.LoadUint32(&o.CH3CONF0.Reg)&^(0x10000000)|value<<28)
}
func (o *RMT_Type) GetCH3CONF0_CARRIER_EN_CH() uint32 {
	return (volatile.LoadUint32(&o.CH3CONF0.Reg) & 0x10000000) >> 28
}
func (o *RMT_Type) SetCH3CONF0_CARRIER_OUT_LV_CH(value uint32) {
	volatile.StoreUint32(&o.CH3CONF0.Reg, volatile.LoadUint32(&o.CH3CONF0.Reg)&^(0x20000000)|value<<29)
}
func (o *RMT_Type) GetCH3CONF0_CARRIER_OUT_LV_CH() uint32 {
	return (volatile.LoadUint32(&o.CH3CONF0.Reg) & 0x20000000) >> 29
}

// RMT.CH3CONF1: Channel %s configure register 1
func (o *RMT_Type) SetCH3CONF1_TX_START_CH0(value uint32) {
	volatile.StoreUint32(&o.CH3CONF1.Reg, volatile.LoadUint32(&o.CH3CONF1.Reg)&^(0x1)|value)
}
func (o *RMT_Type) GetCH3CONF1_TX_START_CH0() uint32 {
	return volatile.LoadUint32(&o.CH3CONF1.Reg) & 0x1
}
func (o *RMT_Type) SetCH3CONF1_RX_EN_CH0(value uint32) {
	volatile.StoreUint32(&o.CH3CONF1.Reg, volatile.LoadUint32(&o.CH3CONF1.Reg)&^(0x2)|value<<1)
}
func (o *RMT_Type) GetCH3CONF1_RX_EN_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH3CONF1.Reg) & 0x2) >> 1
}
func (o *RMT_Type) SetCH3CONF1_MEM_WR_RST_CH0(value uint32) {
	volatile.StoreUint32(&o.CH3CONF1.Reg, volatile.LoadUint32(&o.CH3CONF1.Reg)&^(0x4)|value<<2)
}
func (o *RMT_Type) GetCH3CONF1_MEM_WR_RST_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH3CONF1.Reg) & 0x4) >> 2
}
func (o *RMT_Type) SetCH3CONF1_MEM_RD_RST_CH0(value uint32) {
	volatile.StoreUint32(&o.CH3CONF1.Reg, volatile.LoadUint32(&o.CH3CONF1.Reg)&^(0x8)|value<<3)
}
func (o *RMT_Type) GetCH3CONF1_MEM_RD_RST_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH3CONF1.Reg) & 0x8) >> 3
}
func (o *RMT_Type) SetCH3CONF1_APB_MEM_RST_CH0(value uint32) {
	volatile.StoreUint32(&o.CH3CONF1.Reg, volatile.LoadUint32(&o.CH3CONF1.Reg)&^(0x10)|value<<4)
}
func (o *RMT_Type) GetCH3CONF1_APB_MEM_RST_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH3CONF1.Reg) & 0x10) >> 4
}
func (o *RMT_Type) SetCH3CONF1_MEM_OWNER_CH0(value uint32) {
	volatile.StoreUint32(&o.CH3CONF1.Reg, volatile.LoadUint32(&o.CH3CONF1.Reg)&^(0x20)|value<<5)
}
func (o *RMT_Type) GetCH3CONF1_MEM_OWNER_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH3CONF1.Reg) & 0x20) >> 5
}
func (o *RMT_Type) SetCH3CONF1_TX_CONTI_MODE_CH0(value uint32) {
	volatile.StoreUint32(&o.CH3CONF1.Reg, volatile.LoadUint32(&o.CH3CONF1.Reg)&^(0x40)|value<<6)
}
func (o *RMT_Type) GetCH3CONF1_TX_CONTI_MODE_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH3CONF1.Reg) & 0x40) >> 6
}
func (o *RMT_Type) SetCH3CONF1_RX_FILTER_EN_CH0(value uint32) {
	volatile.StoreUint32(&o.CH3CONF1.Reg, volatile.LoadUint32(&o.CH3CONF1.Reg)&^(0x80)|value<<7)
}
func (o *RMT_Type) GetCH3CONF1_RX_FILTER_EN_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH3CONF1.Reg) & 0x80) >> 7
}
func (o *RMT_Type) SetCH3CONF1_RX_FILTER_THRES_CH0(value uint32) {
	volatile.StoreUint32(&o.CH3CONF1.Reg, volatile.LoadUint32(&o.CH3CONF1.Reg)&^(0xff00)|value<<8)
}
func (o *RMT_Type) GetCH3CONF1_RX_FILTER_THRES_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH3CONF1.Reg) & 0xff00) >> 8
}
func (o *RMT_Type) SetCH3CONF1_CHK_RX_CARRIER_EN_CH0(value uint32) {
	volatile.StoreUint32(&o.CH3CONF1.Reg, volatile.LoadUint32(&o.CH3CONF1.Reg)&^(0x10000)|value<<16)
}
func (o *RMT_Type) GetCH3CONF1_CHK_RX_CARRIER_EN_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH3CONF1.Reg) & 0x10000) >> 16
}
func (o *RMT_Type) SetCH3CONF1_REF_ALWAYS_ON_CH0(value uint32) {
	volatile.StoreUint32(&o.CH3CONF1.Reg, volatile.LoadUint32(&o.CH3CONF1.Reg)&^(0x20000)|value<<17)
}
func (o *RMT_Type) GetCH3CONF1_REF_ALWAYS_ON_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH3CONF1.Reg) & 0x20000) >> 17
}
func (o *RMT_Type) SetCH3CONF1_IDLE_OUT_LV_CH0(value uint32) {
	volatile.StoreUint32(&o.CH3CONF1.Reg, volatile.LoadUint32(&o.CH3CONF1.Reg)&^(0x40000)|value<<18)
}
func (o *RMT_Type) GetCH3CONF1_IDLE_OUT_LV_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH3CONF1.Reg) & 0x40000) >> 18
}
func (o *RMT_Type) SetCH3CONF1_IDLE_OUT_EN_CH0(value uint32) {
	volatile.StoreUint32(&o.CH3CONF1.Reg, volatile.LoadUint32(&o.CH3CONF1.Reg)&^(0x80000)|value<<19)
}
func (o *RMT_Type) GetCH3CONF1_IDLE_OUT_EN_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH3CONF1.Reg) & 0x80000) >> 19
}
func (o *RMT_Type) SetCH3CONF1_TX_STOP_CH0(value uint32) {
	volatile.StoreUint32(&o.CH3CONF1.Reg, volatile.LoadUint32(&o.CH3CONF1.Reg)&^(0x100000)|value<<20)
}
func (o *RMT_Type) GetCH3CONF1_TX_STOP_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH3CONF1.Reg) & 0x100000) >> 20
}

// RMT.CH0STATUS: Channel %s status register
func (o *RMT_Type) SetCH0STATUS_MEM_WADDR_EX_CH0(value uint32) {
	volatile.StoreUint32(&o.CH0STATUS.Reg, volatile.LoadUint32(&o.CH0STATUS.Reg)&^(0x1ff)|value)
}
func (o *RMT_Type) GetCH0STATUS_MEM_WADDR_EX_CH0() uint32 {
	return volatile.LoadUint32(&o.CH0STATUS.Reg) & 0x1ff
}
func (o *RMT_Type) SetCH0STATUS_MEM_RADDR_EX_CH0(value uint32) {
	volatile.StoreUint32(&o.CH0STATUS.Reg, volatile.LoadUint32(&o.CH0STATUS.Reg)&^(0x7fc00)|value<<10)
}
func (o *RMT_Type) GetCH0STATUS_MEM_RADDR_EX_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH0STATUS.Reg) & 0x7fc00) >> 10
}
func (o *RMT_Type) SetCH0STATUS_STATE_CH0(value uint32) {
	volatile.StoreUint32(&o.CH0STATUS.Reg, volatile.LoadUint32(&o.CH0STATUS.Reg)&^(0x700000)|value<<20)
}
func (o *RMT_Type) GetCH0STATUS_STATE_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH0STATUS.Reg) & 0x700000) >> 20
}
func (o *RMT_Type) SetCH0STATUS_MEM_OWNER_ERR_CH0(value uint32) {
	volatile.StoreUint32(&o.CH0STATUS.Reg, volatile.LoadUint32(&o.CH0STATUS.Reg)&^(0x800000)|value<<23)
}
func (o *RMT_Type) GetCH0STATUS_MEM_OWNER_ERR_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH0STATUS.Reg) & 0x800000) >> 23
}
func (o *RMT_Type) SetCH0STATUS_MEM_FULL_CH0(value uint32) {
	volatile.StoreUint32(&o.CH0STATUS.Reg, volatile.LoadUint32(&o.CH0STATUS.Reg)&^(0x1000000)|value<<24)
}
func (o *RMT_Type) GetCH0STATUS_MEM_FULL_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH0STATUS.Reg) & 0x1000000) >> 24
}
func (o *RMT_Type) SetCH0STATUS_MEM_EMPTY_CH0(value uint32) {
	volatile.StoreUint32(&o.CH0STATUS.Reg, volatile.LoadUint32(&o.CH0STATUS.Reg)&^(0x2000000)|value<<25)
}
func (o *RMT_Type) GetCH0STATUS_MEM_EMPTY_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH0STATUS.Reg) & 0x2000000) >> 25
}
func (o *RMT_Type) SetCH0STATUS_APB_MEM_WR_ERR_CH0(value uint32) {
	volatile.StoreUint32(&o.CH0STATUS.Reg, volatile.LoadUint32(&o.CH0STATUS.Reg)&^(0x4000000)|value<<26)
}
func (o *RMT_Type) GetCH0STATUS_APB_MEM_WR_ERR_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH0STATUS.Reg) & 0x4000000) >> 26
}
func (o *RMT_Type) SetCH0STATUS_APB_MEM_RD_ERR_CH0(value uint32) {
	volatile.StoreUint32(&o.CH0STATUS.Reg, volatile.LoadUint32(&o.CH0STATUS.Reg)&^(0x8000000)|value<<27)
}
func (o *RMT_Type) GetCH0STATUS_APB_MEM_RD_ERR_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH0STATUS.Reg) & 0x8000000) >> 27
}

// RMT.CH1STATUS: Channel %s status register
func (o *RMT_Type) SetCH1STATUS_MEM_WADDR_EX_CH0(value uint32) {
	volatile.StoreUint32(&o.CH1STATUS.Reg, volatile.LoadUint32(&o.CH1STATUS.Reg)&^(0x1ff)|value)
}
func (o *RMT_Type) GetCH1STATUS_MEM_WADDR_EX_CH0() uint32 {
	return volatile.LoadUint32(&o.CH1STATUS.Reg) & 0x1ff
}
func (o *RMT_Type) SetCH1STATUS_MEM_RADDR_EX_CH0(value uint32) {
	volatile.StoreUint32(&o.CH1STATUS.Reg, volatile.LoadUint32(&o.CH1STATUS.Reg)&^(0x7fc00)|value<<10)
}
func (o *RMT_Type) GetCH1STATUS_MEM_RADDR_EX_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH1STATUS.Reg) & 0x7fc00) >> 10
}
func (o *RMT_Type) SetCH1STATUS_STATE_CH0(value uint32) {
	volatile.StoreUint32(&o.CH1STATUS.Reg, volatile.LoadUint32(&o.CH1STATUS.Reg)&^(0x700000)|value<<20)
}
func (o *RMT_Type) GetCH1STATUS_STATE_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH1STATUS.Reg) & 0x700000) >> 20
}
func (o *RMT_Type) SetCH1STATUS_MEM_OWNER_ERR_CH0(value uint32) {
	volatile.StoreUint32(&o.CH1STATUS.Reg, volatile.LoadUint32(&o.CH1STATUS.Reg)&^(0x800000)|value<<23)
}
func (o *RMT_Type) GetCH1STATUS_MEM_OWNER_ERR_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH1STATUS.Reg) & 0x800000) >> 23
}
func (o *RMT_Type) SetCH1STATUS_MEM_FULL_CH0(value uint32) {
	volatile.StoreUint32(&o.CH1STATUS.Reg, volatile.LoadUint32(&o.CH1STATUS.Reg)&^(0x1000000)|value<<24)
}
func (o *RMT_Type) GetCH1STATUS_MEM_FULL_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH1STATUS.Reg) & 0x1000000) >> 24
}
func (o *RMT_Type) SetCH1STATUS_MEM_EMPTY_CH0(value uint32) {
	volatile.StoreUint32(&o.CH1STATUS.Reg, volatile.LoadUint32(&o.CH1STATUS.Reg)&^(0x2000000)|value<<25)
}
func (o *RMT_Type) GetCH1STATUS_MEM_EMPTY_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH1STATUS.Reg) & 0x2000000) >> 25
}
func (o *RMT_Type) SetCH1STATUS_APB_MEM_WR_ERR_CH0(value uint32) {
	volatile.StoreUint32(&o.CH1STATUS.Reg, volatile.LoadUint32(&o.CH1STATUS.Reg)&^(0x4000000)|value<<26)
}
func (o *RMT_Type) GetCH1STATUS_APB_MEM_WR_ERR_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH1STATUS.Reg) & 0x4000000) >> 26
}
func (o *RMT_Type) SetCH1STATUS_APB_MEM_RD_ERR_CH0(value uint32) {
	volatile.StoreUint32(&o.CH1STATUS.Reg, volatile.LoadUint32(&o.CH1STATUS.Reg)&^(0x8000000)|value<<27)
}
func (o *RMT_Type) GetCH1STATUS_APB_MEM_RD_ERR_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH1STATUS.Reg) & 0x8000000) >> 27
}

// RMT.CH2STATUS: Channel %s status register
func (o *RMT_Type) SetCH2STATUS_MEM_WADDR_EX_CH0(value uint32) {
	volatile.StoreUint32(&o.CH2STATUS.Reg, volatile.LoadUint32(&o.CH2STATUS.Reg)&^(0x1ff)|value)
}
func (o *RMT_Type) GetCH2STATUS_MEM_WADDR_EX_CH0() uint32 {
	return volatile.LoadUint32(&o.CH2STATUS.Reg) & 0x1ff
}
func (o *RMT_Type) SetCH2STATUS_MEM_RADDR_EX_CH0(value uint32) {
	volatile.StoreUint32(&o.CH2STATUS.Reg, volatile.LoadUint32(&o.CH2STATUS.Reg)&^(0x7fc00)|value<<10)
}
func (o *RMT_Type) GetCH2STATUS_MEM_RADDR_EX_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH2STATUS.Reg) & 0x7fc00) >> 10
}
func (o *RMT_Type) SetCH2STATUS_STATE_CH0(value uint32) {
	volatile.StoreUint32(&o.CH2STATUS.Reg, volatile.LoadUint32(&o.CH2STATUS.Reg)&^(0x700000)|value<<20)
}
func (o *RMT_Type) GetCH2STATUS_STATE_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH2STATUS.Reg) & 0x700000) >> 20
}
func (o *RMT_Type) SetCH2STATUS_MEM_OWNER_ERR_CH0(value uint32) {
	volatile.StoreUint32(&o.CH2STATUS.Reg, volatile.LoadUint32(&o.CH2STATUS.Reg)&^(0x800000)|value<<23)
}
func (o *RMT_Type) GetCH2STATUS_MEM_OWNER_ERR_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH2STATUS.Reg) & 0x800000) >> 23
}
func (o *RMT_Type) SetCH2STATUS_MEM_FULL_CH0(value uint32) {
	volatile.StoreUint32(&o.CH2STATUS.Reg, volatile.LoadUint32(&o.CH2STATUS.Reg)&^(0x1000000)|value<<24)
}
func (o *RMT_Type) GetCH2STATUS_MEM_FULL_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH2STATUS.Reg) & 0x1000000) >> 24
}
func (o *RMT_Type) SetCH2STATUS_MEM_EMPTY_CH0(value uint32) {
	volatile.StoreUint32(&o.CH2STATUS.Reg, volatile.LoadUint32(&o.CH2STATUS.Reg)&^(0x2000000)|value<<25)
}
func (o *RMT_Type) GetCH2STATUS_MEM_EMPTY_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH2STATUS.Reg) & 0x2000000) >> 25
}
func (o *RMT_Type) SetCH2STATUS_APB_MEM_WR_ERR_CH0(value uint32) {
	volatile.StoreUint32(&o.CH2STATUS.Reg, volatile.LoadUint32(&o.CH2STATUS.Reg)&^(0x4000000)|value<<26)
}
func (o *RMT_Type) GetCH2STATUS_APB_MEM_WR_ERR_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH2STATUS.Reg) & 0x4000000) >> 26
}
func (o *RMT_Type) SetCH2STATUS_APB_MEM_RD_ERR_CH0(value uint32) {
	volatile.StoreUint32(&o.CH2STATUS.Reg, volatile.LoadUint32(&o.CH2STATUS.Reg)&^(0x8000000)|value<<27)
}
func (o *RMT_Type) GetCH2STATUS_APB_MEM_RD_ERR_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH2STATUS.Reg) & 0x8000000) >> 27
}

// RMT.CH3STATUS: Channel %s status register
func (o *RMT_Type) SetCH3STATUS_MEM_WADDR_EX_CH0(value uint32) {
	volatile.StoreUint32(&o.CH3STATUS.Reg, volatile.LoadUint32(&o.CH3STATUS.Reg)&^(0x1ff)|value)
}
func (o *RMT_Type) GetCH3STATUS_MEM_WADDR_EX_CH0() uint32 {
	return volatile.LoadUint32(&o.CH3STATUS.Reg) & 0x1ff
}
func (o *RMT_Type) SetCH3STATUS_MEM_RADDR_EX_CH0(value uint32) {
	volatile.StoreUint32(&o.CH3STATUS.Reg, volatile.LoadUint32(&o.CH3STATUS.Reg)&^(0x7fc00)|value<<10)
}
func (o *RMT_Type) GetCH3STATUS_MEM_RADDR_EX_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH3STATUS.Reg) & 0x7fc00) >> 10
}
func (o *RMT_Type) SetCH3STATUS_STATE_CH0(value uint32) {
	volatile.StoreUint32(&o.CH3STATUS.Reg, volatile.LoadUint32(&o.CH3STATUS.Reg)&^(0x700000)|value<<20)
}
func (o *RMT_Type) GetCH3STATUS_STATE_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH3STATUS.Reg) & 0x700000) >> 20
}
func (o *RMT_Type) SetCH3STATUS_MEM_OWNER_ERR_CH0(value uint32) {
	volatile.StoreUint32(&o.CH3STATUS.Reg, volatile.LoadUint32(&o.CH3STATUS.Reg)&^(0x800000)|value<<23)
}
func (o *RMT_Type) GetCH3STATUS_MEM_OWNER_ERR_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH3STATUS.Reg) & 0x800000) >> 23
}
func (o *RMT_Type) SetCH3STATUS_MEM_FULL_CH0(value uint32) {
	volatile.StoreUint32(&o.CH3STATUS.Reg, volatile.LoadUint32(&o.CH3STATUS.Reg)&^(0x1000000)|value<<24)
}
func (o *RMT_Type) GetCH3STATUS_MEM_FULL_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH3STATUS.Reg) & 0x1000000) >> 24
}
func (o *RMT_Type) SetCH3STATUS_MEM_EMPTY_CH0(value uint32) {
	volatile.StoreUint32(&o.CH3STATUS.Reg, volatile.LoadUint32(&o.CH3STATUS.Reg)&^(0x2000000)|value<<25)
}
func (o *RMT_Type) GetCH3STATUS_MEM_EMPTY_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH3STATUS.Reg) & 0x2000000) >> 25
}
func (o *RMT_Type) SetCH3STATUS_APB_MEM_WR_ERR_CH0(value uint32) {
	volatile.StoreUint32(&o.CH3STATUS.Reg, volatile.LoadUint32(&o.CH3STATUS.Reg)&^(0x4000000)|value<<26)
}
func (o *RMT_Type) GetCH3STATUS_APB_MEM_WR_ERR_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH3STATUS.Reg) & 0x4000000) >> 26
}
func (o *RMT_Type) SetCH3STATUS_APB_MEM_RD_ERR_CH0(value uint32) {
	volatile.StoreUint32(&o.CH3STATUS.Reg, volatile.LoadUint32(&o.CH3STATUS.Reg)&^(0x8000000)|value<<27)
}
func (o *RMT_Type) GetCH3STATUS_APB_MEM_RD_ERR_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH3STATUS.Reg) & 0x8000000) >> 27
}

// RMT.CH0ADDR: Channel %s address register
func (o *RMT_Type) SetCH0ADDR_APB_MEM_WADDR_CH0(value uint32) {
	volatile.StoreUint32(&o.CH0ADDR.Reg, volatile.LoadUint32(&o.CH0ADDR.Reg)&^(0x1ff)|value)
}
func (o *RMT_Type) GetCH0ADDR_APB_MEM_WADDR_CH0() uint32 {
	return volatile.LoadUint32(&o.CH0ADDR.Reg) & 0x1ff
}
func (o *RMT_Type) SetCH0ADDR_APB_MEM_RADDR_CH0(value uint32) {
	volatile.StoreUint32(&o.CH0ADDR.Reg, volatile.LoadUint32(&o.CH0ADDR.Reg)&^(0x7fc00)|value<<10)
}
func (o *RMT_Type) GetCH0ADDR_APB_MEM_RADDR_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH0ADDR.Reg) & 0x7fc00) >> 10
}

// RMT.CH1ADDR: Channel %s address register
func (o *RMT_Type) SetCH1ADDR_APB_MEM_WADDR_CH0(value uint32) {
	volatile.StoreUint32(&o.CH1ADDR.Reg, volatile.LoadUint32(&o.CH1ADDR.Reg)&^(0x1ff)|value)
}
func (o *RMT_Type) GetCH1ADDR_APB_MEM_WADDR_CH0() uint32 {
	return volatile.LoadUint32(&o.CH1ADDR.Reg) & 0x1ff
}
func (o *RMT_Type) SetCH1ADDR_APB_MEM_RADDR_CH0(value uint32) {
	volatile.StoreUint32(&o.CH1ADDR.Reg, volatile.LoadUint32(&o.CH1ADDR.Reg)&^(0x7fc00)|value<<10)
}
func (o *RMT_Type) GetCH1ADDR_APB_MEM_RADDR_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH1ADDR.Reg) & 0x7fc00) >> 10
}

// RMT.CH2ADDR: Channel %s address register
func (o *RMT_Type) SetCH2ADDR_APB_MEM_WADDR_CH0(value uint32) {
	volatile.StoreUint32(&o.CH2ADDR.Reg, volatile.LoadUint32(&o.CH2ADDR.Reg)&^(0x1ff)|value)
}
func (o *RMT_Type) GetCH2ADDR_APB_MEM_WADDR_CH0() uint32 {
	return volatile.LoadUint32(&o.CH2ADDR.Reg) & 0x1ff
}
func (o *RMT_Type) SetCH2ADDR_APB_MEM_RADDR_CH0(value uint32) {
	volatile.StoreUint32(&o.CH2ADDR.Reg, volatile.LoadUint32(&o.CH2ADDR.Reg)&^(0x7fc00)|value<<10)
}
func (o *RMT_Type) GetCH2ADDR_APB_MEM_RADDR_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH2ADDR.Reg) & 0x7fc00) >> 10
}

// RMT.CH3ADDR: Channel %s address register
func (o *RMT_Type) SetCH3ADDR_APB_MEM_WADDR_CH0(value uint32) {
	volatile.StoreUint32(&o.CH3ADDR.Reg, volatile.LoadUint32(&o.CH3ADDR.Reg)&^(0x1ff)|value)
}
func (o *RMT_Type) GetCH3ADDR_APB_MEM_WADDR_CH0() uint32 {
	return volatile.LoadUint32(&o.CH3ADDR.Reg) & 0x1ff
}
func (o *RMT_Type) SetCH3ADDR_APB_MEM_RADDR_CH0(value uint32) {
	volatile.StoreUint32(&o.CH3ADDR.Reg, volatile.LoadUint32(&o.CH3ADDR.Reg)&^(0x7fc00)|value<<10)
}
func (o *RMT_Type) GetCH3ADDR_APB_MEM_RADDR_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH3ADDR.Reg) & 0x7fc00) >> 10
}

// RMT.INT_RAW: Raw interrupt status
func (o *RMT_Type) SetINT_RAW_CH0_TX_END_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x1)|value)
}
func (o *RMT_Type) GetINT_RAW_CH0_TX_END_INT_RAW() uint32 {
	return volatile.LoadUint32(&o.INT_RAW.Reg) & 0x1
}
func (o *RMT_Type) SetINT_RAW_CH0_RX_END_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x2)|value<<1)
}
func (o *RMT_Type) GetINT_RAW_CH0_RX_END_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x2) >> 1
}
func (o *RMT_Type) SetINT_RAW_CH0_ERR_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x4)|value<<2)
}
func (o *RMT_Type) GetINT_RAW_CH0_ERR_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x4) >> 2
}
func (o *RMT_Type) SetINT_RAW_CH1_TX_END_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x8)|value<<3)
}
func (o *RMT_Type) GetINT_RAW_CH1_TX_END_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x8) >> 3
}
func (o *RMT_Type) SetINT_RAW_CH1_RX_END_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x10)|value<<4)
}
func (o *RMT_Type) GetINT_RAW_CH1_RX_END_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x10) >> 4
}
func (o *RMT_Type) SetINT_RAW_CH1_ERR_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x20)|value<<5)
}
func (o *RMT_Type) GetINT_RAW_CH1_ERR_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x20) >> 5
}
func (o *RMT_Type) SetINT_RAW_CH2_TX_END_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x40)|value<<6)
}
func (o *RMT_Type) GetINT_RAW_CH2_TX_END_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x40) >> 6
}
func (o *RMT_Type) SetINT_RAW_CH2_RX_END_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x80)|value<<7)
}
func (o *RMT_Type) GetINT_RAW_CH2_RX_END_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x80) >> 7
}
func (o *RMT_Type) SetINT_RAW_CH2_ERR_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x100)|value<<8)
}
func (o *RMT_Type) GetINT_RAW_CH2_ERR_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x100) >> 8
}
func (o *RMT_Type) SetINT_RAW_CH3_TX_END_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x200)|value<<9)
}
func (o *RMT_Type) GetINT_RAW_CH3_TX_END_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x200) >> 9
}
func (o *RMT_Type) SetINT_RAW_CH3_RX_END_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x400)|value<<10)
}
func (o *RMT_Type) GetINT_RAW_CH3_RX_END_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x400) >> 10
}
func (o *RMT_Type) SetINT_RAW_CH3_ERR_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x800)|value<<11)
}
func (o *RMT_Type) GetINT_RAW_CH3_ERR_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x800) >> 11
}
func (o *RMT_Type) SetINT_RAW_CH0_TX_THR_EVENT_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x1000)|value<<12)
}
func (o *RMT_Type) GetINT_RAW_CH0_TX_THR_EVENT_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x1000) >> 12
}
func (o *RMT_Type) SetINT_RAW_CH1_TX_THR_EVENT_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x2000)|value<<13)
}
func (o *RMT_Type) GetINT_RAW_CH1_TX_THR_EVENT_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x2000) >> 13
}
func (o *RMT_Type) SetINT_RAW_CH2_TX_THR_EVENT_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x4000)|value<<14)
}
func (o *RMT_Type) GetINT_RAW_CH2_TX_THR_EVENT_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x4000) >> 14
}
func (o *RMT_Type) SetINT_RAW_CH3_TX_THR_EVENT_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x8000)|value<<15)
}
func (o *RMT_Type) GetINT_RAW_CH3_TX_THR_EVENT_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x8000) >> 15
}
func (o *RMT_Type) SetINT_RAW_CH0_TX_LOOP_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x10000)|value<<16)
}
func (o *RMT_Type) GetINT_RAW_CH0_TX_LOOP_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x10000) >> 16
}
func (o *RMT_Type) SetINT_RAW_CH1_TX_LOOP_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x20000)|value<<17)
}
func (o *RMT_Type) GetINT_RAW_CH1_TX_LOOP_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x20000) >> 17
}
func (o *RMT_Type) SetINT_RAW_CH2_TX_LOOP_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x40000)|value<<18)
}
func (o *RMT_Type) GetINT_RAW_CH2_TX_LOOP_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x40000) >> 18
}
func (o *RMT_Type) SetINT_RAW_CH3_TX_LOOP_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x80000)|value<<19)
}
func (o *RMT_Type) GetINT_RAW_CH3_TX_LOOP_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x80000) >> 19
}

// RMT.INT_ST: Masked interrupt status
func (o *RMT_Type) SetINT_ST_CH0_TX_END_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x1)|value)
}
func (o *RMT_Type) GetINT_ST_CH0_TX_END_INT_ST() uint32 {
	return volatile.LoadUint32(&o.INT_ST.Reg) & 0x1
}
func (o *RMT_Type) SetINT_ST_CH0_RX_END_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x2)|value<<1)
}
func (o *RMT_Type) GetINT_ST_CH0_RX_END_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x2) >> 1
}
func (o *RMT_Type) SetINT_ST_CH0_ERR_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x4)|value<<2)
}
func (o *RMT_Type) GetINT_ST_CH0_ERR_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x4) >> 2
}
func (o *RMT_Type) SetINT_ST_CH1_TX_END_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x8)|value<<3)
}
func (o *RMT_Type) GetINT_ST_CH1_TX_END_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x8) >> 3
}
func (o *RMT_Type) SetINT_ST_CH1_RX_END_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x10)|value<<4)
}
func (o *RMT_Type) GetINT_ST_CH1_RX_END_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x10) >> 4
}
func (o *RMT_Type) SetINT_ST_CH1_ERR_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x20)|value<<5)
}
func (o *RMT_Type) GetINT_ST_CH1_ERR_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x20) >> 5
}
func (o *RMT_Type) SetINT_ST_CH2_TX_END_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x40)|value<<6)
}
func (o *RMT_Type) GetINT_ST_CH2_TX_END_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x40) >> 6
}
func (o *RMT_Type) SetINT_ST_CH2_RX_END_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x80)|value<<7)
}
func (o *RMT_Type) GetINT_ST_CH2_RX_END_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x80) >> 7
}
func (o *RMT_Type) SetINT_ST_CH2_ERR_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x100)|value<<8)
}
func (o *RMT_Type) GetINT_ST_CH2_ERR_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x100) >> 8
}
func (o *RMT_Type) SetINT_ST_CH3_TX_END_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x200)|value<<9)
}
func (o *RMT_Type) GetINT_ST_CH3_TX_END_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x200) >> 9
}
func (o *RMT_Type) SetINT_ST_CH3_RX_END_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x400)|value<<10)
}
func (o *RMT_Type) GetINT_ST_CH3_RX_END_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x400) >> 10
}
func (o *RMT_Type) SetINT_ST_CH3_ERR_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x800)|value<<11)
}
func (o *RMT_Type) GetINT_ST_CH3_ERR_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x800) >> 11
}
func (o *RMT_Type) SetINT_ST_CH0_TX_THR_EVENT_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x1000)|value<<12)
}
func (o *RMT_Type) GetINT_ST_CH0_TX_THR_EVENT_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x1000) >> 12
}
func (o *RMT_Type) SetINT_ST_CH1_TX_THR_EVENT_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x2000)|value<<13)
}
func (o *RMT_Type) GetINT_ST_CH1_TX_THR_EVENT_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x2000) >> 13
}
func (o *RMT_Type) SetINT_ST_CH2_TX_THR_EVENT_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x4000)|value<<14)
}
func (o *RMT_Type) GetINT_ST_CH2_TX_THR_EVENT_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x4000) >> 14
}
func (o *RMT_Type) SetINT_ST_CH3_TX_THR_EVENT_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x8000)|value<<15)
}
func (o *RMT_Type) GetINT_ST_CH3_TX_THR_EVENT_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x8000) >> 15
}
func (o *RMT_Type) SetINT_ST_CH0_TX_LOOP_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x10000)|value<<16)
}
func (o *RMT_Type) GetINT_ST_CH0_TX_LOOP_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x10000) >> 16
}
func (o *RMT_Type) SetINT_ST_CH1_TX_LOOP_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x20000)|value<<17)
}
func (o *RMT_Type) GetINT_ST_CH1_TX_LOOP_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x20000) >> 17
}
func (o *RMT_Type) SetINT_ST_CH2_TX_LOOP_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x40000)|value<<18)
}
func (o *RMT_Type) GetINT_ST_CH2_TX_LOOP_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x40000) >> 18
}
func (o *RMT_Type) SetINT_ST_CH3_TX_LOOP_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x80000)|value<<19)
}
func (o *RMT_Type) GetINT_ST_CH3_TX_LOOP_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x80000) >> 19
}

// RMT.INT_ENA: Interrupt enable bits
func (o *RMT_Type) SetINT_ENA_CH0_TX_END_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x1)|value)
}
func (o *RMT_Type) GetINT_ENA_CH0_TX_END_INT_ENA() uint32 {
	return volatile.LoadUint32(&o.INT_ENA.Reg) & 0x1
}
func (o *RMT_Type) SetINT_ENA_CH0_RX_END_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x2)|value<<1)
}
func (o *RMT_Type) GetINT_ENA_CH0_RX_END_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x2) >> 1
}
func (o *RMT_Type) SetINT_ENA_CH0_ERR_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x4)|value<<2)
}
func (o *RMT_Type) GetINT_ENA_CH0_ERR_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x4) >> 2
}
func (o *RMT_Type) SetINT_ENA_CH1_TX_END_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x8)|value<<3)
}
func (o *RMT_Type) GetINT_ENA_CH1_TX_END_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x8) >> 3
}
func (o *RMT_Type) SetINT_ENA_CH1_RX_END_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x10)|value<<4)
}
func (o *RMT_Type) GetINT_ENA_CH1_RX_END_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x10) >> 4
}
func (o *RMT_Type) SetINT_ENA_CH1_ERR_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x20)|value<<5)
}
func (o *RMT_Type) GetINT_ENA_CH1_ERR_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x20) >> 5
}
func (o *RMT_Type) SetINT_ENA_CH2_TX_END_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x40)|value<<6)
}
func (o *RMT_Type) GetINT_ENA_CH2_TX_END_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x40) >> 6
}
func (o *RMT_Type) SetINT_ENA_CH2_RX_END_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x80)|value<<7)
}
func (o *RMT_Type) GetINT_ENA_CH2_RX_END_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x80) >> 7
}
func (o *RMT_Type) SetINT_ENA_CH2_ERR_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x100)|value<<8)
}
func (o *RMT_Type) GetINT_ENA_CH2_ERR_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x100) >> 8
}
func (o *RMT_Type) SetINT_ENA_CH3_TX_END_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x200)|value<<9)
}
func (o *RMT_Type) GetINT_ENA_CH3_TX_END_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x200) >> 9
}
func (o *RMT_Type) SetINT_ENA_CH3_RX_END_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x400)|value<<10)
}
func (o *RMT_Type) GetINT_ENA_CH3_RX_END_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x400) >> 10
}
func (o *RMT_Type) SetINT_ENA_CH3_ERR_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x800)|value<<11)
}
func (o *RMT_Type) GetINT_ENA_CH3_ERR_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x800) >> 11
}
func (o *RMT_Type) SetINT_ENA_CH0_TX_THR_EVENT_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x1000)|value<<12)
}
func (o *RMT_Type) GetINT_ENA_CH0_TX_THR_EVENT_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x1000) >> 12
}
func (o *RMT_Type) SetINT_ENA_CH1_TX_THR_EVENT_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x2000)|value<<13)
}
func (o *RMT_Type) GetINT_ENA_CH1_TX_THR_EVENT_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x2000) >> 13
}
func (o *RMT_Type) SetINT_ENA_CH2_TX_THR_EVENT_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x4000)|value<<14)
}
func (o *RMT_Type) GetINT_ENA_CH2_TX_THR_EVENT_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x4000) >> 14
}
func (o *RMT_Type) SetINT_ENA_CH3_TX_THR_EVENT_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x8000)|value<<15)
}
func (o *RMT_Type) GetINT_ENA_CH3_TX_THR_EVENT_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x8000) >> 15
}
func (o *RMT_Type) SetINT_ENA_CH0_TX_LOOP_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x10000)|value<<16)
}
func (o *RMT_Type) GetINT_ENA_CH0_TX_LOOP_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x10000) >> 16
}
func (o *RMT_Type) SetINT_ENA_CH1_TX_LOOP_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x20000)|value<<17)
}
func (o *RMT_Type) GetINT_ENA_CH1_TX_LOOP_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x20000) >> 17
}
func (o *RMT_Type) SetINT_ENA_CH2_TX_LOOP_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x40000)|value<<18)
}
func (o *RMT_Type) GetINT_ENA_CH2_TX_LOOP_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x40000) >> 18
}
func (o *RMT_Type) SetINT_ENA_CH3_TX_LOOP_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x80000)|value<<19)
}
func (o *RMT_Type) GetINT_ENA_CH3_TX_LOOP_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x80000) >> 19
}

// RMT.INT_CLR: Interrupt clear bits
func (o *RMT_Type) SetINT_CLR_CH0_TX_END_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x1)|value)
}
func (o *RMT_Type) GetINT_CLR_CH0_TX_END_INT_CLR() uint32 {
	return volatile.LoadUint32(&o.INT_CLR.Reg) & 0x1
}
func (o *RMT_Type) SetINT_CLR_CH0_RX_END_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x2)|value<<1)
}
func (o *RMT_Type) GetINT_CLR_CH0_RX_END_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x2) >> 1
}
func (o *RMT_Type) SetINT_CLR_CH0_ERR_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x4)|value<<2)
}
func (o *RMT_Type) GetINT_CLR_CH0_ERR_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x4) >> 2
}
func (o *RMT_Type) SetINT_CLR_CH1_TX_END_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x8)|value<<3)
}
func (o *RMT_Type) GetINT_CLR_CH1_TX_END_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x8) >> 3
}
func (o *RMT_Type) SetINT_CLR_CH1_RX_END_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x10)|value<<4)
}
func (o *RMT_Type) GetINT_CLR_CH1_RX_END_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x10) >> 4
}
func (o *RMT_Type) SetINT_CLR_CH1_ERR_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x20)|value<<5)
}
func (o *RMT_Type) GetINT_CLR_CH1_ERR_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x20) >> 5
}
func (o *RMT_Type) SetINT_CLR_CH2_TX_END_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x40)|value<<6)
}
func (o *RMT_Type) GetINT_CLR_CH2_TX_END_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x40) >> 6
}
func (o *RMT_Type) SetINT_CLR_CH2_RX_END_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x80)|value<<7)
}
func (o *RMT_Type) GetINT_CLR_CH2_RX_END_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x80) >> 7
}
func (o *RMT_Type) SetINT_CLR_CH2_ERR_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x100)|value<<8)
}
func (o *RMT_Type) GetINT_CLR_CH2_ERR_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x100) >> 8
}
func (o *RMT_Type) SetINT_CLR_CH3_TX_END_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x200)|value<<9)
}
func (o *RMT_Type) GetINT_CLR_CH3_TX_END_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x200) >> 9
}
func (o *RMT_Type) SetINT_CLR_CH3_RX_END_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x400)|value<<10)
}
func (o *RMT_Type) GetINT_CLR_CH3_RX_END_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x400) >> 10
}
func (o *RMT_Type) SetINT_CLR_CH3_ERR_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x800)|value<<11)
}
func (o *RMT_Type) GetINT_CLR_CH3_ERR_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x800) >> 11
}
func (o *RMT_Type) SetINT_CLR_CH0_TX_THR_EVENT_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x1000)|value<<12)
}
func (o *RMT_Type) GetINT_CLR_CH0_TX_THR_EVENT_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x1000) >> 12
}
func (o *RMT_Type) SetINT_CLR_CH1_TX_THR_EVENT_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x2000)|value<<13)
}
func (o *RMT_Type) GetINT_CLR_CH1_TX_THR_EVENT_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x2000) >> 13
}
func (o *RMT_Type) SetINT_CLR_CH2_TX_THR_EVENT_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x4000)|value<<14)
}
func (o *RMT_Type) GetINT_CLR_CH2_TX_THR_EVENT_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x4000) >> 14
}
func (o *RMT_Type) SetINT_CLR_CH3_TX_THR_EVENT_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x8000)|value<<15)
}
func (o *RMT_Type) GetINT_CLR_CH3_TX_THR_EVENT_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x8000) >> 15
}
func (o *RMT_Type) SetINT_CLR_CH0_TX_LOOP_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x10000)|value<<16)
}
func (o *RMT_Type) GetINT_CLR_CH0_TX_LOOP_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x10000) >> 16
}
func (o *RMT_Type) SetINT_CLR_CH1_TX_LOOP_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x20000)|value<<17)
}
func (o *RMT_Type) GetINT_CLR_CH1_TX_LOOP_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x20000) >> 17
}
func (o *RMT_Type) SetINT_CLR_CH2_TX_LOOP_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x40000)|value<<18)
}
func (o *RMT_Type) GetINT_CLR_CH2_TX_LOOP_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x40000) >> 18
}
func (o *RMT_Type) SetINT_CLR_CH3_TX_LOOP_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x80000)|value<<19)
}
func (o *RMT_Type) GetINT_CLR_CH3_TX_LOOP_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x80000) >> 19
}

// RMT.CH0CARRIER_DUTY: Channel %s duty cycle configuration register
func (o *RMT_Type) SetCH0CARRIER_DUTY_CARRIER_LOW_CH0(value uint32) {
	volatile.StoreUint32(&o.CH0CARRIER_DUTY.Reg, volatile.LoadUint32(&o.CH0CARRIER_DUTY.Reg)&^(0xffff)|value)
}
func (o *RMT_Type) GetCH0CARRIER_DUTY_CARRIER_LOW_CH0() uint32 {
	return volatile.LoadUint32(&o.CH0CARRIER_DUTY.Reg) & 0xffff
}
func (o *RMT_Type) SetCH0CARRIER_DUTY_CARRIER_HIGH_CH0(value uint32) {
	volatile.StoreUint32(&o.CH0CARRIER_DUTY.Reg, volatile.LoadUint32(&o.CH0CARRIER_DUTY.Reg)&^(0xffff0000)|value<<16)
}
func (o *RMT_Type) GetCH0CARRIER_DUTY_CARRIER_HIGH_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH0CARRIER_DUTY.Reg) & 0xffff0000) >> 16
}

// RMT.CH1CARRIER_DUTY: Channel %s duty cycle configuration register
func (o *RMT_Type) SetCH1CARRIER_DUTY_CARRIER_LOW_CH0(value uint32) {
	volatile.StoreUint32(&o.CH1CARRIER_DUTY.Reg, volatile.LoadUint32(&o.CH1CARRIER_DUTY.Reg)&^(0xffff)|value)
}
func (o *RMT_Type) GetCH1CARRIER_DUTY_CARRIER_LOW_CH0() uint32 {
	return volatile.LoadUint32(&o.CH1CARRIER_DUTY.Reg) & 0xffff
}
func (o *RMT_Type) SetCH1CARRIER_DUTY_CARRIER_HIGH_CH0(value uint32) {
	volatile.StoreUint32(&o.CH1CARRIER_DUTY.Reg, volatile.LoadUint32(&o.CH1CARRIER_DUTY.Reg)&^(0xffff0000)|value<<16)
}
func (o *RMT_Type) GetCH1CARRIER_DUTY_CARRIER_HIGH_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH1CARRIER_DUTY.Reg) & 0xffff0000) >> 16
}

// RMT.CH2CARRIER_DUTY: Channel %s duty cycle configuration register
func (o *RMT_Type) SetCH2CARRIER_DUTY_CARRIER_LOW_CH0(value uint32) {
	volatile.StoreUint32(&o.CH2CARRIER_DUTY.Reg, volatile.LoadUint32(&o.CH2CARRIER_DUTY.Reg)&^(0xffff)|value)
}
func (o *RMT_Type) GetCH2CARRIER_DUTY_CARRIER_LOW_CH0() uint32 {
	return volatile.LoadUint32(&o.CH2CARRIER_DUTY.Reg) & 0xffff
}
func (o *RMT_Type) SetCH2CARRIER_DUTY_CARRIER_HIGH_CH0(value uint32) {
	volatile.StoreUint32(&o.CH2CARRIER_DUTY.Reg, volatile.LoadUint32(&o.CH2CARRIER_DUTY.Reg)&^(0xffff0000)|value<<16)
}
func (o *RMT_Type) GetCH2CARRIER_DUTY_CARRIER_HIGH_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH2CARRIER_DUTY.Reg) & 0xffff0000) >> 16
}

// RMT.CH3CARRIER_DUTY: Channel %s duty cycle configuration register
func (o *RMT_Type) SetCH3CARRIER_DUTY_CARRIER_LOW_CH0(value uint32) {
	volatile.StoreUint32(&o.CH3CARRIER_DUTY.Reg, volatile.LoadUint32(&o.CH3CARRIER_DUTY.Reg)&^(0xffff)|value)
}
func (o *RMT_Type) GetCH3CARRIER_DUTY_CARRIER_LOW_CH0() uint32 {
	return volatile.LoadUint32(&o.CH3CARRIER_DUTY.Reg) & 0xffff
}
func (o *RMT_Type) SetCH3CARRIER_DUTY_CARRIER_HIGH_CH0(value uint32) {
	volatile.StoreUint32(&o.CH3CARRIER_DUTY.Reg, volatile.LoadUint32(&o.CH3CARRIER_DUTY.Reg)&^(0xffff0000)|value<<16)
}
func (o *RMT_Type) GetCH3CARRIER_DUTY_CARRIER_HIGH_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH3CARRIER_DUTY.Reg) & 0xffff0000) >> 16
}

// RMT.CH0_TX_LIM: Channel %s Tx event configuration register
func (o *RMT_Type) SetCH0_TX_LIM_TX_LIM_CH0(value uint32) {
	volatile.StoreUint32(&o.CH0_TX_LIM.Reg, volatile.LoadUint32(&o.CH0_TX_LIM.Reg)&^(0x1ff)|value)
}
func (o *RMT_Type) GetCH0_TX_LIM_TX_LIM_CH0() uint32 {
	return volatile.LoadUint32(&o.CH0_TX_LIM.Reg) & 0x1ff
}
func (o *RMT_Type) SetCH0_TX_LIM_TX_LOOP_NUM_CH0(value uint32) {
	volatile.StoreUint32(&o.CH0_TX_LIM.Reg, volatile.LoadUint32(&o.CH0_TX_LIM.Reg)&^(0x7fe00)|value<<9)
}
func (o *RMT_Type) GetCH0_TX_LIM_TX_LOOP_NUM_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH0_TX_LIM.Reg) & 0x7fe00) >> 9
}
func (o *RMT_Type) SetCH0_TX_LIM_TX_LOOP_CNT_EN_CH0(value uint32) {
	volatile.StoreUint32(&o.CH0_TX_LIM.Reg, volatile.LoadUint32(&o.CH0_TX_LIM.Reg)&^(0x80000)|value<<19)
}
func (o *RMT_Type) GetCH0_TX_LIM_TX_LOOP_CNT_EN_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH0_TX_LIM.Reg) & 0x80000) >> 19
}
func (o *RMT_Type) SetCH0_TX_LIM_LOOP_COUNT_RESET_CH0(value uint32) {
	volatile.StoreUint32(&o.CH0_TX_LIM.Reg, volatile.LoadUint32(&o.CH0_TX_LIM.Reg)&^(0x100000)|value<<20)
}
func (o *RMT_Type) GetCH0_TX_LIM_LOOP_COUNT_RESET_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH0_TX_LIM.Reg) & 0x100000) >> 20
}

// RMT.CH1_TX_LIM: Channel %s Tx event configuration register
func (o *RMT_Type) SetCH1_TX_LIM_TX_LIM_CH0(value uint32) {
	volatile.StoreUint32(&o.CH1_TX_LIM.Reg, volatile.LoadUint32(&o.CH1_TX_LIM.Reg)&^(0x1ff)|value)
}
func (o *RMT_Type) GetCH1_TX_LIM_TX_LIM_CH0() uint32 {
	return volatile.LoadUint32(&o.CH1_TX_LIM.Reg) & 0x1ff
}
func (o *RMT_Type) SetCH1_TX_LIM_TX_LOOP_NUM_CH0(value uint32) {
	volatile.StoreUint32(&o.CH1_TX_LIM.Reg, volatile.LoadUint32(&o.CH1_TX_LIM.Reg)&^(0x7fe00)|value<<9)
}
func (o *RMT_Type) GetCH1_TX_LIM_TX_LOOP_NUM_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH1_TX_LIM.Reg) & 0x7fe00) >> 9
}
func (o *RMT_Type) SetCH1_TX_LIM_TX_LOOP_CNT_EN_CH0(value uint32) {
	volatile.StoreUint32(&o.CH1_TX_LIM.Reg, volatile.LoadUint32(&o.CH1_TX_LIM.Reg)&^(0x80000)|value<<19)
}
func (o *RMT_Type) GetCH1_TX_LIM_TX_LOOP_CNT_EN_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH1_TX_LIM.Reg) & 0x80000) >> 19
}
func (o *RMT_Type) SetCH1_TX_LIM_LOOP_COUNT_RESET_CH0(value uint32) {
	volatile.StoreUint32(&o.CH1_TX_LIM.Reg, volatile.LoadUint32(&o.CH1_TX_LIM.Reg)&^(0x100000)|value<<20)
}
func (o *RMT_Type) GetCH1_TX_LIM_LOOP_COUNT_RESET_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH1_TX_LIM.Reg) & 0x100000) >> 20
}

// RMT.CH2_TX_LIM: Channel %s Tx event configuration register
func (o *RMT_Type) SetCH2_TX_LIM_TX_LIM_CH0(value uint32) {
	volatile.StoreUint32(&o.CH2_TX_LIM.Reg, volatile.LoadUint32(&o.CH2_TX_LIM.Reg)&^(0x1ff)|value)
}
func (o *RMT_Type) GetCH2_TX_LIM_TX_LIM_CH0() uint32 {
	return volatile.LoadUint32(&o.CH2_TX_LIM.Reg) & 0x1ff
}
func (o *RMT_Type) SetCH2_TX_LIM_TX_LOOP_NUM_CH0(value uint32) {
	volatile.StoreUint32(&o.CH2_TX_LIM.Reg, volatile.LoadUint32(&o.CH2_TX_LIM.Reg)&^(0x7fe00)|value<<9)
}
func (o *RMT_Type) GetCH2_TX_LIM_TX_LOOP_NUM_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH2_TX_LIM.Reg) & 0x7fe00) >> 9
}
func (o *RMT_Type) SetCH2_TX_LIM_TX_LOOP_CNT_EN_CH0(value uint32) {
	volatile.StoreUint32(&o.CH2_TX_LIM.Reg, volatile.LoadUint32(&o.CH2_TX_LIM.Reg)&^(0x80000)|value<<19)
}
func (o *RMT_Type) GetCH2_TX_LIM_TX_LOOP_CNT_EN_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH2_TX_LIM.Reg) & 0x80000) >> 19
}
func (o *RMT_Type) SetCH2_TX_LIM_LOOP_COUNT_RESET_CH0(value uint32) {
	volatile.StoreUint32(&o.CH2_TX_LIM.Reg, volatile.LoadUint32(&o.CH2_TX_LIM.Reg)&^(0x100000)|value<<20)
}
func (o *RMT_Type) GetCH2_TX_LIM_LOOP_COUNT_RESET_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH2_TX_LIM.Reg) & 0x100000) >> 20
}

// RMT.CH3_TX_LIM: Channel %s Tx event configuration register
func (o *RMT_Type) SetCH3_TX_LIM_TX_LIM_CH0(value uint32) {
	volatile.StoreUint32(&o.CH3_TX_LIM.Reg, volatile.LoadUint32(&o.CH3_TX_LIM.Reg)&^(0x1ff)|value)
}
func (o *RMT_Type) GetCH3_TX_LIM_TX_LIM_CH0() uint32 {
	return volatile.LoadUint32(&o.CH3_TX_LIM.Reg) & 0x1ff
}
func (o *RMT_Type) SetCH3_TX_LIM_TX_LOOP_NUM_CH0(value uint32) {
	volatile.StoreUint32(&o.CH3_TX_LIM.Reg, volatile.LoadUint32(&o.CH3_TX_LIM.Reg)&^(0x7fe00)|value<<9)
}
func (o *RMT_Type) GetCH3_TX_LIM_TX_LOOP_NUM_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH3_TX_LIM.Reg) & 0x7fe00) >> 9
}
func (o *RMT_Type) SetCH3_TX_LIM_TX_LOOP_CNT_EN_CH0(value uint32) {
	volatile.StoreUint32(&o.CH3_TX_LIM.Reg, volatile.LoadUint32(&o.CH3_TX_LIM.Reg)&^(0x80000)|value<<19)
}
func (o *RMT_Type) GetCH3_TX_LIM_TX_LOOP_CNT_EN_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH3_TX_LIM.Reg) & 0x80000) >> 19
}
func (o *RMT_Type) SetCH3_TX_LIM_LOOP_COUNT_RESET_CH0(value uint32) {
	volatile.StoreUint32(&o.CH3_TX_LIM.Reg, volatile.LoadUint32(&o.CH3_TX_LIM.Reg)&^(0x100000)|value<<20)
}
func (o *RMT_Type) GetCH3_TX_LIM_LOOP_COUNT_RESET_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH3_TX_LIM.Reg) & 0x100000) >> 20
}

// RMT.APB_CONF: RMT apb configuration register
func (o *RMT_Type) SetAPB_CONF_APB_FIFO_MASK(value uint32) {
	volatile.StoreUint32(&o.APB_CONF.Reg, volatile.LoadUint32(&o.APB_CONF.Reg)&^(0x1)|value)
}
func (o *RMT_Type) GetAPB_CONF_APB_FIFO_MASK() uint32 {
	return volatile.LoadUint32(&o.APB_CONF.Reg) & 0x1
}
func (o *RMT_Type) SetAPB_CONF_MEM_TX_WRAP_EN(value uint32) {
	volatile.StoreUint32(&o.APB_CONF.Reg, volatile.LoadUint32(&o.APB_CONF.Reg)&^(0x2)|value<<1)
}
func (o *RMT_Type) GetAPB_CONF_MEM_TX_WRAP_EN() uint32 {
	return (volatile.LoadUint32(&o.APB_CONF.Reg) & 0x2) >> 1
}
func (o *RMT_Type) SetAPB_CONF_MEM_CLK_FORCE_ON(value uint32) {
	volatile.StoreUint32(&o.APB_CONF.Reg, volatile.LoadUint32(&o.APB_CONF.Reg)&^(0x4)|value<<2)
}
func (o *RMT_Type) GetAPB_CONF_MEM_CLK_FORCE_ON() uint32 {
	return (volatile.LoadUint32(&o.APB_CONF.Reg) & 0x4) >> 2
}
func (o *RMT_Type) SetAPB_CONF_MEM_FORCE_PD(value uint32) {
	volatile.StoreUint32(&o.APB_CONF.Reg, volatile.LoadUint32(&o.APB_CONF.Reg)&^(0x8)|value<<3)
}
func (o *RMT_Type) GetAPB_CONF_MEM_FORCE_PD() uint32 {
	return (volatile.LoadUint32(&o.APB_CONF.Reg) & 0x8) >> 3
}
func (o *RMT_Type) SetAPB_CONF_MEM_FORCE_PU(value uint32) {
	volatile.StoreUint32(&o.APB_CONF.Reg, volatile.LoadUint32(&o.APB_CONF.Reg)&^(0x10)|value<<4)
}
func (o *RMT_Type) GetAPB_CONF_MEM_FORCE_PU() uint32 {
	return (volatile.LoadUint32(&o.APB_CONF.Reg) & 0x10) >> 4
}
func (o *RMT_Type) SetAPB_CONF_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.APB_CONF.Reg, volatile.LoadUint32(&o.APB_CONF.Reg)&^(0x80000000)|value<<31)
}
func (o *RMT_Type) GetAPB_CONF_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.APB_CONF.Reg) & 0x80000000) >> 31
}

// RMT.TX_SIM: RMT TX synchronous register
func (o *RMT_Type) SetTX_SIM_CH0(value uint32) {
	volatile.StoreUint32(&o.TX_SIM.Reg, volatile.LoadUint32(&o.TX_SIM.Reg)&^(0x1)|value)
}
func (o *RMT_Type) GetTX_SIM_CH0() uint32 {
	return volatile.LoadUint32(&o.TX_SIM.Reg) & 0x1
}
func (o *RMT_Type) SetTX_SIM_CH1(value uint32) {
	volatile.StoreUint32(&o.TX_SIM.Reg, volatile.LoadUint32(&o.TX_SIM.Reg)&^(0x2)|value<<1)
}
func (o *RMT_Type) GetTX_SIM_CH1() uint32 {
	return (volatile.LoadUint32(&o.TX_SIM.Reg) & 0x2) >> 1
}
func (o *RMT_Type) SetTX_SIM_CH2(value uint32) {
	volatile.StoreUint32(&o.TX_SIM.Reg, volatile.LoadUint32(&o.TX_SIM.Reg)&^(0x4)|value<<2)
}
func (o *RMT_Type) GetTX_SIM_CH2() uint32 {
	return (volatile.LoadUint32(&o.TX_SIM.Reg) & 0x4) >> 2
}
func (o *RMT_Type) SetTX_SIM_CH3(value uint32) {
	volatile.StoreUint32(&o.TX_SIM.Reg, volatile.LoadUint32(&o.TX_SIM.Reg)&^(0x8)|value<<3)
}
func (o *RMT_Type) GetTX_SIM_CH3() uint32 {
	return (volatile.LoadUint32(&o.TX_SIM.Reg) & 0x8) >> 3
}
func (o *RMT_Type) SetTX_SIM_EN(value uint32) {
	volatile.StoreUint32(&o.TX_SIM.Reg, volatile.LoadUint32(&o.TX_SIM.Reg)&^(0x10)|value<<4)
}
func (o *RMT_Type) GetTX_SIM_EN() uint32 {
	return (volatile.LoadUint32(&o.TX_SIM.Reg) & 0x10) >> 4
}

// RMT.REF_CNT_RST: RMT clock divider reset register
func (o *RMT_Type) SetREF_CNT_RST_CH0(value uint32) {
	volatile.StoreUint32(&o.REF_CNT_RST.Reg, volatile.LoadUint32(&o.REF_CNT_RST.Reg)&^(0x1)|value)
}
func (o *RMT_Type) GetREF_CNT_RST_CH0() uint32 {
	return volatile.LoadUint32(&o.REF_CNT_RST.Reg) & 0x1
}
func (o *RMT_Type) SetREF_CNT_RST_CH1(value uint32) {
	volatile.StoreUint32(&o.REF_CNT_RST.Reg, volatile.LoadUint32(&o.REF_CNT_RST.Reg)&^(0x2)|value<<1)
}
func (o *RMT_Type) GetREF_CNT_RST_CH1() uint32 {
	return (volatile.LoadUint32(&o.REF_CNT_RST.Reg) & 0x2) >> 1
}
func (o *RMT_Type) SetREF_CNT_RST_CH2(value uint32) {
	volatile.StoreUint32(&o.REF_CNT_RST.Reg, volatile.LoadUint32(&o.REF_CNT_RST.Reg)&^(0x4)|value<<2)
}
func (o *RMT_Type) GetREF_CNT_RST_CH2() uint32 {
	return (volatile.LoadUint32(&o.REF_CNT_RST.Reg) & 0x4) >> 2
}
func (o *RMT_Type) SetREF_CNT_RST_CH3(value uint32) {
	volatile.StoreUint32(&o.REF_CNT_RST.Reg, volatile.LoadUint32(&o.REF_CNT_RST.Reg)&^(0x8)|value<<3)
}
func (o *RMT_Type) GetREF_CNT_RST_CH3() uint32 {
	return (volatile.LoadUint32(&o.REF_CNT_RST.Reg) & 0x8) >> 3
}

// RMT.CH0_RX_CARRIER_RM: Channel %s carrier remove register
func (o *RMT_Type) SetCH0_RX_CARRIER_RM_CARRIER_LOW_THRES_CH0(value uint32) {
	volatile.StoreUint32(&o.CH0_RX_CARRIER_RM.Reg, volatile.LoadUint32(&o.CH0_RX_CARRIER_RM.Reg)&^(0xffff)|value)
}
func (o *RMT_Type) GetCH0_RX_CARRIER_RM_CARRIER_LOW_THRES_CH0() uint32 {
	return volatile.LoadUint32(&o.CH0_RX_CARRIER_RM.Reg) & 0xffff
}
func (o *RMT_Type) SetCH0_RX_CARRIER_RM_CARRIER_HIGH_THRES_CH0(value uint32) {
	volatile.StoreUint32(&o.CH0_RX_CARRIER_RM.Reg, volatile.LoadUint32(&o.CH0_RX_CARRIER_RM.Reg)&^(0xffff0000)|value<<16)
}
func (o *RMT_Type) GetCH0_RX_CARRIER_RM_CARRIER_HIGH_THRES_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH0_RX_CARRIER_RM.Reg) & 0xffff0000) >> 16
}

// RMT.CH1_RX_CARRIER_RM: Channel %s carrier remove register
func (o *RMT_Type) SetCH1_RX_CARRIER_RM_CARRIER_LOW_THRES_CH0(value uint32) {
	volatile.StoreUint32(&o.CH1_RX_CARRIER_RM.Reg, volatile.LoadUint32(&o.CH1_RX_CARRIER_RM.Reg)&^(0xffff)|value)
}
func (o *RMT_Type) GetCH1_RX_CARRIER_RM_CARRIER_LOW_THRES_CH0() uint32 {
	return volatile.LoadUint32(&o.CH1_RX_CARRIER_RM.Reg) & 0xffff
}
func (o *RMT_Type) SetCH1_RX_CARRIER_RM_CARRIER_HIGH_THRES_CH0(value uint32) {
	volatile.StoreUint32(&o.CH1_RX_CARRIER_RM.Reg, volatile.LoadUint32(&o.CH1_RX_CARRIER_RM.Reg)&^(0xffff0000)|value<<16)
}
func (o *RMT_Type) GetCH1_RX_CARRIER_RM_CARRIER_HIGH_THRES_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH1_RX_CARRIER_RM.Reg) & 0xffff0000) >> 16
}

// RMT.CH2_RX_CARRIER_RM: Channel %s carrier remove register
func (o *RMT_Type) SetCH2_RX_CARRIER_RM_CARRIER_LOW_THRES_CH0(value uint32) {
	volatile.StoreUint32(&o.CH2_RX_CARRIER_RM.Reg, volatile.LoadUint32(&o.CH2_RX_CARRIER_RM.Reg)&^(0xffff)|value)
}
func (o *RMT_Type) GetCH2_RX_CARRIER_RM_CARRIER_LOW_THRES_CH0() uint32 {
	return volatile.LoadUint32(&o.CH2_RX_CARRIER_RM.Reg) & 0xffff
}
func (o *RMT_Type) SetCH2_RX_CARRIER_RM_CARRIER_HIGH_THRES_CH0(value uint32) {
	volatile.StoreUint32(&o.CH2_RX_CARRIER_RM.Reg, volatile.LoadUint32(&o.CH2_RX_CARRIER_RM.Reg)&^(0xffff0000)|value<<16)
}
func (o *RMT_Type) GetCH2_RX_CARRIER_RM_CARRIER_HIGH_THRES_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH2_RX_CARRIER_RM.Reg) & 0xffff0000) >> 16
}

// RMT.CH3_RX_CARRIER_RM: Channel %s carrier remove register
func (o *RMT_Type) SetCH3_RX_CARRIER_RM_CARRIER_LOW_THRES_CH0(value uint32) {
	volatile.StoreUint32(&o.CH3_RX_CARRIER_RM.Reg, volatile.LoadUint32(&o.CH3_RX_CARRIER_RM.Reg)&^(0xffff)|value)
}
func (o *RMT_Type) GetCH3_RX_CARRIER_RM_CARRIER_LOW_THRES_CH0() uint32 {
	return volatile.LoadUint32(&o.CH3_RX_CARRIER_RM.Reg) & 0xffff
}
func (o *RMT_Type) SetCH3_RX_CARRIER_RM_CARRIER_HIGH_THRES_CH0(value uint32) {
	volatile.StoreUint32(&o.CH3_RX_CARRIER_RM.Reg, volatile.LoadUint32(&o.CH3_RX_CARRIER_RM.Reg)&^(0xffff0000)|value<<16)
}
func (o *RMT_Type) GetCH3_RX_CARRIER_RM_CARRIER_HIGH_THRES_CH0() uint32 {
	return (volatile.LoadUint32(&o.CH3_RX_CARRIER_RM.Reg) & 0xffff0000) >> 16
}

// RMT.DATE: RMT version register
func (o *RMT_Type) SetDATE(value uint32) {
	volatile.StoreUint32(&o.DATE.Reg, value)
}
func (o *RMT_Type) GetDATE() uint32 {
	return volatile.LoadUint32(&o.DATE.Reg)
}

// Peripheral RSA
type RSA_Type struct {
	_               [2048]byte
	M_PRIME         volatile.Register32 // 0x800
	MODE            volatile.Register32 // 0x804
	CLEAN           volatile.Register32 // 0x808
	MODEXP_START    volatile.Register32 // 0x80C
	MODMULT_START   volatile.Register32 // 0x810
	MULT_START      volatile.Register32 // 0x814
	IDLE            volatile.Register32 // 0x818
	CLEAR_INTERRUPT volatile.Register32 // 0x81C
	CONSTANT_TIME   volatile.Register32 // 0x820
	SEARCH_ENABLE   volatile.Register32 // 0x824
	SEARCH_POS      volatile.Register32 // 0x828
	INTERRUPT_ENA   volatile.Register32 // 0x82C
	DATE            volatile.Register32 // 0x830
}

// RSA.M_PRIME: Register to store M'
func (o *RSA_Type) SetM_PRIME(value uint32) {
	volatile.StoreUint32(&o.M_PRIME.Reg, value)
}
func (o *RSA_Type) GetM_PRIME() uint32 {
	return volatile.LoadUint32(&o.M_PRIME.Reg)
}

// RSA.MODE: RSA length mode
func (o *RSA_Type) SetMODE(value uint32) {
	volatile.StoreUint32(&o.MODE.Reg, volatile.LoadUint32(&o.MODE.Reg)&^(0x7f)|value)
}
func (o *RSA_Type) GetMODE() uint32 {
	return volatile.LoadUint32(&o.MODE.Reg) & 0x7f
}

// RSA.CLEAN: RSA clean register
func (o *RSA_Type) SetCLEAN(value uint32) {
	volatile.StoreUint32(&o.CLEAN.Reg, volatile.LoadUint32(&o.CLEAN.Reg)&^(0x1)|value)
}
func (o *RSA_Type) GetCLEAN() uint32 {
	return volatile.LoadUint32(&o.CLEAN.Reg) & 0x1
}

// RSA.MODEXP_START: Modular exponentiation starting bit
func (o *RSA_Type) SetMODEXP_START(value uint32) {
	volatile.StoreUint32(&o.MODEXP_START.Reg, volatile.LoadUint32(&o.MODEXP_START.Reg)&^(0x1)|value)
}
func (o *RSA_Type) GetMODEXP_START() uint32 {
	return volatile.LoadUint32(&o.MODEXP_START.Reg) & 0x1
}

// RSA.MODMULT_START: Modular multiplication starting bit
func (o *RSA_Type) SetMODMULT_START(value uint32) {
	volatile.StoreUint32(&o.MODMULT_START.Reg, volatile.LoadUint32(&o.MODMULT_START.Reg)&^(0x1)|value)
}
func (o *RSA_Type) GetMODMULT_START() uint32 {
	return volatile.LoadUint32(&o.MODMULT_START.Reg) & 0x1
}

// RSA.MULT_START: Normal multiplicaiton starting bit
func (o *RSA_Type) SetMULT_START(value uint32) {
	volatile.StoreUint32(&o.MULT_START.Reg, volatile.LoadUint32(&o.MULT_START.Reg)&^(0x1)|value)
}
func (o *RSA_Type) GetMULT_START() uint32 {
	return volatile.LoadUint32(&o.MULT_START.Reg) & 0x1
}

// RSA.IDLE: RSA idle register
func (o *RSA_Type) SetIDLE(value uint32) {
	volatile.StoreUint32(&o.IDLE.Reg, volatile.LoadUint32(&o.IDLE.Reg)&^(0x1)|value)
}
func (o *RSA_Type) GetIDLE() uint32 {
	return volatile.LoadUint32(&o.IDLE.Reg) & 0x1
}

// RSA.CLEAR_INTERRUPT: RSA clear interrupt register
func (o *RSA_Type) SetCLEAR_INTERRUPT(value uint32) {
	volatile.StoreUint32(&o.CLEAR_INTERRUPT.Reg, volatile.LoadUint32(&o.CLEAR_INTERRUPT.Reg)&^(0x1)|value)
}
func (o *RSA_Type) GetCLEAR_INTERRUPT() uint32 {
	return volatile.LoadUint32(&o.CLEAR_INTERRUPT.Reg) & 0x1
}

// RSA.CONSTANT_TIME: The constant_time option
func (o *RSA_Type) SetCONSTANT_TIME(value uint32) {
	volatile.StoreUint32(&o.CONSTANT_TIME.Reg, volatile.LoadUint32(&o.CONSTANT_TIME.Reg)&^(0x1)|value)
}
func (o *RSA_Type) GetCONSTANT_TIME() uint32 {
	return volatile.LoadUint32(&o.CONSTANT_TIME.Reg) & 0x1
}

// RSA.SEARCH_ENABLE: The search option
func (o *RSA_Type) SetSEARCH_ENABLE(value uint32) {
	volatile.StoreUint32(&o.SEARCH_ENABLE.Reg, volatile.LoadUint32(&o.SEARCH_ENABLE.Reg)&^(0x1)|value)
}
func (o *RSA_Type) GetSEARCH_ENABLE() uint32 {
	return volatile.LoadUint32(&o.SEARCH_ENABLE.Reg) & 0x1
}

// RSA.SEARCH_POS: The search position
func (o *RSA_Type) SetSEARCH_POS(value uint32) {
	volatile.StoreUint32(&o.SEARCH_POS.Reg, volatile.LoadUint32(&o.SEARCH_POS.Reg)&^(0xfff)|value)
}
func (o *RSA_Type) GetSEARCH_POS() uint32 {
	return volatile.LoadUint32(&o.SEARCH_POS.Reg) & 0xfff
}

// RSA.INTERRUPT_ENA: RSA interrupt enable register
func (o *RSA_Type) SetINTERRUPT_ENA(value uint32) {
	volatile.StoreUint32(&o.INTERRUPT_ENA.Reg, volatile.LoadUint32(&o.INTERRUPT_ENA.Reg)&^(0x1)|value)
}
func (o *RSA_Type) GetINTERRUPT_ENA() uint32 {
	return volatile.LoadUint32(&o.INTERRUPT_ENA.Reg) & 0x1
}

// RSA.DATE: Version control register
func (o *RSA_Type) SetDATE(value uint32) {
	volatile.StoreUint32(&o.DATE.Reg, volatile.LoadUint32(&o.DATE.Reg)&^(0x3fffffff)|value)
}
func (o *RSA_Type) GetDATE() uint32 {
	return volatile.LoadUint32(&o.DATE.Reg) & 0x3fffffff
}

// Peripheral RTCIO
type RTCIO_Type struct {
	RTC_GPIO_OUT         volatile.Register32 // 0x0
	RTC_GPIO_OUT_W1TS    volatile.Register32 // 0x4
	RTC_GPIO_OUT_W1TC    volatile.Register32 // 0x8
	RTC_GPIO_ENABLE      volatile.Register32 // 0xC
	RTC_GPIO_ENABLE_W1TS volatile.Register32 // 0x10
	RTC_GPIO_ENABLE_W1TC volatile.Register32 // 0x14
	RTC_GPIO_STATUS      volatile.Register32 // 0x18
	RTC_GPIO_STATUS_W1TS volatile.Register32 // 0x1C
	RTC_GPIO_STATUS_W1TC volatile.Register32 // 0x20
	RTC_GPIO_IN          volatile.Register32 // 0x24
	RTC_GPIO_PIN0        volatile.Register32 // 0x28
	RTC_GPIO_PIN1        volatile.Register32 // 0x2C
	RTC_GPIO_PIN2        volatile.Register32 // 0x30
	RTC_GPIO_PIN3        volatile.Register32 // 0x34
	RTC_GPIO_PIN4        volatile.Register32 // 0x38
	RTC_GPIO_PIN5        volatile.Register32 // 0x3C
	RTC_GPIO_PIN6        volatile.Register32 // 0x40
	RTC_GPIO_PIN7        volatile.Register32 // 0x44
	RTC_GPIO_PIN8        volatile.Register32 // 0x48
	RTC_GPIO_PIN9        volatile.Register32 // 0x4C
	RTC_GPIO_PIN10       volatile.Register32 // 0x50
	RTC_GPIO_PIN11       volatile.Register32 // 0x54
	RTC_GPIO_PIN12       volatile.Register32 // 0x58
	RTC_GPIO_PIN13       volatile.Register32 // 0x5C
	RTC_GPIO_PIN14       volatile.Register32 // 0x60
	RTC_GPIO_PIN15       volatile.Register32 // 0x64
	RTC_GPIO_PIN16       volatile.Register32 // 0x68
	RTC_GPIO_PIN17       volatile.Register32 // 0x6C
	RTC_GPIO_PIN18       volatile.Register32 // 0x70
	RTC_GPIO_PIN19       volatile.Register32 // 0x74
	RTC_GPIO_PIN20       volatile.Register32 // 0x78
	RTC_GPIO_PIN21       volatile.Register32 // 0x7C
	RTC_DEBUG_SEL        volatile.Register32 // 0x80
	TOUCH_PAD0           volatile.Register32 // 0x84
	TOUCH_PAD1           volatile.Register32 // 0x88
	TOUCH_PAD2           volatile.Register32 // 0x8C
	TOUCH_PAD3           volatile.Register32 // 0x90
	TOUCH_PAD4           volatile.Register32 // 0x94
	TOUCH_PAD5           volatile.Register32 // 0x98
	TOUCH_PAD6           volatile.Register32 // 0x9C
	TOUCH_PAD7           volatile.Register32 // 0xA0
	TOUCH_PAD8           volatile.Register32 // 0xA4
	TOUCH_PAD9           volatile.Register32 // 0xA8
	TOUCH_PAD10          volatile.Register32 // 0xAC
	TOUCH_PAD11          volatile.Register32 // 0xB0
	TOUCH_PAD12          volatile.Register32 // 0xB4
	TOUCH_PAD13          volatile.Register32 // 0xB8
	TOUCH_PAD14          volatile.Register32 // 0xBC
	XTAL_32P_PAD         volatile.Register32 // 0xC0
	XTAL_32N_PAD         volatile.Register32 // 0xC4
	PAD_DAC1             volatile.Register32 // 0xC8
	PAD_DAC2             volatile.Register32 // 0xCC
	RTC_PAD19            volatile.Register32 // 0xD0
	RTC_PAD20            volatile.Register32 // 0xD4
	RTC_PAD21            volatile.Register32 // 0xD8
	EXT_WAKEUP0          volatile.Register32 // 0xDC
	XTL_EXT_CTR          volatile.Register32 // 0xE0
	SAR_I2C_IO           volatile.Register32 // 0xE4
	RTC_IO_TOUCH_CTRL    volatile.Register32 // 0xE8
	_                    [272]byte
	RTC_IO_DATE          volatile.Register32 // 0x1FC
}

// RTCIO.RTC_GPIO_OUT: RTC GPIO output register
func (o *RTCIO_Type) SetRTC_GPIO_OUT_GPIO_OUT_DATA(value uint32) {
	volatile.StoreUint32(&o.RTC_GPIO_OUT.Reg, volatile.LoadUint32(&o.RTC_GPIO_OUT.Reg)&^(0xfffffc00)|value<<10)
}
func (o *RTCIO_Type) GetRTC_GPIO_OUT_GPIO_OUT_DATA() uint32 {
	return (volatile.LoadUint32(&o.RTC_GPIO_OUT.Reg) & 0xfffffc00) >> 10
}

// RTCIO.RTC_GPIO_OUT_W1TS: RTC GPIO output bit set register
func (o *RTCIO_Type) SetRTC_GPIO_OUT_W1TS_GPIO_OUT_DATA_W1TS(value uint32) {
	volatile.StoreUint32(&o.RTC_GPIO_OUT_W1TS.Reg, volatile.LoadUint32(&o.RTC_GPIO_OUT_W1TS.Reg)&^(0xfffffc00)|value<<10)
}
func (o *RTCIO_Type) GetRTC_GPIO_OUT_W1TS_GPIO_OUT_DATA_W1TS() uint32 {
	return (volatile.LoadUint32(&o.RTC_GPIO_OUT_W1TS.Reg) & 0xfffffc00) >> 10
}

// RTCIO.RTC_GPIO_OUT_W1TC: RTC GPIO output bit clear register
func (o *RTCIO_Type) SetRTC_GPIO_OUT_W1TC_GPIO_OUT_DATA_W1TC(value uint32) {
	volatile.StoreUint32(&o.RTC_GPIO_OUT_W1TC.Reg, volatile.LoadUint32(&o.RTC_GPIO_OUT_W1TC.Reg)&^(0xfffffc00)|value<<10)
}
func (o *RTCIO_Type) GetRTC_GPIO_OUT_W1TC_GPIO_OUT_DATA_W1TC() uint32 {
	return (volatile.LoadUint32(&o.RTC_GPIO_OUT_W1TC.Reg) & 0xfffffc00) >> 10
}

// RTCIO.RTC_GPIO_ENABLE: RTC GPIO output enable register
func (o *RTCIO_Type) SetRTC_GPIO_ENABLE_REG_RTCIO_REG_GPIO_ENABLE(value uint32) {
	volatile.StoreUint32(&o.RTC_GPIO_ENABLE.Reg, volatile.LoadUint32(&o.RTC_GPIO_ENABLE.Reg)&^(0xfffffc00)|value<<10)
}
func (o *RTCIO_Type) GetRTC_GPIO_ENABLE_REG_RTCIO_REG_GPIO_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.RTC_GPIO_ENABLE.Reg) & 0xfffffc00) >> 10
}

// RTCIO.RTC_GPIO_ENABLE_W1TS: RTC GPIO output enable bit set register
func (o *RTCIO_Type) SetRTC_GPIO_ENABLE_W1TS_REG_RTCIO_REG_GPIO_ENABLE_W1TS(value uint32) {
	volatile.StoreUint32(&o.RTC_GPIO_ENABLE_W1TS.Reg, volatile.LoadUint32(&o.RTC_GPIO_ENABLE_W1TS.Reg)&^(0xfffffc00)|value<<10)
}
func (o *RTCIO_Type) GetRTC_GPIO_ENABLE_W1TS_REG_RTCIO_REG_GPIO_ENABLE_W1TS() uint32 {
	return (volatile.LoadUint32(&o.RTC_GPIO_ENABLE_W1TS.Reg) & 0xfffffc00) >> 10
}

// RTCIO.RTC_GPIO_ENABLE_W1TC: RTC GPIO output enable bit clear register
func (o *RTCIO_Type) SetRTC_GPIO_ENABLE_W1TC_REG_RTCIO_REG_GPIO_ENABLE_W1TC(value uint32) {
	volatile.StoreUint32(&o.RTC_GPIO_ENABLE_W1TC.Reg, volatile.LoadUint32(&o.RTC_GPIO_ENABLE_W1TC.Reg)&^(0xfffffc00)|value<<10)
}
func (o *RTCIO_Type) GetRTC_GPIO_ENABLE_W1TC_REG_RTCIO_REG_GPIO_ENABLE_W1TC() uint32 {
	return (volatile.LoadUint32(&o.RTC_GPIO_ENABLE_W1TC.Reg) & 0xfffffc00) >> 10
}

// RTCIO.RTC_GPIO_STATUS: RTC GPIO interrupt status register
func (o *RTCIO_Type) SetRTC_GPIO_STATUS_GPIO_STATUS_INT(value uint32) {
	volatile.StoreUint32(&o.RTC_GPIO_STATUS.Reg, volatile.LoadUint32(&o.RTC_GPIO_STATUS.Reg)&^(0xfffffc00)|value<<10)
}
func (o *RTCIO_Type) GetRTC_GPIO_STATUS_GPIO_STATUS_INT() uint32 {
	return (volatile.LoadUint32(&o.RTC_GPIO_STATUS.Reg) & 0xfffffc00) >> 10
}

// RTCIO.RTC_GPIO_STATUS_W1TS: RTC GPIO interrupt status bit set register
func (o *RTCIO_Type) SetRTC_GPIO_STATUS_W1TS_GPIO_STATUS_INT_W1TS(value uint32) {
	volatile.StoreUint32(&o.RTC_GPIO_STATUS_W1TS.Reg, volatile.LoadUint32(&o.RTC_GPIO_STATUS_W1TS.Reg)&^(0xfffffc00)|value<<10)
}
func (o *RTCIO_Type) GetRTC_GPIO_STATUS_W1TS_GPIO_STATUS_INT_W1TS() uint32 {
	return (volatile.LoadUint32(&o.RTC_GPIO_STATUS_W1TS.Reg) & 0xfffffc00) >> 10
}

// RTCIO.RTC_GPIO_STATUS_W1TC: RTC GPIO interrupt status bit clear register
func (o *RTCIO_Type) SetRTC_GPIO_STATUS_W1TC_GPIO_STATUS_INT_W1TC(value uint32) {
	volatile.StoreUint32(&o.RTC_GPIO_STATUS_W1TC.Reg, volatile.LoadUint32(&o.RTC_GPIO_STATUS_W1TC.Reg)&^(0xfffffc00)|value<<10)
}
func (o *RTCIO_Type) GetRTC_GPIO_STATUS_W1TC_GPIO_STATUS_INT_W1TC() uint32 {
	return (volatile.LoadUint32(&o.RTC_GPIO_STATUS_W1TC.Reg) & 0xfffffc00) >> 10
}

// RTCIO.RTC_GPIO_IN: RTC GPIO input register
func (o *RTCIO_Type) SetRTC_GPIO_IN_GPIO_IN_NEXT(value uint32) {
	volatile.StoreUint32(&o.RTC_GPIO_IN.Reg, volatile.LoadUint32(&o.RTC_GPIO_IN.Reg)&^(0xfffffc00)|value<<10)
}
func (o *RTCIO_Type) GetRTC_GPIO_IN_GPIO_IN_NEXT() uint32 {
	return (volatile.LoadUint32(&o.RTC_GPIO_IN.Reg) & 0xfffffc00) >> 10
}

// RTCIO.RTC_GPIO_PIN0: RTC configuration for pin %s
func (o *RTCIO_Type) SetRTC_GPIO_PIN0_GPIO_PIN0_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.RTC_GPIO_PIN0.Reg, volatile.LoadUint32(&o.RTC_GPIO_PIN0.Reg)&^(0x4)|value<<2)
}
func (o *RTCIO_Type) GetRTC_GPIO_PIN0_GPIO_PIN0_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.RTC_GPIO_PIN0.Reg) & 0x4) >> 2
}
func (o *RTCIO_Type) SetRTC_GPIO_PIN0_GPIO_PIN0_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.RTC_GPIO_PIN0.Reg, volatile.LoadUint32(&o.RTC_GPIO_PIN0.Reg)&^(0x380)|value<<7)
}
func (o *RTCIO_Type) GetRTC_GPIO_PIN0_GPIO_PIN0_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.RTC_GPIO_PIN0.Reg) & 0x380) >> 7
}
func (o *RTCIO_Type) SetRTC_GPIO_PIN0_GPIO_PIN0_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.RTC_GPIO_PIN0.Reg, volatile.LoadUint32(&o.RTC_GPIO_PIN0.Reg)&^(0x400)|value<<10)
}
func (o *RTCIO_Type) GetRTC_GPIO_PIN0_GPIO_PIN0_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.RTC_GPIO_PIN0.Reg) & 0x400) >> 10
}

// RTCIO.RTC_GPIO_PIN1: RTC configuration for pin %s
func (o *RTCIO_Type) SetRTC_GPIO_PIN1_GPIO_PIN0_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.RTC_GPIO_PIN1.Reg, volatile.LoadUint32(&o.RTC_GPIO_PIN1.Reg)&^(0x4)|value<<2)
}
func (o *RTCIO_Type) GetRTC_GPIO_PIN1_GPIO_PIN0_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.RTC_GPIO_PIN1.Reg) & 0x4) >> 2
}
func (o *RTCIO_Type) SetRTC_GPIO_PIN1_GPIO_PIN0_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.RTC_GPIO_PIN1.Reg, volatile.LoadUint32(&o.RTC_GPIO_PIN1.Reg)&^(0x380)|value<<7)
}
func (o *RTCIO_Type) GetRTC_GPIO_PIN1_GPIO_PIN0_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.RTC_GPIO_PIN1.Reg) & 0x380) >> 7
}
func (o *RTCIO_Type) SetRTC_GPIO_PIN1_GPIO_PIN0_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.RTC_GPIO_PIN1.Reg, volatile.LoadUint32(&o.RTC_GPIO_PIN1.Reg)&^(0x400)|value<<10)
}
func (o *RTCIO_Type) GetRTC_GPIO_PIN1_GPIO_PIN0_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.RTC_GPIO_PIN1.Reg) & 0x400) >> 10
}

// RTCIO.RTC_GPIO_PIN2: RTC configuration for pin %s
func (o *RTCIO_Type) SetRTC_GPIO_PIN2_GPIO_PIN0_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.RTC_GPIO_PIN2.Reg, volatile.LoadUint32(&o.RTC_GPIO_PIN2.Reg)&^(0x4)|value<<2)
}
func (o *RTCIO_Type) GetRTC_GPIO_PIN2_GPIO_PIN0_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.RTC_GPIO_PIN2.Reg) & 0x4) >> 2
}
func (o *RTCIO_Type) SetRTC_GPIO_PIN2_GPIO_PIN0_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.RTC_GPIO_PIN2.Reg, volatile.LoadUint32(&o.RTC_GPIO_PIN2.Reg)&^(0x380)|value<<7)
}
func (o *RTCIO_Type) GetRTC_GPIO_PIN2_GPIO_PIN0_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.RTC_GPIO_PIN2.Reg) & 0x380) >> 7
}
func (o *RTCIO_Type) SetRTC_GPIO_PIN2_GPIO_PIN0_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.RTC_GPIO_PIN2.Reg, volatile.LoadUint32(&o.RTC_GPIO_PIN2.Reg)&^(0x400)|value<<10)
}
func (o *RTCIO_Type) GetRTC_GPIO_PIN2_GPIO_PIN0_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.RTC_GPIO_PIN2.Reg) & 0x400) >> 10
}

// RTCIO.RTC_GPIO_PIN3: RTC configuration for pin %s
func (o *RTCIO_Type) SetRTC_GPIO_PIN3_GPIO_PIN0_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.RTC_GPIO_PIN3.Reg, volatile.LoadUint32(&o.RTC_GPIO_PIN3.Reg)&^(0x4)|value<<2)
}
func (o *RTCIO_Type) GetRTC_GPIO_PIN3_GPIO_PIN0_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.RTC_GPIO_PIN3.Reg) & 0x4) >> 2
}
func (o *RTCIO_Type) SetRTC_GPIO_PIN3_GPIO_PIN0_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.RTC_GPIO_PIN3.Reg, volatile.LoadUint32(&o.RTC_GPIO_PIN3.Reg)&^(0x380)|value<<7)
}
func (o *RTCIO_Type) GetRTC_GPIO_PIN3_GPIO_PIN0_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.RTC_GPIO_PIN3.Reg) & 0x380) >> 7
}
func (o *RTCIO_Type) SetRTC_GPIO_PIN3_GPIO_PIN0_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.RTC_GPIO_PIN3.Reg, volatile.LoadUint32(&o.RTC_GPIO_PIN3.Reg)&^(0x400)|value<<10)
}
func (o *RTCIO_Type) GetRTC_GPIO_PIN3_GPIO_PIN0_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.RTC_GPIO_PIN3.Reg) & 0x400) >> 10
}

// RTCIO.RTC_GPIO_PIN4: RTC configuration for pin %s
func (o *RTCIO_Type) SetRTC_GPIO_PIN4_GPIO_PIN0_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.RTC_GPIO_PIN4.Reg, volatile.LoadUint32(&o.RTC_GPIO_PIN4.Reg)&^(0x4)|value<<2)
}
func (o *RTCIO_Type) GetRTC_GPIO_PIN4_GPIO_PIN0_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.RTC_GPIO_PIN4.Reg) & 0x4) >> 2
}
func (o *RTCIO_Type) SetRTC_GPIO_PIN4_GPIO_PIN0_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.RTC_GPIO_PIN4.Reg, volatile.LoadUint32(&o.RTC_GPIO_PIN4.Reg)&^(0x380)|value<<7)
}
func (o *RTCIO_Type) GetRTC_GPIO_PIN4_GPIO_PIN0_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.RTC_GPIO_PIN4.Reg) & 0x380) >> 7
}
func (o *RTCIO_Type) SetRTC_GPIO_PIN4_GPIO_PIN0_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.RTC_GPIO_PIN4.Reg, volatile.LoadUint32(&o.RTC_GPIO_PIN4.Reg)&^(0x400)|value<<10)
}
func (o *RTCIO_Type) GetRTC_GPIO_PIN4_GPIO_PIN0_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.RTC_GPIO_PIN4.Reg) & 0x400) >> 10
}

// RTCIO.RTC_GPIO_PIN5: RTC configuration for pin %s
func (o *RTCIO_Type) SetRTC_GPIO_PIN5_GPIO_PIN0_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.RTC_GPIO_PIN5.Reg, volatile.LoadUint32(&o.RTC_GPIO_PIN5.Reg)&^(0x4)|value<<2)
}
func (o *RTCIO_Type) GetRTC_GPIO_PIN5_GPIO_PIN0_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.RTC_GPIO_PIN5.Reg) & 0x4) >> 2
}
func (o *RTCIO_Type) SetRTC_GPIO_PIN5_GPIO_PIN0_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.RTC_GPIO_PIN5.Reg, volatile.LoadUint32(&o.RTC_GPIO_PIN5.Reg)&^(0x380)|value<<7)
}
func (o *RTCIO_Type) GetRTC_GPIO_PIN5_GPIO_PIN0_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.RTC_GPIO_PIN5.Reg) & 0x380) >> 7
}
func (o *RTCIO_Type) SetRTC_GPIO_PIN5_GPIO_PIN0_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.RTC_GPIO_PIN5.Reg, volatile.LoadUint32(&o.RTC_GPIO_PIN5.Reg)&^(0x400)|value<<10)
}
func (o *RTCIO_Type) GetRTC_GPIO_PIN5_GPIO_PIN0_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.RTC_GPIO_PIN5.Reg) & 0x400) >> 10
}

// RTCIO.RTC_GPIO_PIN6: RTC configuration for pin %s
func (o *RTCIO_Type) SetRTC_GPIO_PIN6_GPIO_PIN0_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.RTC_GPIO_PIN6.Reg, volatile.LoadUint32(&o.RTC_GPIO_PIN6.Reg)&^(0x4)|value<<2)
}
func (o *RTCIO_Type) GetRTC_GPIO_PIN6_GPIO_PIN0_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.RTC_GPIO_PIN6.Reg) & 0x4) >> 2
}
func (o *RTCIO_Type) SetRTC_GPIO_PIN6_GPIO_PIN0_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.RTC_GPIO_PIN6.Reg, volatile.LoadUint32(&o.RTC_GPIO_PIN6.Reg)&^(0x380)|value<<7)
}
func (o *RTCIO_Type) GetRTC_GPIO_PIN6_GPIO_PIN0_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.RTC_GPIO_PIN6.Reg) & 0x380) >> 7
}
func (o *RTCIO_Type) SetRTC_GPIO_PIN6_GPIO_PIN0_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.RTC_GPIO_PIN6.Reg, volatile.LoadUint32(&o.RTC_GPIO_PIN6.Reg)&^(0x400)|value<<10)
}
func (o *RTCIO_Type) GetRTC_GPIO_PIN6_GPIO_PIN0_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.RTC_GPIO_PIN6.Reg) & 0x400) >> 10
}

// RTCIO.RTC_GPIO_PIN7: RTC configuration for pin %s
func (o *RTCIO_Type) SetRTC_GPIO_PIN7_GPIO_PIN0_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.RTC_GPIO_PIN7.Reg, volatile.LoadUint32(&o.RTC_GPIO_PIN7.Reg)&^(0x4)|value<<2)
}
func (o *RTCIO_Type) GetRTC_GPIO_PIN7_GPIO_PIN0_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.RTC_GPIO_PIN7.Reg) & 0x4) >> 2
}
func (o *RTCIO_Type) SetRTC_GPIO_PIN7_GPIO_PIN0_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.RTC_GPIO_PIN7.Reg, volatile.LoadUint32(&o.RTC_GPIO_PIN7.Reg)&^(0x380)|value<<7)
}
func (o *RTCIO_Type) GetRTC_GPIO_PIN7_GPIO_PIN0_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.RTC_GPIO_PIN7.Reg) & 0x380) >> 7
}
func (o *RTCIO_Type) SetRTC_GPIO_PIN7_GPIO_PIN0_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.RTC_GPIO_PIN7.Reg, volatile.LoadUint32(&o.RTC_GPIO_PIN7.Reg)&^(0x400)|value<<10)
}
func (o *RTCIO_Type) GetRTC_GPIO_PIN7_GPIO_PIN0_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.RTC_GPIO_PIN7.Reg) & 0x400) >> 10
}

// RTCIO.RTC_GPIO_PIN8: RTC configuration for pin %s
func (o *RTCIO_Type) SetRTC_GPIO_PIN8_GPIO_PIN0_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.RTC_GPIO_PIN8.Reg, volatile.LoadUint32(&o.RTC_GPIO_PIN8.Reg)&^(0x4)|value<<2)
}
func (o *RTCIO_Type) GetRTC_GPIO_PIN8_GPIO_PIN0_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.RTC_GPIO_PIN8.Reg) & 0x4) >> 2
}
func (o *RTCIO_Type) SetRTC_GPIO_PIN8_GPIO_PIN0_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.RTC_GPIO_PIN8.Reg, volatile.LoadUint32(&o.RTC_GPIO_PIN8.Reg)&^(0x380)|value<<7)
}
func (o *RTCIO_Type) GetRTC_GPIO_PIN8_GPIO_PIN0_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.RTC_GPIO_PIN8.Reg) & 0x380) >> 7
}
func (o *RTCIO_Type) SetRTC_GPIO_PIN8_GPIO_PIN0_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.RTC_GPIO_PIN8.Reg, volatile.LoadUint32(&o.RTC_GPIO_PIN8.Reg)&^(0x400)|value<<10)
}
func (o *RTCIO_Type) GetRTC_GPIO_PIN8_GPIO_PIN0_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.RTC_GPIO_PIN8.Reg) & 0x400) >> 10
}

// RTCIO.RTC_GPIO_PIN9: RTC configuration for pin %s
func (o *RTCIO_Type) SetRTC_GPIO_PIN9_GPIO_PIN0_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.RTC_GPIO_PIN9.Reg, volatile.LoadUint32(&o.RTC_GPIO_PIN9.Reg)&^(0x4)|value<<2)
}
func (o *RTCIO_Type) GetRTC_GPIO_PIN9_GPIO_PIN0_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.RTC_GPIO_PIN9.Reg) & 0x4) >> 2
}
func (o *RTCIO_Type) SetRTC_GPIO_PIN9_GPIO_PIN0_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.RTC_GPIO_PIN9.Reg, volatile.LoadUint32(&o.RTC_GPIO_PIN9.Reg)&^(0x380)|value<<7)
}
func (o *RTCIO_Type) GetRTC_GPIO_PIN9_GPIO_PIN0_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.RTC_GPIO_PIN9.Reg) & 0x380) >> 7
}
func (o *RTCIO_Type) SetRTC_GPIO_PIN9_GPIO_PIN0_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.RTC_GPIO_PIN9.Reg, volatile.LoadUint32(&o.RTC_GPIO_PIN9.Reg)&^(0x400)|value<<10)
}
func (o *RTCIO_Type) GetRTC_GPIO_PIN9_GPIO_PIN0_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.RTC_GPIO_PIN9.Reg) & 0x400) >> 10
}

// RTCIO.RTC_GPIO_PIN10: RTC configuration for pin %s
func (o *RTCIO_Type) SetRTC_GPIO_PIN10_GPIO_PIN0_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.RTC_GPIO_PIN10.Reg, volatile.LoadUint32(&o.RTC_GPIO_PIN10.Reg)&^(0x4)|value<<2)
}
func (o *RTCIO_Type) GetRTC_GPIO_PIN10_GPIO_PIN0_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.RTC_GPIO_PIN10.Reg) & 0x4) >> 2
}
func (o *RTCIO_Type) SetRTC_GPIO_PIN10_GPIO_PIN0_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.RTC_GPIO_PIN10.Reg, volatile.LoadUint32(&o.RTC_GPIO_PIN10.Reg)&^(0x380)|value<<7)
}
func (o *RTCIO_Type) GetRTC_GPIO_PIN10_GPIO_PIN0_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.RTC_GPIO_PIN10.Reg) & 0x380) >> 7
}
func (o *RTCIO_Type) SetRTC_GPIO_PIN10_GPIO_PIN0_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.RTC_GPIO_PIN10.Reg, volatile.LoadUint32(&o.RTC_GPIO_PIN10.Reg)&^(0x400)|value<<10)
}
func (o *RTCIO_Type) GetRTC_GPIO_PIN10_GPIO_PIN0_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.RTC_GPIO_PIN10.Reg) & 0x400) >> 10
}

// RTCIO.RTC_GPIO_PIN11: RTC configuration for pin %s
func (o *RTCIO_Type) SetRTC_GPIO_PIN11_GPIO_PIN0_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.RTC_GPIO_PIN11.Reg, volatile.LoadUint32(&o.RTC_GPIO_PIN11.Reg)&^(0x4)|value<<2)
}
func (o *RTCIO_Type) GetRTC_GPIO_PIN11_GPIO_PIN0_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.RTC_GPIO_PIN11.Reg) & 0x4) >> 2
}
func (o *RTCIO_Type) SetRTC_GPIO_PIN11_GPIO_PIN0_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.RTC_GPIO_PIN11.Reg, volatile.LoadUint32(&o.RTC_GPIO_PIN11.Reg)&^(0x380)|value<<7)
}
func (o *RTCIO_Type) GetRTC_GPIO_PIN11_GPIO_PIN0_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.RTC_GPIO_PIN11.Reg) & 0x380) >> 7
}
func (o *RTCIO_Type) SetRTC_GPIO_PIN11_GPIO_PIN0_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.RTC_GPIO_PIN11.Reg, volatile.LoadUint32(&o.RTC_GPIO_PIN11.Reg)&^(0x400)|value<<10)
}
func (o *RTCIO_Type) GetRTC_GPIO_PIN11_GPIO_PIN0_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.RTC_GPIO_PIN11.Reg) & 0x400) >> 10
}

// RTCIO.RTC_GPIO_PIN12: RTC configuration for pin %s
func (o *RTCIO_Type) SetRTC_GPIO_PIN12_GPIO_PIN0_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.RTC_GPIO_PIN12.Reg, volatile.LoadUint32(&o.RTC_GPIO_PIN12.Reg)&^(0x4)|value<<2)
}
func (o *RTCIO_Type) GetRTC_GPIO_PIN12_GPIO_PIN0_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.RTC_GPIO_PIN12.Reg) & 0x4) >> 2
}
func (o *RTCIO_Type) SetRTC_GPIO_PIN12_GPIO_PIN0_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.RTC_GPIO_PIN12.Reg, volatile.LoadUint32(&o.RTC_GPIO_PIN12.Reg)&^(0x380)|value<<7)
}
func (o *RTCIO_Type) GetRTC_GPIO_PIN12_GPIO_PIN0_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.RTC_GPIO_PIN12.Reg) & 0x380) >> 7
}
func (o *RTCIO_Type) SetRTC_GPIO_PIN12_GPIO_PIN0_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.RTC_GPIO_PIN12.Reg, volatile.LoadUint32(&o.RTC_GPIO_PIN12.Reg)&^(0x400)|value<<10)
}
func (o *RTCIO_Type) GetRTC_GPIO_PIN12_GPIO_PIN0_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.RTC_GPIO_PIN12.Reg) & 0x400) >> 10
}

// RTCIO.RTC_GPIO_PIN13: RTC configuration for pin %s
func (o *RTCIO_Type) SetRTC_GPIO_PIN13_GPIO_PIN0_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.RTC_GPIO_PIN13.Reg, volatile.LoadUint32(&o.RTC_GPIO_PIN13.Reg)&^(0x4)|value<<2)
}
func (o *RTCIO_Type) GetRTC_GPIO_PIN13_GPIO_PIN0_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.RTC_GPIO_PIN13.Reg) & 0x4) >> 2
}
func (o *RTCIO_Type) SetRTC_GPIO_PIN13_GPIO_PIN0_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.RTC_GPIO_PIN13.Reg, volatile.LoadUint32(&o.RTC_GPIO_PIN13.Reg)&^(0x380)|value<<7)
}
func (o *RTCIO_Type) GetRTC_GPIO_PIN13_GPIO_PIN0_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.RTC_GPIO_PIN13.Reg) & 0x380) >> 7
}
func (o *RTCIO_Type) SetRTC_GPIO_PIN13_GPIO_PIN0_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.RTC_GPIO_PIN13.Reg, volatile.LoadUint32(&o.RTC_GPIO_PIN13.Reg)&^(0x400)|value<<10)
}
func (o *RTCIO_Type) GetRTC_GPIO_PIN13_GPIO_PIN0_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.RTC_GPIO_PIN13.Reg) & 0x400) >> 10
}

// RTCIO.RTC_GPIO_PIN14: RTC configuration for pin %s
func (o *RTCIO_Type) SetRTC_GPIO_PIN14_GPIO_PIN0_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.RTC_GPIO_PIN14.Reg, volatile.LoadUint32(&o.RTC_GPIO_PIN14.Reg)&^(0x4)|value<<2)
}
func (o *RTCIO_Type) GetRTC_GPIO_PIN14_GPIO_PIN0_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.RTC_GPIO_PIN14.Reg) & 0x4) >> 2
}
func (o *RTCIO_Type) SetRTC_GPIO_PIN14_GPIO_PIN0_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.RTC_GPIO_PIN14.Reg, volatile.LoadUint32(&o.RTC_GPIO_PIN14.Reg)&^(0x380)|value<<7)
}
func (o *RTCIO_Type) GetRTC_GPIO_PIN14_GPIO_PIN0_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.RTC_GPIO_PIN14.Reg) & 0x380) >> 7
}
func (o *RTCIO_Type) SetRTC_GPIO_PIN14_GPIO_PIN0_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.RTC_GPIO_PIN14.Reg, volatile.LoadUint32(&o.RTC_GPIO_PIN14.Reg)&^(0x400)|value<<10)
}
func (o *RTCIO_Type) GetRTC_GPIO_PIN14_GPIO_PIN0_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.RTC_GPIO_PIN14.Reg) & 0x400) >> 10
}

// RTCIO.RTC_GPIO_PIN15: RTC configuration for pin %s
func (o *RTCIO_Type) SetRTC_GPIO_PIN15_GPIO_PIN0_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.RTC_GPIO_PIN15.Reg, volatile.LoadUint32(&o.RTC_GPIO_PIN15.Reg)&^(0x4)|value<<2)
}
func (o *RTCIO_Type) GetRTC_GPIO_PIN15_GPIO_PIN0_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.RTC_GPIO_PIN15.Reg) & 0x4) >> 2
}
func (o *RTCIO_Type) SetRTC_GPIO_PIN15_GPIO_PIN0_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.RTC_GPIO_PIN15.Reg, volatile.LoadUint32(&o.RTC_GPIO_PIN15.Reg)&^(0x380)|value<<7)
}
func (o *RTCIO_Type) GetRTC_GPIO_PIN15_GPIO_PIN0_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.RTC_GPIO_PIN15.Reg) & 0x380) >> 7
}
func (o *RTCIO_Type) SetRTC_GPIO_PIN15_GPIO_PIN0_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.RTC_GPIO_PIN15.Reg, volatile.LoadUint32(&o.RTC_GPIO_PIN15.Reg)&^(0x400)|value<<10)
}
func (o *RTCIO_Type) GetRTC_GPIO_PIN15_GPIO_PIN0_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.RTC_GPIO_PIN15.Reg) & 0x400) >> 10
}

// RTCIO.RTC_GPIO_PIN16: RTC configuration for pin %s
func (o *RTCIO_Type) SetRTC_GPIO_PIN16_GPIO_PIN0_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.RTC_GPIO_PIN16.Reg, volatile.LoadUint32(&o.RTC_GPIO_PIN16.Reg)&^(0x4)|value<<2)
}
func (o *RTCIO_Type) GetRTC_GPIO_PIN16_GPIO_PIN0_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.RTC_GPIO_PIN16.Reg) & 0x4) >> 2
}
func (o *RTCIO_Type) SetRTC_GPIO_PIN16_GPIO_PIN0_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.RTC_GPIO_PIN16.Reg, volatile.LoadUint32(&o.RTC_GPIO_PIN16.Reg)&^(0x380)|value<<7)
}
func (o *RTCIO_Type) GetRTC_GPIO_PIN16_GPIO_PIN0_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.RTC_GPIO_PIN16.Reg) & 0x380) >> 7
}
func (o *RTCIO_Type) SetRTC_GPIO_PIN16_GPIO_PIN0_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.RTC_GPIO_PIN16.Reg, volatile.LoadUint32(&o.RTC_GPIO_PIN16.Reg)&^(0x400)|value<<10)
}
func (o *RTCIO_Type) GetRTC_GPIO_PIN16_GPIO_PIN0_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.RTC_GPIO_PIN16.Reg) & 0x400) >> 10
}

// RTCIO.RTC_GPIO_PIN17: RTC configuration for pin %s
func (o *RTCIO_Type) SetRTC_GPIO_PIN17_GPIO_PIN0_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.RTC_GPIO_PIN17.Reg, volatile.LoadUint32(&o.RTC_GPIO_PIN17.Reg)&^(0x4)|value<<2)
}
func (o *RTCIO_Type) GetRTC_GPIO_PIN17_GPIO_PIN0_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.RTC_GPIO_PIN17.Reg) & 0x4) >> 2
}
func (o *RTCIO_Type) SetRTC_GPIO_PIN17_GPIO_PIN0_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.RTC_GPIO_PIN17.Reg, volatile.LoadUint32(&o.RTC_GPIO_PIN17.Reg)&^(0x380)|value<<7)
}
func (o *RTCIO_Type) GetRTC_GPIO_PIN17_GPIO_PIN0_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.RTC_GPIO_PIN17.Reg) & 0x380) >> 7
}
func (o *RTCIO_Type) SetRTC_GPIO_PIN17_GPIO_PIN0_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.RTC_GPIO_PIN17.Reg, volatile.LoadUint32(&o.RTC_GPIO_PIN17.Reg)&^(0x400)|value<<10)
}
func (o *RTCIO_Type) GetRTC_GPIO_PIN17_GPIO_PIN0_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.RTC_GPIO_PIN17.Reg) & 0x400) >> 10
}

// RTCIO.RTC_GPIO_PIN18: RTC configuration for pin %s
func (o *RTCIO_Type) SetRTC_GPIO_PIN18_GPIO_PIN0_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.RTC_GPIO_PIN18.Reg, volatile.LoadUint32(&o.RTC_GPIO_PIN18.Reg)&^(0x4)|value<<2)
}
func (o *RTCIO_Type) GetRTC_GPIO_PIN18_GPIO_PIN0_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.RTC_GPIO_PIN18.Reg) & 0x4) >> 2
}
func (o *RTCIO_Type) SetRTC_GPIO_PIN18_GPIO_PIN0_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.RTC_GPIO_PIN18.Reg, volatile.LoadUint32(&o.RTC_GPIO_PIN18.Reg)&^(0x380)|value<<7)
}
func (o *RTCIO_Type) GetRTC_GPIO_PIN18_GPIO_PIN0_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.RTC_GPIO_PIN18.Reg) & 0x380) >> 7
}
func (o *RTCIO_Type) SetRTC_GPIO_PIN18_GPIO_PIN0_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.RTC_GPIO_PIN18.Reg, volatile.LoadUint32(&o.RTC_GPIO_PIN18.Reg)&^(0x400)|value<<10)
}
func (o *RTCIO_Type) GetRTC_GPIO_PIN18_GPIO_PIN0_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.RTC_GPIO_PIN18.Reg) & 0x400) >> 10
}

// RTCIO.RTC_GPIO_PIN19: RTC configuration for pin %s
func (o *RTCIO_Type) SetRTC_GPIO_PIN19_GPIO_PIN0_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.RTC_GPIO_PIN19.Reg, volatile.LoadUint32(&o.RTC_GPIO_PIN19.Reg)&^(0x4)|value<<2)
}
func (o *RTCIO_Type) GetRTC_GPIO_PIN19_GPIO_PIN0_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.RTC_GPIO_PIN19.Reg) & 0x4) >> 2
}
func (o *RTCIO_Type) SetRTC_GPIO_PIN19_GPIO_PIN0_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.RTC_GPIO_PIN19.Reg, volatile.LoadUint32(&o.RTC_GPIO_PIN19.Reg)&^(0x380)|value<<7)
}
func (o *RTCIO_Type) GetRTC_GPIO_PIN19_GPIO_PIN0_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.RTC_GPIO_PIN19.Reg) & 0x380) >> 7
}
func (o *RTCIO_Type) SetRTC_GPIO_PIN19_GPIO_PIN0_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.RTC_GPIO_PIN19.Reg, volatile.LoadUint32(&o.RTC_GPIO_PIN19.Reg)&^(0x400)|value<<10)
}
func (o *RTCIO_Type) GetRTC_GPIO_PIN19_GPIO_PIN0_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.RTC_GPIO_PIN19.Reg) & 0x400) >> 10
}

// RTCIO.RTC_GPIO_PIN20: RTC configuration for pin %s
func (o *RTCIO_Type) SetRTC_GPIO_PIN20_GPIO_PIN0_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.RTC_GPIO_PIN20.Reg, volatile.LoadUint32(&o.RTC_GPIO_PIN20.Reg)&^(0x4)|value<<2)
}
func (o *RTCIO_Type) GetRTC_GPIO_PIN20_GPIO_PIN0_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.RTC_GPIO_PIN20.Reg) & 0x4) >> 2
}
func (o *RTCIO_Type) SetRTC_GPIO_PIN20_GPIO_PIN0_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.RTC_GPIO_PIN20.Reg, volatile.LoadUint32(&o.RTC_GPIO_PIN20.Reg)&^(0x380)|value<<7)
}
func (o *RTCIO_Type) GetRTC_GPIO_PIN20_GPIO_PIN0_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.RTC_GPIO_PIN20.Reg) & 0x380) >> 7
}
func (o *RTCIO_Type) SetRTC_GPIO_PIN20_GPIO_PIN0_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.RTC_GPIO_PIN20.Reg, volatile.LoadUint32(&o.RTC_GPIO_PIN20.Reg)&^(0x400)|value<<10)
}
func (o *RTCIO_Type) GetRTC_GPIO_PIN20_GPIO_PIN0_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.RTC_GPIO_PIN20.Reg) & 0x400) >> 10
}

// RTCIO.RTC_GPIO_PIN21: RTC configuration for pin %s
func (o *RTCIO_Type) SetRTC_GPIO_PIN21_GPIO_PIN0_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.RTC_GPIO_PIN21.Reg, volatile.LoadUint32(&o.RTC_GPIO_PIN21.Reg)&^(0x4)|value<<2)
}
func (o *RTCIO_Type) GetRTC_GPIO_PIN21_GPIO_PIN0_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.RTC_GPIO_PIN21.Reg) & 0x4) >> 2
}
func (o *RTCIO_Type) SetRTC_GPIO_PIN21_GPIO_PIN0_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.RTC_GPIO_PIN21.Reg, volatile.LoadUint32(&o.RTC_GPIO_PIN21.Reg)&^(0x380)|value<<7)
}
func (o *RTCIO_Type) GetRTC_GPIO_PIN21_GPIO_PIN0_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.RTC_GPIO_PIN21.Reg) & 0x380) >> 7
}
func (o *RTCIO_Type) SetRTC_GPIO_PIN21_GPIO_PIN0_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.RTC_GPIO_PIN21.Reg, volatile.LoadUint32(&o.RTC_GPIO_PIN21.Reg)&^(0x400)|value<<10)
}
func (o *RTCIO_Type) GetRTC_GPIO_PIN21_GPIO_PIN0_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.RTC_GPIO_PIN21.Reg) & 0x400) >> 10
}

// RTCIO.RTC_DEBUG_SEL: RTC debug select register
func (o *RTCIO_Type) SetRTC_DEBUG_SEL_RTC_DEBUG_SEL0(value uint32) {
	volatile.StoreUint32(&o.RTC_DEBUG_SEL.Reg, volatile.LoadUint32(&o.RTC_DEBUG_SEL.Reg)&^(0x1f)|value)
}
func (o *RTCIO_Type) GetRTC_DEBUG_SEL_RTC_DEBUG_SEL0() uint32 {
	return volatile.LoadUint32(&o.RTC_DEBUG_SEL.Reg) & 0x1f
}
func (o *RTCIO_Type) SetRTC_DEBUG_SEL_RTC_DEBUG_SEL1(value uint32) {
	volatile.StoreUint32(&o.RTC_DEBUG_SEL.Reg, volatile.LoadUint32(&o.RTC_DEBUG_SEL.Reg)&^(0x3e0)|value<<5)
}
func (o *RTCIO_Type) GetRTC_DEBUG_SEL_RTC_DEBUG_SEL1() uint32 {
	return (volatile.LoadUint32(&o.RTC_DEBUG_SEL.Reg) & 0x3e0) >> 5
}
func (o *RTCIO_Type) SetRTC_DEBUG_SEL_RTC_DEBUG_SEL2(value uint32) {
	volatile.StoreUint32(&o.RTC_DEBUG_SEL.Reg, volatile.LoadUint32(&o.RTC_DEBUG_SEL.Reg)&^(0x7c00)|value<<10)
}
func (o *RTCIO_Type) GetRTC_DEBUG_SEL_RTC_DEBUG_SEL2() uint32 {
	return (volatile.LoadUint32(&o.RTC_DEBUG_SEL.Reg) & 0x7c00) >> 10
}
func (o *RTCIO_Type) SetRTC_DEBUG_SEL_RTC_DEBUG_SEL3(value uint32) {
	volatile.StoreUint32(&o.RTC_DEBUG_SEL.Reg, volatile.LoadUint32(&o.RTC_DEBUG_SEL.Reg)&^(0xf8000)|value<<15)
}
func (o *RTCIO_Type) GetRTC_DEBUG_SEL_RTC_DEBUG_SEL3() uint32 {
	return (volatile.LoadUint32(&o.RTC_DEBUG_SEL.Reg) & 0xf8000) >> 15
}
func (o *RTCIO_Type) SetRTC_DEBUG_SEL_RTC_DEBUG_SEL4(value uint32) {
	volatile.StoreUint32(&o.RTC_DEBUG_SEL.Reg, volatile.LoadUint32(&o.RTC_DEBUG_SEL.Reg)&^(0x1f00000)|value<<20)
}
func (o *RTCIO_Type) GetRTC_DEBUG_SEL_RTC_DEBUG_SEL4() uint32 {
	return (volatile.LoadUint32(&o.RTC_DEBUG_SEL.Reg) & 0x1f00000) >> 20
}
func (o *RTCIO_Type) SetRTC_DEBUG_SEL_RTC_DEBUG_12M_NO_GATING(value uint32) {
	volatile.StoreUint32(&o.RTC_DEBUG_SEL.Reg, volatile.LoadUint32(&o.RTC_DEBUG_SEL.Reg)&^(0x2000000)|value<<25)
}
func (o *RTCIO_Type) GetRTC_DEBUG_SEL_RTC_DEBUG_12M_NO_GATING() uint32 {
	return (volatile.LoadUint32(&o.RTC_DEBUG_SEL.Reg) & 0x2000000) >> 25
}

// RTCIO.TOUCH_PAD0: Touch pad %s configuration register
func (o *RTCIO_Type) SetTOUCH_PAD0_TOUCH_PAD0_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD0.Reg, volatile.LoadUint32(&o.TOUCH_PAD0.Reg)&^(0x2000)|value<<13)
}
func (o *RTCIO_Type) GetTOUCH_PAD0_TOUCH_PAD0_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD0.Reg) & 0x2000) >> 13
}
func (o *RTCIO_Type) SetTOUCH_PAD0_TOUCH_PAD0_SLP_OE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD0.Reg, volatile.LoadUint32(&o.TOUCH_PAD0.Reg)&^(0x4000)|value<<14)
}
func (o *RTCIO_Type) GetTOUCH_PAD0_TOUCH_PAD0_SLP_OE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD0.Reg) & 0x4000) >> 14
}
func (o *RTCIO_Type) SetTOUCH_PAD0_TOUCH_PAD0_SLP_IE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD0.Reg, volatile.LoadUint32(&o.TOUCH_PAD0.Reg)&^(0x8000)|value<<15)
}
func (o *RTCIO_Type) GetTOUCH_PAD0_TOUCH_PAD0_SLP_IE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD0.Reg) & 0x8000) >> 15
}
func (o *RTCIO_Type) SetTOUCH_PAD0_TOUCH_PAD0_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD0.Reg, volatile.LoadUint32(&o.TOUCH_PAD0.Reg)&^(0x10000)|value<<16)
}
func (o *RTCIO_Type) GetTOUCH_PAD0_TOUCH_PAD0_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD0.Reg) & 0x10000) >> 16
}
func (o *RTCIO_Type) SetTOUCH_PAD0_TOUCH_PAD0_FUN_SEL(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD0.Reg, volatile.LoadUint32(&o.TOUCH_PAD0.Reg)&^(0x60000)|value<<17)
}
func (o *RTCIO_Type) GetTOUCH_PAD0_TOUCH_PAD0_FUN_SEL() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD0.Reg) & 0x60000) >> 17
}
func (o *RTCIO_Type) SetTOUCH_PAD0_TOUCH_PAD0_MUX_SEL(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD0.Reg, volatile.LoadUint32(&o.TOUCH_PAD0.Reg)&^(0x80000)|value<<19)
}
func (o *RTCIO_Type) GetTOUCH_PAD0_TOUCH_PAD0_MUX_SEL() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD0.Reg) & 0x80000) >> 19
}
func (o *RTCIO_Type) SetTOUCH_PAD0_TOUCH_PAD0_XPD(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD0.Reg, volatile.LoadUint32(&o.TOUCH_PAD0.Reg)&^(0x100000)|value<<20)
}
func (o *RTCIO_Type) GetTOUCH_PAD0_TOUCH_PAD0_XPD() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD0.Reg) & 0x100000) >> 20
}
func (o *RTCIO_Type) SetTOUCH_PAD0_TOUCH_PAD0_TIE_OPT(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD0.Reg, volatile.LoadUint32(&o.TOUCH_PAD0.Reg)&^(0x200000)|value<<21)
}
func (o *RTCIO_Type) GetTOUCH_PAD0_TOUCH_PAD0_TIE_OPT() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD0.Reg) & 0x200000) >> 21
}
func (o *RTCIO_Type) SetTOUCH_PAD0_TOUCH_PAD0_START(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD0.Reg, volatile.LoadUint32(&o.TOUCH_PAD0.Reg)&^(0x400000)|value<<22)
}
func (o *RTCIO_Type) GetTOUCH_PAD0_TOUCH_PAD0_START() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD0.Reg) & 0x400000) >> 22
}
func (o *RTCIO_Type) SetTOUCH_PAD0_TOUCH_PAD0_DAC(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD0.Reg, volatile.LoadUint32(&o.TOUCH_PAD0.Reg)&^(0x3800000)|value<<23)
}
func (o *RTCIO_Type) GetTOUCH_PAD0_TOUCH_PAD0_DAC() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD0.Reg) & 0x3800000) >> 23
}
func (o *RTCIO_Type) SetTOUCH_PAD0_TOUCH_PAD0_RUE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD0.Reg, volatile.LoadUint32(&o.TOUCH_PAD0.Reg)&^(0x8000000)|value<<27)
}
func (o *RTCIO_Type) GetTOUCH_PAD0_TOUCH_PAD0_RUE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD0.Reg) & 0x8000000) >> 27
}
func (o *RTCIO_Type) SetTOUCH_PAD0_TOUCH_PAD0_RDE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD0.Reg, volatile.LoadUint32(&o.TOUCH_PAD0.Reg)&^(0x10000000)|value<<28)
}
func (o *RTCIO_Type) GetTOUCH_PAD0_TOUCH_PAD0_RDE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD0.Reg) & 0x10000000) >> 28
}
func (o *RTCIO_Type) SetTOUCH_PAD0_TOUCH_PAD0_DRV(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD0.Reg, volatile.LoadUint32(&o.TOUCH_PAD0.Reg)&^(0x60000000)|value<<29)
}
func (o *RTCIO_Type) GetTOUCH_PAD0_TOUCH_PAD0_DRV() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD0.Reg) & 0x60000000) >> 29
}

// RTCIO.TOUCH_PAD1: Touch pad %s configuration register
func (o *RTCIO_Type) SetTOUCH_PAD1_TOUCH_PAD0_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD1.Reg, volatile.LoadUint32(&o.TOUCH_PAD1.Reg)&^(0x2000)|value<<13)
}
func (o *RTCIO_Type) GetTOUCH_PAD1_TOUCH_PAD0_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD1.Reg) & 0x2000) >> 13
}
func (o *RTCIO_Type) SetTOUCH_PAD1_TOUCH_PAD0_SLP_OE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD1.Reg, volatile.LoadUint32(&o.TOUCH_PAD1.Reg)&^(0x4000)|value<<14)
}
func (o *RTCIO_Type) GetTOUCH_PAD1_TOUCH_PAD0_SLP_OE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD1.Reg) & 0x4000) >> 14
}
func (o *RTCIO_Type) SetTOUCH_PAD1_TOUCH_PAD0_SLP_IE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD1.Reg, volatile.LoadUint32(&o.TOUCH_PAD1.Reg)&^(0x8000)|value<<15)
}
func (o *RTCIO_Type) GetTOUCH_PAD1_TOUCH_PAD0_SLP_IE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD1.Reg) & 0x8000) >> 15
}
func (o *RTCIO_Type) SetTOUCH_PAD1_TOUCH_PAD0_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD1.Reg, volatile.LoadUint32(&o.TOUCH_PAD1.Reg)&^(0x10000)|value<<16)
}
func (o *RTCIO_Type) GetTOUCH_PAD1_TOUCH_PAD0_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD1.Reg) & 0x10000) >> 16
}
func (o *RTCIO_Type) SetTOUCH_PAD1_TOUCH_PAD0_FUN_SEL(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD1.Reg, volatile.LoadUint32(&o.TOUCH_PAD1.Reg)&^(0x60000)|value<<17)
}
func (o *RTCIO_Type) GetTOUCH_PAD1_TOUCH_PAD0_FUN_SEL() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD1.Reg) & 0x60000) >> 17
}
func (o *RTCIO_Type) SetTOUCH_PAD1_TOUCH_PAD0_MUX_SEL(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD1.Reg, volatile.LoadUint32(&o.TOUCH_PAD1.Reg)&^(0x80000)|value<<19)
}
func (o *RTCIO_Type) GetTOUCH_PAD1_TOUCH_PAD0_MUX_SEL() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD1.Reg) & 0x80000) >> 19
}
func (o *RTCIO_Type) SetTOUCH_PAD1_TOUCH_PAD0_XPD(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD1.Reg, volatile.LoadUint32(&o.TOUCH_PAD1.Reg)&^(0x100000)|value<<20)
}
func (o *RTCIO_Type) GetTOUCH_PAD1_TOUCH_PAD0_XPD() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD1.Reg) & 0x100000) >> 20
}
func (o *RTCIO_Type) SetTOUCH_PAD1_TOUCH_PAD0_TIE_OPT(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD1.Reg, volatile.LoadUint32(&o.TOUCH_PAD1.Reg)&^(0x200000)|value<<21)
}
func (o *RTCIO_Type) GetTOUCH_PAD1_TOUCH_PAD0_TIE_OPT() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD1.Reg) & 0x200000) >> 21
}
func (o *RTCIO_Type) SetTOUCH_PAD1_TOUCH_PAD0_START(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD1.Reg, volatile.LoadUint32(&o.TOUCH_PAD1.Reg)&^(0x400000)|value<<22)
}
func (o *RTCIO_Type) GetTOUCH_PAD1_TOUCH_PAD0_START() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD1.Reg) & 0x400000) >> 22
}
func (o *RTCIO_Type) SetTOUCH_PAD1_TOUCH_PAD0_DAC(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD1.Reg, volatile.LoadUint32(&o.TOUCH_PAD1.Reg)&^(0x3800000)|value<<23)
}
func (o *RTCIO_Type) GetTOUCH_PAD1_TOUCH_PAD0_DAC() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD1.Reg) & 0x3800000) >> 23
}
func (o *RTCIO_Type) SetTOUCH_PAD1_TOUCH_PAD0_RUE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD1.Reg, volatile.LoadUint32(&o.TOUCH_PAD1.Reg)&^(0x8000000)|value<<27)
}
func (o *RTCIO_Type) GetTOUCH_PAD1_TOUCH_PAD0_RUE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD1.Reg) & 0x8000000) >> 27
}
func (o *RTCIO_Type) SetTOUCH_PAD1_TOUCH_PAD0_RDE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD1.Reg, volatile.LoadUint32(&o.TOUCH_PAD1.Reg)&^(0x10000000)|value<<28)
}
func (o *RTCIO_Type) GetTOUCH_PAD1_TOUCH_PAD0_RDE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD1.Reg) & 0x10000000) >> 28
}
func (o *RTCIO_Type) SetTOUCH_PAD1_TOUCH_PAD0_DRV(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD1.Reg, volatile.LoadUint32(&o.TOUCH_PAD1.Reg)&^(0x60000000)|value<<29)
}
func (o *RTCIO_Type) GetTOUCH_PAD1_TOUCH_PAD0_DRV() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD1.Reg) & 0x60000000) >> 29
}

// RTCIO.TOUCH_PAD2: Touch pad %s configuration register
func (o *RTCIO_Type) SetTOUCH_PAD2_TOUCH_PAD0_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD2.Reg, volatile.LoadUint32(&o.TOUCH_PAD2.Reg)&^(0x2000)|value<<13)
}
func (o *RTCIO_Type) GetTOUCH_PAD2_TOUCH_PAD0_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD2.Reg) & 0x2000) >> 13
}
func (o *RTCIO_Type) SetTOUCH_PAD2_TOUCH_PAD0_SLP_OE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD2.Reg, volatile.LoadUint32(&o.TOUCH_PAD2.Reg)&^(0x4000)|value<<14)
}
func (o *RTCIO_Type) GetTOUCH_PAD2_TOUCH_PAD0_SLP_OE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD2.Reg) & 0x4000) >> 14
}
func (o *RTCIO_Type) SetTOUCH_PAD2_TOUCH_PAD0_SLP_IE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD2.Reg, volatile.LoadUint32(&o.TOUCH_PAD2.Reg)&^(0x8000)|value<<15)
}
func (o *RTCIO_Type) GetTOUCH_PAD2_TOUCH_PAD0_SLP_IE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD2.Reg) & 0x8000) >> 15
}
func (o *RTCIO_Type) SetTOUCH_PAD2_TOUCH_PAD0_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD2.Reg, volatile.LoadUint32(&o.TOUCH_PAD2.Reg)&^(0x10000)|value<<16)
}
func (o *RTCIO_Type) GetTOUCH_PAD2_TOUCH_PAD0_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD2.Reg) & 0x10000) >> 16
}
func (o *RTCIO_Type) SetTOUCH_PAD2_TOUCH_PAD0_FUN_SEL(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD2.Reg, volatile.LoadUint32(&o.TOUCH_PAD2.Reg)&^(0x60000)|value<<17)
}
func (o *RTCIO_Type) GetTOUCH_PAD2_TOUCH_PAD0_FUN_SEL() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD2.Reg) & 0x60000) >> 17
}
func (o *RTCIO_Type) SetTOUCH_PAD2_TOUCH_PAD0_MUX_SEL(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD2.Reg, volatile.LoadUint32(&o.TOUCH_PAD2.Reg)&^(0x80000)|value<<19)
}
func (o *RTCIO_Type) GetTOUCH_PAD2_TOUCH_PAD0_MUX_SEL() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD2.Reg) & 0x80000) >> 19
}
func (o *RTCIO_Type) SetTOUCH_PAD2_TOUCH_PAD0_XPD(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD2.Reg, volatile.LoadUint32(&o.TOUCH_PAD2.Reg)&^(0x100000)|value<<20)
}
func (o *RTCIO_Type) GetTOUCH_PAD2_TOUCH_PAD0_XPD() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD2.Reg) & 0x100000) >> 20
}
func (o *RTCIO_Type) SetTOUCH_PAD2_TOUCH_PAD0_TIE_OPT(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD2.Reg, volatile.LoadUint32(&o.TOUCH_PAD2.Reg)&^(0x200000)|value<<21)
}
func (o *RTCIO_Type) GetTOUCH_PAD2_TOUCH_PAD0_TIE_OPT() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD2.Reg) & 0x200000) >> 21
}
func (o *RTCIO_Type) SetTOUCH_PAD2_TOUCH_PAD0_START(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD2.Reg, volatile.LoadUint32(&o.TOUCH_PAD2.Reg)&^(0x400000)|value<<22)
}
func (o *RTCIO_Type) GetTOUCH_PAD2_TOUCH_PAD0_START() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD2.Reg) & 0x400000) >> 22
}
func (o *RTCIO_Type) SetTOUCH_PAD2_TOUCH_PAD0_DAC(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD2.Reg, volatile.LoadUint32(&o.TOUCH_PAD2.Reg)&^(0x3800000)|value<<23)
}
func (o *RTCIO_Type) GetTOUCH_PAD2_TOUCH_PAD0_DAC() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD2.Reg) & 0x3800000) >> 23
}
func (o *RTCIO_Type) SetTOUCH_PAD2_TOUCH_PAD0_RUE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD2.Reg, volatile.LoadUint32(&o.TOUCH_PAD2.Reg)&^(0x8000000)|value<<27)
}
func (o *RTCIO_Type) GetTOUCH_PAD2_TOUCH_PAD0_RUE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD2.Reg) & 0x8000000) >> 27
}
func (o *RTCIO_Type) SetTOUCH_PAD2_TOUCH_PAD0_RDE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD2.Reg, volatile.LoadUint32(&o.TOUCH_PAD2.Reg)&^(0x10000000)|value<<28)
}
func (o *RTCIO_Type) GetTOUCH_PAD2_TOUCH_PAD0_RDE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD2.Reg) & 0x10000000) >> 28
}
func (o *RTCIO_Type) SetTOUCH_PAD2_TOUCH_PAD0_DRV(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD2.Reg, volatile.LoadUint32(&o.TOUCH_PAD2.Reg)&^(0x60000000)|value<<29)
}
func (o *RTCIO_Type) GetTOUCH_PAD2_TOUCH_PAD0_DRV() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD2.Reg) & 0x60000000) >> 29
}

// RTCIO.TOUCH_PAD3: Touch pad %s configuration register
func (o *RTCIO_Type) SetTOUCH_PAD3_TOUCH_PAD0_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD3.Reg, volatile.LoadUint32(&o.TOUCH_PAD3.Reg)&^(0x2000)|value<<13)
}
func (o *RTCIO_Type) GetTOUCH_PAD3_TOUCH_PAD0_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD3.Reg) & 0x2000) >> 13
}
func (o *RTCIO_Type) SetTOUCH_PAD3_TOUCH_PAD0_SLP_OE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD3.Reg, volatile.LoadUint32(&o.TOUCH_PAD3.Reg)&^(0x4000)|value<<14)
}
func (o *RTCIO_Type) GetTOUCH_PAD3_TOUCH_PAD0_SLP_OE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD3.Reg) & 0x4000) >> 14
}
func (o *RTCIO_Type) SetTOUCH_PAD3_TOUCH_PAD0_SLP_IE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD3.Reg, volatile.LoadUint32(&o.TOUCH_PAD3.Reg)&^(0x8000)|value<<15)
}
func (o *RTCIO_Type) GetTOUCH_PAD3_TOUCH_PAD0_SLP_IE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD3.Reg) & 0x8000) >> 15
}
func (o *RTCIO_Type) SetTOUCH_PAD3_TOUCH_PAD0_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD3.Reg, volatile.LoadUint32(&o.TOUCH_PAD3.Reg)&^(0x10000)|value<<16)
}
func (o *RTCIO_Type) GetTOUCH_PAD3_TOUCH_PAD0_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD3.Reg) & 0x10000) >> 16
}
func (o *RTCIO_Type) SetTOUCH_PAD3_TOUCH_PAD0_FUN_SEL(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD3.Reg, volatile.LoadUint32(&o.TOUCH_PAD3.Reg)&^(0x60000)|value<<17)
}
func (o *RTCIO_Type) GetTOUCH_PAD3_TOUCH_PAD0_FUN_SEL() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD3.Reg) & 0x60000) >> 17
}
func (o *RTCIO_Type) SetTOUCH_PAD3_TOUCH_PAD0_MUX_SEL(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD3.Reg, volatile.LoadUint32(&o.TOUCH_PAD3.Reg)&^(0x80000)|value<<19)
}
func (o *RTCIO_Type) GetTOUCH_PAD3_TOUCH_PAD0_MUX_SEL() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD3.Reg) & 0x80000) >> 19
}
func (o *RTCIO_Type) SetTOUCH_PAD3_TOUCH_PAD0_XPD(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD3.Reg, volatile.LoadUint32(&o.TOUCH_PAD3.Reg)&^(0x100000)|value<<20)
}
func (o *RTCIO_Type) GetTOUCH_PAD3_TOUCH_PAD0_XPD() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD3.Reg) & 0x100000) >> 20
}
func (o *RTCIO_Type) SetTOUCH_PAD3_TOUCH_PAD0_TIE_OPT(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD3.Reg, volatile.LoadUint32(&o.TOUCH_PAD3.Reg)&^(0x200000)|value<<21)
}
func (o *RTCIO_Type) GetTOUCH_PAD3_TOUCH_PAD0_TIE_OPT() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD3.Reg) & 0x200000) >> 21
}
func (o *RTCIO_Type) SetTOUCH_PAD3_TOUCH_PAD0_START(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD3.Reg, volatile.LoadUint32(&o.TOUCH_PAD3.Reg)&^(0x400000)|value<<22)
}
func (o *RTCIO_Type) GetTOUCH_PAD3_TOUCH_PAD0_START() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD3.Reg) & 0x400000) >> 22
}
func (o *RTCIO_Type) SetTOUCH_PAD3_TOUCH_PAD0_DAC(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD3.Reg, volatile.LoadUint32(&o.TOUCH_PAD3.Reg)&^(0x3800000)|value<<23)
}
func (o *RTCIO_Type) GetTOUCH_PAD3_TOUCH_PAD0_DAC() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD3.Reg) & 0x3800000) >> 23
}
func (o *RTCIO_Type) SetTOUCH_PAD3_TOUCH_PAD0_RUE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD3.Reg, volatile.LoadUint32(&o.TOUCH_PAD3.Reg)&^(0x8000000)|value<<27)
}
func (o *RTCIO_Type) GetTOUCH_PAD3_TOUCH_PAD0_RUE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD3.Reg) & 0x8000000) >> 27
}
func (o *RTCIO_Type) SetTOUCH_PAD3_TOUCH_PAD0_RDE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD3.Reg, volatile.LoadUint32(&o.TOUCH_PAD3.Reg)&^(0x10000000)|value<<28)
}
func (o *RTCIO_Type) GetTOUCH_PAD3_TOUCH_PAD0_RDE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD3.Reg) & 0x10000000) >> 28
}
func (o *RTCIO_Type) SetTOUCH_PAD3_TOUCH_PAD0_DRV(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD3.Reg, volatile.LoadUint32(&o.TOUCH_PAD3.Reg)&^(0x60000000)|value<<29)
}
func (o *RTCIO_Type) GetTOUCH_PAD3_TOUCH_PAD0_DRV() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD3.Reg) & 0x60000000) >> 29
}

// RTCIO.TOUCH_PAD4: Touch pad %s configuration register
func (o *RTCIO_Type) SetTOUCH_PAD4_TOUCH_PAD0_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD4.Reg, volatile.LoadUint32(&o.TOUCH_PAD4.Reg)&^(0x2000)|value<<13)
}
func (o *RTCIO_Type) GetTOUCH_PAD4_TOUCH_PAD0_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD4.Reg) & 0x2000) >> 13
}
func (o *RTCIO_Type) SetTOUCH_PAD4_TOUCH_PAD0_SLP_OE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD4.Reg, volatile.LoadUint32(&o.TOUCH_PAD4.Reg)&^(0x4000)|value<<14)
}
func (o *RTCIO_Type) GetTOUCH_PAD4_TOUCH_PAD0_SLP_OE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD4.Reg) & 0x4000) >> 14
}
func (o *RTCIO_Type) SetTOUCH_PAD4_TOUCH_PAD0_SLP_IE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD4.Reg, volatile.LoadUint32(&o.TOUCH_PAD4.Reg)&^(0x8000)|value<<15)
}
func (o *RTCIO_Type) GetTOUCH_PAD4_TOUCH_PAD0_SLP_IE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD4.Reg) & 0x8000) >> 15
}
func (o *RTCIO_Type) SetTOUCH_PAD4_TOUCH_PAD0_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD4.Reg, volatile.LoadUint32(&o.TOUCH_PAD4.Reg)&^(0x10000)|value<<16)
}
func (o *RTCIO_Type) GetTOUCH_PAD4_TOUCH_PAD0_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD4.Reg) & 0x10000) >> 16
}
func (o *RTCIO_Type) SetTOUCH_PAD4_TOUCH_PAD0_FUN_SEL(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD4.Reg, volatile.LoadUint32(&o.TOUCH_PAD4.Reg)&^(0x60000)|value<<17)
}
func (o *RTCIO_Type) GetTOUCH_PAD4_TOUCH_PAD0_FUN_SEL() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD4.Reg) & 0x60000) >> 17
}
func (o *RTCIO_Type) SetTOUCH_PAD4_TOUCH_PAD0_MUX_SEL(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD4.Reg, volatile.LoadUint32(&o.TOUCH_PAD4.Reg)&^(0x80000)|value<<19)
}
func (o *RTCIO_Type) GetTOUCH_PAD4_TOUCH_PAD0_MUX_SEL() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD4.Reg) & 0x80000) >> 19
}
func (o *RTCIO_Type) SetTOUCH_PAD4_TOUCH_PAD0_XPD(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD4.Reg, volatile.LoadUint32(&o.TOUCH_PAD4.Reg)&^(0x100000)|value<<20)
}
func (o *RTCIO_Type) GetTOUCH_PAD4_TOUCH_PAD0_XPD() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD4.Reg) & 0x100000) >> 20
}
func (o *RTCIO_Type) SetTOUCH_PAD4_TOUCH_PAD0_TIE_OPT(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD4.Reg, volatile.LoadUint32(&o.TOUCH_PAD4.Reg)&^(0x200000)|value<<21)
}
func (o *RTCIO_Type) GetTOUCH_PAD4_TOUCH_PAD0_TIE_OPT() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD4.Reg) & 0x200000) >> 21
}
func (o *RTCIO_Type) SetTOUCH_PAD4_TOUCH_PAD0_START(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD4.Reg, volatile.LoadUint32(&o.TOUCH_PAD4.Reg)&^(0x400000)|value<<22)
}
func (o *RTCIO_Type) GetTOUCH_PAD4_TOUCH_PAD0_START() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD4.Reg) & 0x400000) >> 22
}
func (o *RTCIO_Type) SetTOUCH_PAD4_TOUCH_PAD0_DAC(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD4.Reg, volatile.LoadUint32(&o.TOUCH_PAD4.Reg)&^(0x3800000)|value<<23)
}
func (o *RTCIO_Type) GetTOUCH_PAD4_TOUCH_PAD0_DAC() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD4.Reg) & 0x3800000) >> 23
}
func (o *RTCIO_Type) SetTOUCH_PAD4_TOUCH_PAD0_RUE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD4.Reg, volatile.LoadUint32(&o.TOUCH_PAD4.Reg)&^(0x8000000)|value<<27)
}
func (o *RTCIO_Type) GetTOUCH_PAD4_TOUCH_PAD0_RUE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD4.Reg) & 0x8000000) >> 27
}
func (o *RTCIO_Type) SetTOUCH_PAD4_TOUCH_PAD0_RDE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD4.Reg, volatile.LoadUint32(&o.TOUCH_PAD4.Reg)&^(0x10000000)|value<<28)
}
func (o *RTCIO_Type) GetTOUCH_PAD4_TOUCH_PAD0_RDE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD4.Reg) & 0x10000000) >> 28
}
func (o *RTCIO_Type) SetTOUCH_PAD4_TOUCH_PAD0_DRV(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD4.Reg, volatile.LoadUint32(&o.TOUCH_PAD4.Reg)&^(0x60000000)|value<<29)
}
func (o *RTCIO_Type) GetTOUCH_PAD4_TOUCH_PAD0_DRV() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD4.Reg) & 0x60000000) >> 29
}

// RTCIO.TOUCH_PAD5: Touch pad %s configuration register
func (o *RTCIO_Type) SetTOUCH_PAD5_TOUCH_PAD0_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD5.Reg, volatile.LoadUint32(&o.TOUCH_PAD5.Reg)&^(0x2000)|value<<13)
}
func (o *RTCIO_Type) GetTOUCH_PAD5_TOUCH_PAD0_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD5.Reg) & 0x2000) >> 13
}
func (o *RTCIO_Type) SetTOUCH_PAD5_TOUCH_PAD0_SLP_OE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD5.Reg, volatile.LoadUint32(&o.TOUCH_PAD5.Reg)&^(0x4000)|value<<14)
}
func (o *RTCIO_Type) GetTOUCH_PAD5_TOUCH_PAD0_SLP_OE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD5.Reg) & 0x4000) >> 14
}
func (o *RTCIO_Type) SetTOUCH_PAD5_TOUCH_PAD0_SLP_IE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD5.Reg, volatile.LoadUint32(&o.TOUCH_PAD5.Reg)&^(0x8000)|value<<15)
}
func (o *RTCIO_Type) GetTOUCH_PAD5_TOUCH_PAD0_SLP_IE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD5.Reg) & 0x8000) >> 15
}
func (o *RTCIO_Type) SetTOUCH_PAD5_TOUCH_PAD0_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD5.Reg, volatile.LoadUint32(&o.TOUCH_PAD5.Reg)&^(0x10000)|value<<16)
}
func (o *RTCIO_Type) GetTOUCH_PAD5_TOUCH_PAD0_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD5.Reg) & 0x10000) >> 16
}
func (o *RTCIO_Type) SetTOUCH_PAD5_TOUCH_PAD0_FUN_SEL(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD5.Reg, volatile.LoadUint32(&o.TOUCH_PAD5.Reg)&^(0x60000)|value<<17)
}
func (o *RTCIO_Type) GetTOUCH_PAD5_TOUCH_PAD0_FUN_SEL() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD5.Reg) & 0x60000) >> 17
}
func (o *RTCIO_Type) SetTOUCH_PAD5_TOUCH_PAD0_MUX_SEL(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD5.Reg, volatile.LoadUint32(&o.TOUCH_PAD5.Reg)&^(0x80000)|value<<19)
}
func (o *RTCIO_Type) GetTOUCH_PAD5_TOUCH_PAD0_MUX_SEL() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD5.Reg) & 0x80000) >> 19
}
func (o *RTCIO_Type) SetTOUCH_PAD5_TOUCH_PAD0_XPD(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD5.Reg, volatile.LoadUint32(&o.TOUCH_PAD5.Reg)&^(0x100000)|value<<20)
}
func (o *RTCIO_Type) GetTOUCH_PAD5_TOUCH_PAD0_XPD() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD5.Reg) & 0x100000) >> 20
}
func (o *RTCIO_Type) SetTOUCH_PAD5_TOUCH_PAD0_TIE_OPT(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD5.Reg, volatile.LoadUint32(&o.TOUCH_PAD5.Reg)&^(0x200000)|value<<21)
}
func (o *RTCIO_Type) GetTOUCH_PAD5_TOUCH_PAD0_TIE_OPT() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD5.Reg) & 0x200000) >> 21
}
func (o *RTCIO_Type) SetTOUCH_PAD5_TOUCH_PAD0_START(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD5.Reg, volatile.LoadUint32(&o.TOUCH_PAD5.Reg)&^(0x400000)|value<<22)
}
func (o *RTCIO_Type) GetTOUCH_PAD5_TOUCH_PAD0_START() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD5.Reg) & 0x400000) >> 22
}
func (o *RTCIO_Type) SetTOUCH_PAD5_TOUCH_PAD0_DAC(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD5.Reg, volatile.LoadUint32(&o.TOUCH_PAD5.Reg)&^(0x3800000)|value<<23)
}
func (o *RTCIO_Type) GetTOUCH_PAD5_TOUCH_PAD0_DAC() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD5.Reg) & 0x3800000) >> 23
}
func (o *RTCIO_Type) SetTOUCH_PAD5_TOUCH_PAD0_RUE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD5.Reg, volatile.LoadUint32(&o.TOUCH_PAD5.Reg)&^(0x8000000)|value<<27)
}
func (o *RTCIO_Type) GetTOUCH_PAD5_TOUCH_PAD0_RUE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD5.Reg) & 0x8000000) >> 27
}
func (o *RTCIO_Type) SetTOUCH_PAD5_TOUCH_PAD0_RDE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD5.Reg, volatile.LoadUint32(&o.TOUCH_PAD5.Reg)&^(0x10000000)|value<<28)
}
func (o *RTCIO_Type) GetTOUCH_PAD5_TOUCH_PAD0_RDE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD5.Reg) & 0x10000000) >> 28
}
func (o *RTCIO_Type) SetTOUCH_PAD5_TOUCH_PAD0_DRV(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD5.Reg, volatile.LoadUint32(&o.TOUCH_PAD5.Reg)&^(0x60000000)|value<<29)
}
func (o *RTCIO_Type) GetTOUCH_PAD5_TOUCH_PAD0_DRV() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD5.Reg) & 0x60000000) >> 29
}

// RTCIO.TOUCH_PAD6: Touch pad %s configuration register
func (o *RTCIO_Type) SetTOUCH_PAD6_TOUCH_PAD0_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD6.Reg, volatile.LoadUint32(&o.TOUCH_PAD6.Reg)&^(0x2000)|value<<13)
}
func (o *RTCIO_Type) GetTOUCH_PAD6_TOUCH_PAD0_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD6.Reg) & 0x2000) >> 13
}
func (o *RTCIO_Type) SetTOUCH_PAD6_TOUCH_PAD0_SLP_OE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD6.Reg, volatile.LoadUint32(&o.TOUCH_PAD6.Reg)&^(0x4000)|value<<14)
}
func (o *RTCIO_Type) GetTOUCH_PAD6_TOUCH_PAD0_SLP_OE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD6.Reg) & 0x4000) >> 14
}
func (o *RTCIO_Type) SetTOUCH_PAD6_TOUCH_PAD0_SLP_IE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD6.Reg, volatile.LoadUint32(&o.TOUCH_PAD6.Reg)&^(0x8000)|value<<15)
}
func (o *RTCIO_Type) GetTOUCH_PAD6_TOUCH_PAD0_SLP_IE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD6.Reg) & 0x8000) >> 15
}
func (o *RTCIO_Type) SetTOUCH_PAD6_TOUCH_PAD0_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD6.Reg, volatile.LoadUint32(&o.TOUCH_PAD6.Reg)&^(0x10000)|value<<16)
}
func (o *RTCIO_Type) GetTOUCH_PAD6_TOUCH_PAD0_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD6.Reg) & 0x10000) >> 16
}
func (o *RTCIO_Type) SetTOUCH_PAD6_TOUCH_PAD0_FUN_SEL(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD6.Reg, volatile.LoadUint32(&o.TOUCH_PAD6.Reg)&^(0x60000)|value<<17)
}
func (o *RTCIO_Type) GetTOUCH_PAD6_TOUCH_PAD0_FUN_SEL() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD6.Reg) & 0x60000) >> 17
}
func (o *RTCIO_Type) SetTOUCH_PAD6_TOUCH_PAD0_MUX_SEL(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD6.Reg, volatile.LoadUint32(&o.TOUCH_PAD6.Reg)&^(0x80000)|value<<19)
}
func (o *RTCIO_Type) GetTOUCH_PAD6_TOUCH_PAD0_MUX_SEL() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD6.Reg) & 0x80000) >> 19
}
func (o *RTCIO_Type) SetTOUCH_PAD6_TOUCH_PAD0_XPD(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD6.Reg, volatile.LoadUint32(&o.TOUCH_PAD6.Reg)&^(0x100000)|value<<20)
}
func (o *RTCIO_Type) GetTOUCH_PAD6_TOUCH_PAD0_XPD() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD6.Reg) & 0x100000) >> 20
}
func (o *RTCIO_Type) SetTOUCH_PAD6_TOUCH_PAD0_TIE_OPT(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD6.Reg, volatile.LoadUint32(&o.TOUCH_PAD6.Reg)&^(0x200000)|value<<21)
}
func (o *RTCIO_Type) GetTOUCH_PAD6_TOUCH_PAD0_TIE_OPT() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD6.Reg) & 0x200000) >> 21
}
func (o *RTCIO_Type) SetTOUCH_PAD6_TOUCH_PAD0_START(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD6.Reg, volatile.LoadUint32(&o.TOUCH_PAD6.Reg)&^(0x400000)|value<<22)
}
func (o *RTCIO_Type) GetTOUCH_PAD6_TOUCH_PAD0_START() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD6.Reg) & 0x400000) >> 22
}
func (o *RTCIO_Type) SetTOUCH_PAD6_TOUCH_PAD0_DAC(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD6.Reg, volatile.LoadUint32(&o.TOUCH_PAD6.Reg)&^(0x3800000)|value<<23)
}
func (o *RTCIO_Type) GetTOUCH_PAD6_TOUCH_PAD0_DAC() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD6.Reg) & 0x3800000) >> 23
}
func (o *RTCIO_Type) SetTOUCH_PAD6_TOUCH_PAD0_RUE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD6.Reg, volatile.LoadUint32(&o.TOUCH_PAD6.Reg)&^(0x8000000)|value<<27)
}
func (o *RTCIO_Type) GetTOUCH_PAD6_TOUCH_PAD0_RUE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD6.Reg) & 0x8000000) >> 27
}
func (o *RTCIO_Type) SetTOUCH_PAD6_TOUCH_PAD0_RDE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD6.Reg, volatile.LoadUint32(&o.TOUCH_PAD6.Reg)&^(0x10000000)|value<<28)
}
func (o *RTCIO_Type) GetTOUCH_PAD6_TOUCH_PAD0_RDE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD6.Reg) & 0x10000000) >> 28
}
func (o *RTCIO_Type) SetTOUCH_PAD6_TOUCH_PAD0_DRV(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD6.Reg, volatile.LoadUint32(&o.TOUCH_PAD6.Reg)&^(0x60000000)|value<<29)
}
func (o *RTCIO_Type) GetTOUCH_PAD6_TOUCH_PAD0_DRV() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD6.Reg) & 0x60000000) >> 29
}

// RTCIO.TOUCH_PAD7: Touch pad %s configuration register
func (o *RTCIO_Type) SetTOUCH_PAD7_TOUCH_PAD0_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD7.Reg, volatile.LoadUint32(&o.TOUCH_PAD7.Reg)&^(0x2000)|value<<13)
}
func (o *RTCIO_Type) GetTOUCH_PAD7_TOUCH_PAD0_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD7.Reg) & 0x2000) >> 13
}
func (o *RTCIO_Type) SetTOUCH_PAD7_TOUCH_PAD0_SLP_OE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD7.Reg, volatile.LoadUint32(&o.TOUCH_PAD7.Reg)&^(0x4000)|value<<14)
}
func (o *RTCIO_Type) GetTOUCH_PAD7_TOUCH_PAD0_SLP_OE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD7.Reg) & 0x4000) >> 14
}
func (o *RTCIO_Type) SetTOUCH_PAD7_TOUCH_PAD0_SLP_IE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD7.Reg, volatile.LoadUint32(&o.TOUCH_PAD7.Reg)&^(0x8000)|value<<15)
}
func (o *RTCIO_Type) GetTOUCH_PAD7_TOUCH_PAD0_SLP_IE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD7.Reg) & 0x8000) >> 15
}
func (o *RTCIO_Type) SetTOUCH_PAD7_TOUCH_PAD0_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD7.Reg, volatile.LoadUint32(&o.TOUCH_PAD7.Reg)&^(0x10000)|value<<16)
}
func (o *RTCIO_Type) GetTOUCH_PAD7_TOUCH_PAD0_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD7.Reg) & 0x10000) >> 16
}
func (o *RTCIO_Type) SetTOUCH_PAD7_TOUCH_PAD0_FUN_SEL(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD7.Reg, volatile.LoadUint32(&o.TOUCH_PAD7.Reg)&^(0x60000)|value<<17)
}
func (o *RTCIO_Type) GetTOUCH_PAD7_TOUCH_PAD0_FUN_SEL() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD7.Reg) & 0x60000) >> 17
}
func (o *RTCIO_Type) SetTOUCH_PAD7_TOUCH_PAD0_MUX_SEL(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD7.Reg, volatile.LoadUint32(&o.TOUCH_PAD7.Reg)&^(0x80000)|value<<19)
}
func (o *RTCIO_Type) GetTOUCH_PAD7_TOUCH_PAD0_MUX_SEL() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD7.Reg) & 0x80000) >> 19
}
func (o *RTCIO_Type) SetTOUCH_PAD7_TOUCH_PAD0_XPD(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD7.Reg, volatile.LoadUint32(&o.TOUCH_PAD7.Reg)&^(0x100000)|value<<20)
}
func (o *RTCIO_Type) GetTOUCH_PAD7_TOUCH_PAD0_XPD() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD7.Reg) & 0x100000) >> 20
}
func (o *RTCIO_Type) SetTOUCH_PAD7_TOUCH_PAD0_TIE_OPT(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD7.Reg, volatile.LoadUint32(&o.TOUCH_PAD7.Reg)&^(0x200000)|value<<21)
}
func (o *RTCIO_Type) GetTOUCH_PAD7_TOUCH_PAD0_TIE_OPT() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD7.Reg) & 0x200000) >> 21
}
func (o *RTCIO_Type) SetTOUCH_PAD7_TOUCH_PAD0_START(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD7.Reg, volatile.LoadUint32(&o.TOUCH_PAD7.Reg)&^(0x400000)|value<<22)
}
func (o *RTCIO_Type) GetTOUCH_PAD7_TOUCH_PAD0_START() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD7.Reg) & 0x400000) >> 22
}
func (o *RTCIO_Type) SetTOUCH_PAD7_TOUCH_PAD0_DAC(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD7.Reg, volatile.LoadUint32(&o.TOUCH_PAD7.Reg)&^(0x3800000)|value<<23)
}
func (o *RTCIO_Type) GetTOUCH_PAD7_TOUCH_PAD0_DAC() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD7.Reg) & 0x3800000) >> 23
}
func (o *RTCIO_Type) SetTOUCH_PAD7_TOUCH_PAD0_RUE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD7.Reg, volatile.LoadUint32(&o.TOUCH_PAD7.Reg)&^(0x8000000)|value<<27)
}
func (o *RTCIO_Type) GetTOUCH_PAD7_TOUCH_PAD0_RUE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD7.Reg) & 0x8000000) >> 27
}
func (o *RTCIO_Type) SetTOUCH_PAD7_TOUCH_PAD0_RDE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD7.Reg, volatile.LoadUint32(&o.TOUCH_PAD7.Reg)&^(0x10000000)|value<<28)
}
func (o *RTCIO_Type) GetTOUCH_PAD7_TOUCH_PAD0_RDE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD7.Reg) & 0x10000000) >> 28
}
func (o *RTCIO_Type) SetTOUCH_PAD7_TOUCH_PAD0_DRV(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD7.Reg, volatile.LoadUint32(&o.TOUCH_PAD7.Reg)&^(0x60000000)|value<<29)
}
func (o *RTCIO_Type) GetTOUCH_PAD7_TOUCH_PAD0_DRV() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD7.Reg) & 0x60000000) >> 29
}

// RTCIO.TOUCH_PAD8: Touch pad %s configuration register
func (o *RTCIO_Type) SetTOUCH_PAD8_TOUCH_PAD0_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD8.Reg, volatile.LoadUint32(&o.TOUCH_PAD8.Reg)&^(0x2000)|value<<13)
}
func (o *RTCIO_Type) GetTOUCH_PAD8_TOUCH_PAD0_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD8.Reg) & 0x2000) >> 13
}
func (o *RTCIO_Type) SetTOUCH_PAD8_TOUCH_PAD0_SLP_OE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD8.Reg, volatile.LoadUint32(&o.TOUCH_PAD8.Reg)&^(0x4000)|value<<14)
}
func (o *RTCIO_Type) GetTOUCH_PAD8_TOUCH_PAD0_SLP_OE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD8.Reg) & 0x4000) >> 14
}
func (o *RTCIO_Type) SetTOUCH_PAD8_TOUCH_PAD0_SLP_IE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD8.Reg, volatile.LoadUint32(&o.TOUCH_PAD8.Reg)&^(0x8000)|value<<15)
}
func (o *RTCIO_Type) GetTOUCH_PAD8_TOUCH_PAD0_SLP_IE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD8.Reg) & 0x8000) >> 15
}
func (o *RTCIO_Type) SetTOUCH_PAD8_TOUCH_PAD0_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD8.Reg, volatile.LoadUint32(&o.TOUCH_PAD8.Reg)&^(0x10000)|value<<16)
}
func (o *RTCIO_Type) GetTOUCH_PAD8_TOUCH_PAD0_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD8.Reg) & 0x10000) >> 16
}
func (o *RTCIO_Type) SetTOUCH_PAD8_TOUCH_PAD0_FUN_SEL(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD8.Reg, volatile.LoadUint32(&o.TOUCH_PAD8.Reg)&^(0x60000)|value<<17)
}
func (o *RTCIO_Type) GetTOUCH_PAD8_TOUCH_PAD0_FUN_SEL() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD8.Reg) & 0x60000) >> 17
}
func (o *RTCIO_Type) SetTOUCH_PAD8_TOUCH_PAD0_MUX_SEL(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD8.Reg, volatile.LoadUint32(&o.TOUCH_PAD8.Reg)&^(0x80000)|value<<19)
}
func (o *RTCIO_Type) GetTOUCH_PAD8_TOUCH_PAD0_MUX_SEL() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD8.Reg) & 0x80000) >> 19
}
func (o *RTCIO_Type) SetTOUCH_PAD8_TOUCH_PAD0_XPD(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD8.Reg, volatile.LoadUint32(&o.TOUCH_PAD8.Reg)&^(0x100000)|value<<20)
}
func (o *RTCIO_Type) GetTOUCH_PAD8_TOUCH_PAD0_XPD() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD8.Reg) & 0x100000) >> 20
}
func (o *RTCIO_Type) SetTOUCH_PAD8_TOUCH_PAD0_TIE_OPT(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD8.Reg, volatile.LoadUint32(&o.TOUCH_PAD8.Reg)&^(0x200000)|value<<21)
}
func (o *RTCIO_Type) GetTOUCH_PAD8_TOUCH_PAD0_TIE_OPT() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD8.Reg) & 0x200000) >> 21
}
func (o *RTCIO_Type) SetTOUCH_PAD8_TOUCH_PAD0_START(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD8.Reg, volatile.LoadUint32(&o.TOUCH_PAD8.Reg)&^(0x400000)|value<<22)
}
func (o *RTCIO_Type) GetTOUCH_PAD8_TOUCH_PAD0_START() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD8.Reg) & 0x400000) >> 22
}
func (o *RTCIO_Type) SetTOUCH_PAD8_TOUCH_PAD0_DAC(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD8.Reg, volatile.LoadUint32(&o.TOUCH_PAD8.Reg)&^(0x3800000)|value<<23)
}
func (o *RTCIO_Type) GetTOUCH_PAD8_TOUCH_PAD0_DAC() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD8.Reg) & 0x3800000) >> 23
}
func (o *RTCIO_Type) SetTOUCH_PAD8_TOUCH_PAD0_RUE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD8.Reg, volatile.LoadUint32(&o.TOUCH_PAD8.Reg)&^(0x8000000)|value<<27)
}
func (o *RTCIO_Type) GetTOUCH_PAD8_TOUCH_PAD0_RUE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD8.Reg) & 0x8000000) >> 27
}
func (o *RTCIO_Type) SetTOUCH_PAD8_TOUCH_PAD0_RDE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD8.Reg, volatile.LoadUint32(&o.TOUCH_PAD8.Reg)&^(0x10000000)|value<<28)
}
func (o *RTCIO_Type) GetTOUCH_PAD8_TOUCH_PAD0_RDE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD8.Reg) & 0x10000000) >> 28
}
func (o *RTCIO_Type) SetTOUCH_PAD8_TOUCH_PAD0_DRV(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD8.Reg, volatile.LoadUint32(&o.TOUCH_PAD8.Reg)&^(0x60000000)|value<<29)
}
func (o *RTCIO_Type) GetTOUCH_PAD8_TOUCH_PAD0_DRV() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD8.Reg) & 0x60000000) >> 29
}

// RTCIO.TOUCH_PAD9: Touch pad %s configuration register
func (o *RTCIO_Type) SetTOUCH_PAD9_TOUCH_PAD0_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD9.Reg, volatile.LoadUint32(&o.TOUCH_PAD9.Reg)&^(0x2000)|value<<13)
}
func (o *RTCIO_Type) GetTOUCH_PAD9_TOUCH_PAD0_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD9.Reg) & 0x2000) >> 13
}
func (o *RTCIO_Type) SetTOUCH_PAD9_TOUCH_PAD0_SLP_OE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD9.Reg, volatile.LoadUint32(&o.TOUCH_PAD9.Reg)&^(0x4000)|value<<14)
}
func (o *RTCIO_Type) GetTOUCH_PAD9_TOUCH_PAD0_SLP_OE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD9.Reg) & 0x4000) >> 14
}
func (o *RTCIO_Type) SetTOUCH_PAD9_TOUCH_PAD0_SLP_IE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD9.Reg, volatile.LoadUint32(&o.TOUCH_PAD9.Reg)&^(0x8000)|value<<15)
}
func (o *RTCIO_Type) GetTOUCH_PAD9_TOUCH_PAD0_SLP_IE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD9.Reg) & 0x8000) >> 15
}
func (o *RTCIO_Type) SetTOUCH_PAD9_TOUCH_PAD0_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD9.Reg, volatile.LoadUint32(&o.TOUCH_PAD9.Reg)&^(0x10000)|value<<16)
}
func (o *RTCIO_Type) GetTOUCH_PAD9_TOUCH_PAD0_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD9.Reg) & 0x10000) >> 16
}
func (o *RTCIO_Type) SetTOUCH_PAD9_TOUCH_PAD0_FUN_SEL(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD9.Reg, volatile.LoadUint32(&o.TOUCH_PAD9.Reg)&^(0x60000)|value<<17)
}
func (o *RTCIO_Type) GetTOUCH_PAD9_TOUCH_PAD0_FUN_SEL() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD9.Reg) & 0x60000) >> 17
}
func (o *RTCIO_Type) SetTOUCH_PAD9_TOUCH_PAD0_MUX_SEL(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD9.Reg, volatile.LoadUint32(&o.TOUCH_PAD9.Reg)&^(0x80000)|value<<19)
}
func (o *RTCIO_Type) GetTOUCH_PAD9_TOUCH_PAD0_MUX_SEL() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD9.Reg) & 0x80000) >> 19
}
func (o *RTCIO_Type) SetTOUCH_PAD9_TOUCH_PAD0_XPD(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD9.Reg, volatile.LoadUint32(&o.TOUCH_PAD9.Reg)&^(0x100000)|value<<20)
}
func (o *RTCIO_Type) GetTOUCH_PAD9_TOUCH_PAD0_XPD() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD9.Reg) & 0x100000) >> 20
}
func (o *RTCIO_Type) SetTOUCH_PAD9_TOUCH_PAD0_TIE_OPT(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD9.Reg, volatile.LoadUint32(&o.TOUCH_PAD9.Reg)&^(0x200000)|value<<21)
}
func (o *RTCIO_Type) GetTOUCH_PAD9_TOUCH_PAD0_TIE_OPT() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD9.Reg) & 0x200000) >> 21
}
func (o *RTCIO_Type) SetTOUCH_PAD9_TOUCH_PAD0_START(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD9.Reg, volatile.LoadUint32(&o.TOUCH_PAD9.Reg)&^(0x400000)|value<<22)
}
func (o *RTCIO_Type) GetTOUCH_PAD9_TOUCH_PAD0_START() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD9.Reg) & 0x400000) >> 22
}
func (o *RTCIO_Type) SetTOUCH_PAD9_TOUCH_PAD0_DAC(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD9.Reg, volatile.LoadUint32(&o.TOUCH_PAD9.Reg)&^(0x3800000)|value<<23)
}
func (o *RTCIO_Type) GetTOUCH_PAD9_TOUCH_PAD0_DAC() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD9.Reg) & 0x3800000) >> 23
}
func (o *RTCIO_Type) SetTOUCH_PAD9_TOUCH_PAD0_RUE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD9.Reg, volatile.LoadUint32(&o.TOUCH_PAD9.Reg)&^(0x8000000)|value<<27)
}
func (o *RTCIO_Type) GetTOUCH_PAD9_TOUCH_PAD0_RUE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD9.Reg) & 0x8000000) >> 27
}
func (o *RTCIO_Type) SetTOUCH_PAD9_TOUCH_PAD0_RDE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD9.Reg, volatile.LoadUint32(&o.TOUCH_PAD9.Reg)&^(0x10000000)|value<<28)
}
func (o *RTCIO_Type) GetTOUCH_PAD9_TOUCH_PAD0_RDE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD9.Reg) & 0x10000000) >> 28
}
func (o *RTCIO_Type) SetTOUCH_PAD9_TOUCH_PAD0_DRV(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD9.Reg, volatile.LoadUint32(&o.TOUCH_PAD9.Reg)&^(0x60000000)|value<<29)
}
func (o *RTCIO_Type) GetTOUCH_PAD9_TOUCH_PAD0_DRV() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD9.Reg) & 0x60000000) >> 29
}

// RTCIO.TOUCH_PAD10: Touch pad %s configuration register
func (o *RTCIO_Type) SetTOUCH_PAD10_TOUCH_PAD0_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD10.Reg, volatile.LoadUint32(&o.TOUCH_PAD10.Reg)&^(0x2000)|value<<13)
}
func (o *RTCIO_Type) GetTOUCH_PAD10_TOUCH_PAD0_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD10.Reg) & 0x2000) >> 13
}
func (o *RTCIO_Type) SetTOUCH_PAD10_TOUCH_PAD0_SLP_OE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD10.Reg, volatile.LoadUint32(&o.TOUCH_PAD10.Reg)&^(0x4000)|value<<14)
}
func (o *RTCIO_Type) GetTOUCH_PAD10_TOUCH_PAD0_SLP_OE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD10.Reg) & 0x4000) >> 14
}
func (o *RTCIO_Type) SetTOUCH_PAD10_TOUCH_PAD0_SLP_IE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD10.Reg, volatile.LoadUint32(&o.TOUCH_PAD10.Reg)&^(0x8000)|value<<15)
}
func (o *RTCIO_Type) GetTOUCH_PAD10_TOUCH_PAD0_SLP_IE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD10.Reg) & 0x8000) >> 15
}
func (o *RTCIO_Type) SetTOUCH_PAD10_TOUCH_PAD0_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD10.Reg, volatile.LoadUint32(&o.TOUCH_PAD10.Reg)&^(0x10000)|value<<16)
}
func (o *RTCIO_Type) GetTOUCH_PAD10_TOUCH_PAD0_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD10.Reg) & 0x10000) >> 16
}
func (o *RTCIO_Type) SetTOUCH_PAD10_TOUCH_PAD0_FUN_SEL(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD10.Reg, volatile.LoadUint32(&o.TOUCH_PAD10.Reg)&^(0x60000)|value<<17)
}
func (o *RTCIO_Type) GetTOUCH_PAD10_TOUCH_PAD0_FUN_SEL() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD10.Reg) & 0x60000) >> 17
}
func (o *RTCIO_Type) SetTOUCH_PAD10_TOUCH_PAD0_MUX_SEL(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD10.Reg, volatile.LoadUint32(&o.TOUCH_PAD10.Reg)&^(0x80000)|value<<19)
}
func (o *RTCIO_Type) GetTOUCH_PAD10_TOUCH_PAD0_MUX_SEL() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD10.Reg) & 0x80000) >> 19
}
func (o *RTCIO_Type) SetTOUCH_PAD10_TOUCH_PAD0_XPD(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD10.Reg, volatile.LoadUint32(&o.TOUCH_PAD10.Reg)&^(0x100000)|value<<20)
}
func (o *RTCIO_Type) GetTOUCH_PAD10_TOUCH_PAD0_XPD() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD10.Reg) & 0x100000) >> 20
}
func (o *RTCIO_Type) SetTOUCH_PAD10_TOUCH_PAD0_TIE_OPT(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD10.Reg, volatile.LoadUint32(&o.TOUCH_PAD10.Reg)&^(0x200000)|value<<21)
}
func (o *RTCIO_Type) GetTOUCH_PAD10_TOUCH_PAD0_TIE_OPT() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD10.Reg) & 0x200000) >> 21
}
func (o *RTCIO_Type) SetTOUCH_PAD10_TOUCH_PAD0_START(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD10.Reg, volatile.LoadUint32(&o.TOUCH_PAD10.Reg)&^(0x400000)|value<<22)
}
func (o *RTCIO_Type) GetTOUCH_PAD10_TOUCH_PAD0_START() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD10.Reg) & 0x400000) >> 22
}
func (o *RTCIO_Type) SetTOUCH_PAD10_TOUCH_PAD0_DAC(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD10.Reg, volatile.LoadUint32(&o.TOUCH_PAD10.Reg)&^(0x3800000)|value<<23)
}
func (o *RTCIO_Type) GetTOUCH_PAD10_TOUCH_PAD0_DAC() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD10.Reg) & 0x3800000) >> 23
}
func (o *RTCIO_Type) SetTOUCH_PAD10_TOUCH_PAD0_RUE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD10.Reg, volatile.LoadUint32(&o.TOUCH_PAD10.Reg)&^(0x8000000)|value<<27)
}
func (o *RTCIO_Type) GetTOUCH_PAD10_TOUCH_PAD0_RUE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD10.Reg) & 0x8000000) >> 27
}
func (o *RTCIO_Type) SetTOUCH_PAD10_TOUCH_PAD0_RDE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD10.Reg, volatile.LoadUint32(&o.TOUCH_PAD10.Reg)&^(0x10000000)|value<<28)
}
func (o *RTCIO_Type) GetTOUCH_PAD10_TOUCH_PAD0_RDE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD10.Reg) & 0x10000000) >> 28
}
func (o *RTCIO_Type) SetTOUCH_PAD10_TOUCH_PAD0_DRV(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD10.Reg, volatile.LoadUint32(&o.TOUCH_PAD10.Reg)&^(0x60000000)|value<<29)
}
func (o *RTCIO_Type) GetTOUCH_PAD10_TOUCH_PAD0_DRV() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD10.Reg) & 0x60000000) >> 29
}

// RTCIO.TOUCH_PAD11: Touch pad %s configuration register
func (o *RTCIO_Type) SetTOUCH_PAD11_TOUCH_PAD0_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD11.Reg, volatile.LoadUint32(&o.TOUCH_PAD11.Reg)&^(0x2000)|value<<13)
}
func (o *RTCIO_Type) GetTOUCH_PAD11_TOUCH_PAD0_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD11.Reg) & 0x2000) >> 13
}
func (o *RTCIO_Type) SetTOUCH_PAD11_TOUCH_PAD0_SLP_OE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD11.Reg, volatile.LoadUint32(&o.TOUCH_PAD11.Reg)&^(0x4000)|value<<14)
}
func (o *RTCIO_Type) GetTOUCH_PAD11_TOUCH_PAD0_SLP_OE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD11.Reg) & 0x4000) >> 14
}
func (o *RTCIO_Type) SetTOUCH_PAD11_TOUCH_PAD0_SLP_IE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD11.Reg, volatile.LoadUint32(&o.TOUCH_PAD11.Reg)&^(0x8000)|value<<15)
}
func (o *RTCIO_Type) GetTOUCH_PAD11_TOUCH_PAD0_SLP_IE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD11.Reg) & 0x8000) >> 15
}
func (o *RTCIO_Type) SetTOUCH_PAD11_TOUCH_PAD0_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD11.Reg, volatile.LoadUint32(&o.TOUCH_PAD11.Reg)&^(0x10000)|value<<16)
}
func (o *RTCIO_Type) GetTOUCH_PAD11_TOUCH_PAD0_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD11.Reg) & 0x10000) >> 16
}
func (o *RTCIO_Type) SetTOUCH_PAD11_TOUCH_PAD0_FUN_SEL(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD11.Reg, volatile.LoadUint32(&o.TOUCH_PAD11.Reg)&^(0x60000)|value<<17)
}
func (o *RTCIO_Type) GetTOUCH_PAD11_TOUCH_PAD0_FUN_SEL() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD11.Reg) & 0x60000) >> 17
}
func (o *RTCIO_Type) SetTOUCH_PAD11_TOUCH_PAD0_MUX_SEL(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD11.Reg, volatile.LoadUint32(&o.TOUCH_PAD11.Reg)&^(0x80000)|value<<19)
}
func (o *RTCIO_Type) GetTOUCH_PAD11_TOUCH_PAD0_MUX_SEL() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD11.Reg) & 0x80000) >> 19
}
func (o *RTCIO_Type) SetTOUCH_PAD11_TOUCH_PAD0_XPD(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD11.Reg, volatile.LoadUint32(&o.TOUCH_PAD11.Reg)&^(0x100000)|value<<20)
}
func (o *RTCIO_Type) GetTOUCH_PAD11_TOUCH_PAD0_XPD() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD11.Reg) & 0x100000) >> 20
}
func (o *RTCIO_Type) SetTOUCH_PAD11_TOUCH_PAD0_TIE_OPT(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD11.Reg, volatile.LoadUint32(&o.TOUCH_PAD11.Reg)&^(0x200000)|value<<21)
}
func (o *RTCIO_Type) GetTOUCH_PAD11_TOUCH_PAD0_TIE_OPT() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD11.Reg) & 0x200000) >> 21
}
func (o *RTCIO_Type) SetTOUCH_PAD11_TOUCH_PAD0_START(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD11.Reg, volatile.LoadUint32(&o.TOUCH_PAD11.Reg)&^(0x400000)|value<<22)
}
func (o *RTCIO_Type) GetTOUCH_PAD11_TOUCH_PAD0_START() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD11.Reg) & 0x400000) >> 22
}
func (o *RTCIO_Type) SetTOUCH_PAD11_TOUCH_PAD0_DAC(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD11.Reg, volatile.LoadUint32(&o.TOUCH_PAD11.Reg)&^(0x3800000)|value<<23)
}
func (o *RTCIO_Type) GetTOUCH_PAD11_TOUCH_PAD0_DAC() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD11.Reg) & 0x3800000) >> 23
}
func (o *RTCIO_Type) SetTOUCH_PAD11_TOUCH_PAD0_RUE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD11.Reg, volatile.LoadUint32(&o.TOUCH_PAD11.Reg)&^(0x8000000)|value<<27)
}
func (o *RTCIO_Type) GetTOUCH_PAD11_TOUCH_PAD0_RUE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD11.Reg) & 0x8000000) >> 27
}
func (o *RTCIO_Type) SetTOUCH_PAD11_TOUCH_PAD0_RDE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD11.Reg, volatile.LoadUint32(&o.TOUCH_PAD11.Reg)&^(0x10000000)|value<<28)
}
func (o *RTCIO_Type) GetTOUCH_PAD11_TOUCH_PAD0_RDE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD11.Reg) & 0x10000000) >> 28
}
func (o *RTCIO_Type) SetTOUCH_PAD11_TOUCH_PAD0_DRV(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD11.Reg, volatile.LoadUint32(&o.TOUCH_PAD11.Reg)&^(0x60000000)|value<<29)
}
func (o *RTCIO_Type) GetTOUCH_PAD11_TOUCH_PAD0_DRV() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD11.Reg) & 0x60000000) >> 29
}

// RTCIO.TOUCH_PAD12: Touch pad %s configuration register
func (o *RTCIO_Type) SetTOUCH_PAD12_TOUCH_PAD0_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD12.Reg, volatile.LoadUint32(&o.TOUCH_PAD12.Reg)&^(0x2000)|value<<13)
}
func (o *RTCIO_Type) GetTOUCH_PAD12_TOUCH_PAD0_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD12.Reg) & 0x2000) >> 13
}
func (o *RTCIO_Type) SetTOUCH_PAD12_TOUCH_PAD0_SLP_OE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD12.Reg, volatile.LoadUint32(&o.TOUCH_PAD12.Reg)&^(0x4000)|value<<14)
}
func (o *RTCIO_Type) GetTOUCH_PAD12_TOUCH_PAD0_SLP_OE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD12.Reg) & 0x4000) >> 14
}
func (o *RTCIO_Type) SetTOUCH_PAD12_TOUCH_PAD0_SLP_IE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD12.Reg, volatile.LoadUint32(&o.TOUCH_PAD12.Reg)&^(0x8000)|value<<15)
}
func (o *RTCIO_Type) GetTOUCH_PAD12_TOUCH_PAD0_SLP_IE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD12.Reg) & 0x8000) >> 15
}
func (o *RTCIO_Type) SetTOUCH_PAD12_TOUCH_PAD0_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD12.Reg, volatile.LoadUint32(&o.TOUCH_PAD12.Reg)&^(0x10000)|value<<16)
}
func (o *RTCIO_Type) GetTOUCH_PAD12_TOUCH_PAD0_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD12.Reg) & 0x10000) >> 16
}
func (o *RTCIO_Type) SetTOUCH_PAD12_TOUCH_PAD0_FUN_SEL(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD12.Reg, volatile.LoadUint32(&o.TOUCH_PAD12.Reg)&^(0x60000)|value<<17)
}
func (o *RTCIO_Type) GetTOUCH_PAD12_TOUCH_PAD0_FUN_SEL() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD12.Reg) & 0x60000) >> 17
}
func (o *RTCIO_Type) SetTOUCH_PAD12_TOUCH_PAD0_MUX_SEL(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD12.Reg, volatile.LoadUint32(&o.TOUCH_PAD12.Reg)&^(0x80000)|value<<19)
}
func (o *RTCIO_Type) GetTOUCH_PAD12_TOUCH_PAD0_MUX_SEL() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD12.Reg) & 0x80000) >> 19
}
func (o *RTCIO_Type) SetTOUCH_PAD12_TOUCH_PAD0_XPD(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD12.Reg, volatile.LoadUint32(&o.TOUCH_PAD12.Reg)&^(0x100000)|value<<20)
}
func (o *RTCIO_Type) GetTOUCH_PAD12_TOUCH_PAD0_XPD() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD12.Reg) & 0x100000) >> 20
}
func (o *RTCIO_Type) SetTOUCH_PAD12_TOUCH_PAD0_TIE_OPT(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD12.Reg, volatile.LoadUint32(&o.TOUCH_PAD12.Reg)&^(0x200000)|value<<21)
}
func (o *RTCIO_Type) GetTOUCH_PAD12_TOUCH_PAD0_TIE_OPT() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD12.Reg) & 0x200000) >> 21
}
func (o *RTCIO_Type) SetTOUCH_PAD12_TOUCH_PAD0_START(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD12.Reg, volatile.LoadUint32(&o.TOUCH_PAD12.Reg)&^(0x400000)|value<<22)
}
func (o *RTCIO_Type) GetTOUCH_PAD12_TOUCH_PAD0_START() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD12.Reg) & 0x400000) >> 22
}
func (o *RTCIO_Type) SetTOUCH_PAD12_TOUCH_PAD0_DAC(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD12.Reg, volatile.LoadUint32(&o.TOUCH_PAD12.Reg)&^(0x3800000)|value<<23)
}
func (o *RTCIO_Type) GetTOUCH_PAD12_TOUCH_PAD0_DAC() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD12.Reg) & 0x3800000) >> 23
}
func (o *RTCIO_Type) SetTOUCH_PAD12_TOUCH_PAD0_RUE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD12.Reg, volatile.LoadUint32(&o.TOUCH_PAD12.Reg)&^(0x8000000)|value<<27)
}
func (o *RTCIO_Type) GetTOUCH_PAD12_TOUCH_PAD0_RUE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD12.Reg) & 0x8000000) >> 27
}
func (o *RTCIO_Type) SetTOUCH_PAD12_TOUCH_PAD0_RDE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD12.Reg, volatile.LoadUint32(&o.TOUCH_PAD12.Reg)&^(0x10000000)|value<<28)
}
func (o *RTCIO_Type) GetTOUCH_PAD12_TOUCH_PAD0_RDE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD12.Reg) & 0x10000000) >> 28
}
func (o *RTCIO_Type) SetTOUCH_PAD12_TOUCH_PAD0_DRV(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD12.Reg, volatile.LoadUint32(&o.TOUCH_PAD12.Reg)&^(0x60000000)|value<<29)
}
func (o *RTCIO_Type) GetTOUCH_PAD12_TOUCH_PAD0_DRV() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD12.Reg) & 0x60000000) >> 29
}

// RTCIO.TOUCH_PAD13: Touch pad %s configuration register
func (o *RTCIO_Type) SetTOUCH_PAD13_TOUCH_PAD0_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD13.Reg, volatile.LoadUint32(&o.TOUCH_PAD13.Reg)&^(0x2000)|value<<13)
}
func (o *RTCIO_Type) GetTOUCH_PAD13_TOUCH_PAD0_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD13.Reg) & 0x2000) >> 13
}
func (o *RTCIO_Type) SetTOUCH_PAD13_TOUCH_PAD0_SLP_OE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD13.Reg, volatile.LoadUint32(&o.TOUCH_PAD13.Reg)&^(0x4000)|value<<14)
}
func (o *RTCIO_Type) GetTOUCH_PAD13_TOUCH_PAD0_SLP_OE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD13.Reg) & 0x4000) >> 14
}
func (o *RTCIO_Type) SetTOUCH_PAD13_TOUCH_PAD0_SLP_IE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD13.Reg, volatile.LoadUint32(&o.TOUCH_PAD13.Reg)&^(0x8000)|value<<15)
}
func (o *RTCIO_Type) GetTOUCH_PAD13_TOUCH_PAD0_SLP_IE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD13.Reg) & 0x8000) >> 15
}
func (o *RTCIO_Type) SetTOUCH_PAD13_TOUCH_PAD0_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD13.Reg, volatile.LoadUint32(&o.TOUCH_PAD13.Reg)&^(0x10000)|value<<16)
}
func (o *RTCIO_Type) GetTOUCH_PAD13_TOUCH_PAD0_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD13.Reg) & 0x10000) >> 16
}
func (o *RTCIO_Type) SetTOUCH_PAD13_TOUCH_PAD0_FUN_SEL(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD13.Reg, volatile.LoadUint32(&o.TOUCH_PAD13.Reg)&^(0x60000)|value<<17)
}
func (o *RTCIO_Type) GetTOUCH_PAD13_TOUCH_PAD0_FUN_SEL() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD13.Reg) & 0x60000) >> 17
}
func (o *RTCIO_Type) SetTOUCH_PAD13_TOUCH_PAD0_MUX_SEL(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD13.Reg, volatile.LoadUint32(&o.TOUCH_PAD13.Reg)&^(0x80000)|value<<19)
}
func (o *RTCIO_Type) GetTOUCH_PAD13_TOUCH_PAD0_MUX_SEL() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD13.Reg) & 0x80000) >> 19
}
func (o *RTCIO_Type) SetTOUCH_PAD13_TOUCH_PAD0_XPD(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD13.Reg, volatile.LoadUint32(&o.TOUCH_PAD13.Reg)&^(0x100000)|value<<20)
}
func (o *RTCIO_Type) GetTOUCH_PAD13_TOUCH_PAD0_XPD() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD13.Reg) & 0x100000) >> 20
}
func (o *RTCIO_Type) SetTOUCH_PAD13_TOUCH_PAD0_TIE_OPT(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD13.Reg, volatile.LoadUint32(&o.TOUCH_PAD13.Reg)&^(0x200000)|value<<21)
}
func (o *RTCIO_Type) GetTOUCH_PAD13_TOUCH_PAD0_TIE_OPT() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD13.Reg) & 0x200000) >> 21
}
func (o *RTCIO_Type) SetTOUCH_PAD13_TOUCH_PAD0_START(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD13.Reg, volatile.LoadUint32(&o.TOUCH_PAD13.Reg)&^(0x400000)|value<<22)
}
func (o *RTCIO_Type) GetTOUCH_PAD13_TOUCH_PAD0_START() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD13.Reg) & 0x400000) >> 22
}
func (o *RTCIO_Type) SetTOUCH_PAD13_TOUCH_PAD0_DAC(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD13.Reg, volatile.LoadUint32(&o.TOUCH_PAD13.Reg)&^(0x3800000)|value<<23)
}
func (o *RTCIO_Type) GetTOUCH_PAD13_TOUCH_PAD0_DAC() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD13.Reg) & 0x3800000) >> 23
}
func (o *RTCIO_Type) SetTOUCH_PAD13_TOUCH_PAD0_RUE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD13.Reg, volatile.LoadUint32(&o.TOUCH_PAD13.Reg)&^(0x8000000)|value<<27)
}
func (o *RTCIO_Type) GetTOUCH_PAD13_TOUCH_PAD0_RUE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD13.Reg) & 0x8000000) >> 27
}
func (o *RTCIO_Type) SetTOUCH_PAD13_TOUCH_PAD0_RDE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD13.Reg, volatile.LoadUint32(&o.TOUCH_PAD13.Reg)&^(0x10000000)|value<<28)
}
func (o *RTCIO_Type) GetTOUCH_PAD13_TOUCH_PAD0_RDE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD13.Reg) & 0x10000000) >> 28
}
func (o *RTCIO_Type) SetTOUCH_PAD13_TOUCH_PAD0_DRV(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD13.Reg, volatile.LoadUint32(&o.TOUCH_PAD13.Reg)&^(0x60000000)|value<<29)
}
func (o *RTCIO_Type) GetTOUCH_PAD13_TOUCH_PAD0_DRV() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD13.Reg) & 0x60000000) >> 29
}

// RTCIO.TOUCH_PAD14: Touch pad %s configuration register
func (o *RTCIO_Type) SetTOUCH_PAD14_TOUCH_PAD0_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD14.Reg, volatile.LoadUint32(&o.TOUCH_PAD14.Reg)&^(0x2000)|value<<13)
}
func (o *RTCIO_Type) GetTOUCH_PAD14_TOUCH_PAD0_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD14.Reg) & 0x2000) >> 13
}
func (o *RTCIO_Type) SetTOUCH_PAD14_TOUCH_PAD0_SLP_OE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD14.Reg, volatile.LoadUint32(&o.TOUCH_PAD14.Reg)&^(0x4000)|value<<14)
}
func (o *RTCIO_Type) GetTOUCH_PAD14_TOUCH_PAD0_SLP_OE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD14.Reg) & 0x4000) >> 14
}
func (o *RTCIO_Type) SetTOUCH_PAD14_TOUCH_PAD0_SLP_IE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD14.Reg, volatile.LoadUint32(&o.TOUCH_PAD14.Reg)&^(0x8000)|value<<15)
}
func (o *RTCIO_Type) GetTOUCH_PAD14_TOUCH_PAD0_SLP_IE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD14.Reg) & 0x8000) >> 15
}
func (o *RTCIO_Type) SetTOUCH_PAD14_TOUCH_PAD0_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD14.Reg, volatile.LoadUint32(&o.TOUCH_PAD14.Reg)&^(0x10000)|value<<16)
}
func (o *RTCIO_Type) GetTOUCH_PAD14_TOUCH_PAD0_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD14.Reg) & 0x10000) >> 16
}
func (o *RTCIO_Type) SetTOUCH_PAD14_TOUCH_PAD0_FUN_SEL(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD14.Reg, volatile.LoadUint32(&o.TOUCH_PAD14.Reg)&^(0x60000)|value<<17)
}
func (o *RTCIO_Type) GetTOUCH_PAD14_TOUCH_PAD0_FUN_SEL() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD14.Reg) & 0x60000) >> 17
}
func (o *RTCIO_Type) SetTOUCH_PAD14_TOUCH_PAD0_MUX_SEL(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD14.Reg, volatile.LoadUint32(&o.TOUCH_PAD14.Reg)&^(0x80000)|value<<19)
}
func (o *RTCIO_Type) GetTOUCH_PAD14_TOUCH_PAD0_MUX_SEL() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD14.Reg) & 0x80000) >> 19
}
func (o *RTCIO_Type) SetTOUCH_PAD14_TOUCH_PAD0_XPD(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD14.Reg, volatile.LoadUint32(&o.TOUCH_PAD14.Reg)&^(0x100000)|value<<20)
}
func (o *RTCIO_Type) GetTOUCH_PAD14_TOUCH_PAD0_XPD() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD14.Reg) & 0x100000) >> 20
}
func (o *RTCIO_Type) SetTOUCH_PAD14_TOUCH_PAD0_TIE_OPT(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD14.Reg, volatile.LoadUint32(&o.TOUCH_PAD14.Reg)&^(0x200000)|value<<21)
}
func (o *RTCIO_Type) GetTOUCH_PAD14_TOUCH_PAD0_TIE_OPT() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD14.Reg) & 0x200000) >> 21
}
func (o *RTCIO_Type) SetTOUCH_PAD14_TOUCH_PAD0_START(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD14.Reg, volatile.LoadUint32(&o.TOUCH_PAD14.Reg)&^(0x400000)|value<<22)
}
func (o *RTCIO_Type) GetTOUCH_PAD14_TOUCH_PAD0_START() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD14.Reg) & 0x400000) >> 22
}
func (o *RTCIO_Type) SetTOUCH_PAD14_TOUCH_PAD0_DAC(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD14.Reg, volatile.LoadUint32(&o.TOUCH_PAD14.Reg)&^(0x3800000)|value<<23)
}
func (o *RTCIO_Type) GetTOUCH_PAD14_TOUCH_PAD0_DAC() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD14.Reg) & 0x3800000) >> 23
}
func (o *RTCIO_Type) SetTOUCH_PAD14_TOUCH_PAD0_RUE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD14.Reg, volatile.LoadUint32(&o.TOUCH_PAD14.Reg)&^(0x8000000)|value<<27)
}
func (o *RTCIO_Type) GetTOUCH_PAD14_TOUCH_PAD0_RUE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD14.Reg) & 0x8000000) >> 27
}
func (o *RTCIO_Type) SetTOUCH_PAD14_TOUCH_PAD0_RDE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD14.Reg, volatile.LoadUint32(&o.TOUCH_PAD14.Reg)&^(0x10000000)|value<<28)
}
func (o *RTCIO_Type) GetTOUCH_PAD14_TOUCH_PAD0_RDE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD14.Reg) & 0x10000000) >> 28
}
func (o *RTCIO_Type) SetTOUCH_PAD14_TOUCH_PAD0_DRV(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD14.Reg, volatile.LoadUint32(&o.TOUCH_PAD14.Reg)&^(0x60000000)|value<<29)
}
func (o *RTCIO_Type) GetTOUCH_PAD14_TOUCH_PAD0_DRV() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD14.Reg) & 0x60000000) >> 29
}

// RTCIO.XTAL_32P_PAD: 32KHz crystal P-pad configuration register
func (o *RTCIO_Type) SetXTAL_32P_PAD_X32P_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.XTAL_32P_PAD.Reg, volatile.LoadUint32(&o.XTAL_32P_PAD.Reg)&^(0x2000)|value<<13)
}
func (o *RTCIO_Type) GetXTAL_32P_PAD_X32P_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.XTAL_32P_PAD.Reg) & 0x2000) >> 13
}
func (o *RTCIO_Type) SetXTAL_32P_PAD_X32P_SLP_OE(value uint32) {
	volatile.StoreUint32(&o.XTAL_32P_PAD.Reg, volatile.LoadUint32(&o.XTAL_32P_PAD.Reg)&^(0x4000)|value<<14)
}
func (o *RTCIO_Type) GetXTAL_32P_PAD_X32P_SLP_OE() uint32 {
	return (volatile.LoadUint32(&o.XTAL_32P_PAD.Reg) & 0x4000) >> 14
}
func (o *RTCIO_Type) SetXTAL_32P_PAD_X32P_SLP_IE(value uint32) {
	volatile.StoreUint32(&o.XTAL_32P_PAD.Reg, volatile.LoadUint32(&o.XTAL_32P_PAD.Reg)&^(0x8000)|value<<15)
}
func (o *RTCIO_Type) GetXTAL_32P_PAD_X32P_SLP_IE() uint32 {
	return (volatile.LoadUint32(&o.XTAL_32P_PAD.Reg) & 0x8000) >> 15
}
func (o *RTCIO_Type) SetXTAL_32P_PAD_X32P_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.XTAL_32P_PAD.Reg, volatile.LoadUint32(&o.XTAL_32P_PAD.Reg)&^(0x10000)|value<<16)
}
func (o *RTCIO_Type) GetXTAL_32P_PAD_X32P_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.XTAL_32P_PAD.Reg) & 0x10000) >> 16
}
func (o *RTCIO_Type) SetXTAL_32P_PAD_X32P_FUN_SEL(value uint32) {
	volatile.StoreUint32(&o.XTAL_32P_PAD.Reg, volatile.LoadUint32(&o.XTAL_32P_PAD.Reg)&^(0x60000)|value<<17)
}
func (o *RTCIO_Type) GetXTAL_32P_PAD_X32P_FUN_SEL() uint32 {
	return (volatile.LoadUint32(&o.XTAL_32P_PAD.Reg) & 0x60000) >> 17
}
func (o *RTCIO_Type) SetXTAL_32P_PAD_X32P_MUX_SEL(value uint32) {
	volatile.StoreUint32(&o.XTAL_32P_PAD.Reg, volatile.LoadUint32(&o.XTAL_32P_PAD.Reg)&^(0x80000)|value<<19)
}
func (o *RTCIO_Type) GetXTAL_32P_PAD_X32P_MUX_SEL() uint32 {
	return (volatile.LoadUint32(&o.XTAL_32P_PAD.Reg) & 0x80000) >> 19
}
func (o *RTCIO_Type) SetXTAL_32P_PAD_X32P_RUE(value uint32) {
	volatile.StoreUint32(&o.XTAL_32P_PAD.Reg, volatile.LoadUint32(&o.XTAL_32P_PAD.Reg)&^(0x8000000)|value<<27)
}
func (o *RTCIO_Type) GetXTAL_32P_PAD_X32P_RUE() uint32 {
	return (volatile.LoadUint32(&o.XTAL_32P_PAD.Reg) & 0x8000000) >> 27
}
func (o *RTCIO_Type) SetXTAL_32P_PAD_X32P_RDE(value uint32) {
	volatile.StoreUint32(&o.XTAL_32P_PAD.Reg, volatile.LoadUint32(&o.XTAL_32P_PAD.Reg)&^(0x10000000)|value<<28)
}
func (o *RTCIO_Type) GetXTAL_32P_PAD_X32P_RDE() uint32 {
	return (volatile.LoadUint32(&o.XTAL_32P_PAD.Reg) & 0x10000000) >> 28
}
func (o *RTCIO_Type) SetXTAL_32P_PAD_X32P_DRV(value uint32) {
	volatile.StoreUint32(&o.XTAL_32P_PAD.Reg, volatile.LoadUint32(&o.XTAL_32P_PAD.Reg)&^(0x60000000)|value<<29)
}
func (o *RTCIO_Type) GetXTAL_32P_PAD_X32P_DRV() uint32 {
	return (volatile.LoadUint32(&o.XTAL_32P_PAD.Reg) & 0x60000000) >> 29
}

// RTCIO.XTAL_32N_PAD: 32KHz crystal N-pad configuration register
func (o *RTCIO_Type) SetXTAL_32N_PAD_X32N_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.XTAL_32N_PAD.Reg, volatile.LoadUint32(&o.XTAL_32N_PAD.Reg)&^(0x2000)|value<<13)
}
func (o *RTCIO_Type) GetXTAL_32N_PAD_X32N_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.XTAL_32N_PAD.Reg) & 0x2000) >> 13
}
func (o *RTCIO_Type) SetXTAL_32N_PAD_X32N_SLP_OE(value uint32) {
	volatile.StoreUint32(&o.XTAL_32N_PAD.Reg, volatile.LoadUint32(&o.XTAL_32N_PAD.Reg)&^(0x4000)|value<<14)
}
func (o *RTCIO_Type) GetXTAL_32N_PAD_X32N_SLP_OE() uint32 {
	return (volatile.LoadUint32(&o.XTAL_32N_PAD.Reg) & 0x4000) >> 14
}
func (o *RTCIO_Type) SetXTAL_32N_PAD_X32N_SLP_IE(value uint32) {
	volatile.StoreUint32(&o.XTAL_32N_PAD.Reg, volatile.LoadUint32(&o.XTAL_32N_PAD.Reg)&^(0x8000)|value<<15)
}
func (o *RTCIO_Type) GetXTAL_32N_PAD_X32N_SLP_IE() uint32 {
	return (volatile.LoadUint32(&o.XTAL_32N_PAD.Reg) & 0x8000) >> 15
}
func (o *RTCIO_Type) SetXTAL_32N_PAD_X32N_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.XTAL_32N_PAD.Reg, volatile.LoadUint32(&o.XTAL_32N_PAD.Reg)&^(0x10000)|value<<16)
}
func (o *RTCIO_Type) GetXTAL_32N_PAD_X32N_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.XTAL_32N_PAD.Reg) & 0x10000) >> 16
}
func (o *RTCIO_Type) SetXTAL_32N_PAD_X32N_FUN_SEL(value uint32) {
	volatile.StoreUint32(&o.XTAL_32N_PAD.Reg, volatile.LoadUint32(&o.XTAL_32N_PAD.Reg)&^(0x60000)|value<<17)
}
func (o *RTCIO_Type) GetXTAL_32N_PAD_X32N_FUN_SEL() uint32 {
	return (volatile.LoadUint32(&o.XTAL_32N_PAD.Reg) & 0x60000) >> 17
}
func (o *RTCIO_Type) SetXTAL_32N_PAD_X32N_MUX_SEL(value uint32) {
	volatile.StoreUint32(&o.XTAL_32N_PAD.Reg, volatile.LoadUint32(&o.XTAL_32N_PAD.Reg)&^(0x80000)|value<<19)
}
func (o *RTCIO_Type) GetXTAL_32N_PAD_X32N_MUX_SEL() uint32 {
	return (volatile.LoadUint32(&o.XTAL_32N_PAD.Reg) & 0x80000) >> 19
}
func (o *RTCIO_Type) SetXTAL_32N_PAD_X32N_RUE(value uint32) {
	volatile.StoreUint32(&o.XTAL_32N_PAD.Reg, volatile.LoadUint32(&o.XTAL_32N_PAD.Reg)&^(0x8000000)|value<<27)
}
func (o *RTCIO_Type) GetXTAL_32N_PAD_X32N_RUE() uint32 {
	return (volatile.LoadUint32(&o.XTAL_32N_PAD.Reg) & 0x8000000) >> 27
}
func (o *RTCIO_Type) SetXTAL_32N_PAD_X32N_RDE(value uint32) {
	volatile.StoreUint32(&o.XTAL_32N_PAD.Reg, volatile.LoadUint32(&o.XTAL_32N_PAD.Reg)&^(0x10000000)|value<<28)
}
func (o *RTCIO_Type) GetXTAL_32N_PAD_X32N_RDE() uint32 {
	return (volatile.LoadUint32(&o.XTAL_32N_PAD.Reg) & 0x10000000) >> 28
}
func (o *RTCIO_Type) SetXTAL_32N_PAD_X32N_DRV(value uint32) {
	volatile.StoreUint32(&o.XTAL_32N_PAD.Reg, volatile.LoadUint32(&o.XTAL_32N_PAD.Reg)&^(0x60000000)|value<<29)
}
func (o *RTCIO_Type) GetXTAL_32N_PAD_X32N_DRV() uint32 {
	return (volatile.LoadUint32(&o.XTAL_32N_PAD.Reg) & 0x60000000) >> 29
}

// RTCIO.PAD_DAC1: DAC1 configuration register
func (o *RTCIO_Type) SetPAD_DAC1_PDAC1_DAC(value uint32) {
	volatile.StoreUint32(&o.PAD_DAC1.Reg, volatile.LoadUint32(&o.PAD_DAC1.Reg)&^(0x7f8)|value<<3)
}
func (o *RTCIO_Type) GetPAD_DAC1_PDAC1_DAC() uint32 {
	return (volatile.LoadUint32(&o.PAD_DAC1.Reg) & 0x7f8) >> 3
}
func (o *RTCIO_Type) SetPAD_DAC1_PDAC1_XPD_DAC(value uint32) {
	volatile.StoreUint32(&o.PAD_DAC1.Reg, volatile.LoadUint32(&o.PAD_DAC1.Reg)&^(0x800)|value<<11)
}
func (o *RTCIO_Type) GetPAD_DAC1_PDAC1_XPD_DAC() uint32 {
	return (volatile.LoadUint32(&o.PAD_DAC1.Reg) & 0x800) >> 11
}
func (o *RTCIO_Type) SetPAD_DAC1_PDAC1_DAC_XPD_FORCE(value uint32) {
	volatile.StoreUint32(&o.PAD_DAC1.Reg, volatile.LoadUint32(&o.PAD_DAC1.Reg)&^(0x1000)|value<<12)
}
func (o *RTCIO_Type) GetPAD_DAC1_PDAC1_DAC_XPD_FORCE() uint32 {
	return (volatile.LoadUint32(&o.PAD_DAC1.Reg) & 0x1000) >> 12
}
func (o *RTCIO_Type) SetPAD_DAC1_PDAC1_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.PAD_DAC1.Reg, volatile.LoadUint32(&o.PAD_DAC1.Reg)&^(0x2000)|value<<13)
}
func (o *RTCIO_Type) GetPAD_DAC1_PDAC1_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.PAD_DAC1.Reg) & 0x2000) >> 13
}
func (o *RTCIO_Type) SetPAD_DAC1_PDAC1_SLP_OE(value uint32) {
	volatile.StoreUint32(&o.PAD_DAC1.Reg, volatile.LoadUint32(&o.PAD_DAC1.Reg)&^(0x4000)|value<<14)
}
func (o *RTCIO_Type) GetPAD_DAC1_PDAC1_SLP_OE() uint32 {
	return (volatile.LoadUint32(&o.PAD_DAC1.Reg) & 0x4000) >> 14
}
func (o *RTCIO_Type) SetPAD_DAC1_PDAC1_SLP_IE(value uint32) {
	volatile.StoreUint32(&o.PAD_DAC1.Reg, volatile.LoadUint32(&o.PAD_DAC1.Reg)&^(0x8000)|value<<15)
}
func (o *RTCIO_Type) GetPAD_DAC1_PDAC1_SLP_IE() uint32 {
	return (volatile.LoadUint32(&o.PAD_DAC1.Reg) & 0x8000) >> 15
}
func (o *RTCIO_Type) SetPAD_DAC1_PDAC1_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.PAD_DAC1.Reg, volatile.LoadUint32(&o.PAD_DAC1.Reg)&^(0x10000)|value<<16)
}
func (o *RTCIO_Type) GetPAD_DAC1_PDAC1_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.PAD_DAC1.Reg) & 0x10000) >> 16
}
func (o *RTCIO_Type) SetPAD_DAC1_PDAC1_FUN_SEL(value uint32) {
	volatile.StoreUint32(&o.PAD_DAC1.Reg, volatile.LoadUint32(&o.PAD_DAC1.Reg)&^(0x60000)|value<<17)
}
func (o *RTCIO_Type) GetPAD_DAC1_PDAC1_FUN_SEL() uint32 {
	return (volatile.LoadUint32(&o.PAD_DAC1.Reg) & 0x60000) >> 17
}
func (o *RTCIO_Type) SetPAD_DAC1_PDAC1_MUX_SEL(value uint32) {
	volatile.StoreUint32(&o.PAD_DAC1.Reg, volatile.LoadUint32(&o.PAD_DAC1.Reg)&^(0x80000)|value<<19)
}
func (o *RTCIO_Type) GetPAD_DAC1_PDAC1_MUX_SEL() uint32 {
	return (volatile.LoadUint32(&o.PAD_DAC1.Reg) & 0x80000) >> 19
}
func (o *RTCIO_Type) SetPAD_DAC1_PDAC1_RUE(value uint32) {
	volatile.StoreUint32(&o.PAD_DAC1.Reg, volatile.LoadUint32(&o.PAD_DAC1.Reg)&^(0x8000000)|value<<27)
}
func (o *RTCIO_Type) GetPAD_DAC1_PDAC1_RUE() uint32 {
	return (volatile.LoadUint32(&o.PAD_DAC1.Reg) & 0x8000000) >> 27
}
func (o *RTCIO_Type) SetPAD_DAC1_PDAC1_RDE(value uint32) {
	volatile.StoreUint32(&o.PAD_DAC1.Reg, volatile.LoadUint32(&o.PAD_DAC1.Reg)&^(0x10000000)|value<<28)
}
func (o *RTCIO_Type) GetPAD_DAC1_PDAC1_RDE() uint32 {
	return (volatile.LoadUint32(&o.PAD_DAC1.Reg) & 0x10000000) >> 28
}
func (o *RTCIO_Type) SetPAD_DAC1_PDAC1_DRV(value uint32) {
	volatile.StoreUint32(&o.PAD_DAC1.Reg, volatile.LoadUint32(&o.PAD_DAC1.Reg)&^(0x60000000)|value<<29)
}
func (o *RTCIO_Type) GetPAD_DAC1_PDAC1_DRV() uint32 {
	return (volatile.LoadUint32(&o.PAD_DAC1.Reg) & 0x60000000) >> 29
}

// RTCIO.PAD_DAC2: DAC2 configuration register
func (o *RTCIO_Type) SetPAD_DAC2_PDAC2_DAC(value uint32) {
	volatile.StoreUint32(&o.PAD_DAC2.Reg, volatile.LoadUint32(&o.PAD_DAC2.Reg)&^(0x7f8)|value<<3)
}
func (o *RTCIO_Type) GetPAD_DAC2_PDAC2_DAC() uint32 {
	return (volatile.LoadUint32(&o.PAD_DAC2.Reg) & 0x7f8) >> 3
}
func (o *RTCIO_Type) SetPAD_DAC2_PDAC2_XPD_DAC(value uint32) {
	volatile.StoreUint32(&o.PAD_DAC2.Reg, volatile.LoadUint32(&o.PAD_DAC2.Reg)&^(0x800)|value<<11)
}
func (o *RTCIO_Type) GetPAD_DAC2_PDAC2_XPD_DAC() uint32 {
	return (volatile.LoadUint32(&o.PAD_DAC2.Reg) & 0x800) >> 11
}
func (o *RTCIO_Type) SetPAD_DAC2_PDAC2_DAC_XPD_FORCE(value uint32) {
	volatile.StoreUint32(&o.PAD_DAC2.Reg, volatile.LoadUint32(&o.PAD_DAC2.Reg)&^(0x1000)|value<<12)
}
func (o *RTCIO_Type) GetPAD_DAC2_PDAC2_DAC_XPD_FORCE() uint32 {
	return (volatile.LoadUint32(&o.PAD_DAC2.Reg) & 0x1000) >> 12
}
func (o *RTCIO_Type) SetPAD_DAC2_PDAC2_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.PAD_DAC2.Reg, volatile.LoadUint32(&o.PAD_DAC2.Reg)&^(0x2000)|value<<13)
}
func (o *RTCIO_Type) GetPAD_DAC2_PDAC2_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.PAD_DAC2.Reg) & 0x2000) >> 13
}
func (o *RTCIO_Type) SetPAD_DAC2_PDAC2_SLP_OE(value uint32) {
	volatile.StoreUint32(&o.PAD_DAC2.Reg, volatile.LoadUint32(&o.PAD_DAC2.Reg)&^(0x4000)|value<<14)
}
func (o *RTCIO_Type) GetPAD_DAC2_PDAC2_SLP_OE() uint32 {
	return (volatile.LoadUint32(&o.PAD_DAC2.Reg) & 0x4000) >> 14
}
func (o *RTCIO_Type) SetPAD_DAC2_PDAC2_SLP_IE(value uint32) {
	volatile.StoreUint32(&o.PAD_DAC2.Reg, volatile.LoadUint32(&o.PAD_DAC2.Reg)&^(0x8000)|value<<15)
}
func (o *RTCIO_Type) GetPAD_DAC2_PDAC2_SLP_IE() uint32 {
	return (volatile.LoadUint32(&o.PAD_DAC2.Reg) & 0x8000) >> 15
}
func (o *RTCIO_Type) SetPAD_DAC2_PDAC2_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.PAD_DAC2.Reg, volatile.LoadUint32(&o.PAD_DAC2.Reg)&^(0x10000)|value<<16)
}
func (o *RTCIO_Type) GetPAD_DAC2_PDAC2_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.PAD_DAC2.Reg) & 0x10000) >> 16
}
func (o *RTCIO_Type) SetPAD_DAC2_PDAC2_FUN_SEL(value uint32) {
	volatile.StoreUint32(&o.PAD_DAC2.Reg, volatile.LoadUint32(&o.PAD_DAC2.Reg)&^(0x60000)|value<<17)
}
func (o *RTCIO_Type) GetPAD_DAC2_PDAC2_FUN_SEL() uint32 {
	return (volatile.LoadUint32(&o.PAD_DAC2.Reg) & 0x60000) >> 17
}
func (o *RTCIO_Type) SetPAD_DAC2_PDAC2_MUX_SEL(value uint32) {
	volatile.StoreUint32(&o.PAD_DAC2.Reg, volatile.LoadUint32(&o.PAD_DAC2.Reg)&^(0x80000)|value<<19)
}
func (o *RTCIO_Type) GetPAD_DAC2_PDAC2_MUX_SEL() uint32 {
	return (volatile.LoadUint32(&o.PAD_DAC2.Reg) & 0x80000) >> 19
}
func (o *RTCIO_Type) SetPAD_DAC2_PDAC2_RUE(value uint32) {
	volatile.StoreUint32(&o.PAD_DAC2.Reg, volatile.LoadUint32(&o.PAD_DAC2.Reg)&^(0x8000000)|value<<27)
}
func (o *RTCIO_Type) GetPAD_DAC2_PDAC2_RUE() uint32 {
	return (volatile.LoadUint32(&o.PAD_DAC2.Reg) & 0x8000000) >> 27
}
func (o *RTCIO_Type) SetPAD_DAC2_PDAC2_RDE(value uint32) {
	volatile.StoreUint32(&o.PAD_DAC2.Reg, volatile.LoadUint32(&o.PAD_DAC2.Reg)&^(0x10000000)|value<<28)
}
func (o *RTCIO_Type) GetPAD_DAC2_PDAC2_RDE() uint32 {
	return (volatile.LoadUint32(&o.PAD_DAC2.Reg) & 0x10000000) >> 28
}
func (o *RTCIO_Type) SetPAD_DAC2_PDAC2_DRV(value uint32) {
	volatile.StoreUint32(&o.PAD_DAC2.Reg, volatile.LoadUint32(&o.PAD_DAC2.Reg)&^(0x60000000)|value<<29)
}
func (o *RTCIO_Type) GetPAD_DAC2_PDAC2_DRV() uint32 {
	return (volatile.LoadUint32(&o.PAD_DAC2.Reg) & 0x60000000) >> 29
}

// RTCIO.RTC_PAD19: Touch pad 19 configuration register
func (o *RTCIO_Type) SetRTC_PAD19_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.RTC_PAD19.Reg, volatile.LoadUint32(&o.RTC_PAD19.Reg)&^(0x2000)|value<<13)
}
func (o *RTCIO_Type) GetRTC_PAD19_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.RTC_PAD19.Reg) & 0x2000) >> 13
}
func (o *RTCIO_Type) SetRTC_PAD19_SLP_OE(value uint32) {
	volatile.StoreUint32(&o.RTC_PAD19.Reg, volatile.LoadUint32(&o.RTC_PAD19.Reg)&^(0x4000)|value<<14)
}
func (o *RTCIO_Type) GetRTC_PAD19_SLP_OE() uint32 {
	return (volatile.LoadUint32(&o.RTC_PAD19.Reg) & 0x4000) >> 14
}
func (o *RTCIO_Type) SetRTC_PAD19_SLP_IE(value uint32) {
	volatile.StoreUint32(&o.RTC_PAD19.Reg, volatile.LoadUint32(&o.RTC_PAD19.Reg)&^(0x8000)|value<<15)
}
func (o *RTCIO_Type) GetRTC_PAD19_SLP_IE() uint32 {
	return (volatile.LoadUint32(&o.RTC_PAD19.Reg) & 0x8000) >> 15
}
func (o *RTCIO_Type) SetRTC_PAD19_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.RTC_PAD19.Reg, volatile.LoadUint32(&o.RTC_PAD19.Reg)&^(0x10000)|value<<16)
}
func (o *RTCIO_Type) GetRTC_PAD19_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.RTC_PAD19.Reg) & 0x10000) >> 16
}
func (o *RTCIO_Type) SetRTC_PAD19_FUN_SEL(value uint32) {
	volatile.StoreUint32(&o.RTC_PAD19.Reg, volatile.LoadUint32(&o.RTC_PAD19.Reg)&^(0x60000)|value<<17)
}
func (o *RTCIO_Type) GetRTC_PAD19_FUN_SEL() uint32 {
	return (volatile.LoadUint32(&o.RTC_PAD19.Reg) & 0x60000) >> 17
}
func (o *RTCIO_Type) SetRTC_PAD19_MUX_SEL(value uint32) {
	volatile.StoreUint32(&o.RTC_PAD19.Reg, volatile.LoadUint32(&o.RTC_PAD19.Reg)&^(0x80000)|value<<19)
}
func (o *RTCIO_Type) GetRTC_PAD19_MUX_SEL() uint32 {
	return (volatile.LoadUint32(&o.RTC_PAD19.Reg) & 0x80000) >> 19
}
func (o *RTCIO_Type) SetRTC_PAD19_RUE(value uint32) {
	volatile.StoreUint32(&o.RTC_PAD19.Reg, volatile.LoadUint32(&o.RTC_PAD19.Reg)&^(0x8000000)|value<<27)
}
func (o *RTCIO_Type) GetRTC_PAD19_RUE() uint32 {
	return (volatile.LoadUint32(&o.RTC_PAD19.Reg) & 0x8000000) >> 27
}
func (o *RTCIO_Type) SetRTC_PAD19_RDE(value uint32) {
	volatile.StoreUint32(&o.RTC_PAD19.Reg, volatile.LoadUint32(&o.RTC_PAD19.Reg)&^(0x10000000)|value<<28)
}
func (o *RTCIO_Type) GetRTC_PAD19_RDE() uint32 {
	return (volatile.LoadUint32(&o.RTC_PAD19.Reg) & 0x10000000) >> 28
}
func (o *RTCIO_Type) SetRTC_PAD19_DRV(value uint32) {
	volatile.StoreUint32(&o.RTC_PAD19.Reg, volatile.LoadUint32(&o.RTC_PAD19.Reg)&^(0x60000000)|value<<29)
}
func (o *RTCIO_Type) GetRTC_PAD19_DRV() uint32 {
	return (volatile.LoadUint32(&o.RTC_PAD19.Reg) & 0x60000000) >> 29
}

// RTCIO.RTC_PAD20: Touch pad 20 configuration register
func (o *RTCIO_Type) SetRTC_PAD20_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.RTC_PAD20.Reg, volatile.LoadUint32(&o.RTC_PAD20.Reg)&^(0x2000)|value<<13)
}
func (o *RTCIO_Type) GetRTC_PAD20_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.RTC_PAD20.Reg) & 0x2000) >> 13
}
func (o *RTCIO_Type) SetRTC_PAD20_SLP_OE(value uint32) {
	volatile.StoreUint32(&o.RTC_PAD20.Reg, volatile.LoadUint32(&o.RTC_PAD20.Reg)&^(0x4000)|value<<14)
}
func (o *RTCIO_Type) GetRTC_PAD20_SLP_OE() uint32 {
	return (volatile.LoadUint32(&o.RTC_PAD20.Reg) & 0x4000) >> 14
}
func (o *RTCIO_Type) SetRTC_PAD20_SLP_IE(value uint32) {
	volatile.StoreUint32(&o.RTC_PAD20.Reg, volatile.LoadUint32(&o.RTC_PAD20.Reg)&^(0x8000)|value<<15)
}
func (o *RTCIO_Type) GetRTC_PAD20_SLP_IE() uint32 {
	return (volatile.LoadUint32(&o.RTC_PAD20.Reg) & 0x8000) >> 15
}
func (o *RTCIO_Type) SetRTC_PAD20_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.RTC_PAD20.Reg, volatile.LoadUint32(&o.RTC_PAD20.Reg)&^(0x10000)|value<<16)
}
func (o *RTCIO_Type) GetRTC_PAD20_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.RTC_PAD20.Reg) & 0x10000) >> 16
}
func (o *RTCIO_Type) SetRTC_PAD20_FUN_SEL(value uint32) {
	volatile.StoreUint32(&o.RTC_PAD20.Reg, volatile.LoadUint32(&o.RTC_PAD20.Reg)&^(0x60000)|value<<17)
}
func (o *RTCIO_Type) GetRTC_PAD20_FUN_SEL() uint32 {
	return (volatile.LoadUint32(&o.RTC_PAD20.Reg) & 0x60000) >> 17
}
func (o *RTCIO_Type) SetRTC_PAD20_MUX_SEL(value uint32) {
	volatile.StoreUint32(&o.RTC_PAD20.Reg, volatile.LoadUint32(&o.RTC_PAD20.Reg)&^(0x80000)|value<<19)
}
func (o *RTCIO_Type) GetRTC_PAD20_MUX_SEL() uint32 {
	return (volatile.LoadUint32(&o.RTC_PAD20.Reg) & 0x80000) >> 19
}
func (o *RTCIO_Type) SetRTC_PAD20_RUE(value uint32) {
	volatile.StoreUint32(&o.RTC_PAD20.Reg, volatile.LoadUint32(&o.RTC_PAD20.Reg)&^(0x8000000)|value<<27)
}
func (o *RTCIO_Type) GetRTC_PAD20_RUE() uint32 {
	return (volatile.LoadUint32(&o.RTC_PAD20.Reg) & 0x8000000) >> 27
}
func (o *RTCIO_Type) SetRTC_PAD20_RDE(value uint32) {
	volatile.StoreUint32(&o.RTC_PAD20.Reg, volatile.LoadUint32(&o.RTC_PAD20.Reg)&^(0x10000000)|value<<28)
}
func (o *RTCIO_Type) GetRTC_PAD20_RDE() uint32 {
	return (volatile.LoadUint32(&o.RTC_PAD20.Reg) & 0x10000000) >> 28
}
func (o *RTCIO_Type) SetRTC_PAD20_DRV(value uint32) {
	volatile.StoreUint32(&o.RTC_PAD20.Reg, volatile.LoadUint32(&o.RTC_PAD20.Reg)&^(0x60000000)|value<<29)
}
func (o *RTCIO_Type) GetRTC_PAD20_DRV() uint32 {
	return (volatile.LoadUint32(&o.RTC_PAD20.Reg) & 0x60000000) >> 29
}

// RTCIO.RTC_PAD21: Touch pad 21 configuration register
func (o *RTCIO_Type) SetRTC_PAD21_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.RTC_PAD21.Reg, volatile.LoadUint32(&o.RTC_PAD21.Reg)&^(0x2000)|value<<13)
}
func (o *RTCIO_Type) GetRTC_PAD21_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.RTC_PAD21.Reg) & 0x2000) >> 13
}
func (o *RTCIO_Type) SetRTC_PAD21_SLP_OE(value uint32) {
	volatile.StoreUint32(&o.RTC_PAD21.Reg, volatile.LoadUint32(&o.RTC_PAD21.Reg)&^(0x4000)|value<<14)
}
func (o *RTCIO_Type) GetRTC_PAD21_SLP_OE() uint32 {
	return (volatile.LoadUint32(&o.RTC_PAD21.Reg) & 0x4000) >> 14
}
func (o *RTCIO_Type) SetRTC_PAD21_SLP_IE(value uint32) {
	volatile.StoreUint32(&o.RTC_PAD21.Reg, volatile.LoadUint32(&o.RTC_PAD21.Reg)&^(0x8000)|value<<15)
}
func (o *RTCIO_Type) GetRTC_PAD21_SLP_IE() uint32 {
	return (volatile.LoadUint32(&o.RTC_PAD21.Reg) & 0x8000) >> 15
}
func (o *RTCIO_Type) SetRTC_PAD21_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.RTC_PAD21.Reg, volatile.LoadUint32(&o.RTC_PAD21.Reg)&^(0x10000)|value<<16)
}
func (o *RTCIO_Type) GetRTC_PAD21_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.RTC_PAD21.Reg) & 0x10000) >> 16
}
func (o *RTCIO_Type) SetRTC_PAD21_FUN_SEL(value uint32) {
	volatile.StoreUint32(&o.RTC_PAD21.Reg, volatile.LoadUint32(&o.RTC_PAD21.Reg)&^(0x60000)|value<<17)
}
func (o *RTCIO_Type) GetRTC_PAD21_FUN_SEL() uint32 {
	return (volatile.LoadUint32(&o.RTC_PAD21.Reg) & 0x60000) >> 17
}
func (o *RTCIO_Type) SetRTC_PAD21_MUX_SEL(value uint32) {
	volatile.StoreUint32(&o.RTC_PAD21.Reg, volatile.LoadUint32(&o.RTC_PAD21.Reg)&^(0x80000)|value<<19)
}
func (o *RTCIO_Type) GetRTC_PAD21_MUX_SEL() uint32 {
	return (volatile.LoadUint32(&o.RTC_PAD21.Reg) & 0x80000) >> 19
}
func (o *RTCIO_Type) SetRTC_PAD21_RUE(value uint32) {
	volatile.StoreUint32(&o.RTC_PAD21.Reg, volatile.LoadUint32(&o.RTC_PAD21.Reg)&^(0x8000000)|value<<27)
}
func (o *RTCIO_Type) GetRTC_PAD21_RUE() uint32 {
	return (volatile.LoadUint32(&o.RTC_PAD21.Reg) & 0x8000000) >> 27
}
func (o *RTCIO_Type) SetRTC_PAD21_RDE(value uint32) {
	volatile.StoreUint32(&o.RTC_PAD21.Reg, volatile.LoadUint32(&o.RTC_PAD21.Reg)&^(0x10000000)|value<<28)
}
func (o *RTCIO_Type) GetRTC_PAD21_RDE() uint32 {
	return (volatile.LoadUint32(&o.RTC_PAD21.Reg) & 0x10000000) >> 28
}
func (o *RTCIO_Type) SetRTC_PAD21_DRV(value uint32) {
	volatile.StoreUint32(&o.RTC_PAD21.Reg, volatile.LoadUint32(&o.RTC_PAD21.Reg)&^(0x60000000)|value<<29)
}
func (o *RTCIO_Type) GetRTC_PAD21_DRV() uint32 {
	return (volatile.LoadUint32(&o.RTC_PAD21.Reg) & 0x60000000) >> 29
}

// RTCIO.EXT_WAKEUP0: External wake up configuration register
func (o *RTCIO_Type) SetEXT_WAKEUP0_SEL(value uint32) {
	volatile.StoreUint32(&o.EXT_WAKEUP0.Reg, volatile.LoadUint32(&o.EXT_WAKEUP0.Reg)&^(0xf8000000)|value<<27)
}
func (o *RTCIO_Type) GetEXT_WAKEUP0_SEL() uint32 {
	return (volatile.LoadUint32(&o.EXT_WAKEUP0.Reg) & 0xf8000000) >> 27
}

// RTCIO.XTL_EXT_CTR: Crystal power down enable GPIO source
func (o *RTCIO_Type) SetXTL_EXT_CTR_SEL(value uint32) {
	volatile.StoreUint32(&o.XTL_EXT_CTR.Reg, volatile.LoadUint32(&o.XTL_EXT_CTR.Reg)&^(0xf8000000)|value<<27)
}
func (o *RTCIO_Type) GetXTL_EXT_CTR_SEL() uint32 {
	return (volatile.LoadUint32(&o.XTL_EXT_CTR.Reg) & 0xf8000000) >> 27
}

// RTCIO.SAR_I2C_IO: RTC I²C pad selection
func (o *RTCIO_Type) SetSAR_I2C_IO_SAR_DEBUG_BIT_SEL(value uint32) {
	volatile.StoreUint32(&o.SAR_I2C_IO.Reg, volatile.LoadUint32(&o.SAR_I2C_IO.Reg)&^(0xf800000)|value<<23)
}
func (o *RTCIO_Type) GetSAR_I2C_IO_SAR_DEBUG_BIT_SEL() uint32 {
	return (volatile.LoadUint32(&o.SAR_I2C_IO.Reg) & 0xf800000) >> 23
}
func (o *RTCIO_Type) SetSAR_I2C_IO_SAR_I2C_SCL_SEL(value uint32) {
	volatile.StoreUint32(&o.SAR_I2C_IO.Reg, volatile.LoadUint32(&o.SAR_I2C_IO.Reg)&^(0x30000000)|value<<28)
}
func (o *RTCIO_Type) GetSAR_I2C_IO_SAR_I2C_SCL_SEL() uint32 {
	return (volatile.LoadUint32(&o.SAR_I2C_IO.Reg) & 0x30000000) >> 28
}
func (o *RTCIO_Type) SetSAR_I2C_IO_SAR_I2C_SDA_SEL(value uint32) {
	volatile.StoreUint32(&o.SAR_I2C_IO.Reg, volatile.LoadUint32(&o.SAR_I2C_IO.Reg)&^(0xc0000000)|value<<30)
}
func (o *RTCIO_Type) GetSAR_I2C_IO_SAR_I2C_SDA_SEL() uint32 {
	return (volatile.LoadUint32(&o.SAR_I2C_IO.Reg) & 0xc0000000) >> 30
}

// RTCIO.RTC_IO_TOUCH_CTRL: Touch Control register
func (o *RTCIO_Type) SetRTC_IO_TOUCH_CTRL_IO_TOUCH_BUFSEL(value uint32) {
	volatile.StoreUint32(&o.RTC_IO_TOUCH_CTRL.Reg, volatile.LoadUint32(&o.RTC_IO_TOUCH_CTRL.Reg)&^(0xf)|value)
}
func (o *RTCIO_Type) GetRTC_IO_TOUCH_CTRL_IO_TOUCH_BUFSEL() uint32 {
	return volatile.LoadUint32(&o.RTC_IO_TOUCH_CTRL.Reg) & 0xf
}
func (o *RTCIO_Type) SetRTC_IO_TOUCH_CTRL_IO_TOUCH_BUFMODE(value uint32) {
	volatile.StoreUint32(&o.RTC_IO_TOUCH_CTRL.Reg, volatile.LoadUint32(&o.RTC_IO_TOUCH_CTRL.Reg)&^(0x10)|value<<4)
}
func (o *RTCIO_Type) GetRTC_IO_TOUCH_CTRL_IO_TOUCH_BUFMODE() uint32 {
	return (volatile.LoadUint32(&o.RTC_IO_TOUCH_CTRL.Reg) & 0x10) >> 4
}

// RTCIO.RTC_IO_DATE: Version control register
func (o *RTCIO_Type) SetRTC_IO_DATE_IO_DATE(value uint32) {
	volatile.StoreUint32(&o.RTC_IO_DATE.Reg, volatile.LoadUint32(&o.RTC_IO_DATE.Reg)&^(0xfffffff)|value)
}
func (o *RTCIO_Type) GetRTC_IO_DATE_IO_DATE() uint32 {
	return volatile.LoadUint32(&o.RTC_IO_DATE.Reg) & 0xfffffff
}

// Peripheral RTC_CNTL
type RTC_CNTL_Type struct {
	OPTIONS0           volatile.Register32 // 0x0
	SLP_TIMER0         volatile.Register32 // 0x4
	SLP_TIMER1         volatile.Register32 // 0x8
	TIME_UPDATE        volatile.Register32 // 0xC
	TIME_LOW0          volatile.Register32 // 0x10
	TIME_HIGH0         volatile.Register32 // 0x14
	STATE0             volatile.Register32 // 0x18
	TIMER1             volatile.Register32 // 0x1C
	TIMER2             volatile.Register32 // 0x20
	TIMER3             volatile.Register32 // 0x24
	TIMER4             volatile.Register32 // 0x28
	TIMER5             volatile.Register32 // 0x2C
	TIMER6             volatile.Register32 // 0x30
	ANA_CONF           volatile.Register32 // 0x34
	RESET_STATE        volatile.Register32 // 0x38
	WAKEUP_STATE       volatile.Register32 // 0x3C
	INT_ENA_RTC        volatile.Register32 // 0x40
	INT_RAW_RTC        volatile.Register32 // 0x44
	INT_ST_RTC         volatile.Register32 // 0x48
	INT_CLR_RTC        volatile.Register32 // 0x4C
	STORE0             volatile.Register32 // 0x50
	STORE1             volatile.Register32 // 0x54
	STORE2             volatile.Register32 // 0x58
	STORE3             volatile.Register32 // 0x5C
	EXT_XTL_CONF       volatile.Register32 // 0x60
	EXT_WAKEUP_CONF    volatile.Register32 // 0x64
	SLP_REJECT_CONF    volatile.Register32 // 0x68
	CPU_PERIOD_CONF    volatile.Register32 // 0x6C
	SDIO_ACT_CONF      volatile.Register32 // 0x70
	CLK_CONF           volatile.Register32 // 0x74
	SLOW_CLK_CONF      volatile.Register32 // 0x78
	SDIO_CONF          volatile.Register32 // 0x7C
	BIAS_CONF          volatile.Register32 // 0x80
	BIAS               volatile.Register32 // 0x84
	PWC                volatile.Register32 // 0x88
	DIG_PWC            volatile.Register32 // 0x8C
	DIG_ISO            volatile.Register32 // 0x90
	WDTCONFIG0         volatile.Register32 // 0x94
	WDTCONFIG1         volatile.Register32 // 0x98
	WDTCONFIG2         volatile.Register32 // 0x9C
	WDTCONFIG3         volatile.Register32 // 0xA0
	WDTCONFIG4         volatile.Register32 // 0xA4
	WDTFEED            volatile.Register32 // 0xA8
	WDTWPROTECT        volatile.Register32 // 0xAC
	SWD_CONF           volatile.Register32 // 0xB0
	SWD_WPROTECT       volatile.Register32 // 0xB4
	SW_CPU_STALL       volatile.Register32 // 0xB8
	STORE4             volatile.Register32 // 0xBC
	STORE5             volatile.Register32 // 0xC0
	STORE6             volatile.Register32 // 0xC4
	STORE7             volatile.Register32 // 0xC8
	LOW_POWER_ST       volatile.Register32 // 0xCC
	DIAG0              volatile.Register32 // 0xD0
	PAD_HOLD           volatile.Register32 // 0xD4
	DIG_PAD_HOLD       volatile.Register32 // 0xD8
	EXT_WAKEUP1        volatile.Register32 // 0xDC
	EXT_WAKEUP1_STATUS volatile.Register32 // 0xE0
	BROWN_OUT          volatile.Register32 // 0xE4
	TIME_LOW1          volatile.Register32 // 0xE8
	TIME_HIGH1         volatile.Register32 // 0xEC
	XTAL32K_CLK_FACTOR volatile.Register32 // 0xF0
	XTAL32K_CONF       volatile.Register32 // 0xF4
	ULP_CP_TIMER       volatile.Register32 // 0xF8
	ULP_CP_CTRL        volatile.Register32 // 0xFC
	COCPU_CTRL         volatile.Register32 // 0x100
	TOUCH_CTRL1        volatile.Register32 // 0x104
	TOUCH_CTRL2        volatile.Register32 // 0x108
	TOUCH_SCAN_CTRL    volatile.Register32 // 0x10C
	TOUCH_SLP_THRES    volatile.Register32 // 0x110
	TOUCH_APPROACH     volatile.Register32 // 0x114
	TOUCH_FILTER_CTRL  volatile.Register32 // 0x118
	USB_CONF           volatile.Register32 // 0x11C
	TOUCH_TIMEOUT_CTRL volatile.Register32 // 0x120
	SLP_REJECT_CAUSE   volatile.Register32 // 0x124
	OPTIONS1           volatile.Register32 // 0x128
	SLP_WAKEUP_CAUSE   volatile.Register32 // 0x12C
	ULP_CP_TIMER_1     volatile.Register32 // 0x130
	_                  [4]byte
	DATE               volatile.Register32 // 0x138
}

// RTC_CNTL.OPTIONS0: Sets the power options of crystal and PLL clocks, and initiates reset by software
func (o *RTC_CNTL_Type) SetOPTIONS0_SW_STALL_APPCPU_C0(value uint32) {
	volatile.StoreUint32(&o.OPTIONS0.Reg, volatile.LoadUint32(&o.OPTIONS0.Reg)&^(0x3)|value)
}
func (o *RTC_CNTL_Type) GetOPTIONS0_SW_STALL_APPCPU_C0() uint32 {
	return volatile.LoadUint32(&o.OPTIONS0.Reg) & 0x3
}
func (o *RTC_CNTL_Type) SetOPTIONS0_SW_STALL_PROCPU_C0(value uint32) {
	volatile.StoreUint32(&o.OPTIONS0.Reg, volatile.LoadUint32(&o.OPTIONS0.Reg)&^(0xc)|value<<2)
}
func (o *RTC_CNTL_Type) GetOPTIONS0_SW_STALL_PROCPU_C0() uint32 {
	return (volatile.LoadUint32(&o.OPTIONS0.Reg) & 0xc) >> 2
}
func (o *RTC_CNTL_Type) SetOPTIONS0_SW_APPCPU_RST(value uint32) {
	volatile.StoreUint32(&o.OPTIONS0.Reg, volatile.LoadUint32(&o.OPTIONS0.Reg)&^(0x10)|value<<4)
}
func (o *RTC_CNTL_Type) GetOPTIONS0_SW_APPCPU_RST() uint32 {
	return (volatile.LoadUint32(&o.OPTIONS0.Reg) & 0x10) >> 4
}
func (o *RTC_CNTL_Type) SetOPTIONS0_SW_PROCPU_RST(value uint32) {
	volatile.StoreUint32(&o.OPTIONS0.Reg, volatile.LoadUint32(&o.OPTIONS0.Reg)&^(0x20)|value<<5)
}
func (o *RTC_CNTL_Type) GetOPTIONS0_SW_PROCPU_RST() uint32 {
	return (volatile.LoadUint32(&o.OPTIONS0.Reg) & 0x20) >> 5
}
func (o *RTC_CNTL_Type) SetOPTIONS0_BB_I2C_FORCE_PD(value uint32) {
	volatile.StoreUint32(&o.OPTIONS0.Reg, volatile.LoadUint32(&o.OPTIONS0.Reg)&^(0x40)|value<<6)
}
func (o *RTC_CNTL_Type) GetOPTIONS0_BB_I2C_FORCE_PD() uint32 {
	return (volatile.LoadUint32(&o.OPTIONS0.Reg) & 0x40) >> 6
}
func (o *RTC_CNTL_Type) SetOPTIONS0_BB_I2C_FORCE_PU(value uint32) {
	volatile.StoreUint32(&o.OPTIONS0.Reg, volatile.LoadUint32(&o.OPTIONS0.Reg)&^(0x80)|value<<7)
}
func (o *RTC_CNTL_Type) GetOPTIONS0_BB_I2C_FORCE_PU() uint32 {
	return (volatile.LoadUint32(&o.OPTIONS0.Reg) & 0x80) >> 7
}
func (o *RTC_CNTL_Type) SetOPTIONS0_BBPLL_I2C_FORCE_PD(value uint32) {
	volatile.StoreUint32(&o.OPTIONS0.Reg, volatile.LoadUint32(&o.OPTIONS0.Reg)&^(0x100)|value<<8)
}
func (o *RTC_CNTL_Type) GetOPTIONS0_BBPLL_I2C_FORCE_PD() uint32 {
	return (volatile.LoadUint32(&o.OPTIONS0.Reg) & 0x100) >> 8
}
func (o *RTC_CNTL_Type) SetOPTIONS0_BBPLL_I2C_FORCE_PU(value uint32) {
	volatile.StoreUint32(&o.OPTIONS0.Reg, volatile.LoadUint32(&o.OPTIONS0.Reg)&^(0x200)|value<<9)
}
func (o *RTC_CNTL_Type) GetOPTIONS0_BBPLL_I2C_FORCE_PU() uint32 {
	return (volatile.LoadUint32(&o.OPTIONS0.Reg) & 0x200) >> 9
}
func (o *RTC_CNTL_Type) SetOPTIONS0_BBPLL_FORCE_PD(value uint32) {
	volatile.StoreUint32(&o.OPTIONS0.Reg, volatile.LoadUint32(&o.OPTIONS0.Reg)&^(0x400)|value<<10)
}
func (o *RTC_CNTL_Type) GetOPTIONS0_BBPLL_FORCE_PD() uint32 {
	return (volatile.LoadUint32(&o.OPTIONS0.Reg) & 0x400) >> 10
}
func (o *RTC_CNTL_Type) SetOPTIONS0_BBPLL_FORCE_PU(value uint32) {
	volatile.StoreUint32(&o.OPTIONS0.Reg, volatile.LoadUint32(&o.OPTIONS0.Reg)&^(0x800)|value<<11)
}
func (o *RTC_CNTL_Type) GetOPTIONS0_BBPLL_FORCE_PU() uint32 {
	return (volatile.LoadUint32(&o.OPTIONS0.Reg) & 0x800) >> 11
}
func (o *RTC_CNTL_Type) SetOPTIONS0_XTL_FORCE_PD(value uint32) {
	volatile.StoreUint32(&o.OPTIONS0.Reg, volatile.LoadUint32(&o.OPTIONS0.Reg)&^(0x1000)|value<<12)
}
func (o *RTC_CNTL_Type) GetOPTIONS0_XTL_FORCE_PD() uint32 {
	return (volatile.LoadUint32(&o.OPTIONS0.Reg) & 0x1000) >> 12
}
func (o *RTC_CNTL_Type) SetOPTIONS0_XTL_FORCE_PU(value uint32) {
	volatile.StoreUint32(&o.OPTIONS0.Reg, volatile.LoadUint32(&o.OPTIONS0.Reg)&^(0x2000)|value<<13)
}
func (o *RTC_CNTL_Type) GetOPTIONS0_XTL_FORCE_PU() uint32 {
	return (volatile.LoadUint32(&o.OPTIONS0.Reg) & 0x2000) >> 13
}
func (o *RTC_CNTL_Type) SetOPTIONS0_XTL_FORCE_ISO(value uint32) {
	volatile.StoreUint32(&o.OPTIONS0.Reg, volatile.LoadUint32(&o.OPTIONS0.Reg)&^(0x800000)|value<<23)
}
func (o *RTC_CNTL_Type) GetOPTIONS0_XTL_FORCE_ISO() uint32 {
	return (volatile.LoadUint32(&o.OPTIONS0.Reg) & 0x800000) >> 23
}
func (o *RTC_CNTL_Type) SetOPTIONS0_PLL_FORCE_ISO(value uint32) {
	volatile.StoreUint32(&o.OPTIONS0.Reg, volatile.LoadUint32(&o.OPTIONS0.Reg)&^(0x1000000)|value<<24)
}
func (o *RTC_CNTL_Type) GetOPTIONS0_PLL_FORCE_ISO() uint32 {
	return (volatile.LoadUint32(&o.OPTIONS0.Reg) & 0x1000000) >> 24
}
func (o *RTC_CNTL_Type) SetOPTIONS0_ANALOG_FORCE_ISO(value uint32) {
	volatile.StoreUint32(&o.OPTIONS0.Reg, volatile.LoadUint32(&o.OPTIONS0.Reg)&^(0x2000000)|value<<25)
}
func (o *RTC_CNTL_Type) GetOPTIONS0_ANALOG_FORCE_ISO() uint32 {
	return (volatile.LoadUint32(&o.OPTIONS0.Reg) & 0x2000000) >> 25
}
func (o *RTC_CNTL_Type) SetOPTIONS0_XTL_FORCE_NOISO(value uint32) {
	volatile.StoreUint32(&o.OPTIONS0.Reg, volatile.LoadUint32(&o.OPTIONS0.Reg)&^(0x4000000)|value<<26)
}
func (o *RTC_CNTL_Type) GetOPTIONS0_XTL_FORCE_NOISO() uint32 {
	return (volatile.LoadUint32(&o.OPTIONS0.Reg) & 0x4000000) >> 26
}
func (o *RTC_CNTL_Type) SetOPTIONS0_PLL_FORCE_NOISO(value uint32) {
	volatile.StoreUint32(&o.OPTIONS0.Reg, volatile.LoadUint32(&o.OPTIONS0.Reg)&^(0x8000000)|value<<27)
}
func (o *RTC_CNTL_Type) GetOPTIONS0_PLL_FORCE_NOISO() uint32 {
	return (volatile.LoadUint32(&o.OPTIONS0.Reg) & 0x8000000) >> 27
}
func (o *RTC_CNTL_Type) SetOPTIONS0_ANALOG_FORCE_NOISO(value uint32) {
	volatile.StoreUint32(&o.OPTIONS0.Reg, volatile.LoadUint32(&o.OPTIONS0.Reg)&^(0x10000000)|value<<28)
}
func (o *RTC_CNTL_Type) GetOPTIONS0_ANALOG_FORCE_NOISO() uint32 {
	return (volatile.LoadUint32(&o.OPTIONS0.Reg) & 0x10000000) >> 28
}
func (o *RTC_CNTL_Type) SetOPTIONS0_DG_WRAP_FORCE_RST(value uint32) {
	volatile.StoreUint32(&o.OPTIONS0.Reg, volatile.LoadUint32(&o.OPTIONS0.Reg)&^(0x20000000)|value<<29)
}
func (o *RTC_CNTL_Type) GetOPTIONS0_DG_WRAP_FORCE_RST() uint32 {
	return (volatile.LoadUint32(&o.OPTIONS0.Reg) & 0x20000000) >> 29
}
func (o *RTC_CNTL_Type) SetOPTIONS0_DG_WRAP_FORCE_NORST(value uint32) {
	volatile.StoreUint32(&o.OPTIONS0.Reg, volatile.LoadUint32(&o.OPTIONS0.Reg)&^(0x40000000)|value<<30)
}
func (o *RTC_CNTL_Type) GetOPTIONS0_DG_WRAP_FORCE_NORST() uint32 {
	return (volatile.LoadUint32(&o.OPTIONS0.Reg) & 0x40000000) >> 30
}
func (o *RTC_CNTL_Type) SetOPTIONS0_SW_SYS_RST(value uint32) {
	volatile.StoreUint32(&o.OPTIONS0.Reg, volatile.LoadUint32(&o.OPTIONS0.Reg)&^(0x80000000)|value<<31)
}
func (o *RTC_CNTL_Type) GetOPTIONS0_SW_SYS_RST() uint32 {
	return (volatile.LoadUint32(&o.OPTIONS0.Reg) & 0x80000000) >> 31
}

// RTC_CNTL.SLP_TIMER0: RTC timer threshold register 0
func (o *RTC_CNTL_Type) SetSLP_TIMER0(value uint32) {
	volatile.StoreUint32(&o.SLP_TIMER0.Reg, value)
}
func (o *RTC_CNTL_Type) GetSLP_TIMER0() uint32 {
	return volatile.LoadUint32(&o.SLP_TIMER0.Reg)
}

// RTC_CNTL.SLP_TIMER1: RTC timer threshold register 1
func (o *RTC_CNTL_Type) SetSLP_TIMER1_SLP_VAL_HI(value uint32) {
	volatile.StoreUint32(&o.SLP_TIMER1.Reg, volatile.LoadUint32(&o.SLP_TIMER1.Reg)&^(0xffff)|value)
}
func (o *RTC_CNTL_Type) GetSLP_TIMER1_SLP_VAL_HI() uint32 {
	return volatile.LoadUint32(&o.SLP_TIMER1.Reg) & 0xffff
}
func (o *RTC_CNTL_Type) SetSLP_TIMER1_MAIN_TIMER_ALARM_EN(value uint32) {
	volatile.StoreUint32(&o.SLP_TIMER1.Reg, volatile.LoadUint32(&o.SLP_TIMER1.Reg)&^(0x10000)|value<<16)
}
func (o *RTC_CNTL_Type) GetSLP_TIMER1_MAIN_TIMER_ALARM_EN() uint32 {
	return (volatile.LoadUint32(&o.SLP_TIMER1.Reg) & 0x10000) >> 16
}

// RTC_CNTL.TIME_UPDATE: RTC timer update control register
func (o *RTC_CNTL_Type) SetTIME_UPDATE_TIMER_SYS_STALL(value uint32) {
	volatile.StoreUint32(&o.TIME_UPDATE.Reg, volatile.LoadUint32(&o.TIME_UPDATE.Reg)&^(0x8000000)|value<<27)
}
func (o *RTC_CNTL_Type) GetTIME_UPDATE_TIMER_SYS_STALL() uint32 {
	return (volatile.LoadUint32(&o.TIME_UPDATE.Reg) & 0x8000000) >> 27
}
func (o *RTC_CNTL_Type) SetTIME_UPDATE_TIMER_XTL_OFF(value uint32) {
	volatile.StoreUint32(&o.TIME_UPDATE.Reg, volatile.LoadUint32(&o.TIME_UPDATE.Reg)&^(0x10000000)|value<<28)
}
func (o *RTC_CNTL_Type) GetTIME_UPDATE_TIMER_XTL_OFF() uint32 {
	return (volatile.LoadUint32(&o.TIME_UPDATE.Reg) & 0x10000000) >> 28
}
func (o *RTC_CNTL_Type) SetTIME_UPDATE_TIMER_SYS_RST(value uint32) {
	volatile.StoreUint32(&o.TIME_UPDATE.Reg, volatile.LoadUint32(&o.TIME_UPDATE.Reg)&^(0x20000000)|value<<29)
}
func (o *RTC_CNTL_Type) GetTIME_UPDATE_TIMER_SYS_RST() uint32 {
	return (volatile.LoadUint32(&o.TIME_UPDATE.Reg) & 0x20000000) >> 29
}
func (o *RTC_CNTL_Type) SetTIME_UPDATE(value uint32) {
	volatile.StoreUint32(&o.TIME_UPDATE.Reg, volatile.LoadUint32(&o.TIME_UPDATE.Reg)&^(0x80000000)|value<<31)
}
func (o *RTC_CNTL_Type) GetTIME_UPDATE() uint32 {
	return (volatile.LoadUint32(&o.TIME_UPDATE.Reg) & 0x80000000) >> 31
}

// RTC_CNTL.TIME_LOW0: Stores the lower 32 bits of RTC timer 0
func (o *RTC_CNTL_Type) SetTIME_LOW0(value uint32) {
	volatile.StoreUint32(&o.TIME_LOW0.Reg, value)
}
func (o *RTC_CNTL_Type) GetTIME_LOW0() uint32 {
	return volatile.LoadUint32(&o.TIME_LOW0.Reg)
}

// RTC_CNTL.TIME_HIGH0: Stores the higher 16 bits of RTC timer 0
func (o *RTC_CNTL_Type) SetTIME_HIGH0_TIMER_VALUE0_HIGH(value uint32) {
	volatile.StoreUint32(&o.TIME_HIGH0.Reg, volatile.LoadUint32(&o.TIME_HIGH0.Reg)&^(0xffff)|value)
}
func (o *RTC_CNTL_Type) GetTIME_HIGH0_TIMER_VALUE0_HIGH() uint32 {
	return volatile.LoadUint32(&o.TIME_HIGH0.Reg) & 0xffff
}

// RTC_CNTL.STATE0: Configures the sleep / reject / wakeup state
func (o *RTC_CNTL_Type) SetSTATE0_SW_CPU_INT(value uint32) {
	volatile.StoreUint32(&o.STATE0.Reg, volatile.LoadUint32(&o.STATE0.Reg)&^(0x1)|value)
}
func (o *RTC_CNTL_Type) GetSTATE0_SW_CPU_INT() uint32 {
	return volatile.LoadUint32(&o.STATE0.Reg) & 0x1
}
func (o *RTC_CNTL_Type) SetSTATE0_SLP_REJECT_CAUSE_CLR(value uint32) {
	volatile.StoreUint32(&o.STATE0.Reg, volatile.LoadUint32(&o.STATE0.Reg)&^(0x2)|value<<1)
}
func (o *RTC_CNTL_Type) GetSTATE0_SLP_REJECT_CAUSE_CLR() uint32 {
	return (volatile.LoadUint32(&o.STATE0.Reg) & 0x2) >> 1
}
func (o *RTC_CNTL_Type) SetSTATE0_APB2RTC_BRIDGE_SEL(value uint32) {
	volatile.StoreUint32(&o.STATE0.Reg, volatile.LoadUint32(&o.STATE0.Reg)&^(0x400000)|value<<22)
}
func (o *RTC_CNTL_Type) GetSTATE0_APB2RTC_BRIDGE_SEL() uint32 {
	return (volatile.LoadUint32(&o.STATE0.Reg) & 0x400000) >> 22
}
func (o *RTC_CNTL_Type) SetSTATE0_SDIO_ACTIVE_IND(value uint32) {
	volatile.StoreUint32(&o.STATE0.Reg, volatile.LoadUint32(&o.STATE0.Reg)&^(0x10000000)|value<<28)
}
func (o *RTC_CNTL_Type) GetSTATE0_SDIO_ACTIVE_IND() uint32 {
	return (volatile.LoadUint32(&o.STATE0.Reg) & 0x10000000) >> 28
}
func (o *RTC_CNTL_Type) SetSTATE0_SLP_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.STATE0.Reg, volatile.LoadUint32(&o.STATE0.Reg)&^(0x20000000)|value<<29)
}
func (o *RTC_CNTL_Type) GetSTATE0_SLP_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.STATE0.Reg) & 0x20000000) >> 29
}
func (o *RTC_CNTL_Type) SetSTATE0_SLP_REJECT(value uint32) {
	volatile.StoreUint32(&o.STATE0.Reg, volatile.LoadUint32(&o.STATE0.Reg)&^(0x40000000)|value<<30)
}
func (o *RTC_CNTL_Type) GetSTATE0_SLP_REJECT() uint32 {
	return (volatile.LoadUint32(&o.STATE0.Reg) & 0x40000000) >> 30
}
func (o *RTC_CNTL_Type) SetSTATE0_SLEEP_EN(value uint32) {
	volatile.StoreUint32(&o.STATE0.Reg, volatile.LoadUint32(&o.STATE0.Reg)&^(0x80000000)|value<<31)
}
func (o *RTC_CNTL_Type) GetSTATE0_SLEEP_EN() uint32 {
	return (volatile.LoadUint32(&o.STATE0.Reg) & 0x80000000) >> 31
}

// RTC_CNTL.TIMER1: Configures CPU stall options
func (o *RTC_CNTL_Type) SetTIMER1_CPU_STALL_EN(value uint32) {
	volatile.StoreUint32(&o.TIMER1.Reg, volatile.LoadUint32(&o.TIMER1.Reg)&^(0x1)|value)
}
func (o *RTC_CNTL_Type) GetTIMER1_CPU_STALL_EN() uint32 {
	return volatile.LoadUint32(&o.TIMER1.Reg) & 0x1
}
func (o *RTC_CNTL_Type) SetTIMER1_CPU_STALL_WAIT(value uint32) {
	volatile.StoreUint32(&o.TIMER1.Reg, volatile.LoadUint32(&o.TIMER1.Reg)&^(0x3e)|value<<1)
}
func (o *RTC_CNTL_Type) GetTIMER1_CPU_STALL_WAIT() uint32 {
	return (volatile.LoadUint32(&o.TIMER1.Reg) & 0x3e) >> 1
}
func (o *RTC_CNTL_Type) SetTIMER1_CK8M_WAIT(value uint32) {
	volatile.StoreUint32(&o.TIMER1.Reg, volatile.LoadUint32(&o.TIMER1.Reg)&^(0x3fc0)|value<<6)
}
func (o *RTC_CNTL_Type) GetTIMER1_CK8M_WAIT() uint32 {
	return (volatile.LoadUint32(&o.TIMER1.Reg) & 0x3fc0) >> 6
}
func (o *RTC_CNTL_Type) SetTIMER1_XTL_BUF_WAIT(value uint32) {
	volatile.StoreUint32(&o.TIMER1.Reg, volatile.LoadUint32(&o.TIMER1.Reg)&^(0xffc000)|value<<14)
}
func (o *RTC_CNTL_Type) GetTIMER1_XTL_BUF_WAIT() uint32 {
	return (volatile.LoadUint32(&o.TIMER1.Reg) & 0xffc000) >> 14
}
func (o *RTC_CNTL_Type) SetTIMER1_PLL_BUF_WAIT(value uint32) {
	volatile.StoreUint32(&o.TIMER1.Reg, volatile.LoadUint32(&o.TIMER1.Reg)&^(0xff000000)|value<<24)
}
func (o *RTC_CNTL_Type) GetTIMER1_PLL_BUF_WAIT() uint32 {
	return (volatile.LoadUint32(&o.TIMER1.Reg) & 0xff000000) >> 24
}

// RTC_CNTL.TIMER2: Configures RTC slow clock and touch controller
func (o *RTC_CNTL_Type) SetTIMER2_ULPCP_TOUCH_START_WAIT(value uint32) {
	volatile.StoreUint32(&o.TIMER2.Reg, volatile.LoadUint32(&o.TIMER2.Reg)&^(0xff8000)|value<<15)
}
func (o *RTC_CNTL_Type) GetTIMER2_ULPCP_TOUCH_START_WAIT() uint32 {
	return (volatile.LoadUint32(&o.TIMER2.Reg) & 0xff8000) >> 15
}
func (o *RTC_CNTL_Type) SetTIMER2_MIN_TIME_CK8M_OFF(value uint32) {
	volatile.StoreUint32(&o.TIMER2.Reg, volatile.LoadUint32(&o.TIMER2.Reg)&^(0xff000000)|value<<24)
}
func (o *RTC_CNTL_Type) GetTIMER2_MIN_TIME_CK8M_OFF() uint32 {
	return (volatile.LoadUint32(&o.TIMER2.Reg) & 0xff000000) >> 24
}

// RTC_CNTL.TIMER3: configure some wait time for power on
func (o *RTC_CNTL_Type) SetTIMER3_WIFI_WAIT_TIMER(value uint32) {
	volatile.StoreUint32(&o.TIMER3.Reg, volatile.LoadUint32(&o.TIMER3.Reg)&^(0x1ff)|value)
}
func (o *RTC_CNTL_Type) GetTIMER3_WIFI_WAIT_TIMER() uint32 {
	return volatile.LoadUint32(&o.TIMER3.Reg) & 0x1ff
}
func (o *RTC_CNTL_Type) SetTIMER3_WIFI_POWERUP_TIMER(value uint32) {
	volatile.StoreUint32(&o.TIMER3.Reg, volatile.LoadUint32(&o.TIMER3.Reg)&^(0xfe00)|value<<9)
}
func (o *RTC_CNTL_Type) GetTIMER3_WIFI_POWERUP_TIMER() uint32 {
	return (volatile.LoadUint32(&o.TIMER3.Reg) & 0xfe00) >> 9
}
func (o *RTC_CNTL_Type) SetTIMER3_ROM_RAM_WAIT_TIMER(value uint32) {
	volatile.StoreUint32(&o.TIMER3.Reg, volatile.LoadUint32(&o.TIMER3.Reg)&^(0x1ff0000)|value<<16)
}
func (o *RTC_CNTL_Type) GetTIMER3_ROM_RAM_WAIT_TIMER() uint32 {
	return (volatile.LoadUint32(&o.TIMER3.Reg) & 0x1ff0000) >> 16
}
func (o *RTC_CNTL_Type) SetTIMER3_ROM_RAM_POWERUP_TIMER(value uint32) {
	volatile.StoreUint32(&o.TIMER3.Reg, volatile.LoadUint32(&o.TIMER3.Reg)&^(0xfe000000)|value<<25)
}
func (o *RTC_CNTL_Type) GetTIMER3_ROM_RAM_POWERUP_TIMER() uint32 {
	return (volatile.LoadUint32(&o.TIMER3.Reg) & 0xfe000000) >> 25
}

// RTC_CNTL.TIMER4: configure some wait time for power on
func (o *RTC_CNTL_Type) SetTIMER4_WAIT_TIMER(value uint32) {
	volatile.StoreUint32(&o.TIMER4.Reg, volatile.LoadUint32(&o.TIMER4.Reg)&^(0x1ff)|value)
}
func (o *RTC_CNTL_Type) GetTIMER4_WAIT_TIMER() uint32 {
	return volatile.LoadUint32(&o.TIMER4.Reg) & 0x1ff
}
func (o *RTC_CNTL_Type) SetTIMER4_POWERUP_TIMER(value uint32) {
	volatile.StoreUint32(&o.TIMER4.Reg, volatile.LoadUint32(&o.TIMER4.Reg)&^(0xfe00)|value<<9)
}
func (o *RTC_CNTL_Type) GetTIMER4_POWERUP_TIMER() uint32 {
	return (volatile.LoadUint32(&o.TIMER4.Reg) & 0xfe00) >> 9
}
func (o *RTC_CNTL_Type) SetTIMER4_DG_WRAP_WAIT_TIMER(value uint32) {
	volatile.StoreUint32(&o.TIMER4.Reg, volatile.LoadUint32(&o.TIMER4.Reg)&^(0x1ff0000)|value<<16)
}
func (o *RTC_CNTL_Type) GetTIMER4_DG_WRAP_WAIT_TIMER() uint32 {
	return (volatile.LoadUint32(&o.TIMER4.Reg) & 0x1ff0000) >> 16
}
func (o *RTC_CNTL_Type) SetTIMER4_DG_WRAP_POWERUP_TIMER(value uint32) {
	volatile.StoreUint32(&o.TIMER4.Reg, volatile.LoadUint32(&o.TIMER4.Reg)&^(0xfe000000)|value<<25)
}
func (o *RTC_CNTL_Type) GetTIMER4_DG_WRAP_POWERUP_TIMER() uint32 {
	return (volatile.LoadUint32(&o.TIMER4.Reg) & 0xfe000000) >> 25
}

// RTC_CNTL.TIMER5: Configures the minimal sleep cycles
func (o *RTC_CNTL_Type) SetTIMER5_MIN_SLP_VAL(value uint32) {
	volatile.StoreUint32(&o.TIMER5.Reg, volatile.LoadUint32(&o.TIMER5.Reg)&^(0xff00)|value<<8)
}
func (o *RTC_CNTL_Type) GetTIMER5_MIN_SLP_VAL() uint32 {
	return (volatile.LoadUint32(&o.TIMER5.Reg) & 0xff00) >> 8
}
func (o *RTC_CNTL_Type) SetTIMER5_RTCMEM_WAIT_TIMER(value uint32) {
	volatile.StoreUint32(&o.TIMER5.Reg, volatile.LoadUint32(&o.TIMER5.Reg)&^(0x1ff0000)|value<<16)
}
func (o *RTC_CNTL_Type) GetTIMER5_RTCMEM_WAIT_TIMER() uint32 {
	return (volatile.LoadUint32(&o.TIMER5.Reg) & 0x1ff0000) >> 16
}
func (o *RTC_CNTL_Type) SetTIMER5_RTCMEM_POWERUP_TIMER(value uint32) {
	volatile.StoreUint32(&o.TIMER5.Reg, volatile.LoadUint32(&o.TIMER5.Reg)&^(0xfe000000)|value<<25)
}
func (o *RTC_CNTL_Type) GetTIMER5_RTCMEM_POWERUP_TIMER() uint32 {
	return (volatile.LoadUint32(&o.TIMER5.Reg) & 0xfe000000) >> 25
}

// RTC_CNTL.TIMER6: Configure minimal sleep cycles register
func (o *RTC_CNTL_Type) SetTIMER6_DG_DCDC_WAIT_TIMER(value uint32) {
	volatile.StoreUint32(&o.TIMER6.Reg, volatile.LoadUint32(&o.TIMER6.Reg)&^(0x1ff0000)|value<<16)
}
func (o *RTC_CNTL_Type) GetTIMER6_DG_DCDC_WAIT_TIMER() uint32 {
	return (volatile.LoadUint32(&o.TIMER6.Reg) & 0x1ff0000) >> 16
}
func (o *RTC_CNTL_Type) SetTIMER6_DG_DCDC_POWERUP_TIMER(value uint32) {
	volatile.StoreUint32(&o.TIMER6.Reg, volatile.LoadUint32(&o.TIMER6.Reg)&^(0xfe000000)|value<<25)
}
func (o *RTC_CNTL_Type) GetTIMER6_DG_DCDC_POWERUP_TIMER() uint32 {
	return (volatile.LoadUint32(&o.TIMER6.Reg) & 0xfe000000) >> 25
}

// RTC_CNTL.ANA_CONF: Configures the power options for I2C and PLLA
func (o *RTC_CNTL_Type) SetANA_CONF_I2C_RESET_POR_FORCE_PD(value uint32) {
	volatile.StoreUint32(&o.ANA_CONF.Reg, volatile.LoadUint32(&o.ANA_CONF.Reg)&^(0x40000)|value<<18)
}
func (o *RTC_CNTL_Type) GetANA_CONF_I2C_RESET_POR_FORCE_PD() uint32 {
	return (volatile.LoadUint32(&o.ANA_CONF.Reg) & 0x40000) >> 18
}
func (o *RTC_CNTL_Type) SetANA_CONF_I2C_RESET_POR_FORCE_PU(value uint32) {
	volatile.StoreUint32(&o.ANA_CONF.Reg, volatile.LoadUint32(&o.ANA_CONF.Reg)&^(0x80000)|value<<19)
}
func (o *RTC_CNTL_Type) GetANA_CONF_I2C_RESET_POR_FORCE_PU() uint32 {
	return (volatile.LoadUint32(&o.ANA_CONF.Reg) & 0x80000) >> 19
}
func (o *RTC_CNTL_Type) SetANA_CONF_GLITCH_RST_EN(value uint32) {
	volatile.StoreUint32(&o.ANA_CONF.Reg, volatile.LoadUint32(&o.ANA_CONF.Reg)&^(0x100000)|value<<20)
}
func (o *RTC_CNTL_Type) GetANA_CONF_GLITCH_RST_EN() uint32 {
	return (volatile.LoadUint32(&o.ANA_CONF.Reg) & 0x100000) >> 20
}
func (o *RTC_CNTL_Type) SetANA_CONF_SAR_I2C_FORCE_PD(value uint32) {
	volatile.StoreUint32(&o.ANA_CONF.Reg, volatile.LoadUint32(&o.ANA_CONF.Reg)&^(0x200000)|value<<21)
}
func (o *RTC_CNTL_Type) GetANA_CONF_SAR_I2C_FORCE_PD() uint32 {
	return (volatile.LoadUint32(&o.ANA_CONF.Reg) & 0x200000) >> 21
}
func (o *RTC_CNTL_Type) SetANA_CONF_SAR_I2C_FORCE_PU(value uint32) {
	volatile.StoreUint32(&o.ANA_CONF.Reg, volatile.LoadUint32(&o.ANA_CONF.Reg)&^(0x400000)|value<<22)
}
func (o *RTC_CNTL_Type) GetANA_CONF_SAR_I2C_FORCE_PU() uint32 {
	return (volatile.LoadUint32(&o.ANA_CONF.Reg) & 0x400000) >> 22
}
func (o *RTC_CNTL_Type) SetANA_CONF_PLLA_FORCE_PD(value uint32) {
	volatile.StoreUint32(&o.ANA_CONF.Reg, volatile.LoadUint32(&o.ANA_CONF.Reg)&^(0x800000)|value<<23)
}
func (o *RTC_CNTL_Type) GetANA_CONF_PLLA_FORCE_PD() uint32 {
	return (volatile.LoadUint32(&o.ANA_CONF.Reg) & 0x800000) >> 23
}
func (o *RTC_CNTL_Type) SetANA_CONF_PLLA_FORCE_PU(value uint32) {
	volatile.StoreUint32(&o.ANA_CONF.Reg, volatile.LoadUint32(&o.ANA_CONF.Reg)&^(0x1000000)|value<<24)
}
func (o *RTC_CNTL_Type) GetANA_CONF_PLLA_FORCE_PU() uint32 {
	return (volatile.LoadUint32(&o.ANA_CONF.Reg) & 0x1000000) >> 24
}
func (o *RTC_CNTL_Type) SetANA_CONF_BBPLL_CAL_SLP_START(value uint32) {
	volatile.StoreUint32(&o.ANA_CONF.Reg, volatile.LoadUint32(&o.ANA_CONF.Reg)&^(0x2000000)|value<<25)
}
func (o *RTC_CNTL_Type) GetANA_CONF_BBPLL_CAL_SLP_START() uint32 {
	return (volatile.LoadUint32(&o.ANA_CONF.Reg) & 0x2000000) >> 25
}
func (o *RTC_CNTL_Type) SetANA_CONF_PVTMON_PU(value uint32) {
	volatile.StoreUint32(&o.ANA_CONF.Reg, volatile.LoadUint32(&o.ANA_CONF.Reg)&^(0x4000000)|value<<26)
}
func (o *RTC_CNTL_Type) GetANA_CONF_PVTMON_PU() uint32 {
	return (volatile.LoadUint32(&o.ANA_CONF.Reg) & 0x4000000) >> 26
}
func (o *RTC_CNTL_Type) SetANA_CONF_TXRF_I2C_PU(value uint32) {
	volatile.StoreUint32(&o.ANA_CONF.Reg, volatile.LoadUint32(&o.ANA_CONF.Reg)&^(0x8000000)|value<<27)
}
func (o *RTC_CNTL_Type) GetANA_CONF_TXRF_I2C_PU() uint32 {
	return (volatile.LoadUint32(&o.ANA_CONF.Reg) & 0x8000000) >> 27
}
func (o *RTC_CNTL_Type) SetANA_CONF_RFRX_PBUS_PU(value uint32) {
	volatile.StoreUint32(&o.ANA_CONF.Reg, volatile.LoadUint32(&o.ANA_CONF.Reg)&^(0x10000000)|value<<28)
}
func (o *RTC_CNTL_Type) GetANA_CONF_RFRX_PBUS_PU() uint32 {
	return (volatile.LoadUint32(&o.ANA_CONF.Reg) & 0x10000000) >> 28
}
func (o *RTC_CNTL_Type) SetANA_CONF_CKGEN_I2C_PU(value uint32) {
	volatile.StoreUint32(&o.ANA_CONF.Reg, volatile.LoadUint32(&o.ANA_CONF.Reg)&^(0x40000000)|value<<30)
}
func (o *RTC_CNTL_Type) GetANA_CONF_CKGEN_I2C_PU() uint32 {
	return (volatile.LoadUint32(&o.ANA_CONF.Reg) & 0x40000000) >> 30
}
func (o *RTC_CNTL_Type) SetANA_CONF_PLL_I2C_PU(value uint32) {
	volatile.StoreUint32(&o.ANA_CONF.Reg, volatile.LoadUint32(&o.ANA_CONF.Reg)&^(0x80000000)|value<<31)
}
func (o *RTC_CNTL_Type) GetANA_CONF_PLL_I2C_PU() uint32 {
	return (volatile.LoadUint32(&o.ANA_CONF.Reg) & 0x80000000) >> 31
}

// RTC_CNTL.RESET_STATE: Indicates the CPU reset source. For more information about the reset cause, please refer to Table \ref{table:resetreasons} in Chapter \ref{module:ResetandClock} \textit{\nameref{module:ResetandClock}}.
func (o *RTC_CNTL_Type) SetRESET_STATE_RESET_CAUSE_PROCPU(value uint32) {
	volatile.StoreUint32(&o.RESET_STATE.Reg, volatile.LoadUint32(&o.RESET_STATE.Reg)&^(0x3f)|value)
}
func (o *RTC_CNTL_Type) GetRESET_STATE_RESET_CAUSE_PROCPU() uint32 {
	return volatile.LoadUint32(&o.RESET_STATE.Reg) & 0x3f
}
func (o *RTC_CNTL_Type) SetRESET_STATE_RESET_CAUSE_APPCPU(value uint32) {
	volatile.StoreUint32(&o.RESET_STATE.Reg, volatile.LoadUint32(&o.RESET_STATE.Reg)&^(0xfc0)|value<<6)
}
func (o *RTC_CNTL_Type) GetRESET_STATE_RESET_CAUSE_APPCPU() uint32 {
	return (volatile.LoadUint32(&o.RESET_STATE.Reg) & 0xfc0) >> 6
}
func (o *RTC_CNTL_Type) SetRESET_STATE_APPCPU_STAT_VECTOR_SEL(value uint32) {
	volatile.StoreUint32(&o.RESET_STATE.Reg, volatile.LoadUint32(&o.RESET_STATE.Reg)&^(0x1000)|value<<12)
}
func (o *RTC_CNTL_Type) GetRESET_STATE_APPCPU_STAT_VECTOR_SEL() uint32 {
	return (volatile.LoadUint32(&o.RESET_STATE.Reg) & 0x1000) >> 12
}
func (o *RTC_CNTL_Type) SetRESET_STATE_PROCPU_STAT_VECTOR_SEL(value uint32) {
	volatile.StoreUint32(&o.RESET_STATE.Reg, volatile.LoadUint32(&o.RESET_STATE.Reg)&^(0x2000)|value<<13)
}
func (o *RTC_CNTL_Type) GetRESET_STATE_PROCPU_STAT_VECTOR_SEL() uint32 {
	return (volatile.LoadUint32(&o.RESET_STATE.Reg) & 0x2000) >> 13
}

// RTC_CNTL.WAKEUP_STATE: Wakeup bitmap enabling register
func (o *RTC_CNTL_Type) SetWAKEUP_STATE_WAKEUP_ENA(value uint32) {
	volatile.StoreUint32(&o.WAKEUP_STATE.Reg, volatile.LoadUint32(&o.WAKEUP_STATE.Reg)&^(0xffff8000)|value<<15)
}
func (o *RTC_CNTL_Type) GetWAKEUP_STATE_WAKEUP_ENA() uint32 {
	return (volatile.LoadUint32(&o.WAKEUP_STATE.Reg) & 0xffff8000) >> 15
}

// RTC_CNTL.INT_ENA_RTC: RTC interrupt enabling register
func (o *RTC_CNTL_Type) SetINT_ENA_RTC_SLP_WAKEUP_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA_RTC.Reg, volatile.LoadUint32(&o.INT_ENA_RTC.Reg)&^(0x1)|value)
}
func (o *RTC_CNTL_Type) GetINT_ENA_RTC_SLP_WAKEUP_INT_ENA() uint32 {
	return volatile.LoadUint32(&o.INT_ENA_RTC.Reg) & 0x1
}
func (o *RTC_CNTL_Type) SetINT_ENA_RTC_SLP_REJECT_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA_RTC.Reg, volatile.LoadUint32(&o.INT_ENA_RTC.Reg)&^(0x2)|value<<1)
}
func (o *RTC_CNTL_Type) GetINT_ENA_RTC_SLP_REJECT_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA_RTC.Reg) & 0x2) >> 1
}
func (o *RTC_CNTL_Type) SetINT_ENA_RTC_SDIO_IDLE_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA_RTC.Reg, volatile.LoadUint32(&o.INT_ENA_RTC.Reg)&^(0x4)|value<<2)
}
func (o *RTC_CNTL_Type) GetINT_ENA_RTC_SDIO_IDLE_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA_RTC.Reg) & 0x4) >> 2
}
func (o *RTC_CNTL_Type) SetINT_ENA_RTC_WDT_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA_RTC.Reg, volatile.LoadUint32(&o.INT_ENA_RTC.Reg)&^(0x8)|value<<3)
}
func (o *RTC_CNTL_Type) GetINT_ENA_RTC_WDT_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA_RTC.Reg) & 0x8) >> 3
}
func (o *RTC_CNTL_Type) SetINT_ENA_RTC_TOUCH_SCAN_DONE_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA_RTC.Reg, volatile.LoadUint32(&o.INT_ENA_RTC.Reg)&^(0x10)|value<<4)
}
func (o *RTC_CNTL_Type) GetINT_ENA_RTC_TOUCH_SCAN_DONE_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA_RTC.Reg) & 0x10) >> 4
}
func (o *RTC_CNTL_Type) SetINT_ENA_RTC_ULP_CP_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA_RTC.Reg, volatile.LoadUint32(&o.INT_ENA_RTC.Reg)&^(0x20)|value<<5)
}
func (o *RTC_CNTL_Type) GetINT_ENA_RTC_ULP_CP_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA_RTC.Reg) & 0x20) >> 5
}
func (o *RTC_CNTL_Type) SetINT_ENA_RTC_TOUCH_DONE_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA_RTC.Reg, volatile.LoadUint32(&o.INT_ENA_RTC.Reg)&^(0x40)|value<<6)
}
func (o *RTC_CNTL_Type) GetINT_ENA_RTC_TOUCH_DONE_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA_RTC.Reg) & 0x40) >> 6
}
func (o *RTC_CNTL_Type) SetINT_ENA_RTC_TOUCH_ACTIVE_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA_RTC.Reg, volatile.LoadUint32(&o.INT_ENA_RTC.Reg)&^(0x80)|value<<7)
}
func (o *RTC_CNTL_Type) GetINT_ENA_RTC_TOUCH_ACTIVE_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA_RTC.Reg) & 0x80) >> 7
}
func (o *RTC_CNTL_Type) SetINT_ENA_RTC_TOUCH_INACTIVE_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA_RTC.Reg, volatile.LoadUint32(&o.INT_ENA_RTC.Reg)&^(0x100)|value<<8)
}
func (o *RTC_CNTL_Type) GetINT_ENA_RTC_TOUCH_INACTIVE_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA_RTC.Reg) & 0x100) >> 8
}
func (o *RTC_CNTL_Type) SetINT_ENA_RTC_BROWN_OUT_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA_RTC.Reg, volatile.LoadUint32(&o.INT_ENA_RTC.Reg)&^(0x200)|value<<9)
}
func (o *RTC_CNTL_Type) GetINT_ENA_RTC_BROWN_OUT_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA_RTC.Reg) & 0x200) >> 9
}
func (o *RTC_CNTL_Type) SetINT_ENA_RTC_MAIN_TIMER_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA_RTC.Reg, volatile.LoadUint32(&o.INT_ENA_RTC.Reg)&^(0x400)|value<<10)
}
func (o *RTC_CNTL_Type) GetINT_ENA_RTC_MAIN_TIMER_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA_RTC.Reg) & 0x400) >> 10
}
func (o *RTC_CNTL_Type) SetINT_ENA_RTC_SARADC1_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA_RTC.Reg, volatile.LoadUint32(&o.INT_ENA_RTC.Reg)&^(0x800)|value<<11)
}
func (o *RTC_CNTL_Type) GetINT_ENA_RTC_SARADC1_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA_RTC.Reg) & 0x800) >> 11
}
func (o *RTC_CNTL_Type) SetINT_ENA_RTC_TSENS_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA_RTC.Reg, volatile.LoadUint32(&o.INT_ENA_RTC.Reg)&^(0x1000)|value<<12)
}
func (o *RTC_CNTL_Type) GetINT_ENA_RTC_TSENS_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA_RTC.Reg) & 0x1000) >> 12
}
func (o *RTC_CNTL_Type) SetINT_ENA_RTC_COCPU_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA_RTC.Reg, volatile.LoadUint32(&o.INT_ENA_RTC.Reg)&^(0x2000)|value<<13)
}
func (o *RTC_CNTL_Type) GetINT_ENA_RTC_COCPU_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA_RTC.Reg) & 0x2000) >> 13
}
func (o *RTC_CNTL_Type) SetINT_ENA_RTC_SARADC2_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA_RTC.Reg, volatile.LoadUint32(&o.INT_ENA_RTC.Reg)&^(0x4000)|value<<14)
}
func (o *RTC_CNTL_Type) GetINT_ENA_RTC_SARADC2_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA_RTC.Reg) & 0x4000) >> 14
}
func (o *RTC_CNTL_Type) SetINT_ENA_RTC_SWD_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA_RTC.Reg, volatile.LoadUint32(&o.INT_ENA_RTC.Reg)&^(0x8000)|value<<15)
}
func (o *RTC_CNTL_Type) GetINT_ENA_RTC_SWD_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA_RTC.Reg) & 0x8000) >> 15
}
func (o *RTC_CNTL_Type) SetINT_ENA_RTC_XTAL32K_DEAD_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA_RTC.Reg, volatile.LoadUint32(&o.INT_ENA_RTC.Reg)&^(0x10000)|value<<16)
}
func (o *RTC_CNTL_Type) GetINT_ENA_RTC_XTAL32K_DEAD_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA_RTC.Reg) & 0x10000) >> 16
}
func (o *RTC_CNTL_Type) SetINT_ENA_RTC_COCPU_TRAP_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA_RTC.Reg, volatile.LoadUint32(&o.INT_ENA_RTC.Reg)&^(0x20000)|value<<17)
}
func (o *RTC_CNTL_Type) GetINT_ENA_RTC_COCPU_TRAP_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA_RTC.Reg) & 0x20000) >> 17
}
func (o *RTC_CNTL_Type) SetINT_ENA_RTC_TOUCH_TIMEOUT_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA_RTC.Reg, volatile.LoadUint32(&o.INT_ENA_RTC.Reg)&^(0x40000)|value<<18)
}
func (o *RTC_CNTL_Type) GetINT_ENA_RTC_TOUCH_TIMEOUT_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA_RTC.Reg) & 0x40000) >> 18
}
func (o *RTC_CNTL_Type) SetINT_ENA_RTC_GLITCH_DET_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA_RTC.Reg, volatile.LoadUint32(&o.INT_ENA_RTC.Reg)&^(0x80000)|value<<19)
}
func (o *RTC_CNTL_Type) GetINT_ENA_RTC_GLITCH_DET_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA_RTC.Reg) & 0x80000) >> 19
}

// RTC_CNTL.INT_RAW_RTC: RTC interrupt raw register
func (o *RTC_CNTL_Type) SetINT_RAW_RTC_SLP_WAKEUP_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW_RTC.Reg, volatile.LoadUint32(&o.INT_RAW_RTC.Reg)&^(0x1)|value)
}
func (o *RTC_CNTL_Type) GetINT_RAW_RTC_SLP_WAKEUP_INT_RAW() uint32 {
	return volatile.LoadUint32(&o.INT_RAW_RTC.Reg) & 0x1
}
func (o *RTC_CNTL_Type) SetINT_RAW_RTC_SLP_REJECT_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW_RTC.Reg, volatile.LoadUint32(&o.INT_RAW_RTC.Reg)&^(0x2)|value<<1)
}
func (o *RTC_CNTL_Type) GetINT_RAW_RTC_SLP_REJECT_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW_RTC.Reg) & 0x2) >> 1
}
func (o *RTC_CNTL_Type) SetINT_RAW_RTC_SDIO_IDLE_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW_RTC.Reg, volatile.LoadUint32(&o.INT_RAW_RTC.Reg)&^(0x4)|value<<2)
}
func (o *RTC_CNTL_Type) GetINT_RAW_RTC_SDIO_IDLE_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW_RTC.Reg) & 0x4) >> 2
}
func (o *RTC_CNTL_Type) SetINT_RAW_RTC_WDT_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW_RTC.Reg, volatile.LoadUint32(&o.INT_RAW_RTC.Reg)&^(0x8)|value<<3)
}
func (o *RTC_CNTL_Type) GetINT_RAW_RTC_WDT_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW_RTC.Reg) & 0x8) >> 3
}
func (o *RTC_CNTL_Type) SetINT_RAW_RTC_TOUCH_SCAN_DONE_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW_RTC.Reg, volatile.LoadUint32(&o.INT_RAW_RTC.Reg)&^(0x10)|value<<4)
}
func (o *RTC_CNTL_Type) GetINT_RAW_RTC_TOUCH_SCAN_DONE_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW_RTC.Reg) & 0x10) >> 4
}
func (o *RTC_CNTL_Type) SetINT_RAW_RTC_ULP_CP_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW_RTC.Reg, volatile.LoadUint32(&o.INT_RAW_RTC.Reg)&^(0x20)|value<<5)
}
func (o *RTC_CNTL_Type) GetINT_RAW_RTC_ULP_CP_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW_RTC.Reg) & 0x20) >> 5
}
func (o *RTC_CNTL_Type) SetINT_RAW_RTC_TOUCH_DONE_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW_RTC.Reg, volatile.LoadUint32(&o.INT_RAW_RTC.Reg)&^(0x40)|value<<6)
}
func (o *RTC_CNTL_Type) GetINT_RAW_RTC_TOUCH_DONE_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW_RTC.Reg) & 0x40) >> 6
}
func (o *RTC_CNTL_Type) SetINT_RAW_RTC_TOUCH_ACTIVE_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW_RTC.Reg, volatile.LoadUint32(&o.INT_RAW_RTC.Reg)&^(0x80)|value<<7)
}
func (o *RTC_CNTL_Type) GetINT_RAW_RTC_TOUCH_ACTIVE_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW_RTC.Reg) & 0x80) >> 7
}
func (o *RTC_CNTL_Type) SetINT_RAW_RTC_TOUCH_INACTIVE_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW_RTC.Reg, volatile.LoadUint32(&o.INT_RAW_RTC.Reg)&^(0x100)|value<<8)
}
func (o *RTC_CNTL_Type) GetINT_RAW_RTC_TOUCH_INACTIVE_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW_RTC.Reg) & 0x100) >> 8
}
func (o *RTC_CNTL_Type) SetINT_RAW_RTC_BROWN_OUT_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW_RTC.Reg, volatile.LoadUint32(&o.INT_RAW_RTC.Reg)&^(0x200)|value<<9)
}
func (o *RTC_CNTL_Type) GetINT_RAW_RTC_BROWN_OUT_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW_RTC.Reg) & 0x200) >> 9
}
func (o *RTC_CNTL_Type) SetINT_RAW_RTC_MAIN_TIMER_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW_RTC.Reg, volatile.LoadUint32(&o.INT_RAW_RTC.Reg)&^(0x400)|value<<10)
}
func (o *RTC_CNTL_Type) GetINT_RAW_RTC_MAIN_TIMER_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW_RTC.Reg) & 0x400) >> 10
}
func (o *RTC_CNTL_Type) SetINT_RAW_RTC_SARADC1_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW_RTC.Reg, volatile.LoadUint32(&o.INT_RAW_RTC.Reg)&^(0x800)|value<<11)
}
func (o *RTC_CNTL_Type) GetINT_RAW_RTC_SARADC1_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW_RTC.Reg) & 0x800) >> 11
}
func (o *RTC_CNTL_Type) SetINT_RAW_RTC_TSENS_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW_RTC.Reg, volatile.LoadUint32(&o.INT_RAW_RTC.Reg)&^(0x1000)|value<<12)
}
func (o *RTC_CNTL_Type) GetINT_RAW_RTC_TSENS_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW_RTC.Reg) & 0x1000) >> 12
}
func (o *RTC_CNTL_Type) SetINT_RAW_RTC_COCPU_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW_RTC.Reg, volatile.LoadUint32(&o.INT_RAW_RTC.Reg)&^(0x2000)|value<<13)
}
func (o *RTC_CNTL_Type) GetINT_RAW_RTC_COCPU_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW_RTC.Reg) & 0x2000) >> 13
}
func (o *RTC_CNTL_Type) SetINT_RAW_RTC_SARADC2_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW_RTC.Reg, volatile.LoadUint32(&o.INT_RAW_RTC.Reg)&^(0x4000)|value<<14)
}
func (o *RTC_CNTL_Type) GetINT_RAW_RTC_SARADC2_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW_RTC.Reg) & 0x4000) >> 14
}
func (o *RTC_CNTL_Type) SetINT_RAW_RTC_SWD_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW_RTC.Reg, volatile.LoadUint32(&o.INT_RAW_RTC.Reg)&^(0x8000)|value<<15)
}
func (o *RTC_CNTL_Type) GetINT_RAW_RTC_SWD_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW_RTC.Reg) & 0x8000) >> 15
}
func (o *RTC_CNTL_Type) SetINT_RAW_RTC_XTAL32K_DEAD_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW_RTC.Reg, volatile.LoadUint32(&o.INT_RAW_RTC.Reg)&^(0x10000)|value<<16)
}
func (o *RTC_CNTL_Type) GetINT_RAW_RTC_XTAL32K_DEAD_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW_RTC.Reg) & 0x10000) >> 16
}
func (o *RTC_CNTL_Type) SetINT_RAW_RTC_COCPU_TRAP_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW_RTC.Reg, volatile.LoadUint32(&o.INT_RAW_RTC.Reg)&^(0x20000)|value<<17)
}
func (o *RTC_CNTL_Type) GetINT_RAW_RTC_COCPU_TRAP_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW_RTC.Reg) & 0x20000) >> 17
}
func (o *RTC_CNTL_Type) SetINT_RAW_RTC_TOUCH_TIMEOUT_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW_RTC.Reg, volatile.LoadUint32(&o.INT_RAW_RTC.Reg)&^(0x40000)|value<<18)
}
func (o *RTC_CNTL_Type) GetINT_RAW_RTC_TOUCH_TIMEOUT_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW_RTC.Reg) & 0x40000) >> 18
}
func (o *RTC_CNTL_Type) SetINT_RAW_RTC_GLITCH_DET_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW_RTC.Reg, volatile.LoadUint32(&o.INT_RAW_RTC.Reg)&^(0x80000)|value<<19)
}
func (o *RTC_CNTL_Type) GetINT_RAW_RTC_GLITCH_DET_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW_RTC.Reg) & 0x80000) >> 19
}

// RTC_CNTL.INT_ST_RTC: RTC interrupt state register
func (o *RTC_CNTL_Type) SetINT_ST_RTC_SLP_WAKEUP_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST_RTC.Reg, volatile.LoadUint32(&o.INT_ST_RTC.Reg)&^(0x1)|value)
}
func (o *RTC_CNTL_Type) GetINT_ST_RTC_SLP_WAKEUP_INT_ST() uint32 {
	return volatile.LoadUint32(&o.INT_ST_RTC.Reg) & 0x1
}
func (o *RTC_CNTL_Type) SetINT_ST_RTC_SLP_REJECT_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST_RTC.Reg, volatile.LoadUint32(&o.INT_ST_RTC.Reg)&^(0x2)|value<<1)
}
func (o *RTC_CNTL_Type) GetINT_ST_RTC_SLP_REJECT_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST_RTC.Reg) & 0x2) >> 1
}
func (o *RTC_CNTL_Type) SetINT_ST_RTC_SDIO_IDLE_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST_RTC.Reg, volatile.LoadUint32(&o.INT_ST_RTC.Reg)&^(0x4)|value<<2)
}
func (o *RTC_CNTL_Type) GetINT_ST_RTC_SDIO_IDLE_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST_RTC.Reg) & 0x4) >> 2
}
func (o *RTC_CNTL_Type) SetINT_ST_RTC_WDT_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST_RTC.Reg, volatile.LoadUint32(&o.INT_ST_RTC.Reg)&^(0x8)|value<<3)
}
func (o *RTC_CNTL_Type) GetINT_ST_RTC_WDT_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST_RTC.Reg) & 0x8) >> 3
}
func (o *RTC_CNTL_Type) SetINT_ST_RTC_TOUCH_SCAN_DONE_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST_RTC.Reg, volatile.LoadUint32(&o.INT_ST_RTC.Reg)&^(0x10)|value<<4)
}
func (o *RTC_CNTL_Type) GetINT_ST_RTC_TOUCH_SCAN_DONE_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST_RTC.Reg) & 0x10) >> 4
}
func (o *RTC_CNTL_Type) SetINT_ST_RTC_ULP_CP_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST_RTC.Reg, volatile.LoadUint32(&o.INT_ST_RTC.Reg)&^(0x20)|value<<5)
}
func (o *RTC_CNTL_Type) GetINT_ST_RTC_ULP_CP_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST_RTC.Reg) & 0x20) >> 5
}
func (o *RTC_CNTL_Type) SetINT_ST_RTC_TOUCH_DONE_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST_RTC.Reg, volatile.LoadUint32(&o.INT_ST_RTC.Reg)&^(0x40)|value<<6)
}
func (o *RTC_CNTL_Type) GetINT_ST_RTC_TOUCH_DONE_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST_RTC.Reg) & 0x40) >> 6
}
func (o *RTC_CNTL_Type) SetINT_ST_RTC_TOUCH_ACTIVE_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST_RTC.Reg, volatile.LoadUint32(&o.INT_ST_RTC.Reg)&^(0x80)|value<<7)
}
func (o *RTC_CNTL_Type) GetINT_ST_RTC_TOUCH_ACTIVE_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST_RTC.Reg) & 0x80) >> 7
}
func (o *RTC_CNTL_Type) SetINT_ST_RTC_TOUCH_INACTIVE_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST_RTC.Reg, volatile.LoadUint32(&o.INT_ST_RTC.Reg)&^(0x100)|value<<8)
}
func (o *RTC_CNTL_Type) GetINT_ST_RTC_TOUCH_INACTIVE_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST_RTC.Reg) & 0x100) >> 8
}
func (o *RTC_CNTL_Type) SetINT_ST_RTC_BROWN_OUT_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST_RTC.Reg, volatile.LoadUint32(&o.INT_ST_RTC.Reg)&^(0x200)|value<<9)
}
func (o *RTC_CNTL_Type) GetINT_ST_RTC_BROWN_OUT_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST_RTC.Reg) & 0x200) >> 9
}
func (o *RTC_CNTL_Type) SetINT_ST_RTC_MAIN_TIMER_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST_RTC.Reg, volatile.LoadUint32(&o.INT_ST_RTC.Reg)&^(0x400)|value<<10)
}
func (o *RTC_CNTL_Type) GetINT_ST_RTC_MAIN_TIMER_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST_RTC.Reg) & 0x400) >> 10
}
func (o *RTC_CNTL_Type) SetINT_ST_RTC_SARADC1_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST_RTC.Reg, volatile.LoadUint32(&o.INT_ST_RTC.Reg)&^(0x800)|value<<11)
}
func (o *RTC_CNTL_Type) GetINT_ST_RTC_SARADC1_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST_RTC.Reg) & 0x800) >> 11
}
func (o *RTC_CNTL_Type) SetINT_ST_RTC_TSENS_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST_RTC.Reg, volatile.LoadUint32(&o.INT_ST_RTC.Reg)&^(0x1000)|value<<12)
}
func (o *RTC_CNTL_Type) GetINT_ST_RTC_TSENS_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST_RTC.Reg) & 0x1000) >> 12
}
func (o *RTC_CNTL_Type) SetINT_ST_RTC_COCPU_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST_RTC.Reg, volatile.LoadUint32(&o.INT_ST_RTC.Reg)&^(0x2000)|value<<13)
}
func (o *RTC_CNTL_Type) GetINT_ST_RTC_COCPU_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST_RTC.Reg) & 0x2000) >> 13
}
func (o *RTC_CNTL_Type) SetINT_ST_RTC_SARADC2_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST_RTC.Reg, volatile.LoadUint32(&o.INT_ST_RTC.Reg)&^(0x4000)|value<<14)
}
func (o *RTC_CNTL_Type) GetINT_ST_RTC_SARADC2_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST_RTC.Reg) & 0x4000) >> 14
}
func (o *RTC_CNTL_Type) SetINT_ST_RTC_SWD_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST_RTC.Reg, volatile.LoadUint32(&o.INT_ST_RTC.Reg)&^(0x8000)|value<<15)
}
func (o *RTC_CNTL_Type) GetINT_ST_RTC_SWD_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST_RTC.Reg) & 0x8000) >> 15
}
func (o *RTC_CNTL_Type) SetINT_ST_RTC_XTAL32K_DEAD_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST_RTC.Reg, volatile.LoadUint32(&o.INT_ST_RTC.Reg)&^(0x10000)|value<<16)
}
func (o *RTC_CNTL_Type) GetINT_ST_RTC_XTAL32K_DEAD_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST_RTC.Reg) & 0x10000) >> 16
}
func (o *RTC_CNTL_Type) SetINT_ST_RTC_COCPU_TRAP_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST_RTC.Reg, volatile.LoadUint32(&o.INT_ST_RTC.Reg)&^(0x20000)|value<<17)
}
func (o *RTC_CNTL_Type) GetINT_ST_RTC_COCPU_TRAP_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST_RTC.Reg) & 0x20000) >> 17
}
func (o *RTC_CNTL_Type) SetINT_ST_RTC_TOUCH_TIMEOUT_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST_RTC.Reg, volatile.LoadUint32(&o.INT_ST_RTC.Reg)&^(0x40000)|value<<18)
}
func (o *RTC_CNTL_Type) GetINT_ST_RTC_TOUCH_TIMEOUT_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST_RTC.Reg) & 0x40000) >> 18
}
func (o *RTC_CNTL_Type) SetINT_ST_RTC_GLITCH_DET_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST_RTC.Reg, volatile.LoadUint32(&o.INT_ST_RTC.Reg)&^(0x80000)|value<<19)
}
func (o *RTC_CNTL_Type) GetINT_ST_RTC_GLITCH_DET_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST_RTC.Reg) & 0x80000) >> 19
}

// RTC_CNTL.INT_CLR_RTC: RTC interrupt clear register
func (o *RTC_CNTL_Type) SetINT_CLR_RTC_SLP_WAKEUP_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR_RTC.Reg, volatile.LoadUint32(&o.INT_CLR_RTC.Reg)&^(0x1)|value)
}
func (o *RTC_CNTL_Type) GetINT_CLR_RTC_SLP_WAKEUP_INT_CLR() uint32 {
	return volatile.LoadUint32(&o.INT_CLR_RTC.Reg) & 0x1
}
func (o *RTC_CNTL_Type) SetINT_CLR_RTC_SLP_REJECT_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR_RTC.Reg, volatile.LoadUint32(&o.INT_CLR_RTC.Reg)&^(0x2)|value<<1)
}
func (o *RTC_CNTL_Type) GetINT_CLR_RTC_SLP_REJECT_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR_RTC.Reg) & 0x2) >> 1
}
func (o *RTC_CNTL_Type) SetINT_CLR_RTC_SDIO_IDLE_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR_RTC.Reg, volatile.LoadUint32(&o.INT_CLR_RTC.Reg)&^(0x4)|value<<2)
}
func (o *RTC_CNTL_Type) GetINT_CLR_RTC_SDIO_IDLE_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR_RTC.Reg) & 0x4) >> 2
}
func (o *RTC_CNTL_Type) SetINT_CLR_RTC_WDT_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR_RTC.Reg, volatile.LoadUint32(&o.INT_CLR_RTC.Reg)&^(0x8)|value<<3)
}
func (o *RTC_CNTL_Type) GetINT_CLR_RTC_WDT_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR_RTC.Reg) & 0x8) >> 3
}
func (o *RTC_CNTL_Type) SetINT_CLR_RTC_TOUCH_SCAN_DONE_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR_RTC.Reg, volatile.LoadUint32(&o.INT_CLR_RTC.Reg)&^(0x10)|value<<4)
}
func (o *RTC_CNTL_Type) GetINT_CLR_RTC_TOUCH_SCAN_DONE_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR_RTC.Reg) & 0x10) >> 4
}
func (o *RTC_CNTL_Type) SetINT_CLR_RTC_ULP_CP_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR_RTC.Reg, volatile.LoadUint32(&o.INT_CLR_RTC.Reg)&^(0x20)|value<<5)
}
func (o *RTC_CNTL_Type) GetINT_CLR_RTC_ULP_CP_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR_RTC.Reg) & 0x20) >> 5
}
func (o *RTC_CNTL_Type) SetINT_CLR_RTC_TOUCH_DONE_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR_RTC.Reg, volatile.LoadUint32(&o.INT_CLR_RTC.Reg)&^(0x40)|value<<6)
}
func (o *RTC_CNTL_Type) GetINT_CLR_RTC_TOUCH_DONE_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR_RTC.Reg) & 0x40) >> 6
}
func (o *RTC_CNTL_Type) SetINT_CLR_RTC_TOUCH_ACTIVE_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR_RTC.Reg, volatile.LoadUint32(&o.INT_CLR_RTC.Reg)&^(0x80)|value<<7)
}
func (o *RTC_CNTL_Type) GetINT_CLR_RTC_TOUCH_ACTIVE_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR_RTC.Reg) & 0x80) >> 7
}
func (o *RTC_CNTL_Type) SetINT_CLR_RTC_TOUCH_INACTIVE_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR_RTC.Reg, volatile.LoadUint32(&o.INT_CLR_RTC.Reg)&^(0x100)|value<<8)
}
func (o *RTC_CNTL_Type) GetINT_CLR_RTC_TOUCH_INACTIVE_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR_RTC.Reg) & 0x100) >> 8
}
func (o *RTC_CNTL_Type) SetINT_CLR_RTC_BROWN_OUT_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR_RTC.Reg, volatile.LoadUint32(&o.INT_CLR_RTC.Reg)&^(0x200)|value<<9)
}
func (o *RTC_CNTL_Type) GetINT_CLR_RTC_BROWN_OUT_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR_RTC.Reg) & 0x200) >> 9
}
func (o *RTC_CNTL_Type) SetINT_CLR_RTC_MAIN_TIMER_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR_RTC.Reg, volatile.LoadUint32(&o.INT_CLR_RTC.Reg)&^(0x400)|value<<10)
}
func (o *RTC_CNTL_Type) GetINT_CLR_RTC_MAIN_TIMER_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR_RTC.Reg) & 0x400) >> 10
}
func (o *RTC_CNTL_Type) SetINT_CLR_RTC_SARADC1_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR_RTC.Reg, volatile.LoadUint32(&o.INT_CLR_RTC.Reg)&^(0x800)|value<<11)
}
func (o *RTC_CNTL_Type) GetINT_CLR_RTC_SARADC1_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR_RTC.Reg) & 0x800) >> 11
}
func (o *RTC_CNTL_Type) SetINT_CLR_RTC_TSENS_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR_RTC.Reg, volatile.LoadUint32(&o.INT_CLR_RTC.Reg)&^(0x1000)|value<<12)
}
func (o *RTC_CNTL_Type) GetINT_CLR_RTC_TSENS_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR_RTC.Reg) & 0x1000) >> 12
}
func (o *RTC_CNTL_Type) SetINT_CLR_RTC_COCPU_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR_RTC.Reg, volatile.LoadUint32(&o.INT_CLR_RTC.Reg)&^(0x2000)|value<<13)
}
func (o *RTC_CNTL_Type) GetINT_CLR_RTC_COCPU_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR_RTC.Reg) & 0x2000) >> 13
}
func (o *RTC_CNTL_Type) SetINT_CLR_RTC_SARADC2_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR_RTC.Reg, volatile.LoadUint32(&o.INT_CLR_RTC.Reg)&^(0x4000)|value<<14)
}
func (o *RTC_CNTL_Type) GetINT_CLR_RTC_SARADC2_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR_RTC.Reg) & 0x4000) >> 14
}
func (o *RTC_CNTL_Type) SetINT_CLR_RTC_SWD_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR_RTC.Reg, volatile.LoadUint32(&o.INT_CLR_RTC.Reg)&^(0x8000)|value<<15)
}
func (o *RTC_CNTL_Type) GetINT_CLR_RTC_SWD_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR_RTC.Reg) & 0x8000) >> 15
}
func (o *RTC_CNTL_Type) SetINT_CLR_RTC_XTAL32K_DEAD_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR_RTC.Reg, volatile.LoadUint32(&o.INT_CLR_RTC.Reg)&^(0x10000)|value<<16)
}
func (o *RTC_CNTL_Type) GetINT_CLR_RTC_XTAL32K_DEAD_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR_RTC.Reg) & 0x10000) >> 16
}
func (o *RTC_CNTL_Type) SetINT_CLR_RTC_COCPU_TRAP_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR_RTC.Reg, volatile.LoadUint32(&o.INT_CLR_RTC.Reg)&^(0x20000)|value<<17)
}
func (o *RTC_CNTL_Type) GetINT_CLR_RTC_COCPU_TRAP_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR_RTC.Reg) & 0x20000) >> 17
}
func (o *RTC_CNTL_Type) SetINT_CLR_RTC_TOUCH_TIMEOUT_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR_RTC.Reg, volatile.LoadUint32(&o.INT_CLR_RTC.Reg)&^(0x40000)|value<<18)
}
func (o *RTC_CNTL_Type) GetINT_CLR_RTC_TOUCH_TIMEOUT_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR_RTC.Reg) & 0x40000) >> 18
}
func (o *RTC_CNTL_Type) SetINT_CLR_RTC_GLITCH_DET_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR_RTC.Reg, volatile.LoadUint32(&o.INT_CLR_RTC.Reg)&^(0x80000)|value<<19)
}
func (o *RTC_CNTL_Type) GetINT_CLR_RTC_GLITCH_DET_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR_RTC.Reg) & 0x80000) >> 19
}

// RTC_CNTL.STORE0: Reservation register 0
func (o *RTC_CNTL_Type) SetSTORE0(value uint32) {
	volatile.StoreUint32(&o.STORE0.Reg, value)
}
func (o *RTC_CNTL_Type) GetSTORE0() uint32 {
	return volatile.LoadUint32(&o.STORE0.Reg)
}

// RTC_CNTL.STORE1: Reservation register 1
func (o *RTC_CNTL_Type) SetSTORE1(value uint32) {
	volatile.StoreUint32(&o.STORE1.Reg, value)
}
func (o *RTC_CNTL_Type) GetSTORE1() uint32 {
	return volatile.LoadUint32(&o.STORE1.Reg)
}

// RTC_CNTL.STORE2: Reservation register 2
func (o *RTC_CNTL_Type) SetSTORE2(value uint32) {
	volatile.StoreUint32(&o.STORE2.Reg, value)
}
func (o *RTC_CNTL_Type) GetSTORE2() uint32 {
	return volatile.LoadUint32(&o.STORE2.Reg)
}

// RTC_CNTL.STORE3: Reservation register 3
func (o *RTC_CNTL_Type) SetSTORE3(value uint32) {
	volatile.StoreUint32(&o.STORE3.Reg, value)
}
func (o *RTC_CNTL_Type) GetSTORE3() uint32 {
	return volatile.LoadUint32(&o.STORE3.Reg)
}

// RTC_CNTL.EXT_XTL_CONF: 32 kHz crystal oscillator configuration register
func (o *RTC_CNTL_Type) SetEXT_XTL_CONF_XTAL32K_WDT_EN(value uint32) {
	volatile.StoreUint32(&o.EXT_XTL_CONF.Reg, volatile.LoadUint32(&o.EXT_XTL_CONF.Reg)&^(0x1)|value)
}
func (o *RTC_CNTL_Type) GetEXT_XTL_CONF_XTAL32K_WDT_EN() uint32 {
	return volatile.LoadUint32(&o.EXT_XTL_CONF.Reg) & 0x1
}
func (o *RTC_CNTL_Type) SetEXT_XTL_CONF_XTAL32K_WDT_CLK_FO(value uint32) {
	volatile.StoreUint32(&o.EXT_XTL_CONF.Reg, volatile.LoadUint32(&o.EXT_XTL_CONF.Reg)&^(0x2)|value<<1)
}
func (o *RTC_CNTL_Type) GetEXT_XTL_CONF_XTAL32K_WDT_CLK_FO() uint32 {
	return (volatile.LoadUint32(&o.EXT_XTL_CONF.Reg) & 0x2) >> 1
}
func (o *RTC_CNTL_Type) SetEXT_XTL_CONF_XTAL32K_WDT_RESET(value uint32) {
	volatile.StoreUint32(&o.EXT_XTL_CONF.Reg, volatile.LoadUint32(&o.EXT_XTL_CONF.Reg)&^(0x4)|value<<2)
}
func (o *RTC_CNTL_Type) GetEXT_XTL_CONF_XTAL32K_WDT_RESET() uint32 {
	return (volatile.LoadUint32(&o.EXT_XTL_CONF.Reg) & 0x4) >> 2
}
func (o *RTC_CNTL_Type) SetEXT_XTL_CONF_XTAL32K_EXT_CLK_FO(value uint32) {
	volatile.StoreUint32(&o.EXT_XTL_CONF.Reg, volatile.LoadUint32(&o.EXT_XTL_CONF.Reg)&^(0x8)|value<<3)
}
func (o *RTC_CNTL_Type) GetEXT_XTL_CONF_XTAL32K_EXT_CLK_FO() uint32 {
	return (volatile.LoadUint32(&o.EXT_XTL_CONF.Reg) & 0x8) >> 3
}
func (o *RTC_CNTL_Type) SetEXT_XTL_CONF_XTAL32K_AUTO_BACKUP(value uint32) {
	volatile.StoreUint32(&o.EXT_XTL_CONF.Reg, volatile.LoadUint32(&o.EXT_XTL_CONF.Reg)&^(0x10)|value<<4)
}
func (o *RTC_CNTL_Type) GetEXT_XTL_CONF_XTAL32K_AUTO_BACKUP() uint32 {
	return (volatile.LoadUint32(&o.EXT_XTL_CONF.Reg) & 0x10) >> 4
}
func (o *RTC_CNTL_Type) SetEXT_XTL_CONF_XTAL32K_AUTO_RESTART(value uint32) {
	volatile.StoreUint32(&o.EXT_XTL_CONF.Reg, volatile.LoadUint32(&o.EXT_XTL_CONF.Reg)&^(0x20)|value<<5)
}
func (o *RTC_CNTL_Type) GetEXT_XTL_CONF_XTAL32K_AUTO_RESTART() uint32 {
	return (volatile.LoadUint32(&o.EXT_XTL_CONF.Reg) & 0x20) >> 5
}
func (o *RTC_CNTL_Type) SetEXT_XTL_CONF_XTAL32K_AUTO_RETURN(value uint32) {
	volatile.StoreUint32(&o.EXT_XTL_CONF.Reg, volatile.LoadUint32(&o.EXT_XTL_CONF.Reg)&^(0x40)|value<<6)
}
func (o *RTC_CNTL_Type) GetEXT_XTL_CONF_XTAL32K_AUTO_RETURN() uint32 {
	return (volatile.LoadUint32(&o.EXT_XTL_CONF.Reg) & 0x40) >> 6
}
func (o *RTC_CNTL_Type) SetEXT_XTL_CONF_XTAL32K_XPD_FORCE(value uint32) {
	volatile.StoreUint32(&o.EXT_XTL_CONF.Reg, volatile.LoadUint32(&o.EXT_XTL_CONF.Reg)&^(0x80)|value<<7)
}
func (o *RTC_CNTL_Type) GetEXT_XTL_CONF_XTAL32K_XPD_FORCE() uint32 {
	return (volatile.LoadUint32(&o.EXT_XTL_CONF.Reg) & 0x80) >> 7
}
func (o *RTC_CNTL_Type) SetEXT_XTL_CONF_ENCKINIT_XTAL_32K(value uint32) {
	volatile.StoreUint32(&o.EXT_XTL_CONF.Reg, volatile.LoadUint32(&o.EXT_XTL_CONF.Reg)&^(0x100)|value<<8)
}
func (o *RTC_CNTL_Type) GetEXT_XTL_CONF_ENCKINIT_XTAL_32K() uint32 {
	return (volatile.LoadUint32(&o.EXT_XTL_CONF.Reg) & 0x100) >> 8
}
func (o *RTC_CNTL_Type) SetEXT_XTL_CONF_DBUF_XTAL_32K(value uint32) {
	volatile.StoreUint32(&o.EXT_XTL_CONF.Reg, volatile.LoadUint32(&o.EXT_XTL_CONF.Reg)&^(0x200)|value<<9)
}
func (o *RTC_CNTL_Type) GetEXT_XTL_CONF_DBUF_XTAL_32K() uint32 {
	return (volatile.LoadUint32(&o.EXT_XTL_CONF.Reg) & 0x200) >> 9
}
func (o *RTC_CNTL_Type) SetEXT_XTL_CONF_DGM_XTAL_32K(value uint32) {
	volatile.StoreUint32(&o.EXT_XTL_CONF.Reg, volatile.LoadUint32(&o.EXT_XTL_CONF.Reg)&^(0x1c00)|value<<10)
}
func (o *RTC_CNTL_Type) GetEXT_XTL_CONF_DGM_XTAL_32K() uint32 {
	return (volatile.LoadUint32(&o.EXT_XTL_CONF.Reg) & 0x1c00) >> 10
}
func (o *RTC_CNTL_Type) SetEXT_XTL_CONF_DRES_XTAL_32K(value uint32) {
	volatile.StoreUint32(&o.EXT_XTL_CONF.Reg, volatile.LoadUint32(&o.EXT_XTL_CONF.Reg)&^(0xe000)|value<<13)
}
func (o *RTC_CNTL_Type) GetEXT_XTL_CONF_DRES_XTAL_32K() uint32 {
	return (volatile.LoadUint32(&o.EXT_XTL_CONF.Reg) & 0xe000) >> 13
}
func (o *RTC_CNTL_Type) SetEXT_XTL_CONF_XPD_XTAL_32K(value uint32) {
	volatile.StoreUint32(&o.EXT_XTL_CONF.Reg, volatile.LoadUint32(&o.EXT_XTL_CONF.Reg)&^(0x10000)|value<<16)
}
func (o *RTC_CNTL_Type) GetEXT_XTL_CONF_XPD_XTAL_32K() uint32 {
	return (volatile.LoadUint32(&o.EXT_XTL_CONF.Reg) & 0x10000) >> 16
}
func (o *RTC_CNTL_Type) SetEXT_XTL_CONF_DAC_XTAL_32K(value uint32) {
	volatile.StoreUint32(&o.EXT_XTL_CONF.Reg, volatile.LoadUint32(&o.EXT_XTL_CONF.Reg)&^(0xe0000)|value<<17)
}
func (o *RTC_CNTL_Type) GetEXT_XTL_CONF_DAC_XTAL_32K() uint32 {
	return (volatile.LoadUint32(&o.EXT_XTL_CONF.Reg) & 0xe0000) >> 17
}
func (o *RTC_CNTL_Type) SetEXT_XTL_CONF_WDT_STATE(value uint32) {
	volatile.StoreUint32(&o.EXT_XTL_CONF.Reg, volatile.LoadUint32(&o.EXT_XTL_CONF.Reg)&^(0x700000)|value<<20)
}
func (o *RTC_CNTL_Type) GetEXT_XTL_CONF_WDT_STATE() uint32 {
	return (volatile.LoadUint32(&o.EXT_XTL_CONF.Reg) & 0x700000) >> 20
}
func (o *RTC_CNTL_Type) SetEXT_XTL_CONF_XTAL32K_GPIO_SEL(value uint32) {
	volatile.StoreUint32(&o.EXT_XTL_CONF.Reg, volatile.LoadUint32(&o.EXT_XTL_CONF.Reg)&^(0x800000)|value<<23)
}
func (o *RTC_CNTL_Type) GetEXT_XTL_CONF_XTAL32K_GPIO_SEL() uint32 {
	return (volatile.LoadUint32(&o.EXT_XTL_CONF.Reg) & 0x800000) >> 23
}
func (o *RTC_CNTL_Type) SetEXT_XTL_CONF_XTL_EXT_CTR_LV(value uint32) {
	volatile.StoreUint32(&o.EXT_XTL_CONF.Reg, volatile.LoadUint32(&o.EXT_XTL_CONF.Reg)&^(0x40000000)|value<<30)
}
func (o *RTC_CNTL_Type) GetEXT_XTL_CONF_XTL_EXT_CTR_LV() uint32 {
	return (volatile.LoadUint32(&o.EXT_XTL_CONF.Reg) & 0x40000000) >> 30
}
func (o *RTC_CNTL_Type) SetEXT_XTL_CONF_XTL_EXT_CTR_EN(value uint32) {
	volatile.StoreUint32(&o.EXT_XTL_CONF.Reg, volatile.LoadUint32(&o.EXT_XTL_CONF.Reg)&^(0x80000000)|value<<31)
}
func (o *RTC_CNTL_Type) GetEXT_XTL_CONF_XTL_EXT_CTR_EN() uint32 {
	return (volatile.LoadUint32(&o.EXT_XTL_CONF.Reg) & 0x80000000) >> 31
}

// RTC_CNTL.EXT_WAKEUP_CONF: GPIO wakeup configuration register
func (o *RTC_CNTL_Type) SetEXT_WAKEUP_CONF_GPIO_WAKEUP_FILTER(value uint32) {
	volatile.StoreUint32(&o.EXT_WAKEUP_CONF.Reg, volatile.LoadUint32(&o.EXT_WAKEUP_CONF.Reg)&^(0x20000000)|value<<29)
}
func (o *RTC_CNTL_Type) GetEXT_WAKEUP_CONF_GPIO_WAKEUP_FILTER() uint32 {
	return (volatile.LoadUint32(&o.EXT_WAKEUP_CONF.Reg) & 0x20000000) >> 29
}
func (o *RTC_CNTL_Type) SetEXT_WAKEUP_CONF_EXT_WAKEUP0_LV(value uint32) {
	volatile.StoreUint32(&o.EXT_WAKEUP_CONF.Reg, volatile.LoadUint32(&o.EXT_WAKEUP_CONF.Reg)&^(0x40000000)|value<<30)
}
func (o *RTC_CNTL_Type) GetEXT_WAKEUP_CONF_EXT_WAKEUP0_LV() uint32 {
	return (volatile.LoadUint32(&o.EXT_WAKEUP_CONF.Reg) & 0x40000000) >> 30
}
func (o *RTC_CNTL_Type) SetEXT_WAKEUP_CONF_EXT_WAKEUP1_LV(value uint32) {
	volatile.StoreUint32(&o.EXT_WAKEUP_CONF.Reg, volatile.LoadUint32(&o.EXT_WAKEUP_CONF.Reg)&^(0x80000000)|value<<31)
}
func (o *RTC_CNTL_Type) GetEXT_WAKEUP_CONF_EXT_WAKEUP1_LV() uint32 {
	return (volatile.LoadUint32(&o.EXT_WAKEUP_CONF.Reg) & 0x80000000) >> 31
}

// RTC_CNTL.SLP_REJECT_CONF: Configures sleep / reject options
func (o *RTC_CNTL_Type) SetSLP_REJECT_CONF_SLEEP_REJECT_ENA(value uint32) {
	volatile.StoreUint32(&o.SLP_REJECT_CONF.Reg, volatile.LoadUint32(&o.SLP_REJECT_CONF.Reg)&^(0x3fffe000)|value<<13)
}
func (o *RTC_CNTL_Type) GetSLP_REJECT_CONF_SLEEP_REJECT_ENA() uint32 {
	return (volatile.LoadUint32(&o.SLP_REJECT_CONF.Reg) & 0x3fffe000) >> 13
}
func (o *RTC_CNTL_Type) SetSLP_REJECT_CONF_LIGHT_SLP_REJECT_EN(value uint32) {
	volatile.StoreUint32(&o.SLP_REJECT_CONF.Reg, volatile.LoadUint32(&o.SLP_REJECT_CONF.Reg)&^(0x40000000)|value<<30)
}
func (o *RTC_CNTL_Type) GetSLP_REJECT_CONF_LIGHT_SLP_REJECT_EN() uint32 {
	return (volatile.LoadUint32(&o.SLP_REJECT_CONF.Reg) & 0x40000000) >> 30
}
func (o *RTC_CNTL_Type) SetSLP_REJECT_CONF_DEEP_SLP_REJECT_EN(value uint32) {
	volatile.StoreUint32(&o.SLP_REJECT_CONF.Reg, volatile.LoadUint32(&o.SLP_REJECT_CONF.Reg)&^(0x80000000)|value<<31)
}
func (o *RTC_CNTL_Type) GetSLP_REJECT_CONF_DEEP_SLP_REJECT_EN() uint32 {
	return (volatile.LoadUint32(&o.SLP_REJECT_CONF.Reg) & 0x80000000) >> 31
}

// RTC_CNTL.CPU_PERIOD_CONF: CPU sel option
func (o *RTC_CNTL_Type) SetCPU_PERIOD_CONF_CPUSEL_CONF(value uint32) {
	volatile.StoreUint32(&o.CPU_PERIOD_CONF.Reg, volatile.LoadUint32(&o.CPU_PERIOD_CONF.Reg)&^(0x20000000)|value<<29)
}
func (o *RTC_CNTL_Type) GetCPU_PERIOD_CONF_CPUSEL_CONF() uint32 {
	return (volatile.LoadUint32(&o.CPU_PERIOD_CONF.Reg) & 0x20000000) >> 29
}
func (o *RTC_CNTL_Type) SetCPU_PERIOD_CONF_CPUPERIOD_SEL(value uint32) {
	volatile.StoreUint32(&o.CPU_PERIOD_CONF.Reg, volatile.LoadUint32(&o.CPU_PERIOD_CONF.Reg)&^(0xc0000000)|value<<30)
}
func (o *RTC_CNTL_Type) GetCPU_PERIOD_CONF_CPUPERIOD_SEL() uint32 {
	return (volatile.LoadUint32(&o.CPU_PERIOD_CONF.Reg) & 0xc0000000) >> 30
}

// RTC_CNTL.SDIO_ACT_CONF: configure sdio active register
func (o *RTC_CNTL_Type) SetSDIO_ACT_CONF_SDIO_ACT_DNUM(value uint32) {
	volatile.StoreUint32(&o.SDIO_ACT_CONF.Reg, volatile.LoadUint32(&o.SDIO_ACT_CONF.Reg)&^(0xffc00000)|value<<22)
}
func (o *RTC_CNTL_Type) GetSDIO_ACT_CONF_SDIO_ACT_DNUM() uint32 {
	return (volatile.LoadUint32(&o.SDIO_ACT_CONF.Reg) & 0xffc00000) >> 22
}

// RTC_CNTL.CLK_CONF: RTC clock configuration register
func (o *RTC_CNTL_Type) SetCLK_CONF_CK8M_DIV_SEL_VLD(value uint32) {
	volatile.StoreUint32(&o.CLK_CONF.Reg, volatile.LoadUint32(&o.CLK_CONF.Reg)&^(0x8)|value<<3)
}
func (o *RTC_CNTL_Type) GetCLK_CONF_CK8M_DIV_SEL_VLD() uint32 {
	return (volatile.LoadUint32(&o.CLK_CONF.Reg) & 0x8) >> 3
}
func (o *RTC_CNTL_Type) SetCLK_CONF_CK8M_DIV(value uint32) {
	volatile.StoreUint32(&o.CLK_CONF.Reg, volatile.LoadUint32(&o.CLK_CONF.Reg)&^(0x30)|value<<4)
}
func (o *RTC_CNTL_Type) GetCLK_CONF_CK8M_DIV() uint32 {
	return (volatile.LoadUint32(&o.CLK_CONF.Reg) & 0x30) >> 4
}
func (o *RTC_CNTL_Type) SetCLK_CONF_ENB_CK8M(value uint32) {
	volatile.StoreUint32(&o.CLK_CONF.Reg, volatile.LoadUint32(&o.CLK_CONF.Reg)&^(0x40)|value<<6)
}
func (o *RTC_CNTL_Type) GetCLK_CONF_ENB_CK8M() uint32 {
	return (volatile.LoadUint32(&o.CLK_CONF.Reg) & 0x40) >> 6
}
func (o *RTC_CNTL_Type) SetCLK_CONF_ENB_CK8M_DIV(value uint32) {
	volatile.StoreUint32(&o.CLK_CONF.Reg, volatile.LoadUint32(&o.CLK_CONF.Reg)&^(0x80)|value<<7)
}
func (o *RTC_CNTL_Type) GetCLK_CONF_ENB_CK8M_DIV() uint32 {
	return (volatile.LoadUint32(&o.CLK_CONF.Reg) & 0x80) >> 7
}
func (o *RTC_CNTL_Type) SetCLK_CONF_DIG_XTAL32K_EN(value uint32) {
	volatile.StoreUint32(&o.CLK_CONF.Reg, volatile.LoadUint32(&o.CLK_CONF.Reg)&^(0x100)|value<<8)
}
func (o *RTC_CNTL_Type) GetCLK_CONF_DIG_XTAL32K_EN() uint32 {
	return (volatile.LoadUint32(&o.CLK_CONF.Reg) & 0x100) >> 8
}
func (o *RTC_CNTL_Type) SetCLK_CONF_DIG_CLK8M_D256_EN(value uint32) {
	volatile.StoreUint32(&o.CLK_CONF.Reg, volatile.LoadUint32(&o.CLK_CONF.Reg)&^(0x200)|value<<9)
}
func (o *RTC_CNTL_Type) GetCLK_CONF_DIG_CLK8M_D256_EN() uint32 {
	return (volatile.LoadUint32(&o.CLK_CONF.Reg) & 0x200) >> 9
}
func (o *RTC_CNTL_Type) SetCLK_CONF_DIG_CLK8M_EN(value uint32) {
	volatile.StoreUint32(&o.CLK_CONF.Reg, volatile.LoadUint32(&o.CLK_CONF.Reg)&^(0x400)|value<<10)
}
func (o *RTC_CNTL_Type) GetCLK_CONF_DIG_CLK8M_EN() uint32 {
	return (volatile.LoadUint32(&o.CLK_CONF.Reg) & 0x400) >> 10
}
func (o *RTC_CNTL_Type) SetCLK_CONF_CK8M_DIV_SEL(value uint32) {
	volatile.StoreUint32(&o.CLK_CONF.Reg, volatile.LoadUint32(&o.CLK_CONF.Reg)&^(0x7000)|value<<12)
}
func (o *RTC_CNTL_Type) GetCLK_CONF_CK8M_DIV_SEL() uint32 {
	return (volatile.LoadUint32(&o.CLK_CONF.Reg) & 0x7000) >> 12
}
func (o *RTC_CNTL_Type) SetCLK_CONF_XTAL_FORCE_NOGATING(value uint32) {
	volatile.StoreUint32(&o.CLK_CONF.Reg, volatile.LoadUint32(&o.CLK_CONF.Reg)&^(0x8000)|value<<15)
}
func (o *RTC_CNTL_Type) GetCLK_CONF_XTAL_FORCE_NOGATING() uint32 {
	return (volatile.LoadUint32(&o.CLK_CONF.Reg) & 0x8000) >> 15
}
func (o *RTC_CNTL_Type) SetCLK_CONF_CK8M_FORCE_NOGATING(value uint32) {
	volatile.StoreUint32(&o.CLK_CONF.Reg, volatile.LoadUint32(&o.CLK_CONF.Reg)&^(0x10000)|value<<16)
}
func (o *RTC_CNTL_Type) GetCLK_CONF_CK8M_FORCE_NOGATING() uint32 {
	return (volatile.LoadUint32(&o.CLK_CONF.Reg) & 0x10000) >> 16
}
func (o *RTC_CNTL_Type) SetCLK_CONF_CK8M_DFREQ(value uint32) {
	volatile.StoreUint32(&o.CLK_CONF.Reg, volatile.LoadUint32(&o.CLK_CONF.Reg)&^(0x1fe0000)|value<<17)
}
func (o *RTC_CNTL_Type) GetCLK_CONF_CK8M_DFREQ() uint32 {
	return (volatile.LoadUint32(&o.CLK_CONF.Reg) & 0x1fe0000) >> 17
}
func (o *RTC_CNTL_Type) SetCLK_CONF_CK8M_FORCE_PD(value uint32) {
	volatile.StoreUint32(&o.CLK_CONF.Reg, volatile.LoadUint32(&o.CLK_CONF.Reg)&^(0x2000000)|value<<25)
}
func (o *RTC_CNTL_Type) GetCLK_CONF_CK8M_FORCE_PD() uint32 {
	return (volatile.LoadUint32(&o.CLK_CONF.Reg) & 0x2000000) >> 25
}
func (o *RTC_CNTL_Type) SetCLK_CONF_CK8M_FORCE_PU(value uint32) {
	volatile.StoreUint32(&o.CLK_CONF.Reg, volatile.LoadUint32(&o.CLK_CONF.Reg)&^(0x4000000)|value<<26)
}
func (o *RTC_CNTL_Type) GetCLK_CONF_CK8M_FORCE_PU() uint32 {
	return (volatile.LoadUint32(&o.CLK_CONF.Reg) & 0x4000000) >> 26
}
func (o *RTC_CNTL_Type) SetCLK_CONF_FAST_CLK_RTC_SEL(value uint32) {
	volatile.StoreUint32(&o.CLK_CONF.Reg, volatile.LoadUint32(&o.CLK_CONF.Reg)&^(0x20000000)|value<<29)
}
func (o *RTC_CNTL_Type) GetCLK_CONF_FAST_CLK_RTC_SEL() uint32 {
	return (volatile.LoadUint32(&o.CLK_CONF.Reg) & 0x20000000) >> 29
}
func (o *RTC_CNTL_Type) SetCLK_CONF_ANA_CLK_RTC_SEL(value uint32) {
	volatile.StoreUint32(&o.CLK_CONF.Reg, volatile.LoadUint32(&o.CLK_CONF.Reg)&^(0xc0000000)|value<<30)
}
func (o *RTC_CNTL_Type) GetCLK_CONF_ANA_CLK_RTC_SEL() uint32 {
	return (volatile.LoadUint32(&o.CLK_CONF.Reg) & 0xc0000000) >> 30
}

// RTC_CNTL.SLOW_CLK_CONF: RTC slow clock configuration register
func (o *RTC_CNTL_Type) SetSLOW_CLK_CONF_ANA_CLK_DIV_VLD(value uint32) {
	volatile.StoreUint32(&o.SLOW_CLK_CONF.Reg, volatile.LoadUint32(&o.SLOW_CLK_CONF.Reg)&^(0x400000)|value<<22)
}
func (o *RTC_CNTL_Type) GetSLOW_CLK_CONF_ANA_CLK_DIV_VLD() uint32 {
	return (volatile.LoadUint32(&o.SLOW_CLK_CONF.Reg) & 0x400000) >> 22
}
func (o *RTC_CNTL_Type) SetSLOW_CLK_CONF_ANA_CLK_DIV(value uint32) {
	volatile.StoreUint32(&o.SLOW_CLK_CONF.Reg, volatile.LoadUint32(&o.SLOW_CLK_CONF.Reg)&^(0x7f800000)|value<<23)
}
func (o *RTC_CNTL_Type) GetSLOW_CLK_CONF_ANA_CLK_DIV() uint32 {
	return (volatile.LoadUint32(&o.SLOW_CLK_CONF.Reg) & 0x7f800000) >> 23
}
func (o *RTC_CNTL_Type) SetSLOW_CLK_CONF_SLOW_CLK_NEXT_EDGE(value uint32) {
	volatile.StoreUint32(&o.SLOW_CLK_CONF.Reg, volatile.LoadUint32(&o.SLOW_CLK_CONF.Reg)&^(0x80000000)|value<<31)
}
func (o *RTC_CNTL_Type) GetSLOW_CLK_CONF_SLOW_CLK_NEXT_EDGE() uint32 {
	return (volatile.LoadUint32(&o.SLOW_CLK_CONF.Reg) & 0x80000000) >> 31
}

// RTC_CNTL.SDIO_CONF: configure vddsdio register
func (o *RTC_CNTL_Type) SetSDIO_CONF_SDIO_TIMER_TARGET(value uint32) {
	volatile.StoreUint32(&o.SDIO_CONF.Reg, volatile.LoadUint32(&o.SDIO_CONF.Reg)&^(0xff)|value)
}
func (o *RTC_CNTL_Type) GetSDIO_CONF_SDIO_TIMER_TARGET() uint32 {
	return volatile.LoadUint32(&o.SDIO_CONF.Reg) & 0xff
}
func (o *RTC_CNTL_Type) SetSDIO_CONF_SDIO_DTHDRV(value uint32) {
	volatile.StoreUint32(&o.SDIO_CONF.Reg, volatile.LoadUint32(&o.SDIO_CONF.Reg)&^(0x600)|value<<9)
}
func (o *RTC_CNTL_Type) GetSDIO_CONF_SDIO_DTHDRV() uint32 {
	return (volatile.LoadUint32(&o.SDIO_CONF.Reg) & 0x600) >> 9
}
func (o *RTC_CNTL_Type) SetSDIO_CONF_SDIO_DCAP(value uint32) {
	volatile.StoreUint32(&o.SDIO_CONF.Reg, volatile.LoadUint32(&o.SDIO_CONF.Reg)&^(0x1800)|value<<11)
}
func (o *RTC_CNTL_Type) GetSDIO_CONF_SDIO_DCAP() uint32 {
	return (volatile.LoadUint32(&o.SDIO_CONF.Reg) & 0x1800) >> 11
}
func (o *RTC_CNTL_Type) SetSDIO_CONF_SDIO_INITI(value uint32) {
	volatile.StoreUint32(&o.SDIO_CONF.Reg, volatile.LoadUint32(&o.SDIO_CONF.Reg)&^(0x6000)|value<<13)
}
func (o *RTC_CNTL_Type) GetSDIO_CONF_SDIO_INITI() uint32 {
	return (volatile.LoadUint32(&o.SDIO_CONF.Reg) & 0x6000) >> 13
}
func (o *RTC_CNTL_Type) SetSDIO_CONF_SDIO_EN_INITI(value uint32) {
	volatile.StoreUint32(&o.SDIO_CONF.Reg, volatile.LoadUint32(&o.SDIO_CONF.Reg)&^(0x8000)|value<<15)
}
func (o *RTC_CNTL_Type) GetSDIO_CONF_SDIO_EN_INITI() uint32 {
	return (volatile.LoadUint32(&o.SDIO_CONF.Reg) & 0x8000) >> 15
}
func (o *RTC_CNTL_Type) SetSDIO_CONF_SDIO_DCURLIM(value uint32) {
	volatile.StoreUint32(&o.SDIO_CONF.Reg, volatile.LoadUint32(&o.SDIO_CONF.Reg)&^(0x70000)|value<<16)
}
func (o *RTC_CNTL_Type) GetSDIO_CONF_SDIO_DCURLIM() uint32 {
	return (volatile.LoadUint32(&o.SDIO_CONF.Reg) & 0x70000) >> 16
}
func (o *RTC_CNTL_Type) SetSDIO_CONF_SDIO_MODECURLIM(value uint32) {
	volatile.StoreUint32(&o.SDIO_CONF.Reg, volatile.LoadUint32(&o.SDIO_CONF.Reg)&^(0x80000)|value<<19)
}
func (o *RTC_CNTL_Type) GetSDIO_CONF_SDIO_MODECURLIM() uint32 {
	return (volatile.LoadUint32(&o.SDIO_CONF.Reg) & 0x80000) >> 19
}
func (o *RTC_CNTL_Type) SetSDIO_CONF_SDIO_ENCURLIM(value uint32) {
	volatile.StoreUint32(&o.SDIO_CONF.Reg, volatile.LoadUint32(&o.SDIO_CONF.Reg)&^(0x100000)|value<<20)
}
func (o *RTC_CNTL_Type) GetSDIO_CONF_SDIO_ENCURLIM() uint32 {
	return (volatile.LoadUint32(&o.SDIO_CONF.Reg) & 0x100000) >> 20
}
func (o *RTC_CNTL_Type) SetSDIO_CONF_SDIO_REG_PD_EN(value uint32) {
	volatile.StoreUint32(&o.SDIO_CONF.Reg, volatile.LoadUint32(&o.SDIO_CONF.Reg)&^(0x200000)|value<<21)
}
func (o *RTC_CNTL_Type) GetSDIO_CONF_SDIO_REG_PD_EN() uint32 {
	return (volatile.LoadUint32(&o.SDIO_CONF.Reg) & 0x200000) >> 21
}
func (o *RTC_CNTL_Type) SetSDIO_CONF_SDIO_FORCE(value uint32) {
	volatile.StoreUint32(&o.SDIO_CONF.Reg, volatile.LoadUint32(&o.SDIO_CONF.Reg)&^(0x400000)|value<<22)
}
func (o *RTC_CNTL_Type) GetSDIO_CONF_SDIO_FORCE() uint32 {
	return (volatile.LoadUint32(&o.SDIO_CONF.Reg) & 0x400000) >> 22
}
func (o *RTC_CNTL_Type) SetSDIO_CONF_SDIO_TIEH(value uint32) {
	volatile.StoreUint32(&o.SDIO_CONF.Reg, volatile.LoadUint32(&o.SDIO_CONF.Reg)&^(0x800000)|value<<23)
}
func (o *RTC_CNTL_Type) GetSDIO_CONF_SDIO_TIEH() uint32 {
	return (volatile.LoadUint32(&o.SDIO_CONF.Reg) & 0x800000) >> 23
}
func (o *RTC_CNTL_Type) SetSDIO_CONF_REG1P8_READY(value uint32) {
	volatile.StoreUint32(&o.SDIO_CONF.Reg, volatile.LoadUint32(&o.SDIO_CONF.Reg)&^(0x1000000)|value<<24)
}
func (o *RTC_CNTL_Type) GetSDIO_CONF_REG1P8_READY() uint32 {
	return (volatile.LoadUint32(&o.SDIO_CONF.Reg) & 0x1000000) >> 24
}
func (o *RTC_CNTL_Type) SetSDIO_CONF_DREFL_SDIO(value uint32) {
	volatile.StoreUint32(&o.SDIO_CONF.Reg, volatile.LoadUint32(&o.SDIO_CONF.Reg)&^(0x6000000)|value<<25)
}
func (o *RTC_CNTL_Type) GetSDIO_CONF_DREFL_SDIO() uint32 {
	return (volatile.LoadUint32(&o.SDIO_CONF.Reg) & 0x6000000) >> 25
}
func (o *RTC_CNTL_Type) SetSDIO_CONF_DREFM_SDIO(value uint32) {
	volatile.StoreUint32(&o.SDIO_CONF.Reg, volatile.LoadUint32(&o.SDIO_CONF.Reg)&^(0x18000000)|value<<27)
}
func (o *RTC_CNTL_Type) GetSDIO_CONF_DREFM_SDIO() uint32 {
	return (volatile.LoadUint32(&o.SDIO_CONF.Reg) & 0x18000000) >> 27
}
func (o *RTC_CNTL_Type) SetSDIO_CONF_DREFH_SDIO(value uint32) {
	volatile.StoreUint32(&o.SDIO_CONF.Reg, volatile.LoadUint32(&o.SDIO_CONF.Reg)&^(0x60000000)|value<<29)
}
func (o *RTC_CNTL_Type) GetSDIO_CONF_DREFH_SDIO() uint32 {
	return (volatile.LoadUint32(&o.SDIO_CONF.Reg) & 0x60000000) >> 29
}
func (o *RTC_CNTL_Type) SetSDIO_CONF_XPD_SDIO(value uint32) {
	volatile.StoreUint32(&o.SDIO_CONF.Reg, volatile.LoadUint32(&o.SDIO_CONF.Reg)&^(0x80000000)|value<<31)
}
func (o *RTC_CNTL_Type) GetSDIO_CONF_XPD_SDIO() uint32 {
	return (volatile.LoadUint32(&o.SDIO_CONF.Reg) & 0x80000000) >> 31
}

// RTC_CNTL.BIAS_CONF: configure power register
func (o *RTC_CNTL_Type) SetBIAS_CONF_BIAS_BUF_IDLE(value uint32) {
	volatile.StoreUint32(&o.BIAS_CONF.Reg, volatile.LoadUint32(&o.BIAS_CONF.Reg)&^(0x400)|value<<10)
}
func (o *RTC_CNTL_Type) GetBIAS_CONF_BIAS_BUF_IDLE() uint32 {
	return (volatile.LoadUint32(&o.BIAS_CONF.Reg) & 0x400) >> 10
}
func (o *RTC_CNTL_Type) SetBIAS_CONF_BIAS_BUF_WAKE(value uint32) {
	volatile.StoreUint32(&o.BIAS_CONF.Reg, volatile.LoadUint32(&o.BIAS_CONF.Reg)&^(0x800)|value<<11)
}
func (o *RTC_CNTL_Type) GetBIAS_CONF_BIAS_BUF_WAKE() uint32 {
	return (volatile.LoadUint32(&o.BIAS_CONF.Reg) & 0x800) >> 11
}
func (o *RTC_CNTL_Type) SetBIAS_CONF_BIAS_BUF_DEEP_SLP(value uint32) {
	volatile.StoreUint32(&o.BIAS_CONF.Reg, volatile.LoadUint32(&o.BIAS_CONF.Reg)&^(0x1000)|value<<12)
}
func (o *RTC_CNTL_Type) GetBIAS_CONF_BIAS_BUF_DEEP_SLP() uint32 {
	return (volatile.LoadUint32(&o.BIAS_CONF.Reg) & 0x1000) >> 12
}
func (o *RTC_CNTL_Type) SetBIAS_CONF_BIAS_BUF_MONITOR(value uint32) {
	volatile.StoreUint32(&o.BIAS_CONF.Reg, volatile.LoadUint32(&o.BIAS_CONF.Reg)&^(0x2000)|value<<13)
}
func (o *RTC_CNTL_Type) GetBIAS_CONF_BIAS_BUF_MONITOR() uint32 {
	return (volatile.LoadUint32(&o.BIAS_CONF.Reg) & 0x2000) >> 13
}
func (o *RTC_CNTL_Type) SetBIAS_CONF_PD_CUR_DEEP_SLP(value uint32) {
	volatile.StoreUint32(&o.BIAS_CONF.Reg, volatile.LoadUint32(&o.BIAS_CONF.Reg)&^(0x4000)|value<<14)
}
func (o *RTC_CNTL_Type) GetBIAS_CONF_PD_CUR_DEEP_SLP() uint32 {
	return (volatile.LoadUint32(&o.BIAS_CONF.Reg) & 0x4000) >> 14
}
func (o *RTC_CNTL_Type) SetBIAS_CONF_PD_CUR_MONITOR(value uint32) {
	volatile.StoreUint32(&o.BIAS_CONF.Reg, volatile.LoadUint32(&o.BIAS_CONF.Reg)&^(0x8000)|value<<15)
}
func (o *RTC_CNTL_Type) GetBIAS_CONF_PD_CUR_MONITOR() uint32 {
	return (volatile.LoadUint32(&o.BIAS_CONF.Reg) & 0x8000) >> 15
}
func (o *RTC_CNTL_Type) SetBIAS_CONF_BIAS_SLEEP_DEEP_SLP(value uint32) {
	volatile.StoreUint32(&o.BIAS_CONF.Reg, volatile.LoadUint32(&o.BIAS_CONF.Reg)&^(0x10000)|value<<16)
}
func (o *RTC_CNTL_Type) GetBIAS_CONF_BIAS_SLEEP_DEEP_SLP() uint32 {
	return (volatile.LoadUint32(&o.BIAS_CONF.Reg) & 0x10000) >> 16
}
func (o *RTC_CNTL_Type) SetBIAS_CONF_BIAS_SLEEP_MONITOR(value uint32) {
	volatile.StoreUint32(&o.BIAS_CONF.Reg, volatile.LoadUint32(&o.BIAS_CONF.Reg)&^(0x20000)|value<<17)
}
func (o *RTC_CNTL_Type) GetBIAS_CONF_BIAS_SLEEP_MONITOR() uint32 {
	return (volatile.LoadUint32(&o.BIAS_CONF.Reg) & 0x20000) >> 17
}
func (o *RTC_CNTL_Type) SetBIAS_CONF_DBG_ATTEN_DEEP_SLP(value uint32) {
	volatile.StoreUint32(&o.BIAS_CONF.Reg, volatile.LoadUint32(&o.BIAS_CONF.Reg)&^(0x3c0000)|value<<18)
}
func (o *RTC_CNTL_Type) GetBIAS_CONF_DBG_ATTEN_DEEP_SLP() uint32 {
	return (volatile.LoadUint32(&o.BIAS_CONF.Reg) & 0x3c0000) >> 18
}
func (o *RTC_CNTL_Type) SetBIAS_CONF_DBG_ATTEN_MONITOR(value uint32) {
	volatile.StoreUint32(&o.BIAS_CONF.Reg, volatile.LoadUint32(&o.BIAS_CONF.Reg)&^(0x3c00000)|value<<22)
}
func (o *RTC_CNTL_Type) GetBIAS_CONF_DBG_ATTEN_MONITOR() uint32 {
	return (volatile.LoadUint32(&o.BIAS_CONF.Reg) & 0x3c00000) >> 22
}
func (o *RTC_CNTL_Type) SetBIAS_CONF_ENB_SCK_XTAL(value uint32) {
	volatile.StoreUint32(&o.BIAS_CONF.Reg, volatile.LoadUint32(&o.BIAS_CONF.Reg)&^(0x4000000)|value<<26)
}
func (o *RTC_CNTL_Type) GetBIAS_CONF_ENB_SCK_XTAL() uint32 {
	return (volatile.LoadUint32(&o.BIAS_CONF.Reg) & 0x4000000) >> 26
}
func (o *RTC_CNTL_Type) SetBIAS_CONF_INC_HEARTBEAT_REFRESH(value uint32) {
	volatile.StoreUint32(&o.BIAS_CONF.Reg, volatile.LoadUint32(&o.BIAS_CONF.Reg)&^(0x8000000)|value<<27)
}
func (o *RTC_CNTL_Type) GetBIAS_CONF_INC_HEARTBEAT_REFRESH() uint32 {
	return (volatile.LoadUint32(&o.BIAS_CONF.Reg) & 0x8000000) >> 27
}
func (o *RTC_CNTL_Type) SetBIAS_CONF_DEC_HEARTBEAT_PERIOD(value uint32) {
	volatile.StoreUint32(&o.BIAS_CONF.Reg, volatile.LoadUint32(&o.BIAS_CONF.Reg)&^(0x10000000)|value<<28)
}
func (o *RTC_CNTL_Type) GetBIAS_CONF_DEC_HEARTBEAT_PERIOD() uint32 {
	return (volatile.LoadUint32(&o.BIAS_CONF.Reg) & 0x10000000) >> 28
}
func (o *RTC_CNTL_Type) SetBIAS_CONF_INC_HEARTBEAT_PERIOD(value uint32) {
	volatile.StoreUint32(&o.BIAS_CONF.Reg, volatile.LoadUint32(&o.BIAS_CONF.Reg)&^(0x20000000)|value<<29)
}
func (o *RTC_CNTL_Type) GetBIAS_CONF_INC_HEARTBEAT_PERIOD() uint32 {
	return (volatile.LoadUint32(&o.BIAS_CONF.Reg) & 0x20000000) >> 29
}
func (o *RTC_CNTL_Type) SetBIAS_CONF_DEC_HEARTBEAT_WIDTH(value uint32) {
	volatile.StoreUint32(&o.BIAS_CONF.Reg, volatile.LoadUint32(&o.BIAS_CONF.Reg)&^(0x40000000)|value<<30)
}
func (o *RTC_CNTL_Type) GetBIAS_CONF_DEC_HEARTBEAT_WIDTH() uint32 {
	return (volatile.LoadUint32(&o.BIAS_CONF.Reg) & 0x40000000) >> 30
}
func (o *RTC_CNTL_Type) SetBIAS_CONF_RST_BIAS_I2C(value uint32) {
	volatile.StoreUint32(&o.BIAS_CONF.Reg, volatile.LoadUint32(&o.BIAS_CONF.Reg)&^(0x80000000)|value<<31)
}
func (o *RTC_CNTL_Type) GetBIAS_CONF_RST_BIAS_I2C() uint32 {
	return (volatile.LoadUint32(&o.BIAS_CONF.Reg) & 0x80000000) >> 31
}

// RTC_CNTL.BIAS: RTC/DIG regulator configuration register
func (o *RTC_CNTL_Type) SetBIAS_DIG_DBIAS_SLP(value uint32) {
	volatile.StoreUint32(&o.BIAS.Reg, volatile.LoadUint32(&o.BIAS.Reg)&^(0x700)|value<<8)
}
func (o *RTC_CNTL_Type) GetBIAS_DIG_DBIAS_SLP() uint32 {
	return (volatile.LoadUint32(&o.BIAS.Reg) & 0x700) >> 8
}
func (o *RTC_CNTL_Type) SetBIAS_DIG_DBIAS_WAK(value uint32) {
	volatile.StoreUint32(&o.BIAS.Reg, volatile.LoadUint32(&o.BIAS.Reg)&^(0x3800)|value<<11)
}
func (o *RTC_CNTL_Type) GetBIAS_DIG_DBIAS_WAK() uint32 {
	return (volatile.LoadUint32(&o.BIAS.Reg) & 0x3800) >> 11
}
func (o *RTC_CNTL_Type) SetBIAS_SCK_DCAP(value uint32) {
	volatile.StoreUint32(&o.BIAS.Reg, volatile.LoadUint32(&o.BIAS.Reg)&^(0x3fc000)|value<<14)
}
func (o *RTC_CNTL_Type) GetBIAS_SCK_DCAP() uint32 {
	return (volatile.LoadUint32(&o.BIAS.Reg) & 0x3fc000) >> 14
}
func (o *RTC_CNTL_Type) SetBIAS_DBIAS_SLP(value uint32) {
	volatile.StoreUint32(&o.BIAS.Reg, volatile.LoadUint32(&o.BIAS.Reg)&^(0x1c00000)|value<<22)
}
func (o *RTC_CNTL_Type) GetBIAS_DBIAS_SLP() uint32 {
	return (volatile.LoadUint32(&o.BIAS.Reg) & 0x1c00000) >> 22
}
func (o *RTC_CNTL_Type) SetBIAS_DBIAS_WAK(value uint32) {
	volatile.StoreUint32(&o.BIAS.Reg, volatile.LoadUint32(&o.BIAS.Reg)&^(0xe000000)|value<<25)
}
func (o *RTC_CNTL_Type) GetBIAS_DBIAS_WAK() uint32 {
	return (volatile.LoadUint32(&o.BIAS.Reg) & 0xe000000) >> 25
}
func (o *RTC_CNTL_Type) SetBIAS_DBOOST_FORCE_PD(value uint32) {
	volatile.StoreUint32(&o.BIAS.Reg, volatile.LoadUint32(&o.BIAS.Reg)&^(0x10000000)|value<<28)
}
func (o *RTC_CNTL_Type) GetBIAS_DBOOST_FORCE_PD() uint32 {
	return (volatile.LoadUint32(&o.BIAS.Reg) & 0x10000000) >> 28
}
func (o *RTC_CNTL_Type) SetBIAS_DBOOST_FORCE_PU(value uint32) {
	volatile.StoreUint32(&o.BIAS.Reg, volatile.LoadUint32(&o.BIAS.Reg)&^(0x20000000)|value<<29)
}
func (o *RTC_CNTL_Type) GetBIAS_DBOOST_FORCE_PU() uint32 {
	return (volatile.LoadUint32(&o.BIAS.Reg) & 0x20000000) >> 29
}
func (o *RTC_CNTL_Type) SetBIAS_REGULATOR_FORCE_PD(value uint32) {
	volatile.StoreUint32(&o.BIAS.Reg, volatile.LoadUint32(&o.BIAS.Reg)&^(0x40000000)|value<<30)
}
func (o *RTC_CNTL_Type) GetBIAS_REGULATOR_FORCE_PD() uint32 {
	return (volatile.LoadUint32(&o.BIAS.Reg) & 0x40000000) >> 30
}
func (o *RTC_CNTL_Type) SetBIAS_REGULATOR_FORCE_PU(value uint32) {
	volatile.StoreUint32(&o.BIAS.Reg, volatile.LoadUint32(&o.BIAS.Reg)&^(0x80000000)|value<<31)
}
func (o *RTC_CNTL_Type) GetBIAS_REGULATOR_FORCE_PU() uint32 {
	return (volatile.LoadUint32(&o.BIAS.Reg) & 0x80000000) >> 31
}

// RTC_CNTL.PWC: RTC power configuraiton register
func (o *RTC_CNTL_Type) SetPWC_FASTMEM_FORCE_NOISO(value uint32) {
	volatile.StoreUint32(&o.PWC.Reg, volatile.LoadUint32(&o.PWC.Reg)&^(0x1)|value)
}
func (o *RTC_CNTL_Type) GetPWC_FASTMEM_FORCE_NOISO() uint32 {
	return volatile.LoadUint32(&o.PWC.Reg) & 0x1
}
func (o *RTC_CNTL_Type) SetPWC_FASTMEM_FORCE_ISO(value uint32) {
	volatile.StoreUint32(&o.PWC.Reg, volatile.LoadUint32(&o.PWC.Reg)&^(0x2)|value<<1)
}
func (o *RTC_CNTL_Type) GetPWC_FASTMEM_FORCE_ISO() uint32 {
	return (volatile.LoadUint32(&o.PWC.Reg) & 0x2) >> 1
}
func (o *RTC_CNTL_Type) SetPWC_SLOWMEM_FORCE_NOISO(value uint32) {
	volatile.StoreUint32(&o.PWC.Reg, volatile.LoadUint32(&o.PWC.Reg)&^(0x4)|value<<2)
}
func (o *RTC_CNTL_Type) GetPWC_SLOWMEM_FORCE_NOISO() uint32 {
	return (volatile.LoadUint32(&o.PWC.Reg) & 0x4) >> 2
}
func (o *RTC_CNTL_Type) SetPWC_SLOWMEM_FORCE_ISO(value uint32) {
	volatile.StoreUint32(&o.PWC.Reg, volatile.LoadUint32(&o.PWC.Reg)&^(0x8)|value<<3)
}
func (o *RTC_CNTL_Type) GetPWC_SLOWMEM_FORCE_ISO() uint32 {
	return (volatile.LoadUint32(&o.PWC.Reg) & 0x8) >> 3
}
func (o *RTC_CNTL_Type) SetPWC_FORCE_ISO(value uint32) {
	volatile.StoreUint32(&o.PWC.Reg, volatile.LoadUint32(&o.PWC.Reg)&^(0x10)|value<<4)
}
func (o *RTC_CNTL_Type) GetPWC_FORCE_ISO() uint32 {
	return (volatile.LoadUint32(&o.PWC.Reg) & 0x10) >> 4
}
func (o *RTC_CNTL_Type) SetPWC_FORCE_NOISO(value uint32) {
	volatile.StoreUint32(&o.PWC.Reg, volatile.LoadUint32(&o.PWC.Reg)&^(0x20)|value<<5)
}
func (o *RTC_CNTL_Type) GetPWC_FORCE_NOISO() uint32 {
	return (volatile.LoadUint32(&o.PWC.Reg) & 0x20) >> 5
}
func (o *RTC_CNTL_Type) SetPWC_FASTMEM_FOLW_CPU(value uint32) {
	volatile.StoreUint32(&o.PWC.Reg, volatile.LoadUint32(&o.PWC.Reg)&^(0x40)|value<<6)
}
func (o *RTC_CNTL_Type) GetPWC_FASTMEM_FOLW_CPU() uint32 {
	return (volatile.LoadUint32(&o.PWC.Reg) & 0x40) >> 6
}
func (o *RTC_CNTL_Type) SetPWC_FASTMEM_FORCE_LPD(value uint32) {
	volatile.StoreUint32(&o.PWC.Reg, volatile.LoadUint32(&o.PWC.Reg)&^(0x80)|value<<7)
}
func (o *RTC_CNTL_Type) GetPWC_FASTMEM_FORCE_LPD() uint32 {
	return (volatile.LoadUint32(&o.PWC.Reg) & 0x80) >> 7
}
func (o *RTC_CNTL_Type) SetPWC_FASTMEM_FORCE_LPU(value uint32) {
	volatile.StoreUint32(&o.PWC.Reg, volatile.LoadUint32(&o.PWC.Reg)&^(0x100)|value<<8)
}
func (o *RTC_CNTL_Type) GetPWC_FASTMEM_FORCE_LPU() uint32 {
	return (volatile.LoadUint32(&o.PWC.Reg) & 0x100) >> 8
}
func (o *RTC_CNTL_Type) SetPWC_SLOWMEM_FOLW_CPU(value uint32) {
	volatile.StoreUint32(&o.PWC.Reg, volatile.LoadUint32(&o.PWC.Reg)&^(0x200)|value<<9)
}
func (o *RTC_CNTL_Type) GetPWC_SLOWMEM_FOLW_CPU() uint32 {
	return (volatile.LoadUint32(&o.PWC.Reg) & 0x200) >> 9
}
func (o *RTC_CNTL_Type) SetPWC_SLOWMEM_FORCE_LPD(value uint32) {
	volatile.StoreUint32(&o.PWC.Reg, volatile.LoadUint32(&o.PWC.Reg)&^(0x400)|value<<10)
}
func (o *RTC_CNTL_Type) GetPWC_SLOWMEM_FORCE_LPD() uint32 {
	return (volatile.LoadUint32(&o.PWC.Reg) & 0x400) >> 10
}
func (o *RTC_CNTL_Type) SetPWC_SLOWMEM_FORCE_LPU(value uint32) {
	volatile.StoreUint32(&o.PWC.Reg, volatile.LoadUint32(&o.PWC.Reg)&^(0x800)|value<<11)
}
func (o *RTC_CNTL_Type) GetPWC_SLOWMEM_FORCE_LPU() uint32 {
	return (volatile.LoadUint32(&o.PWC.Reg) & 0x800) >> 11
}
func (o *RTC_CNTL_Type) SetPWC_FASTMEM_FORCE_PD(value uint32) {
	volatile.StoreUint32(&o.PWC.Reg, volatile.LoadUint32(&o.PWC.Reg)&^(0x1000)|value<<12)
}
func (o *RTC_CNTL_Type) GetPWC_FASTMEM_FORCE_PD() uint32 {
	return (volatile.LoadUint32(&o.PWC.Reg) & 0x1000) >> 12
}
func (o *RTC_CNTL_Type) SetPWC_FASTMEM_FORCE_PU(value uint32) {
	volatile.StoreUint32(&o.PWC.Reg, volatile.LoadUint32(&o.PWC.Reg)&^(0x2000)|value<<13)
}
func (o *RTC_CNTL_Type) GetPWC_FASTMEM_FORCE_PU() uint32 {
	return (volatile.LoadUint32(&o.PWC.Reg) & 0x2000) >> 13
}
func (o *RTC_CNTL_Type) SetPWC_FASTMEM_PD_EN(value uint32) {
	volatile.StoreUint32(&o.PWC.Reg, volatile.LoadUint32(&o.PWC.Reg)&^(0x4000)|value<<14)
}
func (o *RTC_CNTL_Type) GetPWC_FASTMEM_PD_EN() uint32 {
	return (volatile.LoadUint32(&o.PWC.Reg) & 0x4000) >> 14
}
func (o *RTC_CNTL_Type) SetPWC_SLOWMEM_FORCE_PD(value uint32) {
	volatile.StoreUint32(&o.PWC.Reg, volatile.LoadUint32(&o.PWC.Reg)&^(0x8000)|value<<15)
}
func (o *RTC_CNTL_Type) GetPWC_SLOWMEM_FORCE_PD() uint32 {
	return (volatile.LoadUint32(&o.PWC.Reg) & 0x8000) >> 15
}
func (o *RTC_CNTL_Type) SetPWC_SLOWMEM_FORCE_PU(value uint32) {
	volatile.StoreUint32(&o.PWC.Reg, volatile.LoadUint32(&o.PWC.Reg)&^(0x10000)|value<<16)
}
func (o *RTC_CNTL_Type) GetPWC_SLOWMEM_FORCE_PU() uint32 {
	return (volatile.LoadUint32(&o.PWC.Reg) & 0x10000) >> 16
}
func (o *RTC_CNTL_Type) SetPWC_SLOWMEM_PD_EN(value uint32) {
	volatile.StoreUint32(&o.PWC.Reg, volatile.LoadUint32(&o.PWC.Reg)&^(0x20000)|value<<17)
}
func (o *RTC_CNTL_Type) GetPWC_SLOWMEM_PD_EN() uint32 {
	return (volatile.LoadUint32(&o.PWC.Reg) & 0x20000) >> 17
}
func (o *RTC_CNTL_Type) SetPWC_FORCE_PD(value uint32) {
	volatile.StoreUint32(&o.PWC.Reg, volatile.LoadUint32(&o.PWC.Reg)&^(0x40000)|value<<18)
}
func (o *RTC_CNTL_Type) GetPWC_FORCE_PD() uint32 {
	return (volatile.LoadUint32(&o.PWC.Reg) & 0x40000) >> 18
}
func (o *RTC_CNTL_Type) SetPWC_FORCE_PU(value uint32) {
	volatile.StoreUint32(&o.PWC.Reg, volatile.LoadUint32(&o.PWC.Reg)&^(0x80000)|value<<19)
}
func (o *RTC_CNTL_Type) GetPWC_FORCE_PU() uint32 {
	return (volatile.LoadUint32(&o.PWC.Reg) & 0x80000) >> 19
}
func (o *RTC_CNTL_Type) SetPWC_PD_EN(value uint32) {
	volatile.StoreUint32(&o.PWC.Reg, volatile.LoadUint32(&o.PWC.Reg)&^(0x100000)|value<<20)
}
func (o *RTC_CNTL_Type) GetPWC_PD_EN() uint32 {
	return (volatile.LoadUint32(&o.PWC.Reg) & 0x100000) >> 20
}
func (o *RTC_CNTL_Type) SetPWC_PAD_FORCE_HOLD(value uint32) {
	volatile.StoreUint32(&o.PWC.Reg, volatile.LoadUint32(&o.PWC.Reg)&^(0x200000)|value<<21)
}
func (o *RTC_CNTL_Type) GetPWC_PAD_FORCE_HOLD() uint32 {
	return (volatile.LoadUint32(&o.PWC.Reg) & 0x200000) >> 21
}

// RTC_CNTL.DIG_PWC: Digital system power configuraiton register
func (o *RTC_CNTL_Type) SetDIG_PWC_LSLP_MEM_FORCE_PD(value uint32) {
	volatile.StoreUint32(&o.DIG_PWC.Reg, volatile.LoadUint32(&o.DIG_PWC.Reg)&^(0x8)|value<<3)
}
func (o *RTC_CNTL_Type) GetDIG_PWC_LSLP_MEM_FORCE_PD() uint32 {
	return (volatile.LoadUint32(&o.DIG_PWC.Reg) & 0x8) >> 3
}
func (o *RTC_CNTL_Type) SetDIG_PWC_LSLP_MEM_FORCE_PU(value uint32) {
	volatile.StoreUint32(&o.DIG_PWC.Reg, volatile.LoadUint32(&o.DIG_PWC.Reg)&^(0x10)|value<<4)
}
func (o *RTC_CNTL_Type) GetDIG_PWC_LSLP_MEM_FORCE_PU() uint32 {
	return (volatile.LoadUint32(&o.DIG_PWC.Reg) & 0x10) >> 4
}
func (o *RTC_CNTL_Type) SetDIG_PWC_ROM0_FORCE_PD(value uint32) {
	volatile.StoreUint32(&o.DIG_PWC.Reg, volatile.LoadUint32(&o.DIG_PWC.Reg)&^(0x20)|value<<5)
}
func (o *RTC_CNTL_Type) GetDIG_PWC_ROM0_FORCE_PD() uint32 {
	return (volatile.LoadUint32(&o.DIG_PWC.Reg) & 0x20) >> 5
}
func (o *RTC_CNTL_Type) SetDIG_PWC_ROM0_FORCE_PU(value uint32) {
	volatile.StoreUint32(&o.DIG_PWC.Reg, volatile.LoadUint32(&o.DIG_PWC.Reg)&^(0x40)|value<<6)
}
func (o *RTC_CNTL_Type) GetDIG_PWC_ROM0_FORCE_PU() uint32 {
	return (volatile.LoadUint32(&o.DIG_PWC.Reg) & 0x40) >> 6
}
func (o *RTC_CNTL_Type) SetDIG_PWC_INTER_RAM0_FORCE_PD(value uint32) {
	volatile.StoreUint32(&o.DIG_PWC.Reg, volatile.LoadUint32(&o.DIG_PWC.Reg)&^(0x80)|value<<7)
}
func (o *RTC_CNTL_Type) GetDIG_PWC_INTER_RAM0_FORCE_PD() uint32 {
	return (volatile.LoadUint32(&o.DIG_PWC.Reg) & 0x80) >> 7
}
func (o *RTC_CNTL_Type) SetDIG_PWC_INTER_RAM0_FORCE_PU(value uint32) {
	volatile.StoreUint32(&o.DIG_PWC.Reg, volatile.LoadUint32(&o.DIG_PWC.Reg)&^(0x100)|value<<8)
}
func (o *RTC_CNTL_Type) GetDIG_PWC_INTER_RAM0_FORCE_PU() uint32 {
	return (volatile.LoadUint32(&o.DIG_PWC.Reg) & 0x100) >> 8
}
func (o *RTC_CNTL_Type) SetDIG_PWC_INTER_RAM1_FORCE_PD(value uint32) {
	volatile.StoreUint32(&o.DIG_PWC.Reg, volatile.LoadUint32(&o.DIG_PWC.Reg)&^(0x200)|value<<9)
}
func (o *RTC_CNTL_Type) GetDIG_PWC_INTER_RAM1_FORCE_PD() uint32 {
	return (volatile.LoadUint32(&o.DIG_PWC.Reg) & 0x200) >> 9
}
func (o *RTC_CNTL_Type) SetDIG_PWC_INTER_RAM1_FORCE_PU(value uint32) {
	volatile.StoreUint32(&o.DIG_PWC.Reg, volatile.LoadUint32(&o.DIG_PWC.Reg)&^(0x400)|value<<10)
}
func (o *RTC_CNTL_Type) GetDIG_PWC_INTER_RAM1_FORCE_PU() uint32 {
	return (volatile.LoadUint32(&o.DIG_PWC.Reg) & 0x400) >> 10
}
func (o *RTC_CNTL_Type) SetDIG_PWC_INTER_RAM2_FORCE_PD(value uint32) {
	volatile.StoreUint32(&o.DIG_PWC.Reg, volatile.LoadUint32(&o.DIG_PWC.Reg)&^(0x800)|value<<11)
}
func (o *RTC_CNTL_Type) GetDIG_PWC_INTER_RAM2_FORCE_PD() uint32 {
	return (volatile.LoadUint32(&o.DIG_PWC.Reg) & 0x800) >> 11
}
func (o *RTC_CNTL_Type) SetDIG_PWC_INTER_RAM2_FORCE_PU(value uint32) {
	volatile.StoreUint32(&o.DIG_PWC.Reg, volatile.LoadUint32(&o.DIG_PWC.Reg)&^(0x1000)|value<<12)
}
func (o *RTC_CNTL_Type) GetDIG_PWC_INTER_RAM2_FORCE_PU() uint32 {
	return (volatile.LoadUint32(&o.DIG_PWC.Reg) & 0x1000) >> 12
}
func (o *RTC_CNTL_Type) SetDIG_PWC_INTER_RAM3_FORCE_PD(value uint32) {
	volatile.StoreUint32(&o.DIG_PWC.Reg, volatile.LoadUint32(&o.DIG_PWC.Reg)&^(0x2000)|value<<13)
}
func (o *RTC_CNTL_Type) GetDIG_PWC_INTER_RAM3_FORCE_PD() uint32 {
	return (volatile.LoadUint32(&o.DIG_PWC.Reg) & 0x2000) >> 13
}
func (o *RTC_CNTL_Type) SetDIG_PWC_INTER_RAM3_FORCE_PU(value uint32) {
	volatile.StoreUint32(&o.DIG_PWC.Reg, volatile.LoadUint32(&o.DIG_PWC.Reg)&^(0x4000)|value<<14)
}
func (o *RTC_CNTL_Type) GetDIG_PWC_INTER_RAM3_FORCE_PU() uint32 {
	return (volatile.LoadUint32(&o.DIG_PWC.Reg) & 0x4000) >> 14
}
func (o *RTC_CNTL_Type) SetDIG_PWC_INTER_RAM4_FORCE_PD(value uint32) {
	volatile.StoreUint32(&o.DIG_PWC.Reg, volatile.LoadUint32(&o.DIG_PWC.Reg)&^(0x8000)|value<<15)
}
func (o *RTC_CNTL_Type) GetDIG_PWC_INTER_RAM4_FORCE_PD() uint32 {
	return (volatile.LoadUint32(&o.DIG_PWC.Reg) & 0x8000) >> 15
}
func (o *RTC_CNTL_Type) SetDIG_PWC_INTER_RAM4_FORCE_PU(value uint32) {
	volatile.StoreUint32(&o.DIG_PWC.Reg, volatile.LoadUint32(&o.DIG_PWC.Reg)&^(0x10000)|value<<16)
}
func (o *RTC_CNTL_Type) GetDIG_PWC_INTER_RAM4_FORCE_PU() uint32 {
	return (volatile.LoadUint32(&o.DIG_PWC.Reg) & 0x10000) >> 16
}
func (o *RTC_CNTL_Type) SetDIG_PWC_WIFI_FORCE_PD(value uint32) {
	volatile.StoreUint32(&o.DIG_PWC.Reg, volatile.LoadUint32(&o.DIG_PWC.Reg)&^(0x20000)|value<<17)
}
func (o *RTC_CNTL_Type) GetDIG_PWC_WIFI_FORCE_PD() uint32 {
	return (volatile.LoadUint32(&o.DIG_PWC.Reg) & 0x20000) >> 17
}
func (o *RTC_CNTL_Type) SetDIG_PWC_WIFI_FORCE_PU(value uint32) {
	volatile.StoreUint32(&o.DIG_PWC.Reg, volatile.LoadUint32(&o.DIG_PWC.Reg)&^(0x40000)|value<<18)
}
func (o *RTC_CNTL_Type) GetDIG_PWC_WIFI_FORCE_PU() uint32 {
	return (volatile.LoadUint32(&o.DIG_PWC.Reg) & 0x40000) >> 18
}
func (o *RTC_CNTL_Type) SetDIG_PWC_DG_WRAP_FORCE_PD(value uint32) {
	volatile.StoreUint32(&o.DIG_PWC.Reg, volatile.LoadUint32(&o.DIG_PWC.Reg)&^(0x80000)|value<<19)
}
func (o *RTC_CNTL_Type) GetDIG_PWC_DG_WRAP_FORCE_PD() uint32 {
	return (volatile.LoadUint32(&o.DIG_PWC.Reg) & 0x80000) >> 19
}
func (o *RTC_CNTL_Type) SetDIG_PWC_DG_WRAP_FORCE_PU(value uint32) {
	volatile.StoreUint32(&o.DIG_PWC.Reg, volatile.LoadUint32(&o.DIG_PWC.Reg)&^(0x100000)|value<<20)
}
func (o *RTC_CNTL_Type) GetDIG_PWC_DG_WRAP_FORCE_PU() uint32 {
	return (volatile.LoadUint32(&o.DIG_PWC.Reg) & 0x100000) >> 20
}
func (o *RTC_CNTL_Type) SetDIG_PWC_DG_DCDC_FORCE_PD(value uint32) {
	volatile.StoreUint32(&o.DIG_PWC.Reg, volatile.LoadUint32(&o.DIG_PWC.Reg)&^(0x200000)|value<<21)
}
func (o *RTC_CNTL_Type) GetDIG_PWC_DG_DCDC_FORCE_PD() uint32 {
	return (volatile.LoadUint32(&o.DIG_PWC.Reg) & 0x200000) >> 21
}
func (o *RTC_CNTL_Type) SetDIG_PWC_DG_DCDC_FORCE_PU(value uint32) {
	volatile.StoreUint32(&o.DIG_PWC.Reg, volatile.LoadUint32(&o.DIG_PWC.Reg)&^(0x400000)|value<<22)
}
func (o *RTC_CNTL_Type) GetDIG_PWC_DG_DCDC_FORCE_PU() uint32 {
	return (volatile.LoadUint32(&o.DIG_PWC.Reg) & 0x400000) >> 22
}
func (o *RTC_CNTL_Type) SetDIG_PWC_DG_DCDC_PD_EN(value uint32) {
	volatile.StoreUint32(&o.DIG_PWC.Reg, volatile.LoadUint32(&o.DIG_PWC.Reg)&^(0x800000)|value<<23)
}
func (o *RTC_CNTL_Type) GetDIG_PWC_DG_DCDC_PD_EN() uint32 {
	return (volatile.LoadUint32(&o.DIG_PWC.Reg) & 0x800000) >> 23
}
func (o *RTC_CNTL_Type) SetDIG_PWC_ROM0_PD_EN(value uint32) {
	volatile.StoreUint32(&o.DIG_PWC.Reg, volatile.LoadUint32(&o.DIG_PWC.Reg)&^(0x1000000)|value<<24)
}
func (o *RTC_CNTL_Type) GetDIG_PWC_ROM0_PD_EN() uint32 {
	return (volatile.LoadUint32(&o.DIG_PWC.Reg) & 0x1000000) >> 24
}
func (o *RTC_CNTL_Type) SetDIG_PWC_INTER_RAM0_PD_EN(value uint32) {
	volatile.StoreUint32(&o.DIG_PWC.Reg, volatile.LoadUint32(&o.DIG_PWC.Reg)&^(0x2000000)|value<<25)
}
func (o *RTC_CNTL_Type) GetDIG_PWC_INTER_RAM0_PD_EN() uint32 {
	return (volatile.LoadUint32(&o.DIG_PWC.Reg) & 0x2000000) >> 25
}
func (o *RTC_CNTL_Type) SetDIG_PWC_INTER_RAM1_PD_EN(value uint32) {
	volatile.StoreUint32(&o.DIG_PWC.Reg, volatile.LoadUint32(&o.DIG_PWC.Reg)&^(0x4000000)|value<<26)
}
func (o *RTC_CNTL_Type) GetDIG_PWC_INTER_RAM1_PD_EN() uint32 {
	return (volatile.LoadUint32(&o.DIG_PWC.Reg) & 0x4000000) >> 26
}
func (o *RTC_CNTL_Type) SetDIG_PWC_INTER_RAM2_PD_EN(value uint32) {
	volatile.StoreUint32(&o.DIG_PWC.Reg, volatile.LoadUint32(&o.DIG_PWC.Reg)&^(0x8000000)|value<<27)
}
func (o *RTC_CNTL_Type) GetDIG_PWC_INTER_RAM2_PD_EN() uint32 {
	return (volatile.LoadUint32(&o.DIG_PWC.Reg) & 0x8000000) >> 27
}
func (o *RTC_CNTL_Type) SetDIG_PWC_INTER_RAM3_PD_EN(value uint32) {
	volatile.StoreUint32(&o.DIG_PWC.Reg, volatile.LoadUint32(&o.DIG_PWC.Reg)&^(0x10000000)|value<<28)
}
func (o *RTC_CNTL_Type) GetDIG_PWC_INTER_RAM3_PD_EN() uint32 {
	return (volatile.LoadUint32(&o.DIG_PWC.Reg) & 0x10000000) >> 28
}
func (o *RTC_CNTL_Type) SetDIG_PWC_INTER_RAM4_PD_EN(value uint32) {
	volatile.StoreUint32(&o.DIG_PWC.Reg, volatile.LoadUint32(&o.DIG_PWC.Reg)&^(0x20000000)|value<<29)
}
func (o *RTC_CNTL_Type) GetDIG_PWC_INTER_RAM4_PD_EN() uint32 {
	return (volatile.LoadUint32(&o.DIG_PWC.Reg) & 0x20000000) >> 29
}
func (o *RTC_CNTL_Type) SetDIG_PWC_WIFI_PD_EN(value uint32) {
	volatile.StoreUint32(&o.DIG_PWC.Reg, volatile.LoadUint32(&o.DIG_PWC.Reg)&^(0x40000000)|value<<30)
}
func (o *RTC_CNTL_Type) GetDIG_PWC_WIFI_PD_EN() uint32 {
	return (volatile.LoadUint32(&o.DIG_PWC.Reg) & 0x40000000) >> 30
}
func (o *RTC_CNTL_Type) SetDIG_PWC_DG_WRAP_PD_EN(value uint32) {
	volatile.StoreUint32(&o.DIG_PWC.Reg, volatile.LoadUint32(&o.DIG_PWC.Reg)&^(0x80000000)|value<<31)
}
func (o *RTC_CNTL_Type) GetDIG_PWC_DG_WRAP_PD_EN() uint32 {
	return (volatile.LoadUint32(&o.DIG_PWC.Reg) & 0x80000000) >> 31
}

// RTC_CNTL.DIG_ISO: Digital system ISO configuration register
func (o *RTC_CNTL_Type) SetDIG_ISO_FORCE_OFF(value uint32) {
	volatile.StoreUint32(&o.DIG_ISO.Reg, volatile.LoadUint32(&o.DIG_ISO.Reg)&^(0x80)|value<<7)
}
func (o *RTC_CNTL_Type) GetDIG_ISO_FORCE_OFF() uint32 {
	return (volatile.LoadUint32(&o.DIG_ISO.Reg) & 0x80) >> 7
}
func (o *RTC_CNTL_Type) SetDIG_ISO_FORCE_ON(value uint32) {
	volatile.StoreUint32(&o.DIG_ISO.Reg, volatile.LoadUint32(&o.DIG_ISO.Reg)&^(0x100)|value<<8)
}
func (o *RTC_CNTL_Type) GetDIG_ISO_FORCE_ON() uint32 {
	return (volatile.LoadUint32(&o.DIG_ISO.Reg) & 0x100) >> 8
}
func (o *RTC_CNTL_Type) SetDIG_ISO_DG_PAD_AUTOHOLD(value uint32) {
	volatile.StoreUint32(&o.DIG_ISO.Reg, volatile.LoadUint32(&o.DIG_ISO.Reg)&^(0x200)|value<<9)
}
func (o *RTC_CNTL_Type) GetDIG_ISO_DG_PAD_AUTOHOLD() uint32 {
	return (volatile.LoadUint32(&o.DIG_ISO.Reg) & 0x200) >> 9
}
func (o *RTC_CNTL_Type) SetDIG_ISO_CLR_DG_PAD_AUTOHOLD(value uint32) {
	volatile.StoreUint32(&o.DIG_ISO.Reg, volatile.LoadUint32(&o.DIG_ISO.Reg)&^(0x400)|value<<10)
}
func (o *RTC_CNTL_Type) GetDIG_ISO_CLR_DG_PAD_AUTOHOLD() uint32 {
	return (volatile.LoadUint32(&o.DIG_ISO.Reg) & 0x400) >> 10
}
func (o *RTC_CNTL_Type) SetDIG_ISO_DG_PAD_AUTOHOLD_EN(value uint32) {
	volatile.StoreUint32(&o.DIG_ISO.Reg, volatile.LoadUint32(&o.DIG_ISO.Reg)&^(0x800)|value<<11)
}
func (o *RTC_CNTL_Type) GetDIG_ISO_DG_PAD_AUTOHOLD_EN() uint32 {
	return (volatile.LoadUint32(&o.DIG_ISO.Reg) & 0x800) >> 11
}
func (o *RTC_CNTL_Type) SetDIG_ISO_DG_PAD_FORCE_NOISO(value uint32) {
	volatile.StoreUint32(&o.DIG_ISO.Reg, volatile.LoadUint32(&o.DIG_ISO.Reg)&^(0x1000)|value<<12)
}
func (o *RTC_CNTL_Type) GetDIG_ISO_DG_PAD_FORCE_NOISO() uint32 {
	return (volatile.LoadUint32(&o.DIG_ISO.Reg) & 0x1000) >> 12
}
func (o *RTC_CNTL_Type) SetDIG_ISO_DG_PAD_FORCE_ISO(value uint32) {
	volatile.StoreUint32(&o.DIG_ISO.Reg, volatile.LoadUint32(&o.DIG_ISO.Reg)&^(0x2000)|value<<13)
}
func (o *RTC_CNTL_Type) GetDIG_ISO_DG_PAD_FORCE_ISO() uint32 {
	return (volatile.LoadUint32(&o.DIG_ISO.Reg) & 0x2000) >> 13
}
func (o *RTC_CNTL_Type) SetDIG_ISO_DG_PAD_FORCE_UNHOLD(value uint32) {
	volatile.StoreUint32(&o.DIG_ISO.Reg, volatile.LoadUint32(&o.DIG_ISO.Reg)&^(0x4000)|value<<14)
}
func (o *RTC_CNTL_Type) GetDIG_ISO_DG_PAD_FORCE_UNHOLD() uint32 {
	return (volatile.LoadUint32(&o.DIG_ISO.Reg) & 0x4000) >> 14
}
func (o *RTC_CNTL_Type) SetDIG_ISO_DG_PAD_FORCE_HOLD(value uint32) {
	volatile.StoreUint32(&o.DIG_ISO.Reg, volatile.LoadUint32(&o.DIG_ISO.Reg)&^(0x8000)|value<<15)
}
func (o *RTC_CNTL_Type) GetDIG_ISO_DG_PAD_FORCE_HOLD() uint32 {
	return (volatile.LoadUint32(&o.DIG_ISO.Reg) & 0x8000) >> 15
}
func (o *RTC_CNTL_Type) SetDIG_ISO_ROM0_FORCE_ISO(value uint32) {
	volatile.StoreUint32(&o.DIG_ISO.Reg, volatile.LoadUint32(&o.DIG_ISO.Reg)&^(0x10000)|value<<16)
}
func (o *RTC_CNTL_Type) GetDIG_ISO_ROM0_FORCE_ISO() uint32 {
	return (volatile.LoadUint32(&o.DIG_ISO.Reg) & 0x10000) >> 16
}
func (o *RTC_CNTL_Type) SetDIG_ISO_ROM0_FORCE_NOISO(value uint32) {
	volatile.StoreUint32(&o.DIG_ISO.Reg, volatile.LoadUint32(&o.DIG_ISO.Reg)&^(0x20000)|value<<17)
}
func (o *RTC_CNTL_Type) GetDIG_ISO_ROM0_FORCE_NOISO() uint32 {
	return (volatile.LoadUint32(&o.DIG_ISO.Reg) & 0x20000) >> 17
}
func (o *RTC_CNTL_Type) SetDIG_ISO_INTER_RAM0_FORCE_ISO(value uint32) {
	volatile.StoreUint32(&o.DIG_ISO.Reg, volatile.LoadUint32(&o.DIG_ISO.Reg)&^(0x40000)|value<<18)
}
func (o *RTC_CNTL_Type) GetDIG_ISO_INTER_RAM0_FORCE_ISO() uint32 {
	return (volatile.LoadUint32(&o.DIG_ISO.Reg) & 0x40000) >> 18
}
func (o *RTC_CNTL_Type) SetDIG_ISO_INTER_RAM0_FORCE_NOISO(value uint32) {
	volatile.StoreUint32(&o.DIG_ISO.Reg, volatile.LoadUint32(&o.DIG_ISO.Reg)&^(0x80000)|value<<19)
}
func (o *RTC_CNTL_Type) GetDIG_ISO_INTER_RAM0_FORCE_NOISO() uint32 {
	return (volatile.LoadUint32(&o.DIG_ISO.Reg) & 0x80000) >> 19
}
func (o *RTC_CNTL_Type) SetDIG_ISO_INTER_RAM1_FORCE_ISO(value uint32) {
	volatile.StoreUint32(&o.DIG_ISO.Reg, volatile.LoadUint32(&o.DIG_ISO.Reg)&^(0x100000)|value<<20)
}
func (o *RTC_CNTL_Type) GetDIG_ISO_INTER_RAM1_FORCE_ISO() uint32 {
	return (volatile.LoadUint32(&o.DIG_ISO.Reg) & 0x100000) >> 20
}
func (o *RTC_CNTL_Type) SetDIG_ISO_INTER_RAM1_FORCE_NOISO(value uint32) {
	volatile.StoreUint32(&o.DIG_ISO.Reg, volatile.LoadUint32(&o.DIG_ISO.Reg)&^(0x200000)|value<<21)
}
func (o *RTC_CNTL_Type) GetDIG_ISO_INTER_RAM1_FORCE_NOISO() uint32 {
	return (volatile.LoadUint32(&o.DIG_ISO.Reg) & 0x200000) >> 21
}
func (o *RTC_CNTL_Type) SetDIG_ISO_INTER_RAM2_FORCE_ISO(value uint32) {
	volatile.StoreUint32(&o.DIG_ISO.Reg, volatile.LoadUint32(&o.DIG_ISO.Reg)&^(0x400000)|value<<22)
}
func (o *RTC_CNTL_Type) GetDIG_ISO_INTER_RAM2_FORCE_ISO() uint32 {
	return (volatile.LoadUint32(&o.DIG_ISO.Reg) & 0x400000) >> 22
}
func (o *RTC_CNTL_Type) SetDIG_ISO_INTER_RAM2_FORCE_NOISO(value uint32) {
	volatile.StoreUint32(&o.DIG_ISO.Reg, volatile.LoadUint32(&o.DIG_ISO.Reg)&^(0x800000)|value<<23)
}
func (o *RTC_CNTL_Type) GetDIG_ISO_INTER_RAM2_FORCE_NOISO() uint32 {
	return (volatile.LoadUint32(&o.DIG_ISO.Reg) & 0x800000) >> 23
}
func (o *RTC_CNTL_Type) SetDIG_ISO_INTER_RAM3_FORCE_ISO(value uint32) {
	volatile.StoreUint32(&o.DIG_ISO.Reg, volatile.LoadUint32(&o.DIG_ISO.Reg)&^(0x1000000)|value<<24)
}
func (o *RTC_CNTL_Type) GetDIG_ISO_INTER_RAM3_FORCE_ISO() uint32 {
	return (volatile.LoadUint32(&o.DIG_ISO.Reg) & 0x1000000) >> 24
}
func (o *RTC_CNTL_Type) SetDIG_ISO_INTER_RAM3_FORCE_NOISO(value uint32) {
	volatile.StoreUint32(&o.DIG_ISO.Reg, volatile.LoadUint32(&o.DIG_ISO.Reg)&^(0x2000000)|value<<25)
}
func (o *RTC_CNTL_Type) GetDIG_ISO_INTER_RAM3_FORCE_NOISO() uint32 {
	return (volatile.LoadUint32(&o.DIG_ISO.Reg) & 0x2000000) >> 25
}
func (o *RTC_CNTL_Type) SetDIG_ISO_INTER_RAM4_FORCE_ISO(value uint32) {
	volatile.StoreUint32(&o.DIG_ISO.Reg, volatile.LoadUint32(&o.DIG_ISO.Reg)&^(0x4000000)|value<<26)
}
func (o *RTC_CNTL_Type) GetDIG_ISO_INTER_RAM4_FORCE_ISO() uint32 {
	return (volatile.LoadUint32(&o.DIG_ISO.Reg) & 0x4000000) >> 26
}
func (o *RTC_CNTL_Type) SetDIG_ISO_INTER_RAM4_FORCE_NOISO(value uint32) {
	volatile.StoreUint32(&o.DIG_ISO.Reg, volatile.LoadUint32(&o.DIG_ISO.Reg)&^(0x8000000)|value<<27)
}
func (o *RTC_CNTL_Type) GetDIG_ISO_INTER_RAM4_FORCE_NOISO() uint32 {
	return (volatile.LoadUint32(&o.DIG_ISO.Reg) & 0x8000000) >> 27
}
func (o *RTC_CNTL_Type) SetDIG_ISO_WIFI_FORCE_ISO(value uint32) {
	volatile.StoreUint32(&o.DIG_ISO.Reg, volatile.LoadUint32(&o.DIG_ISO.Reg)&^(0x10000000)|value<<28)
}
func (o *RTC_CNTL_Type) GetDIG_ISO_WIFI_FORCE_ISO() uint32 {
	return (volatile.LoadUint32(&o.DIG_ISO.Reg) & 0x10000000) >> 28
}
func (o *RTC_CNTL_Type) SetDIG_ISO_WIFI_FORCE_NOISO(value uint32) {
	volatile.StoreUint32(&o.DIG_ISO.Reg, volatile.LoadUint32(&o.DIG_ISO.Reg)&^(0x20000000)|value<<29)
}
func (o *RTC_CNTL_Type) GetDIG_ISO_WIFI_FORCE_NOISO() uint32 {
	return (volatile.LoadUint32(&o.DIG_ISO.Reg) & 0x20000000) >> 29
}
func (o *RTC_CNTL_Type) SetDIG_ISO_DG_WRAP_FORCE_ISO(value uint32) {
	volatile.StoreUint32(&o.DIG_ISO.Reg, volatile.LoadUint32(&o.DIG_ISO.Reg)&^(0x40000000)|value<<30)
}
func (o *RTC_CNTL_Type) GetDIG_ISO_DG_WRAP_FORCE_ISO() uint32 {
	return (volatile.LoadUint32(&o.DIG_ISO.Reg) & 0x40000000) >> 30
}
func (o *RTC_CNTL_Type) SetDIG_ISO_DG_WRAP_FORCE_NOISO(value uint32) {
	volatile.StoreUint32(&o.DIG_ISO.Reg, volatile.LoadUint32(&o.DIG_ISO.Reg)&^(0x80000000)|value<<31)
}
func (o *RTC_CNTL_Type) GetDIG_ISO_DG_WRAP_FORCE_NOISO() uint32 {
	return (volatile.LoadUint32(&o.DIG_ISO.Reg) & 0x80000000) >> 31
}

// RTC_CNTL.WDTCONFIG0: RTC watchdog configuration register
func (o *RTC_CNTL_Type) SetWDTCONFIG0_WDT_CHIP_RESET_WIDTH(value uint32) {
	volatile.StoreUint32(&o.WDTCONFIG0.Reg, volatile.LoadUint32(&o.WDTCONFIG0.Reg)&^(0xff)|value)
}
func (o *RTC_CNTL_Type) GetWDTCONFIG0_WDT_CHIP_RESET_WIDTH() uint32 {
	return volatile.LoadUint32(&o.WDTCONFIG0.Reg) & 0xff
}
func (o *RTC_CNTL_Type) SetWDTCONFIG0_WDT_CHIP_RESET_EN(value uint32) {
	volatile.StoreUint32(&o.WDTCONFIG0.Reg, volatile.LoadUint32(&o.WDTCONFIG0.Reg)&^(0x100)|value<<8)
}
func (o *RTC_CNTL_Type) GetWDTCONFIG0_WDT_CHIP_RESET_EN() uint32 {
	return (volatile.LoadUint32(&o.WDTCONFIG0.Reg) & 0x100) >> 8
}
func (o *RTC_CNTL_Type) SetWDTCONFIG0_WDT_PAUSE_IN_SLP(value uint32) {
	volatile.StoreUint32(&o.WDTCONFIG0.Reg, volatile.LoadUint32(&o.WDTCONFIG0.Reg)&^(0x200)|value<<9)
}
func (o *RTC_CNTL_Type) GetWDTCONFIG0_WDT_PAUSE_IN_SLP() uint32 {
	return (volatile.LoadUint32(&o.WDTCONFIG0.Reg) & 0x200) >> 9
}
func (o *RTC_CNTL_Type) SetWDTCONFIG0_WDT_APPCPU_RESET_EN(value uint32) {
	volatile.StoreUint32(&o.WDTCONFIG0.Reg, volatile.LoadUint32(&o.WDTCONFIG0.Reg)&^(0x400)|value<<10)
}
func (o *RTC_CNTL_Type) GetWDTCONFIG0_WDT_APPCPU_RESET_EN() uint32 {
	return (volatile.LoadUint32(&o.WDTCONFIG0.Reg) & 0x400) >> 10
}
func (o *RTC_CNTL_Type) SetWDTCONFIG0_WDT_PROCPU_RESET_EN(value uint32) {
	volatile.StoreUint32(&o.WDTCONFIG0.Reg, volatile.LoadUint32(&o.WDTCONFIG0.Reg)&^(0x800)|value<<11)
}
func (o *RTC_CNTL_Type) GetWDTCONFIG0_WDT_PROCPU_RESET_EN() uint32 {
	return (volatile.LoadUint32(&o.WDTCONFIG0.Reg) & 0x800) >> 11
}
func (o *RTC_CNTL_Type) SetWDTCONFIG0_WDT_FLASHBOOT_MOD_EN(value uint32) {
	volatile.StoreUint32(&o.WDTCONFIG0.Reg, volatile.LoadUint32(&o.WDTCONFIG0.Reg)&^(0x1000)|value<<12)
}
func (o *RTC_CNTL_Type) GetWDTCONFIG0_WDT_FLASHBOOT_MOD_EN() uint32 {
	return (volatile.LoadUint32(&o.WDTCONFIG0.Reg) & 0x1000) >> 12
}
func (o *RTC_CNTL_Type) SetWDTCONFIG0_WDT_SYS_RESET_LENGTH(value uint32) {
	volatile.StoreUint32(&o.WDTCONFIG0.Reg, volatile.LoadUint32(&o.WDTCONFIG0.Reg)&^(0xe000)|value<<13)
}
func (o *RTC_CNTL_Type) GetWDTCONFIG0_WDT_SYS_RESET_LENGTH() uint32 {
	return (volatile.LoadUint32(&o.WDTCONFIG0.Reg) & 0xe000) >> 13
}
func (o *RTC_CNTL_Type) SetWDTCONFIG0_WDT_CPU_RESET_LENGTH(value uint32) {
	volatile.StoreUint32(&o.WDTCONFIG0.Reg, volatile.LoadUint32(&o.WDTCONFIG0.Reg)&^(0x70000)|value<<16)
}
func (o *RTC_CNTL_Type) GetWDTCONFIG0_WDT_CPU_RESET_LENGTH() uint32 {
	return (volatile.LoadUint32(&o.WDTCONFIG0.Reg) & 0x70000) >> 16
}
func (o *RTC_CNTL_Type) SetWDTCONFIG0_WDT_STG3(value uint32) {
	volatile.StoreUint32(&o.WDTCONFIG0.Reg, volatile.LoadUint32(&o.WDTCONFIG0.Reg)&^(0x380000)|value<<19)
}
func (o *RTC_CNTL_Type) GetWDTCONFIG0_WDT_STG3() uint32 {
	return (volatile.LoadUint32(&o.WDTCONFIG0.Reg) & 0x380000) >> 19
}
func (o *RTC_CNTL_Type) SetWDTCONFIG0_WDT_STG2(value uint32) {
	volatile.StoreUint32(&o.WDTCONFIG0.Reg, volatile.LoadUint32(&o.WDTCONFIG0.Reg)&^(0x1c00000)|value<<22)
}
func (o *RTC_CNTL_Type) GetWDTCONFIG0_WDT_STG2() uint32 {
	return (volatile.LoadUint32(&o.WDTCONFIG0.Reg) & 0x1c00000) >> 22
}
func (o *RTC_CNTL_Type) SetWDTCONFIG0_WDT_STG1(value uint32) {
	volatile.StoreUint32(&o.WDTCONFIG0.Reg, volatile.LoadUint32(&o.WDTCONFIG0.Reg)&^(0xe000000)|value<<25)
}
func (o *RTC_CNTL_Type) GetWDTCONFIG0_WDT_STG1() uint32 {
	return (volatile.LoadUint32(&o.WDTCONFIG0.Reg) & 0xe000000) >> 25
}
func (o *RTC_CNTL_Type) SetWDTCONFIG0_WDT_STG0(value uint32) {
	volatile.StoreUint32(&o.WDTCONFIG0.Reg, volatile.LoadUint32(&o.WDTCONFIG0.Reg)&^(0x70000000)|value<<28)
}
func (o *RTC_CNTL_Type) GetWDTCONFIG0_WDT_STG0() uint32 {
	return (volatile.LoadUint32(&o.WDTCONFIG0.Reg) & 0x70000000) >> 28
}
func (o *RTC_CNTL_Type) SetWDTCONFIG0_WDT_EN(value uint32) {
	volatile.StoreUint32(&o.WDTCONFIG0.Reg, volatile.LoadUint32(&o.WDTCONFIG0.Reg)&^(0x80000000)|value<<31)
}
func (o *RTC_CNTL_Type) GetWDTCONFIG0_WDT_EN() uint32 {
	return (volatile.LoadUint32(&o.WDTCONFIG0.Reg) & 0x80000000) >> 31
}

// RTC_CNTL.WDTCONFIG1: Configures the hold time of RTC watchdog at level 1
func (o *RTC_CNTL_Type) SetWDTCONFIG1(value uint32) {
	volatile.StoreUint32(&o.WDTCONFIG1.Reg, value)
}
func (o *RTC_CNTL_Type) GetWDTCONFIG1() uint32 {
	return volatile.LoadUint32(&o.WDTCONFIG1.Reg)
}

// RTC_CNTL.WDTCONFIG2: Configures the hold time of RTC watchdog at level 2
func (o *RTC_CNTL_Type) SetWDTCONFIG2(value uint32) {
	volatile.StoreUint32(&o.WDTCONFIG2.Reg, value)
}
func (o *RTC_CNTL_Type) GetWDTCONFIG2() uint32 {
	return volatile.LoadUint32(&o.WDTCONFIG2.Reg)
}

// RTC_CNTL.WDTCONFIG3: Configures the hold time of RTC watchdog at level 3
func (o *RTC_CNTL_Type) SetWDTCONFIG3(value uint32) {
	volatile.StoreUint32(&o.WDTCONFIG3.Reg, value)
}
func (o *RTC_CNTL_Type) GetWDTCONFIG3() uint32 {
	return volatile.LoadUint32(&o.WDTCONFIG3.Reg)
}

// RTC_CNTL.WDTCONFIG4: Configures the hold time of RTC watchdog at level 4
func (o *RTC_CNTL_Type) SetWDTCONFIG4(value uint32) {
	volatile.StoreUint32(&o.WDTCONFIG4.Reg, value)
}
func (o *RTC_CNTL_Type) GetWDTCONFIG4() uint32 {
	return volatile.LoadUint32(&o.WDTCONFIG4.Reg)
}

// RTC_CNTL.WDTFEED: RTC watchdog SW feed configuration register
func (o *RTC_CNTL_Type) SetWDTFEED_WDT_FEED(value uint32) {
	volatile.StoreUint32(&o.WDTFEED.Reg, volatile.LoadUint32(&o.WDTFEED.Reg)&^(0x80000000)|value<<31)
}
func (o *RTC_CNTL_Type) GetWDTFEED_WDT_FEED() uint32 {
	return (volatile.LoadUint32(&o.WDTFEED.Reg) & 0x80000000) >> 31
}

// RTC_CNTL.WDTWPROTECT: RTC watchdog write protection configuration register
func (o *RTC_CNTL_Type) SetWDTWPROTECT(value uint32) {
	volatile.StoreUint32(&o.WDTWPROTECT.Reg, value)
}
func (o *RTC_CNTL_Type) GetWDTWPROTECT() uint32 {
	return volatile.LoadUint32(&o.WDTWPROTECT.Reg)
}

// RTC_CNTL.SWD_CONF: Super watchdog configuration register
func (o *RTC_CNTL_Type) SetSWD_CONF_SWD_RESET_FLAG(value uint32) {
	volatile.StoreUint32(&o.SWD_CONF.Reg, volatile.LoadUint32(&o.SWD_CONF.Reg)&^(0x1)|value)
}
func (o *RTC_CNTL_Type) GetSWD_CONF_SWD_RESET_FLAG() uint32 {
	return volatile.LoadUint32(&o.SWD_CONF.Reg) & 0x1
}
func (o *RTC_CNTL_Type) SetSWD_CONF_SWD_FEED_INT(value uint32) {
	volatile.StoreUint32(&o.SWD_CONF.Reg, volatile.LoadUint32(&o.SWD_CONF.Reg)&^(0x2)|value<<1)
}
func (o *RTC_CNTL_Type) GetSWD_CONF_SWD_FEED_INT() uint32 {
	return (volatile.LoadUint32(&o.SWD_CONF.Reg) & 0x2) >> 1
}
func (o *RTC_CNTL_Type) SetSWD_CONF_SWD_SIGNAL_WIDTH(value uint32) {
	volatile.StoreUint32(&o.SWD_CONF.Reg, volatile.LoadUint32(&o.SWD_CONF.Reg)&^(0xffc0000)|value<<18)
}
func (o *RTC_CNTL_Type) GetSWD_CONF_SWD_SIGNAL_WIDTH() uint32 {
	return (volatile.LoadUint32(&o.SWD_CONF.Reg) & 0xffc0000) >> 18
}
func (o *RTC_CNTL_Type) SetSWD_CONF_SWD_RST_FLAG_CLR(value uint32) {
	volatile.StoreUint32(&o.SWD_CONF.Reg, volatile.LoadUint32(&o.SWD_CONF.Reg)&^(0x10000000)|value<<28)
}
func (o *RTC_CNTL_Type) GetSWD_CONF_SWD_RST_FLAG_CLR() uint32 {
	return (volatile.LoadUint32(&o.SWD_CONF.Reg) & 0x10000000) >> 28
}
func (o *RTC_CNTL_Type) SetSWD_CONF_SWD_FEED(value uint32) {
	volatile.StoreUint32(&o.SWD_CONF.Reg, volatile.LoadUint32(&o.SWD_CONF.Reg)&^(0x20000000)|value<<29)
}
func (o *RTC_CNTL_Type) GetSWD_CONF_SWD_FEED() uint32 {
	return (volatile.LoadUint32(&o.SWD_CONF.Reg) & 0x20000000) >> 29
}
func (o *RTC_CNTL_Type) SetSWD_CONF_SWD_DISABLE(value uint32) {
	volatile.StoreUint32(&o.SWD_CONF.Reg, volatile.LoadUint32(&o.SWD_CONF.Reg)&^(0x40000000)|value<<30)
}
func (o *RTC_CNTL_Type) GetSWD_CONF_SWD_DISABLE() uint32 {
	return (volatile.LoadUint32(&o.SWD_CONF.Reg) & 0x40000000) >> 30
}
func (o *RTC_CNTL_Type) SetSWD_CONF_SWD_AUTO_FEED_EN(value uint32) {
	volatile.StoreUint32(&o.SWD_CONF.Reg, volatile.LoadUint32(&o.SWD_CONF.Reg)&^(0x80000000)|value<<31)
}
func (o *RTC_CNTL_Type) GetSWD_CONF_SWD_AUTO_FEED_EN() uint32 {
	return (volatile.LoadUint32(&o.SWD_CONF.Reg) & 0x80000000) >> 31
}

// RTC_CNTL.SWD_WPROTECT: Super watchdog write protection configuration register
func (o *RTC_CNTL_Type) SetSWD_WPROTECT(value uint32) {
	volatile.StoreUint32(&o.SWD_WPROTECT.Reg, value)
}
func (o *RTC_CNTL_Type) GetSWD_WPROTECT() uint32 {
	return volatile.LoadUint32(&o.SWD_WPROTECT.Reg)
}

// RTC_CNTL.SW_CPU_STALL: CPU stall configuration register
func (o *RTC_CNTL_Type) SetSW_CPU_STALL_SW_STALL_APPCPU_C1(value uint32) {
	volatile.StoreUint32(&o.SW_CPU_STALL.Reg, volatile.LoadUint32(&o.SW_CPU_STALL.Reg)&^(0x3f00000)|value<<20)
}
func (o *RTC_CNTL_Type) GetSW_CPU_STALL_SW_STALL_APPCPU_C1() uint32 {
	return (volatile.LoadUint32(&o.SW_CPU_STALL.Reg) & 0x3f00000) >> 20
}
func (o *RTC_CNTL_Type) SetSW_CPU_STALL_SW_STALL_PROCPU_C1(value uint32) {
	volatile.StoreUint32(&o.SW_CPU_STALL.Reg, volatile.LoadUint32(&o.SW_CPU_STALL.Reg)&^(0xfc000000)|value<<26)
}
func (o *RTC_CNTL_Type) GetSW_CPU_STALL_SW_STALL_PROCPU_C1() uint32 {
	return (volatile.LoadUint32(&o.SW_CPU_STALL.Reg) & 0xfc000000) >> 26
}

// RTC_CNTL.STORE4: Reservation register 4
func (o *RTC_CNTL_Type) SetSTORE4(value uint32) {
	volatile.StoreUint32(&o.STORE4.Reg, value)
}
func (o *RTC_CNTL_Type) GetSTORE4() uint32 {
	return volatile.LoadUint32(&o.STORE4.Reg)
}

// RTC_CNTL.STORE5: Reservation register 5
func (o *RTC_CNTL_Type) SetSTORE5(value uint32) {
	volatile.StoreUint32(&o.STORE5.Reg, value)
}
func (o *RTC_CNTL_Type) GetSTORE5() uint32 {
	return volatile.LoadUint32(&o.STORE5.Reg)
}

// RTC_CNTL.STORE6: Reservation register 6
func (o *RTC_CNTL_Type) SetSTORE6(value uint32) {
	volatile.StoreUint32(&o.STORE6.Reg, value)
}
func (o *RTC_CNTL_Type) GetSTORE6() uint32 {
	return volatile.LoadUint32(&o.STORE6.Reg)
}

// RTC_CNTL.STORE7: Reservation register 7
func (o *RTC_CNTL_Type) SetSTORE7(value uint32) {
	volatile.StoreUint32(&o.STORE7.Reg, value)
}
func (o *RTC_CNTL_Type) GetSTORE7() uint32 {
	return volatile.LoadUint32(&o.STORE7.Reg)
}

// RTC_CNTL.LOW_POWER_ST: RTC main state machine status register
func (o *RTC_CNTL_Type) SetLOW_POWER_ST_XPD_ROM0(value uint32) {
	volatile.StoreUint32(&o.LOW_POWER_ST.Reg, volatile.LoadUint32(&o.LOW_POWER_ST.Reg)&^(0x1)|value)
}
func (o *RTC_CNTL_Type) GetLOW_POWER_ST_XPD_ROM0() uint32 {
	return volatile.LoadUint32(&o.LOW_POWER_ST.Reg) & 0x1
}
func (o *RTC_CNTL_Type) SetLOW_POWER_ST_XPD_DIG_DCDC(value uint32) {
	volatile.StoreUint32(&o.LOW_POWER_ST.Reg, volatile.LoadUint32(&o.LOW_POWER_ST.Reg)&^(0x4)|value<<2)
}
func (o *RTC_CNTL_Type) GetLOW_POWER_ST_XPD_DIG_DCDC() uint32 {
	return (volatile.LoadUint32(&o.LOW_POWER_ST.Reg) & 0x4) >> 2
}
func (o *RTC_CNTL_Type) SetLOW_POWER_ST_PERI_ISO(value uint32) {
	volatile.StoreUint32(&o.LOW_POWER_ST.Reg, volatile.LoadUint32(&o.LOW_POWER_ST.Reg)&^(0x8)|value<<3)
}
func (o *RTC_CNTL_Type) GetLOW_POWER_ST_PERI_ISO() uint32 {
	return (volatile.LoadUint32(&o.LOW_POWER_ST.Reg) & 0x8) >> 3
}
func (o *RTC_CNTL_Type) SetLOW_POWER_ST_XPD_RTC_PERI(value uint32) {
	volatile.StoreUint32(&o.LOW_POWER_ST.Reg, volatile.LoadUint32(&o.LOW_POWER_ST.Reg)&^(0x10)|value<<4)
}
func (o *RTC_CNTL_Type) GetLOW_POWER_ST_XPD_RTC_PERI() uint32 {
	return (volatile.LoadUint32(&o.LOW_POWER_ST.Reg) & 0x10) >> 4
}
func (o *RTC_CNTL_Type) SetLOW_POWER_ST_WIFI_ISO(value uint32) {
	volatile.StoreUint32(&o.LOW_POWER_ST.Reg, volatile.LoadUint32(&o.LOW_POWER_ST.Reg)&^(0x20)|value<<5)
}
func (o *RTC_CNTL_Type) GetLOW_POWER_ST_WIFI_ISO() uint32 {
	return (volatile.LoadUint32(&o.LOW_POWER_ST.Reg) & 0x20) >> 5
}
func (o *RTC_CNTL_Type) SetLOW_POWER_ST_XPD_WIFI(value uint32) {
	volatile.StoreUint32(&o.LOW_POWER_ST.Reg, volatile.LoadUint32(&o.LOW_POWER_ST.Reg)&^(0x40)|value<<6)
}
func (o *RTC_CNTL_Type) GetLOW_POWER_ST_XPD_WIFI() uint32 {
	return (volatile.LoadUint32(&o.LOW_POWER_ST.Reg) & 0x40) >> 6
}
func (o *RTC_CNTL_Type) SetLOW_POWER_ST_DIG_ISO(value uint32) {
	volatile.StoreUint32(&o.LOW_POWER_ST.Reg, volatile.LoadUint32(&o.LOW_POWER_ST.Reg)&^(0x80)|value<<7)
}
func (o *RTC_CNTL_Type) GetLOW_POWER_ST_DIG_ISO() uint32 {
	return (volatile.LoadUint32(&o.LOW_POWER_ST.Reg) & 0x80) >> 7
}
func (o *RTC_CNTL_Type) SetLOW_POWER_ST_XPD_DIG(value uint32) {
	volatile.StoreUint32(&o.LOW_POWER_ST.Reg, volatile.LoadUint32(&o.LOW_POWER_ST.Reg)&^(0x100)|value<<8)
}
func (o *RTC_CNTL_Type) GetLOW_POWER_ST_XPD_DIG() uint32 {
	return (volatile.LoadUint32(&o.LOW_POWER_ST.Reg) & 0x100) >> 8
}
func (o *RTC_CNTL_Type) SetLOW_POWER_ST_TOUCH_STATE_START(value uint32) {
	volatile.StoreUint32(&o.LOW_POWER_ST.Reg, volatile.LoadUint32(&o.LOW_POWER_ST.Reg)&^(0x200)|value<<9)
}
func (o *RTC_CNTL_Type) GetLOW_POWER_ST_TOUCH_STATE_START() uint32 {
	return (volatile.LoadUint32(&o.LOW_POWER_ST.Reg) & 0x200) >> 9
}
func (o *RTC_CNTL_Type) SetLOW_POWER_ST_TOUCH_STATE_SWITCH(value uint32) {
	volatile.StoreUint32(&o.LOW_POWER_ST.Reg, volatile.LoadUint32(&o.LOW_POWER_ST.Reg)&^(0x400)|value<<10)
}
func (o *RTC_CNTL_Type) GetLOW_POWER_ST_TOUCH_STATE_SWITCH() uint32 {
	return (volatile.LoadUint32(&o.LOW_POWER_ST.Reg) & 0x400) >> 10
}
func (o *RTC_CNTL_Type) SetLOW_POWER_ST_TOUCH_STATE_SLP(value uint32) {
	volatile.StoreUint32(&o.LOW_POWER_ST.Reg, volatile.LoadUint32(&o.LOW_POWER_ST.Reg)&^(0x800)|value<<11)
}
func (o *RTC_CNTL_Type) GetLOW_POWER_ST_TOUCH_STATE_SLP() uint32 {
	return (volatile.LoadUint32(&o.LOW_POWER_ST.Reg) & 0x800) >> 11
}
func (o *RTC_CNTL_Type) SetLOW_POWER_ST_TOUCH_STATE_DONE(value uint32) {
	volatile.StoreUint32(&o.LOW_POWER_ST.Reg, volatile.LoadUint32(&o.LOW_POWER_ST.Reg)&^(0x1000)|value<<12)
}
func (o *RTC_CNTL_Type) GetLOW_POWER_ST_TOUCH_STATE_DONE() uint32 {
	return (volatile.LoadUint32(&o.LOW_POWER_ST.Reg) & 0x1000) >> 12
}
func (o *RTC_CNTL_Type) SetLOW_POWER_ST_COCPU_STATE_START(value uint32) {
	volatile.StoreUint32(&o.LOW_POWER_ST.Reg, volatile.LoadUint32(&o.LOW_POWER_ST.Reg)&^(0x2000)|value<<13)
}
func (o *RTC_CNTL_Type) GetLOW_POWER_ST_COCPU_STATE_START() uint32 {
	return (volatile.LoadUint32(&o.LOW_POWER_ST.Reg) & 0x2000) >> 13
}
func (o *RTC_CNTL_Type) SetLOW_POWER_ST_COCPU_STATE_SWITCH(value uint32) {
	volatile.StoreUint32(&o.LOW_POWER_ST.Reg, volatile.LoadUint32(&o.LOW_POWER_ST.Reg)&^(0x4000)|value<<14)
}
func (o *RTC_CNTL_Type) GetLOW_POWER_ST_COCPU_STATE_SWITCH() uint32 {
	return (volatile.LoadUint32(&o.LOW_POWER_ST.Reg) & 0x4000) >> 14
}
func (o *RTC_CNTL_Type) SetLOW_POWER_ST_COCPU_STATE_SLP(value uint32) {
	volatile.StoreUint32(&o.LOW_POWER_ST.Reg, volatile.LoadUint32(&o.LOW_POWER_ST.Reg)&^(0x8000)|value<<15)
}
func (o *RTC_CNTL_Type) GetLOW_POWER_ST_COCPU_STATE_SLP() uint32 {
	return (volatile.LoadUint32(&o.LOW_POWER_ST.Reg) & 0x8000) >> 15
}
func (o *RTC_CNTL_Type) SetLOW_POWER_ST_COCPU_STATE_DONE(value uint32) {
	volatile.StoreUint32(&o.LOW_POWER_ST.Reg, volatile.LoadUint32(&o.LOW_POWER_ST.Reg)&^(0x10000)|value<<16)
}
func (o *RTC_CNTL_Type) GetLOW_POWER_ST_COCPU_STATE_DONE() uint32 {
	return (volatile.LoadUint32(&o.LOW_POWER_ST.Reg) & 0x10000) >> 16
}
func (o *RTC_CNTL_Type) SetLOW_POWER_ST_MAIN_STATE_XTAL_ISO(value uint32) {
	volatile.StoreUint32(&o.LOW_POWER_ST.Reg, volatile.LoadUint32(&o.LOW_POWER_ST.Reg)&^(0x20000)|value<<17)
}
func (o *RTC_CNTL_Type) GetLOW_POWER_ST_MAIN_STATE_XTAL_ISO() uint32 {
	return (volatile.LoadUint32(&o.LOW_POWER_ST.Reg) & 0x20000) >> 17
}
func (o *RTC_CNTL_Type) SetLOW_POWER_ST_MAIN_STATE_PLL_ON(value uint32) {
	volatile.StoreUint32(&o.LOW_POWER_ST.Reg, volatile.LoadUint32(&o.LOW_POWER_ST.Reg)&^(0x40000)|value<<18)
}
func (o *RTC_CNTL_Type) GetLOW_POWER_ST_MAIN_STATE_PLL_ON() uint32 {
	return (volatile.LoadUint32(&o.LOW_POWER_ST.Reg) & 0x40000) >> 18
}
func (o *RTC_CNTL_Type) SetLOW_POWER_ST_RDY_FOR_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.LOW_POWER_ST.Reg, volatile.LoadUint32(&o.LOW_POWER_ST.Reg)&^(0x80000)|value<<19)
}
func (o *RTC_CNTL_Type) GetLOW_POWER_ST_RDY_FOR_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.LOW_POWER_ST.Reg) & 0x80000) >> 19
}
func (o *RTC_CNTL_Type) SetLOW_POWER_ST_MAIN_STATE_WAIT_END(value uint32) {
	volatile.StoreUint32(&o.LOW_POWER_ST.Reg, volatile.LoadUint32(&o.LOW_POWER_ST.Reg)&^(0x100000)|value<<20)
}
func (o *RTC_CNTL_Type) GetLOW_POWER_ST_MAIN_STATE_WAIT_END() uint32 {
	return (volatile.LoadUint32(&o.LOW_POWER_ST.Reg) & 0x100000) >> 20
}
func (o *RTC_CNTL_Type) SetLOW_POWER_ST_IN_WAKEUP_STATE(value uint32) {
	volatile.StoreUint32(&o.LOW_POWER_ST.Reg, volatile.LoadUint32(&o.LOW_POWER_ST.Reg)&^(0x200000)|value<<21)
}
func (o *RTC_CNTL_Type) GetLOW_POWER_ST_IN_WAKEUP_STATE() uint32 {
	return (volatile.LoadUint32(&o.LOW_POWER_ST.Reg) & 0x200000) >> 21
}
func (o *RTC_CNTL_Type) SetLOW_POWER_ST_IN_LOW_POWER_STATE(value uint32) {
	volatile.StoreUint32(&o.LOW_POWER_ST.Reg, volatile.LoadUint32(&o.LOW_POWER_ST.Reg)&^(0x400000)|value<<22)
}
func (o *RTC_CNTL_Type) GetLOW_POWER_ST_IN_LOW_POWER_STATE() uint32 {
	return (volatile.LoadUint32(&o.LOW_POWER_ST.Reg) & 0x400000) >> 22
}
func (o *RTC_CNTL_Type) SetLOW_POWER_ST_MAIN_STATE_IN_WAIT_8M(value uint32) {
	volatile.StoreUint32(&o.LOW_POWER_ST.Reg, volatile.LoadUint32(&o.LOW_POWER_ST.Reg)&^(0x800000)|value<<23)
}
func (o *RTC_CNTL_Type) GetLOW_POWER_ST_MAIN_STATE_IN_WAIT_8M() uint32 {
	return (volatile.LoadUint32(&o.LOW_POWER_ST.Reg) & 0x800000) >> 23
}
func (o *RTC_CNTL_Type) SetLOW_POWER_ST_MAIN_STATE_IN_WAIT_PLL(value uint32) {
	volatile.StoreUint32(&o.LOW_POWER_ST.Reg, volatile.LoadUint32(&o.LOW_POWER_ST.Reg)&^(0x1000000)|value<<24)
}
func (o *RTC_CNTL_Type) GetLOW_POWER_ST_MAIN_STATE_IN_WAIT_PLL() uint32 {
	return (volatile.LoadUint32(&o.LOW_POWER_ST.Reg) & 0x1000000) >> 24
}
func (o *RTC_CNTL_Type) SetLOW_POWER_ST_MAIN_STATE_IN_WAIT_XTL(value uint32) {
	volatile.StoreUint32(&o.LOW_POWER_ST.Reg, volatile.LoadUint32(&o.LOW_POWER_ST.Reg)&^(0x2000000)|value<<25)
}
func (o *RTC_CNTL_Type) GetLOW_POWER_ST_MAIN_STATE_IN_WAIT_XTL() uint32 {
	return (volatile.LoadUint32(&o.LOW_POWER_ST.Reg) & 0x2000000) >> 25
}
func (o *RTC_CNTL_Type) SetLOW_POWER_ST_MAIN_STATE_IN_SLP(value uint32) {
	volatile.StoreUint32(&o.LOW_POWER_ST.Reg, volatile.LoadUint32(&o.LOW_POWER_ST.Reg)&^(0x4000000)|value<<26)
}
func (o *RTC_CNTL_Type) GetLOW_POWER_ST_MAIN_STATE_IN_SLP() uint32 {
	return (volatile.LoadUint32(&o.LOW_POWER_ST.Reg) & 0x4000000) >> 26
}
func (o *RTC_CNTL_Type) SetLOW_POWER_ST_MAIN_STATE_IN_IDLE(value uint32) {
	volatile.StoreUint32(&o.LOW_POWER_ST.Reg, volatile.LoadUint32(&o.LOW_POWER_ST.Reg)&^(0x8000000)|value<<27)
}
func (o *RTC_CNTL_Type) GetLOW_POWER_ST_MAIN_STATE_IN_IDLE() uint32 {
	return (volatile.LoadUint32(&o.LOW_POWER_ST.Reg) & 0x8000000) >> 27
}
func (o *RTC_CNTL_Type) SetLOW_POWER_ST_MAIN_STATE(value uint32) {
	volatile.StoreUint32(&o.LOW_POWER_ST.Reg, volatile.LoadUint32(&o.LOW_POWER_ST.Reg)&^(0xf0000000)|value<<28)
}
func (o *RTC_CNTL_Type) GetLOW_POWER_ST_MAIN_STATE() uint32 {
	return (volatile.LoadUint32(&o.LOW_POWER_ST.Reg) & 0xf0000000) >> 28
}

// RTC_CNTL.DIAG0: debug register
func (o *RTC_CNTL_Type) SetDIAG0(value uint32) {
	volatile.StoreUint32(&o.DIAG0.Reg, value)
}
func (o *RTC_CNTL_Type) GetDIAG0() uint32 {
	return volatile.LoadUint32(&o.DIAG0.Reg)
}

// RTC_CNTL.PAD_HOLD: Configures the hold options for RTC GPIOs
func (o *RTC_CNTL_Type) SetPAD_HOLD_TOUCH_PAD0_HOLD(value uint32) {
	volatile.StoreUint32(&o.PAD_HOLD.Reg, volatile.LoadUint32(&o.PAD_HOLD.Reg)&^(0x1)|value)
}
func (o *RTC_CNTL_Type) GetPAD_HOLD_TOUCH_PAD0_HOLD() uint32 {
	return volatile.LoadUint32(&o.PAD_HOLD.Reg) & 0x1
}
func (o *RTC_CNTL_Type) SetPAD_HOLD_TOUCH_PAD1_HOLD(value uint32) {
	volatile.StoreUint32(&o.PAD_HOLD.Reg, volatile.LoadUint32(&o.PAD_HOLD.Reg)&^(0x2)|value<<1)
}
func (o *RTC_CNTL_Type) GetPAD_HOLD_TOUCH_PAD1_HOLD() uint32 {
	return (volatile.LoadUint32(&o.PAD_HOLD.Reg) & 0x2) >> 1
}
func (o *RTC_CNTL_Type) SetPAD_HOLD_TOUCH_PAD2_HOLD(value uint32) {
	volatile.StoreUint32(&o.PAD_HOLD.Reg, volatile.LoadUint32(&o.PAD_HOLD.Reg)&^(0x4)|value<<2)
}
func (o *RTC_CNTL_Type) GetPAD_HOLD_TOUCH_PAD2_HOLD() uint32 {
	return (volatile.LoadUint32(&o.PAD_HOLD.Reg) & 0x4) >> 2
}
func (o *RTC_CNTL_Type) SetPAD_HOLD_TOUCH_PAD3_HOLD(value uint32) {
	volatile.StoreUint32(&o.PAD_HOLD.Reg, volatile.LoadUint32(&o.PAD_HOLD.Reg)&^(0x8)|value<<3)
}
func (o *RTC_CNTL_Type) GetPAD_HOLD_TOUCH_PAD3_HOLD() uint32 {
	return (volatile.LoadUint32(&o.PAD_HOLD.Reg) & 0x8) >> 3
}
func (o *RTC_CNTL_Type) SetPAD_HOLD_TOUCH_PAD4_HOLD(value uint32) {
	volatile.StoreUint32(&o.PAD_HOLD.Reg, volatile.LoadUint32(&o.PAD_HOLD.Reg)&^(0x10)|value<<4)
}
func (o *RTC_CNTL_Type) GetPAD_HOLD_TOUCH_PAD4_HOLD() uint32 {
	return (volatile.LoadUint32(&o.PAD_HOLD.Reg) & 0x10) >> 4
}
func (o *RTC_CNTL_Type) SetPAD_HOLD_TOUCH_PAD5_HOLD(value uint32) {
	volatile.StoreUint32(&o.PAD_HOLD.Reg, volatile.LoadUint32(&o.PAD_HOLD.Reg)&^(0x20)|value<<5)
}
func (o *RTC_CNTL_Type) GetPAD_HOLD_TOUCH_PAD5_HOLD() uint32 {
	return (volatile.LoadUint32(&o.PAD_HOLD.Reg) & 0x20) >> 5
}
func (o *RTC_CNTL_Type) SetPAD_HOLD_TOUCH_PAD6_HOLD(value uint32) {
	volatile.StoreUint32(&o.PAD_HOLD.Reg, volatile.LoadUint32(&o.PAD_HOLD.Reg)&^(0x40)|value<<6)
}
func (o *RTC_CNTL_Type) GetPAD_HOLD_TOUCH_PAD6_HOLD() uint32 {
	return (volatile.LoadUint32(&o.PAD_HOLD.Reg) & 0x40) >> 6
}
func (o *RTC_CNTL_Type) SetPAD_HOLD_TOUCH_PAD7_HOLD(value uint32) {
	volatile.StoreUint32(&o.PAD_HOLD.Reg, volatile.LoadUint32(&o.PAD_HOLD.Reg)&^(0x80)|value<<7)
}
func (o *RTC_CNTL_Type) GetPAD_HOLD_TOUCH_PAD7_HOLD() uint32 {
	return (volatile.LoadUint32(&o.PAD_HOLD.Reg) & 0x80) >> 7
}
func (o *RTC_CNTL_Type) SetPAD_HOLD_TOUCH_PAD8_HOLD(value uint32) {
	volatile.StoreUint32(&o.PAD_HOLD.Reg, volatile.LoadUint32(&o.PAD_HOLD.Reg)&^(0x100)|value<<8)
}
func (o *RTC_CNTL_Type) GetPAD_HOLD_TOUCH_PAD8_HOLD() uint32 {
	return (volatile.LoadUint32(&o.PAD_HOLD.Reg) & 0x100) >> 8
}
func (o *RTC_CNTL_Type) SetPAD_HOLD_TOUCH_PAD9_HOLD(value uint32) {
	volatile.StoreUint32(&o.PAD_HOLD.Reg, volatile.LoadUint32(&o.PAD_HOLD.Reg)&^(0x200)|value<<9)
}
func (o *RTC_CNTL_Type) GetPAD_HOLD_TOUCH_PAD9_HOLD() uint32 {
	return (volatile.LoadUint32(&o.PAD_HOLD.Reg) & 0x200) >> 9
}
func (o *RTC_CNTL_Type) SetPAD_HOLD_TOUCH_PAD10_HOLD(value uint32) {
	volatile.StoreUint32(&o.PAD_HOLD.Reg, volatile.LoadUint32(&o.PAD_HOLD.Reg)&^(0x400)|value<<10)
}
func (o *RTC_CNTL_Type) GetPAD_HOLD_TOUCH_PAD10_HOLD() uint32 {
	return (volatile.LoadUint32(&o.PAD_HOLD.Reg) & 0x400) >> 10
}
func (o *RTC_CNTL_Type) SetPAD_HOLD_TOUCH_PAD11_HOLD(value uint32) {
	volatile.StoreUint32(&o.PAD_HOLD.Reg, volatile.LoadUint32(&o.PAD_HOLD.Reg)&^(0x800)|value<<11)
}
func (o *RTC_CNTL_Type) GetPAD_HOLD_TOUCH_PAD11_HOLD() uint32 {
	return (volatile.LoadUint32(&o.PAD_HOLD.Reg) & 0x800) >> 11
}
func (o *RTC_CNTL_Type) SetPAD_HOLD_TOUCH_PAD12_HOLD(value uint32) {
	volatile.StoreUint32(&o.PAD_HOLD.Reg, volatile.LoadUint32(&o.PAD_HOLD.Reg)&^(0x1000)|value<<12)
}
func (o *RTC_CNTL_Type) GetPAD_HOLD_TOUCH_PAD12_HOLD() uint32 {
	return (volatile.LoadUint32(&o.PAD_HOLD.Reg) & 0x1000) >> 12
}
func (o *RTC_CNTL_Type) SetPAD_HOLD_TOUCH_PAD13_HOLD(value uint32) {
	volatile.StoreUint32(&o.PAD_HOLD.Reg, volatile.LoadUint32(&o.PAD_HOLD.Reg)&^(0x2000)|value<<13)
}
func (o *RTC_CNTL_Type) GetPAD_HOLD_TOUCH_PAD13_HOLD() uint32 {
	return (volatile.LoadUint32(&o.PAD_HOLD.Reg) & 0x2000) >> 13
}
func (o *RTC_CNTL_Type) SetPAD_HOLD_TOUCH_PAD14_HOLD(value uint32) {
	volatile.StoreUint32(&o.PAD_HOLD.Reg, volatile.LoadUint32(&o.PAD_HOLD.Reg)&^(0x4000)|value<<14)
}
func (o *RTC_CNTL_Type) GetPAD_HOLD_TOUCH_PAD14_HOLD() uint32 {
	return (volatile.LoadUint32(&o.PAD_HOLD.Reg) & 0x4000) >> 14
}
func (o *RTC_CNTL_Type) SetPAD_HOLD_X32P_HOLD(value uint32) {
	volatile.StoreUint32(&o.PAD_HOLD.Reg, volatile.LoadUint32(&o.PAD_HOLD.Reg)&^(0x8000)|value<<15)
}
func (o *RTC_CNTL_Type) GetPAD_HOLD_X32P_HOLD() uint32 {
	return (volatile.LoadUint32(&o.PAD_HOLD.Reg) & 0x8000) >> 15
}
func (o *RTC_CNTL_Type) SetPAD_HOLD_X32N_HOLD(value uint32) {
	volatile.StoreUint32(&o.PAD_HOLD.Reg, volatile.LoadUint32(&o.PAD_HOLD.Reg)&^(0x10000)|value<<16)
}
func (o *RTC_CNTL_Type) GetPAD_HOLD_X32N_HOLD() uint32 {
	return (volatile.LoadUint32(&o.PAD_HOLD.Reg) & 0x10000) >> 16
}
func (o *RTC_CNTL_Type) SetPAD_HOLD_PDAC1_HOLD(value uint32) {
	volatile.StoreUint32(&o.PAD_HOLD.Reg, volatile.LoadUint32(&o.PAD_HOLD.Reg)&^(0x20000)|value<<17)
}
func (o *RTC_CNTL_Type) GetPAD_HOLD_PDAC1_HOLD() uint32 {
	return (volatile.LoadUint32(&o.PAD_HOLD.Reg) & 0x20000) >> 17
}
func (o *RTC_CNTL_Type) SetPAD_HOLD_PDAC2_HOLD(value uint32) {
	volatile.StoreUint32(&o.PAD_HOLD.Reg, volatile.LoadUint32(&o.PAD_HOLD.Reg)&^(0x40000)|value<<18)
}
func (o *RTC_CNTL_Type) GetPAD_HOLD_PDAC2_HOLD() uint32 {
	return (volatile.LoadUint32(&o.PAD_HOLD.Reg) & 0x40000) >> 18
}
func (o *RTC_CNTL_Type) SetPAD_HOLD_PAD19_HOLD(value uint32) {
	volatile.StoreUint32(&o.PAD_HOLD.Reg, volatile.LoadUint32(&o.PAD_HOLD.Reg)&^(0x80000)|value<<19)
}
func (o *RTC_CNTL_Type) GetPAD_HOLD_PAD19_HOLD() uint32 {
	return (volatile.LoadUint32(&o.PAD_HOLD.Reg) & 0x80000) >> 19
}
func (o *RTC_CNTL_Type) SetPAD_HOLD_PAD20_HOLD(value uint32) {
	volatile.StoreUint32(&o.PAD_HOLD.Reg, volatile.LoadUint32(&o.PAD_HOLD.Reg)&^(0x100000)|value<<20)
}
func (o *RTC_CNTL_Type) GetPAD_HOLD_PAD20_HOLD() uint32 {
	return (volatile.LoadUint32(&o.PAD_HOLD.Reg) & 0x100000) >> 20
}
func (o *RTC_CNTL_Type) SetPAD_HOLD_PAD21_HOLD(value uint32) {
	volatile.StoreUint32(&o.PAD_HOLD.Reg, volatile.LoadUint32(&o.PAD_HOLD.Reg)&^(0x200000)|value<<21)
}
func (o *RTC_CNTL_Type) GetPAD_HOLD_PAD21_HOLD() uint32 {
	return (volatile.LoadUint32(&o.PAD_HOLD.Reg) & 0x200000) >> 21
}

// RTC_CNTL.DIG_PAD_HOLD: Configures the hold option for digital GPIOs
func (o *RTC_CNTL_Type) SetDIG_PAD_HOLD(value uint32) {
	volatile.StoreUint32(&o.DIG_PAD_HOLD.Reg, value)
}
func (o *RTC_CNTL_Type) GetDIG_PAD_HOLD() uint32 {
	return volatile.LoadUint32(&o.DIG_PAD_HOLD.Reg)
}

// RTC_CNTL.EXT_WAKEUP1: EXT1 wakeup configuration register
func (o *RTC_CNTL_Type) SetEXT_WAKEUP1_SEL(value uint32) {
	volatile.StoreUint32(&o.EXT_WAKEUP1.Reg, volatile.LoadUint32(&o.EXT_WAKEUP1.Reg)&^(0x3fffff)|value)
}
func (o *RTC_CNTL_Type) GetEXT_WAKEUP1_SEL() uint32 {
	return volatile.LoadUint32(&o.EXT_WAKEUP1.Reg) & 0x3fffff
}
func (o *RTC_CNTL_Type) SetEXT_WAKEUP1_STATUS_CLR(value uint32) {
	volatile.StoreUint32(&o.EXT_WAKEUP1.Reg, volatile.LoadUint32(&o.EXT_WAKEUP1.Reg)&^(0x400000)|value<<22)
}
func (o *RTC_CNTL_Type) GetEXT_WAKEUP1_STATUS_CLR() uint32 {
	return (volatile.LoadUint32(&o.EXT_WAKEUP1.Reg) & 0x400000) >> 22
}

// RTC_CNTL.EXT_WAKEUP1_STATUS: EXT1 wakeup source register
func (o *RTC_CNTL_Type) SetEXT_WAKEUP1_STATUS(value uint32) {
	volatile.StoreUint32(&o.EXT_WAKEUP1_STATUS.Reg, volatile.LoadUint32(&o.EXT_WAKEUP1_STATUS.Reg)&^(0x3fffff)|value)
}
func (o *RTC_CNTL_Type) GetEXT_WAKEUP1_STATUS() uint32 {
	return volatile.LoadUint32(&o.EXT_WAKEUP1_STATUS.Reg) & 0x3fffff
}

// RTC_CNTL.BROWN_OUT: Brownout configuration register
func (o *RTC_CNTL_Type) SetBROWN_OUT_BROWN_OUT2_ENA(value uint32) {
	volatile.StoreUint32(&o.BROWN_OUT.Reg, volatile.LoadUint32(&o.BROWN_OUT.Reg)&^(0x1)|value)
}
func (o *RTC_CNTL_Type) GetBROWN_OUT_BROWN_OUT2_ENA() uint32 {
	return volatile.LoadUint32(&o.BROWN_OUT.Reg) & 0x1
}
func (o *RTC_CNTL_Type) SetBROWN_OUT_INT_WAIT(value uint32) {
	volatile.StoreUint32(&o.BROWN_OUT.Reg, volatile.LoadUint32(&o.BROWN_OUT.Reg)&^(0x3ff0)|value<<4)
}
func (o *RTC_CNTL_Type) GetBROWN_OUT_INT_WAIT() uint32 {
	return (volatile.LoadUint32(&o.BROWN_OUT.Reg) & 0x3ff0) >> 4
}
func (o *RTC_CNTL_Type) SetBROWN_OUT_CLOSE_FLASH_ENA(value uint32) {
	volatile.StoreUint32(&o.BROWN_OUT.Reg, volatile.LoadUint32(&o.BROWN_OUT.Reg)&^(0x4000)|value<<14)
}
func (o *RTC_CNTL_Type) GetBROWN_OUT_CLOSE_FLASH_ENA() uint32 {
	return (volatile.LoadUint32(&o.BROWN_OUT.Reg) & 0x4000) >> 14
}
func (o *RTC_CNTL_Type) SetBROWN_OUT_PD_RF_ENA(value uint32) {
	volatile.StoreUint32(&o.BROWN_OUT.Reg, volatile.LoadUint32(&o.BROWN_OUT.Reg)&^(0x8000)|value<<15)
}
func (o *RTC_CNTL_Type) GetBROWN_OUT_PD_RF_ENA() uint32 {
	return (volatile.LoadUint32(&o.BROWN_OUT.Reg) & 0x8000) >> 15
}
func (o *RTC_CNTL_Type) SetBROWN_OUT_RST_WAIT(value uint32) {
	volatile.StoreUint32(&o.BROWN_OUT.Reg, volatile.LoadUint32(&o.BROWN_OUT.Reg)&^(0x3ff0000)|value<<16)
}
func (o *RTC_CNTL_Type) GetBROWN_OUT_RST_WAIT() uint32 {
	return (volatile.LoadUint32(&o.BROWN_OUT.Reg) & 0x3ff0000) >> 16
}
func (o *RTC_CNTL_Type) SetBROWN_OUT_RST_ENA(value uint32) {
	volatile.StoreUint32(&o.BROWN_OUT.Reg, volatile.LoadUint32(&o.BROWN_OUT.Reg)&^(0x4000000)|value<<26)
}
func (o *RTC_CNTL_Type) GetBROWN_OUT_RST_ENA() uint32 {
	return (volatile.LoadUint32(&o.BROWN_OUT.Reg) & 0x4000000) >> 26
}
func (o *RTC_CNTL_Type) SetBROWN_OUT_RST_SEL(value uint32) {
	volatile.StoreUint32(&o.BROWN_OUT.Reg, volatile.LoadUint32(&o.BROWN_OUT.Reg)&^(0x8000000)|value<<27)
}
func (o *RTC_CNTL_Type) GetBROWN_OUT_RST_SEL() uint32 {
	return (volatile.LoadUint32(&o.BROWN_OUT.Reg) & 0x8000000) >> 27
}
func (o *RTC_CNTL_Type) SetBROWN_OUT_CNT_CLR(value uint32) {
	volatile.StoreUint32(&o.BROWN_OUT.Reg, volatile.LoadUint32(&o.BROWN_OUT.Reg)&^(0x20000000)|value<<29)
}
func (o *RTC_CNTL_Type) GetBROWN_OUT_CNT_CLR() uint32 {
	return (volatile.LoadUint32(&o.BROWN_OUT.Reg) & 0x20000000) >> 29
}
func (o *RTC_CNTL_Type) SetBROWN_OUT_ENA(value uint32) {
	volatile.StoreUint32(&o.BROWN_OUT.Reg, volatile.LoadUint32(&o.BROWN_OUT.Reg)&^(0x40000000)|value<<30)
}
func (o *RTC_CNTL_Type) GetBROWN_OUT_ENA() uint32 {
	return (volatile.LoadUint32(&o.BROWN_OUT.Reg) & 0x40000000) >> 30
}
func (o *RTC_CNTL_Type) SetBROWN_OUT_DET(value uint32) {
	volatile.StoreUint32(&o.BROWN_OUT.Reg, volatile.LoadUint32(&o.BROWN_OUT.Reg)&^(0x80000000)|value<<31)
}
func (o *RTC_CNTL_Type) GetBROWN_OUT_DET() uint32 {
	return (volatile.LoadUint32(&o.BROWN_OUT.Reg) & 0x80000000) >> 31
}

// RTC_CNTL.TIME_LOW1: Stores the lower 32 bits of RTC timer 1
func (o *RTC_CNTL_Type) SetTIME_LOW1(value uint32) {
	volatile.StoreUint32(&o.TIME_LOW1.Reg, value)
}
func (o *RTC_CNTL_Type) GetTIME_LOW1() uint32 {
	return volatile.LoadUint32(&o.TIME_LOW1.Reg)
}

// RTC_CNTL.TIME_HIGH1: Stores the higher 16 bits of RTC timer 1
func (o *RTC_CNTL_Type) SetTIME_HIGH1_TIMER_VALUE1_HIGH(value uint32) {
	volatile.StoreUint32(&o.TIME_HIGH1.Reg, volatile.LoadUint32(&o.TIME_HIGH1.Reg)&^(0xffff)|value)
}
func (o *RTC_CNTL_Type) GetTIME_HIGH1_TIMER_VALUE1_HIGH() uint32 {
	return volatile.LoadUint32(&o.TIME_HIGH1.Reg) & 0xffff
}

// RTC_CNTL.XTAL32K_CLK_FACTOR: Configures the divider factor for the backup clock of 32 kHz crystal oscillator
func (o *RTC_CNTL_Type) SetXTAL32K_CLK_FACTOR(value uint32) {
	volatile.StoreUint32(&o.XTAL32K_CLK_FACTOR.Reg, value)
}
func (o *RTC_CNTL_Type) GetXTAL32K_CLK_FACTOR() uint32 {
	return volatile.LoadUint32(&o.XTAL32K_CLK_FACTOR.Reg)
}

// RTC_CNTL.XTAL32K_CONF: 32 kHz crystal oscillator configuration register
func (o *RTC_CNTL_Type) SetXTAL32K_CONF_XTAL32K_RETURN_WAIT(value uint32) {
	volatile.StoreUint32(&o.XTAL32K_CONF.Reg, volatile.LoadUint32(&o.XTAL32K_CONF.Reg)&^(0xf)|value)
}
func (o *RTC_CNTL_Type) GetXTAL32K_CONF_XTAL32K_RETURN_WAIT() uint32 {
	return volatile.LoadUint32(&o.XTAL32K_CONF.Reg) & 0xf
}
func (o *RTC_CNTL_Type) SetXTAL32K_CONF_XTAL32K_RESTART_WAIT(value uint32) {
	volatile.StoreUint32(&o.XTAL32K_CONF.Reg, volatile.LoadUint32(&o.XTAL32K_CONF.Reg)&^(0xffff0)|value<<4)
}
func (o *RTC_CNTL_Type) GetXTAL32K_CONF_XTAL32K_RESTART_WAIT() uint32 {
	return (volatile.LoadUint32(&o.XTAL32K_CONF.Reg) & 0xffff0) >> 4
}
func (o *RTC_CNTL_Type) SetXTAL32K_CONF_XTAL32K_WDT_TIMEOUT(value uint32) {
	volatile.StoreUint32(&o.XTAL32K_CONF.Reg, volatile.LoadUint32(&o.XTAL32K_CONF.Reg)&^(0xff00000)|value<<20)
}
func (o *RTC_CNTL_Type) GetXTAL32K_CONF_XTAL32K_WDT_TIMEOUT() uint32 {
	return (volatile.LoadUint32(&o.XTAL32K_CONF.Reg) & 0xff00000) >> 20
}
func (o *RTC_CNTL_Type) SetXTAL32K_CONF_XTAL32K_STABLE_THRES(value uint32) {
	volatile.StoreUint32(&o.XTAL32K_CONF.Reg, volatile.LoadUint32(&o.XTAL32K_CONF.Reg)&^(0xf0000000)|value<<28)
}
func (o *RTC_CNTL_Type) GetXTAL32K_CONF_XTAL32K_STABLE_THRES() uint32 {
	return (volatile.LoadUint32(&o.XTAL32K_CONF.Reg) & 0xf0000000) >> 28
}

// RTC_CNTL.ULP_CP_TIMER: Configure coprocessor timer
func (o *RTC_CNTL_Type) SetULP_CP_TIMER_ULP_CP_PC_INIT(value uint32) {
	volatile.StoreUint32(&o.ULP_CP_TIMER.Reg, volatile.LoadUint32(&o.ULP_CP_TIMER.Reg)&^(0x7ff)|value)
}
func (o *RTC_CNTL_Type) GetULP_CP_TIMER_ULP_CP_PC_INIT() uint32 {
	return volatile.LoadUint32(&o.ULP_CP_TIMER.Reg) & 0x7ff
}
func (o *RTC_CNTL_Type) SetULP_CP_TIMER_ULP_CP_GPIO_WAKEUP_ENA(value uint32) {
	volatile.StoreUint32(&o.ULP_CP_TIMER.Reg, volatile.LoadUint32(&o.ULP_CP_TIMER.Reg)&^(0x20000000)|value<<29)
}
func (o *RTC_CNTL_Type) GetULP_CP_TIMER_ULP_CP_GPIO_WAKEUP_ENA() uint32 {
	return (volatile.LoadUint32(&o.ULP_CP_TIMER.Reg) & 0x20000000) >> 29
}
func (o *RTC_CNTL_Type) SetULP_CP_TIMER_ULP_CP_GPIO_WAKEUP_CLR(value uint32) {
	volatile.StoreUint32(&o.ULP_CP_TIMER.Reg, volatile.LoadUint32(&o.ULP_CP_TIMER.Reg)&^(0x40000000)|value<<30)
}
func (o *RTC_CNTL_Type) GetULP_CP_TIMER_ULP_CP_GPIO_WAKEUP_CLR() uint32 {
	return (volatile.LoadUint32(&o.ULP_CP_TIMER.Reg) & 0x40000000) >> 30
}
func (o *RTC_CNTL_Type) SetULP_CP_TIMER_ULP_CP_SLP_TIMER_EN(value uint32) {
	volatile.StoreUint32(&o.ULP_CP_TIMER.Reg, volatile.LoadUint32(&o.ULP_CP_TIMER.Reg)&^(0x80000000)|value<<31)
}
func (o *RTC_CNTL_Type) GetULP_CP_TIMER_ULP_CP_SLP_TIMER_EN() uint32 {
	return (volatile.LoadUint32(&o.ULP_CP_TIMER.Reg) & 0x80000000) >> 31
}

// RTC_CNTL.ULP_CP_CTRL: ULP-FSM configuration register
func (o *RTC_CNTL_Type) SetULP_CP_CTRL_ULP_CP_MEM_ADDR_INIT(value uint32) {
	volatile.StoreUint32(&o.ULP_CP_CTRL.Reg, volatile.LoadUint32(&o.ULP_CP_CTRL.Reg)&^(0x7ff)|value)
}
func (o *RTC_CNTL_Type) GetULP_CP_CTRL_ULP_CP_MEM_ADDR_INIT() uint32 {
	return volatile.LoadUint32(&o.ULP_CP_CTRL.Reg) & 0x7ff
}
func (o *RTC_CNTL_Type) SetULP_CP_CTRL_ULP_CP_MEM_ADDR_SIZE(value uint32) {
	volatile.StoreUint32(&o.ULP_CP_CTRL.Reg, volatile.LoadUint32(&o.ULP_CP_CTRL.Reg)&^(0x3ff800)|value<<11)
}
func (o *RTC_CNTL_Type) GetULP_CP_CTRL_ULP_CP_MEM_ADDR_SIZE() uint32 {
	return (volatile.LoadUint32(&o.ULP_CP_CTRL.Reg) & 0x3ff800) >> 11
}
func (o *RTC_CNTL_Type) SetULP_CP_CTRL_ULP_CP_MEM_OFFSET_CLR(value uint32) {
	volatile.StoreUint32(&o.ULP_CP_CTRL.Reg, volatile.LoadUint32(&o.ULP_CP_CTRL.Reg)&^(0x400000)|value<<22)
}
func (o *RTC_CNTL_Type) GetULP_CP_CTRL_ULP_CP_MEM_OFFSET_CLR() uint32 {
	return (volatile.LoadUint32(&o.ULP_CP_CTRL.Reg) & 0x400000) >> 22
}
func (o *RTC_CNTL_Type) SetULP_CP_CTRL_ULP_CP_CLK_FO(value uint32) {
	volatile.StoreUint32(&o.ULP_CP_CTRL.Reg, volatile.LoadUint32(&o.ULP_CP_CTRL.Reg)&^(0x10000000)|value<<28)
}
func (o *RTC_CNTL_Type) GetULP_CP_CTRL_ULP_CP_CLK_FO() uint32 {
	return (volatile.LoadUint32(&o.ULP_CP_CTRL.Reg) & 0x10000000) >> 28
}
func (o *RTC_CNTL_Type) SetULP_CP_CTRL_ULP_CP_RESET(value uint32) {
	volatile.StoreUint32(&o.ULP_CP_CTRL.Reg, volatile.LoadUint32(&o.ULP_CP_CTRL.Reg)&^(0x20000000)|value<<29)
}
func (o *RTC_CNTL_Type) GetULP_CP_CTRL_ULP_CP_RESET() uint32 {
	return (volatile.LoadUint32(&o.ULP_CP_CTRL.Reg) & 0x20000000) >> 29
}
func (o *RTC_CNTL_Type) SetULP_CP_CTRL_ULP_CP_FORCE_START_TOP(value uint32) {
	volatile.StoreUint32(&o.ULP_CP_CTRL.Reg, volatile.LoadUint32(&o.ULP_CP_CTRL.Reg)&^(0x40000000)|value<<30)
}
func (o *RTC_CNTL_Type) GetULP_CP_CTRL_ULP_CP_FORCE_START_TOP() uint32 {
	return (volatile.LoadUint32(&o.ULP_CP_CTRL.Reg) & 0x40000000) >> 30
}
func (o *RTC_CNTL_Type) SetULP_CP_CTRL_ULP_CP_START_TOP(value uint32) {
	volatile.StoreUint32(&o.ULP_CP_CTRL.Reg, volatile.LoadUint32(&o.ULP_CP_CTRL.Reg)&^(0x80000000)|value<<31)
}
func (o *RTC_CNTL_Type) GetULP_CP_CTRL_ULP_CP_START_TOP() uint32 {
	return (volatile.LoadUint32(&o.ULP_CP_CTRL.Reg) & 0x80000000) >> 31
}

// RTC_CNTL.COCPU_CTRL: ULP-RISCV configuration register
func (o *RTC_CNTL_Type) SetCOCPU_CTRL_COCPU_CLK_FO(value uint32) {
	volatile.StoreUint32(&o.COCPU_CTRL.Reg, volatile.LoadUint32(&o.COCPU_CTRL.Reg)&^(0x1)|value)
}
func (o *RTC_CNTL_Type) GetCOCPU_CTRL_COCPU_CLK_FO() uint32 {
	return volatile.LoadUint32(&o.COCPU_CTRL.Reg) & 0x1
}
func (o *RTC_CNTL_Type) SetCOCPU_CTRL_COCPU_START_2_RESET_DIS(value uint32) {
	volatile.StoreUint32(&o.COCPU_CTRL.Reg, volatile.LoadUint32(&o.COCPU_CTRL.Reg)&^(0x7e)|value<<1)
}
func (o *RTC_CNTL_Type) GetCOCPU_CTRL_COCPU_START_2_RESET_DIS() uint32 {
	return (volatile.LoadUint32(&o.COCPU_CTRL.Reg) & 0x7e) >> 1
}
func (o *RTC_CNTL_Type) SetCOCPU_CTRL_COCPU_START_2_INTR_EN(value uint32) {
	volatile.StoreUint32(&o.COCPU_CTRL.Reg, volatile.LoadUint32(&o.COCPU_CTRL.Reg)&^(0x1f80)|value<<7)
}
func (o *RTC_CNTL_Type) GetCOCPU_CTRL_COCPU_START_2_INTR_EN() uint32 {
	return (volatile.LoadUint32(&o.COCPU_CTRL.Reg) & 0x1f80) >> 7
}
func (o *RTC_CNTL_Type) SetCOCPU_CTRL_COCPU_SHUT(value uint32) {
	volatile.StoreUint32(&o.COCPU_CTRL.Reg, volatile.LoadUint32(&o.COCPU_CTRL.Reg)&^(0x2000)|value<<13)
}
func (o *RTC_CNTL_Type) GetCOCPU_CTRL_COCPU_SHUT() uint32 {
	return (volatile.LoadUint32(&o.COCPU_CTRL.Reg) & 0x2000) >> 13
}
func (o *RTC_CNTL_Type) SetCOCPU_CTRL_COCPU_SHUT_2_CLK_DIS(value uint32) {
	volatile.StoreUint32(&o.COCPU_CTRL.Reg, volatile.LoadUint32(&o.COCPU_CTRL.Reg)&^(0x3fc000)|value<<14)
}
func (o *RTC_CNTL_Type) GetCOCPU_CTRL_COCPU_SHUT_2_CLK_DIS() uint32 {
	return (volatile.LoadUint32(&o.COCPU_CTRL.Reg) & 0x3fc000) >> 14
}
func (o *RTC_CNTL_Type) SetCOCPU_CTRL_COCPU_SHUT_RESET_EN(value uint32) {
	volatile.StoreUint32(&o.COCPU_CTRL.Reg, volatile.LoadUint32(&o.COCPU_CTRL.Reg)&^(0x400000)|value<<22)
}
func (o *RTC_CNTL_Type) GetCOCPU_CTRL_COCPU_SHUT_RESET_EN() uint32 {
	return (volatile.LoadUint32(&o.COCPU_CTRL.Reg) & 0x400000) >> 22
}
func (o *RTC_CNTL_Type) SetCOCPU_CTRL_COCPU_SEL(value uint32) {
	volatile.StoreUint32(&o.COCPU_CTRL.Reg, volatile.LoadUint32(&o.COCPU_CTRL.Reg)&^(0x800000)|value<<23)
}
func (o *RTC_CNTL_Type) GetCOCPU_CTRL_COCPU_SEL() uint32 {
	return (volatile.LoadUint32(&o.COCPU_CTRL.Reg) & 0x800000) >> 23
}
func (o *RTC_CNTL_Type) SetCOCPU_CTRL_COCPU_DONE_FORCE(value uint32) {
	volatile.StoreUint32(&o.COCPU_CTRL.Reg, volatile.LoadUint32(&o.COCPU_CTRL.Reg)&^(0x1000000)|value<<24)
}
func (o *RTC_CNTL_Type) GetCOCPU_CTRL_COCPU_DONE_FORCE() uint32 {
	return (volatile.LoadUint32(&o.COCPU_CTRL.Reg) & 0x1000000) >> 24
}
func (o *RTC_CNTL_Type) SetCOCPU_CTRL_COCPU_DONE(value uint32) {
	volatile.StoreUint32(&o.COCPU_CTRL.Reg, volatile.LoadUint32(&o.COCPU_CTRL.Reg)&^(0x2000000)|value<<25)
}
func (o *RTC_CNTL_Type) GetCOCPU_CTRL_COCPU_DONE() uint32 {
	return (volatile.LoadUint32(&o.COCPU_CTRL.Reg) & 0x2000000) >> 25
}
func (o *RTC_CNTL_Type) SetCOCPU_CTRL_COCPU_SW_INT_TRIGGER(value uint32) {
	volatile.StoreUint32(&o.COCPU_CTRL.Reg, volatile.LoadUint32(&o.COCPU_CTRL.Reg)&^(0x4000000)|value<<26)
}
func (o *RTC_CNTL_Type) GetCOCPU_CTRL_COCPU_SW_INT_TRIGGER() uint32 {
	return (volatile.LoadUint32(&o.COCPU_CTRL.Reg) & 0x4000000) >> 26
}

// RTC_CNTL.TOUCH_CTRL1: Touch control register
func (o *RTC_CNTL_Type) SetTOUCH_CTRL1_TOUCH_SLEEP_CYCLES(value uint32) {
	volatile.StoreUint32(&o.TOUCH_CTRL1.Reg, volatile.LoadUint32(&o.TOUCH_CTRL1.Reg)&^(0xffff)|value)
}
func (o *RTC_CNTL_Type) GetTOUCH_CTRL1_TOUCH_SLEEP_CYCLES() uint32 {
	return volatile.LoadUint32(&o.TOUCH_CTRL1.Reg) & 0xffff
}
func (o *RTC_CNTL_Type) SetTOUCH_CTRL1_TOUCH_MEAS_NUM(value uint32) {
	volatile.StoreUint32(&o.TOUCH_CTRL1.Reg, volatile.LoadUint32(&o.TOUCH_CTRL1.Reg)&^(0xffff0000)|value<<16)
}
func (o *RTC_CNTL_Type) GetTOUCH_CTRL1_TOUCH_MEAS_NUM() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_CTRL1.Reg) & 0xffff0000) >> 16
}

// RTC_CNTL.TOUCH_CTRL2: Touch control register
func (o *RTC_CNTL_Type) SetTOUCH_CTRL2_TOUCH_DRANGE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_CTRL2.Reg, volatile.LoadUint32(&o.TOUCH_CTRL2.Reg)&^(0xc)|value<<2)
}
func (o *RTC_CNTL_Type) GetTOUCH_CTRL2_TOUCH_DRANGE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_CTRL2.Reg) & 0xc) >> 2
}
func (o *RTC_CNTL_Type) SetTOUCH_CTRL2_TOUCH_DREFL(value uint32) {
	volatile.StoreUint32(&o.TOUCH_CTRL2.Reg, volatile.LoadUint32(&o.TOUCH_CTRL2.Reg)&^(0x30)|value<<4)
}
func (o *RTC_CNTL_Type) GetTOUCH_CTRL2_TOUCH_DREFL() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_CTRL2.Reg) & 0x30) >> 4
}
func (o *RTC_CNTL_Type) SetTOUCH_CTRL2_TOUCH_DREFH(value uint32) {
	volatile.StoreUint32(&o.TOUCH_CTRL2.Reg, volatile.LoadUint32(&o.TOUCH_CTRL2.Reg)&^(0xc0)|value<<6)
}
func (o *RTC_CNTL_Type) GetTOUCH_CTRL2_TOUCH_DREFH() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_CTRL2.Reg) & 0xc0) >> 6
}
func (o *RTC_CNTL_Type) SetTOUCH_CTRL2_TOUCH_XPD_BIAS(value uint32) {
	volatile.StoreUint32(&o.TOUCH_CTRL2.Reg, volatile.LoadUint32(&o.TOUCH_CTRL2.Reg)&^(0x100)|value<<8)
}
func (o *RTC_CNTL_Type) GetTOUCH_CTRL2_TOUCH_XPD_BIAS() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_CTRL2.Reg) & 0x100) >> 8
}
func (o *RTC_CNTL_Type) SetTOUCH_CTRL2_TOUCH_REFC(value uint32) {
	volatile.StoreUint32(&o.TOUCH_CTRL2.Reg, volatile.LoadUint32(&o.TOUCH_CTRL2.Reg)&^(0xe00)|value<<9)
}
func (o *RTC_CNTL_Type) GetTOUCH_CTRL2_TOUCH_REFC() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_CTRL2.Reg) & 0xe00) >> 9
}
func (o *RTC_CNTL_Type) SetTOUCH_CTRL2_TOUCH_DBIAS(value uint32) {
	volatile.StoreUint32(&o.TOUCH_CTRL2.Reg, volatile.LoadUint32(&o.TOUCH_CTRL2.Reg)&^(0x1000)|value<<12)
}
func (o *RTC_CNTL_Type) GetTOUCH_CTRL2_TOUCH_DBIAS() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_CTRL2.Reg) & 0x1000) >> 12
}
func (o *RTC_CNTL_Type) SetTOUCH_CTRL2_TOUCH_SLP_TIMER_EN(value uint32) {
	volatile.StoreUint32(&o.TOUCH_CTRL2.Reg, volatile.LoadUint32(&o.TOUCH_CTRL2.Reg)&^(0x2000)|value<<13)
}
func (o *RTC_CNTL_Type) GetTOUCH_CTRL2_TOUCH_SLP_TIMER_EN() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_CTRL2.Reg) & 0x2000) >> 13
}
func (o *RTC_CNTL_Type) SetTOUCH_CTRL2_TOUCH_START_FSM_EN(value uint32) {
	volatile.StoreUint32(&o.TOUCH_CTRL2.Reg, volatile.LoadUint32(&o.TOUCH_CTRL2.Reg)&^(0x4000)|value<<14)
}
func (o *RTC_CNTL_Type) GetTOUCH_CTRL2_TOUCH_START_FSM_EN() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_CTRL2.Reg) & 0x4000) >> 14
}
func (o *RTC_CNTL_Type) SetTOUCH_CTRL2_TOUCH_START_EN(value uint32) {
	volatile.StoreUint32(&o.TOUCH_CTRL2.Reg, volatile.LoadUint32(&o.TOUCH_CTRL2.Reg)&^(0x8000)|value<<15)
}
func (o *RTC_CNTL_Type) GetTOUCH_CTRL2_TOUCH_START_EN() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_CTRL2.Reg) & 0x8000) >> 15
}
func (o *RTC_CNTL_Type) SetTOUCH_CTRL2_TOUCH_START_FORCE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_CTRL2.Reg, volatile.LoadUint32(&o.TOUCH_CTRL2.Reg)&^(0x10000)|value<<16)
}
func (o *RTC_CNTL_Type) GetTOUCH_CTRL2_TOUCH_START_FORCE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_CTRL2.Reg) & 0x10000) >> 16
}
func (o *RTC_CNTL_Type) SetTOUCH_CTRL2_TOUCH_XPD_WAIT(value uint32) {
	volatile.StoreUint32(&o.TOUCH_CTRL2.Reg, volatile.LoadUint32(&o.TOUCH_CTRL2.Reg)&^(0x1fe0000)|value<<17)
}
func (o *RTC_CNTL_Type) GetTOUCH_CTRL2_TOUCH_XPD_WAIT() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_CTRL2.Reg) & 0x1fe0000) >> 17
}
func (o *RTC_CNTL_Type) SetTOUCH_CTRL2_TOUCH_SLP_CYC_DIV(value uint32) {
	volatile.StoreUint32(&o.TOUCH_CTRL2.Reg, volatile.LoadUint32(&o.TOUCH_CTRL2.Reg)&^(0x6000000)|value<<25)
}
func (o *RTC_CNTL_Type) GetTOUCH_CTRL2_TOUCH_SLP_CYC_DIV() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_CTRL2.Reg) & 0x6000000) >> 25
}
func (o *RTC_CNTL_Type) SetTOUCH_CTRL2_TOUCH_TIMER_FORCE_DONE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_CTRL2.Reg, volatile.LoadUint32(&o.TOUCH_CTRL2.Reg)&^(0x18000000)|value<<27)
}
func (o *RTC_CNTL_Type) GetTOUCH_CTRL2_TOUCH_TIMER_FORCE_DONE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_CTRL2.Reg) & 0x18000000) >> 27
}
func (o *RTC_CNTL_Type) SetTOUCH_CTRL2_TOUCH_RESET(value uint32) {
	volatile.StoreUint32(&o.TOUCH_CTRL2.Reg, volatile.LoadUint32(&o.TOUCH_CTRL2.Reg)&^(0x20000000)|value<<29)
}
func (o *RTC_CNTL_Type) GetTOUCH_CTRL2_TOUCH_RESET() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_CTRL2.Reg) & 0x20000000) >> 29
}
func (o *RTC_CNTL_Type) SetTOUCH_CTRL2_TOUCH_CLK_FO(value uint32) {
	volatile.StoreUint32(&o.TOUCH_CTRL2.Reg, volatile.LoadUint32(&o.TOUCH_CTRL2.Reg)&^(0x40000000)|value<<30)
}
func (o *RTC_CNTL_Type) GetTOUCH_CTRL2_TOUCH_CLK_FO() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_CTRL2.Reg) & 0x40000000) >> 30
}
func (o *RTC_CNTL_Type) SetTOUCH_CTRL2_TOUCH_CLKGATE_EN(value uint32) {
	volatile.StoreUint32(&o.TOUCH_CTRL2.Reg, volatile.LoadUint32(&o.TOUCH_CTRL2.Reg)&^(0x80000000)|value<<31)
}
func (o *RTC_CNTL_Type) GetTOUCH_CTRL2_TOUCH_CLKGATE_EN() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_CTRL2.Reg) & 0x80000000) >> 31
}

// RTC_CNTL.TOUCH_SCAN_CTRL: Configure touch scan settings
func (o *RTC_CNTL_Type) SetTOUCH_SCAN_CTRL_TOUCH_DENOISE_RES(value uint32) {
	volatile.StoreUint32(&o.TOUCH_SCAN_CTRL.Reg, volatile.LoadUint32(&o.TOUCH_SCAN_CTRL.Reg)&^(0x3)|value)
}
func (o *RTC_CNTL_Type) GetTOUCH_SCAN_CTRL_TOUCH_DENOISE_RES() uint32 {
	return volatile.LoadUint32(&o.TOUCH_SCAN_CTRL.Reg) & 0x3
}
func (o *RTC_CNTL_Type) SetTOUCH_SCAN_CTRL_TOUCH_DENOISE_EN(value uint32) {
	volatile.StoreUint32(&o.TOUCH_SCAN_CTRL.Reg, volatile.LoadUint32(&o.TOUCH_SCAN_CTRL.Reg)&^(0x4)|value<<2)
}
func (o *RTC_CNTL_Type) GetTOUCH_SCAN_CTRL_TOUCH_DENOISE_EN() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_SCAN_CTRL.Reg) & 0x4) >> 2
}
func (o *RTC_CNTL_Type) SetTOUCH_SCAN_CTRL_TOUCH_INACTIVE_CONNECTION(value uint32) {
	volatile.StoreUint32(&o.TOUCH_SCAN_CTRL.Reg, volatile.LoadUint32(&o.TOUCH_SCAN_CTRL.Reg)&^(0x100)|value<<8)
}
func (o *RTC_CNTL_Type) GetTOUCH_SCAN_CTRL_TOUCH_INACTIVE_CONNECTION() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_SCAN_CTRL.Reg) & 0x100) >> 8
}
func (o *RTC_CNTL_Type) SetTOUCH_SCAN_CTRL_TOUCH_SHIELD_PAD_EN(value uint32) {
	volatile.StoreUint32(&o.TOUCH_SCAN_CTRL.Reg, volatile.LoadUint32(&o.TOUCH_SCAN_CTRL.Reg)&^(0x200)|value<<9)
}
func (o *RTC_CNTL_Type) GetTOUCH_SCAN_CTRL_TOUCH_SHIELD_PAD_EN() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_SCAN_CTRL.Reg) & 0x200) >> 9
}
func (o *RTC_CNTL_Type) SetTOUCH_SCAN_CTRL_TOUCH_SCAN_PAD_MAP(value uint32) {
	volatile.StoreUint32(&o.TOUCH_SCAN_CTRL.Reg, volatile.LoadUint32(&o.TOUCH_SCAN_CTRL.Reg)&^(0x1fffc00)|value<<10)
}
func (o *RTC_CNTL_Type) GetTOUCH_SCAN_CTRL_TOUCH_SCAN_PAD_MAP() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_SCAN_CTRL.Reg) & 0x1fffc00) >> 10
}
func (o *RTC_CNTL_Type) SetTOUCH_SCAN_CTRL_TOUCH_BUFDRV(value uint32) {
	volatile.StoreUint32(&o.TOUCH_SCAN_CTRL.Reg, volatile.LoadUint32(&o.TOUCH_SCAN_CTRL.Reg)&^(0xe000000)|value<<25)
}
func (o *RTC_CNTL_Type) GetTOUCH_SCAN_CTRL_TOUCH_BUFDRV() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_SCAN_CTRL.Reg) & 0xe000000) >> 25
}
func (o *RTC_CNTL_Type) SetTOUCH_SCAN_CTRL_TOUCH_OUT_RING(value uint32) {
	volatile.StoreUint32(&o.TOUCH_SCAN_CTRL.Reg, volatile.LoadUint32(&o.TOUCH_SCAN_CTRL.Reg)&^(0xf0000000)|value<<28)
}
func (o *RTC_CNTL_Type) GetTOUCH_SCAN_CTRL_TOUCH_OUT_RING() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_SCAN_CTRL.Reg) & 0xf0000000) >> 28
}

// RTC_CNTL.TOUCH_SLP_THRES: Configure the settings of touch sleep pad
func (o *RTC_CNTL_Type) SetTOUCH_SLP_THRES_TOUCH_SLP_TH(value uint32) {
	volatile.StoreUint32(&o.TOUCH_SLP_THRES.Reg, volatile.LoadUint32(&o.TOUCH_SLP_THRES.Reg)&^(0x3fffff)|value)
}
func (o *RTC_CNTL_Type) GetTOUCH_SLP_THRES_TOUCH_SLP_TH() uint32 {
	return volatile.LoadUint32(&o.TOUCH_SLP_THRES.Reg) & 0x3fffff
}
func (o *RTC_CNTL_Type) SetTOUCH_SLP_THRES_TOUCH_SLP_APPROACH_EN(value uint32) {
	volatile.StoreUint32(&o.TOUCH_SLP_THRES.Reg, volatile.LoadUint32(&o.TOUCH_SLP_THRES.Reg)&^(0x4000000)|value<<26)
}
func (o *RTC_CNTL_Type) GetTOUCH_SLP_THRES_TOUCH_SLP_APPROACH_EN() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_SLP_THRES.Reg) & 0x4000000) >> 26
}
func (o *RTC_CNTL_Type) SetTOUCH_SLP_THRES_TOUCH_SLP_PAD(value uint32) {
	volatile.StoreUint32(&o.TOUCH_SLP_THRES.Reg, volatile.LoadUint32(&o.TOUCH_SLP_THRES.Reg)&^(0xf8000000)|value<<27)
}
func (o *RTC_CNTL_Type) GetTOUCH_SLP_THRES_TOUCH_SLP_PAD() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_SLP_THRES.Reg) & 0xf8000000) >> 27
}

// RTC_CNTL.TOUCH_APPROACH: Configure touch approach settings
func (o *RTC_CNTL_Type) SetTOUCH_APPROACH_TOUCH_SLP_CHANNEL_CLR(value uint32) {
	volatile.StoreUint32(&o.TOUCH_APPROACH.Reg, volatile.LoadUint32(&o.TOUCH_APPROACH.Reg)&^(0x800000)|value<<23)
}
func (o *RTC_CNTL_Type) GetTOUCH_APPROACH_TOUCH_SLP_CHANNEL_CLR() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_APPROACH.Reg) & 0x800000) >> 23
}
func (o *RTC_CNTL_Type) SetTOUCH_APPROACH_MEAS_TIME(value uint32) {
	volatile.StoreUint32(&o.TOUCH_APPROACH.Reg, volatile.LoadUint32(&o.TOUCH_APPROACH.Reg)&^(0xff000000)|value<<24)
}
func (o *RTC_CNTL_Type) GetTOUCH_APPROACH_MEAS_TIME() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_APPROACH.Reg) & 0xff000000) >> 24
}

// RTC_CNTL.TOUCH_FILTER_CTRL: Configure touch filter settings
func (o *RTC_CNTL_Type) SetTOUCH_FILTER_CTRL_TOUCH_SMOOTH_LVL(value uint32) {
	volatile.StoreUint32(&o.TOUCH_FILTER_CTRL.Reg, volatile.LoadUint32(&o.TOUCH_FILTER_CTRL.Reg)&^(0x600)|value<<9)
}
func (o *RTC_CNTL_Type) GetTOUCH_FILTER_CTRL_TOUCH_SMOOTH_LVL() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_FILTER_CTRL.Reg) & 0x600) >> 9
}
func (o *RTC_CNTL_Type) SetTOUCH_FILTER_CTRL_TOUCH_JITTER_STEP(value uint32) {
	volatile.StoreUint32(&o.TOUCH_FILTER_CTRL.Reg, volatile.LoadUint32(&o.TOUCH_FILTER_CTRL.Reg)&^(0x7800)|value<<11)
}
func (o *RTC_CNTL_Type) GetTOUCH_FILTER_CTRL_TOUCH_JITTER_STEP() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_FILTER_CTRL.Reg) & 0x7800) >> 11
}
func (o *RTC_CNTL_Type) SetTOUCH_FILTER_CTRL_TOUCH_NEG_NOISE_LIMIT(value uint32) {
	volatile.StoreUint32(&o.TOUCH_FILTER_CTRL.Reg, volatile.LoadUint32(&o.TOUCH_FILTER_CTRL.Reg)&^(0x78000)|value<<15)
}
func (o *RTC_CNTL_Type) GetTOUCH_FILTER_CTRL_TOUCH_NEG_NOISE_LIMIT() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_FILTER_CTRL.Reg) & 0x78000) >> 15
}
func (o *RTC_CNTL_Type) SetTOUCH_FILTER_CTRL_TOUCH_NEG_NOISE_THRES(value uint32) {
	volatile.StoreUint32(&o.TOUCH_FILTER_CTRL.Reg, volatile.LoadUint32(&o.TOUCH_FILTER_CTRL.Reg)&^(0x180000)|value<<19)
}
func (o *RTC_CNTL_Type) GetTOUCH_FILTER_CTRL_TOUCH_NEG_NOISE_THRES() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_FILTER_CTRL.Reg) & 0x180000) >> 19
}
func (o *RTC_CNTL_Type) SetTOUCH_FILTER_CTRL_TOUCH_NOISE_THRES(value uint32) {
	volatile.StoreUint32(&o.TOUCH_FILTER_CTRL.Reg, volatile.LoadUint32(&o.TOUCH_FILTER_CTRL.Reg)&^(0x600000)|value<<21)
}
func (o *RTC_CNTL_Type) GetTOUCH_FILTER_CTRL_TOUCH_NOISE_THRES() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_FILTER_CTRL.Reg) & 0x600000) >> 21
}
func (o *RTC_CNTL_Type) SetTOUCH_FILTER_CTRL_TOUCH_HYSTERESIS(value uint32) {
	volatile.StoreUint32(&o.TOUCH_FILTER_CTRL.Reg, volatile.LoadUint32(&o.TOUCH_FILTER_CTRL.Reg)&^(0x1800000)|value<<23)
}
func (o *RTC_CNTL_Type) GetTOUCH_FILTER_CTRL_TOUCH_HYSTERESIS() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_FILTER_CTRL.Reg) & 0x1800000) >> 23
}
func (o *RTC_CNTL_Type) SetTOUCH_FILTER_CTRL_TOUCH_DEBOUNCE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_FILTER_CTRL.Reg, volatile.LoadUint32(&o.TOUCH_FILTER_CTRL.Reg)&^(0xe000000)|value<<25)
}
func (o *RTC_CNTL_Type) GetTOUCH_FILTER_CTRL_TOUCH_DEBOUNCE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_FILTER_CTRL.Reg) & 0xe000000) >> 25
}
func (o *RTC_CNTL_Type) SetTOUCH_FILTER_CTRL_TOUCH_FILTER_MODE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_FILTER_CTRL.Reg, volatile.LoadUint32(&o.TOUCH_FILTER_CTRL.Reg)&^(0x70000000)|value<<28)
}
func (o *RTC_CNTL_Type) GetTOUCH_FILTER_CTRL_TOUCH_FILTER_MODE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_FILTER_CTRL.Reg) & 0x70000000) >> 28
}
func (o *RTC_CNTL_Type) SetTOUCH_FILTER_CTRL_TOUCH_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.TOUCH_FILTER_CTRL.Reg, volatile.LoadUint32(&o.TOUCH_FILTER_CTRL.Reg)&^(0x80000000)|value<<31)
}
func (o *RTC_CNTL_Type) GetTOUCH_FILTER_CTRL_TOUCH_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_FILTER_CTRL.Reg) & 0x80000000) >> 31
}

// RTC_CNTL.USB_CONF: configure usb control register
func (o *RTC_CNTL_Type) SetUSB_CONF_USB_VREFH(value uint32) {
	volatile.StoreUint32(&o.USB_CONF.Reg, volatile.LoadUint32(&o.USB_CONF.Reg)&^(0x3)|value)
}
func (o *RTC_CNTL_Type) GetUSB_CONF_USB_VREFH() uint32 {
	return volatile.LoadUint32(&o.USB_CONF.Reg) & 0x3
}
func (o *RTC_CNTL_Type) SetUSB_CONF_USB_VREFL(value uint32) {
	volatile.StoreUint32(&o.USB_CONF.Reg, volatile.LoadUint32(&o.USB_CONF.Reg)&^(0xc)|value<<2)
}
func (o *RTC_CNTL_Type) GetUSB_CONF_USB_VREFL() uint32 {
	return (volatile.LoadUint32(&o.USB_CONF.Reg) & 0xc) >> 2
}
func (o *RTC_CNTL_Type) SetUSB_CONF_USB_VREF_OVERRIDE(value uint32) {
	volatile.StoreUint32(&o.USB_CONF.Reg, volatile.LoadUint32(&o.USB_CONF.Reg)&^(0x10)|value<<4)
}
func (o *RTC_CNTL_Type) GetUSB_CONF_USB_VREF_OVERRIDE() uint32 {
	return (volatile.LoadUint32(&o.USB_CONF.Reg) & 0x10) >> 4
}
func (o *RTC_CNTL_Type) SetUSB_CONF_USB_PAD_PULL_OVERRIDE(value uint32) {
	volatile.StoreUint32(&o.USB_CONF.Reg, volatile.LoadUint32(&o.USB_CONF.Reg)&^(0x20)|value<<5)
}
func (o *RTC_CNTL_Type) GetUSB_CONF_USB_PAD_PULL_OVERRIDE() uint32 {
	return (volatile.LoadUint32(&o.USB_CONF.Reg) & 0x20) >> 5
}
func (o *RTC_CNTL_Type) SetUSB_CONF_USB_DP_PULLUP(value uint32) {
	volatile.StoreUint32(&o.USB_CONF.Reg, volatile.LoadUint32(&o.USB_CONF.Reg)&^(0x40)|value<<6)
}
func (o *RTC_CNTL_Type) GetUSB_CONF_USB_DP_PULLUP() uint32 {
	return (volatile.LoadUint32(&o.USB_CONF.Reg) & 0x40) >> 6
}
func (o *RTC_CNTL_Type) SetUSB_CONF_USB_DP_PULLDOWN(value uint32) {
	volatile.StoreUint32(&o.USB_CONF.Reg, volatile.LoadUint32(&o.USB_CONF.Reg)&^(0x80)|value<<7)
}
func (o *RTC_CNTL_Type) GetUSB_CONF_USB_DP_PULLDOWN() uint32 {
	return (volatile.LoadUint32(&o.USB_CONF.Reg) & 0x80) >> 7
}
func (o *RTC_CNTL_Type) SetUSB_CONF_USB_DM_PULLUP(value uint32) {
	volatile.StoreUint32(&o.USB_CONF.Reg, volatile.LoadUint32(&o.USB_CONF.Reg)&^(0x100)|value<<8)
}
func (o *RTC_CNTL_Type) GetUSB_CONF_USB_DM_PULLUP() uint32 {
	return (volatile.LoadUint32(&o.USB_CONF.Reg) & 0x100) >> 8
}
func (o *RTC_CNTL_Type) SetUSB_CONF_USB_DM_PULLDOWN(value uint32) {
	volatile.StoreUint32(&o.USB_CONF.Reg, volatile.LoadUint32(&o.USB_CONF.Reg)&^(0x200)|value<<9)
}
func (o *RTC_CNTL_Type) GetUSB_CONF_USB_DM_PULLDOWN() uint32 {
	return (volatile.LoadUint32(&o.USB_CONF.Reg) & 0x200) >> 9
}
func (o *RTC_CNTL_Type) SetUSB_CONF_USB_PULLUP_VALUE(value uint32) {
	volatile.StoreUint32(&o.USB_CONF.Reg, volatile.LoadUint32(&o.USB_CONF.Reg)&^(0x400)|value<<10)
}
func (o *RTC_CNTL_Type) GetUSB_CONF_USB_PULLUP_VALUE() uint32 {
	return (volatile.LoadUint32(&o.USB_CONF.Reg) & 0x400) >> 10
}
func (o *RTC_CNTL_Type) SetUSB_CONF_USB_PAD_ENABLE_OVERRIDE(value uint32) {
	volatile.StoreUint32(&o.USB_CONF.Reg, volatile.LoadUint32(&o.USB_CONF.Reg)&^(0x800)|value<<11)
}
func (o *RTC_CNTL_Type) GetUSB_CONF_USB_PAD_ENABLE_OVERRIDE() uint32 {
	return (volatile.LoadUint32(&o.USB_CONF.Reg) & 0x800) >> 11
}
func (o *RTC_CNTL_Type) SetUSB_CONF_USB_PAD_ENABLE(value uint32) {
	volatile.StoreUint32(&o.USB_CONF.Reg, volatile.LoadUint32(&o.USB_CONF.Reg)&^(0x1000)|value<<12)
}
func (o *RTC_CNTL_Type) GetUSB_CONF_USB_PAD_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.USB_CONF.Reg) & 0x1000) >> 12
}
func (o *RTC_CNTL_Type) SetUSB_CONF_USB_TXM(value uint32) {
	volatile.StoreUint32(&o.USB_CONF.Reg, volatile.LoadUint32(&o.USB_CONF.Reg)&^(0x2000)|value<<13)
}
func (o *RTC_CNTL_Type) GetUSB_CONF_USB_TXM() uint32 {
	return (volatile.LoadUint32(&o.USB_CONF.Reg) & 0x2000) >> 13
}
func (o *RTC_CNTL_Type) SetUSB_CONF_USB_TXP(value uint32) {
	volatile.StoreUint32(&o.USB_CONF.Reg, volatile.LoadUint32(&o.USB_CONF.Reg)&^(0x4000)|value<<14)
}
func (o *RTC_CNTL_Type) GetUSB_CONF_USB_TXP() uint32 {
	return (volatile.LoadUint32(&o.USB_CONF.Reg) & 0x4000) >> 14
}
func (o *RTC_CNTL_Type) SetUSB_CONF_USB_TX_EN(value uint32) {
	volatile.StoreUint32(&o.USB_CONF.Reg, volatile.LoadUint32(&o.USB_CONF.Reg)&^(0x8000)|value<<15)
}
func (o *RTC_CNTL_Type) GetUSB_CONF_USB_TX_EN() uint32 {
	return (volatile.LoadUint32(&o.USB_CONF.Reg) & 0x8000) >> 15
}
func (o *RTC_CNTL_Type) SetUSB_CONF_USB_TX_EN_OVERRIDE(value uint32) {
	volatile.StoreUint32(&o.USB_CONF.Reg, volatile.LoadUint32(&o.USB_CONF.Reg)&^(0x10000)|value<<16)
}
func (o *RTC_CNTL_Type) GetUSB_CONF_USB_TX_EN_OVERRIDE() uint32 {
	return (volatile.LoadUint32(&o.USB_CONF.Reg) & 0x10000) >> 16
}
func (o *RTC_CNTL_Type) SetUSB_CONF_USB_RESET_DISABLE(value uint32) {
	volatile.StoreUint32(&o.USB_CONF.Reg, volatile.LoadUint32(&o.USB_CONF.Reg)&^(0x20000)|value<<17)
}
func (o *RTC_CNTL_Type) GetUSB_CONF_USB_RESET_DISABLE() uint32 {
	return (volatile.LoadUint32(&o.USB_CONF.Reg) & 0x20000) >> 17
}
func (o *RTC_CNTL_Type) SetUSB_CONF_IO_MUX_RESET_DISABLE(value uint32) {
	volatile.StoreUint32(&o.USB_CONF.Reg, volatile.LoadUint32(&o.USB_CONF.Reg)&^(0x40000)|value<<18)
}
func (o *RTC_CNTL_Type) GetUSB_CONF_IO_MUX_RESET_DISABLE() uint32 {
	return (volatile.LoadUint32(&o.USB_CONF.Reg) & 0x40000) >> 18
}

// RTC_CNTL.TOUCH_TIMEOUT_CTRL: Configure touch timeout settings
func (o *RTC_CNTL_Type) SetTOUCH_TIMEOUT_CTRL_TOUCH_TIMEOUT_NUM(value uint32) {
	volatile.StoreUint32(&o.TOUCH_TIMEOUT_CTRL.Reg, volatile.LoadUint32(&o.TOUCH_TIMEOUT_CTRL.Reg)&^(0x3fffff)|value)
}
func (o *RTC_CNTL_Type) GetTOUCH_TIMEOUT_CTRL_TOUCH_TIMEOUT_NUM() uint32 {
	return volatile.LoadUint32(&o.TOUCH_TIMEOUT_CTRL.Reg) & 0x3fffff
}
func (o *RTC_CNTL_Type) SetTOUCH_TIMEOUT_CTRL_TOUCH_TIMEOUT_EN(value uint32) {
	volatile.StoreUint32(&o.TOUCH_TIMEOUT_CTRL.Reg, volatile.LoadUint32(&o.TOUCH_TIMEOUT_CTRL.Reg)&^(0x400000)|value<<22)
}
func (o *RTC_CNTL_Type) GetTOUCH_TIMEOUT_CTRL_TOUCH_TIMEOUT_EN() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_TIMEOUT_CTRL.Reg) & 0x400000) >> 22
}

// RTC_CNTL.SLP_REJECT_CAUSE: Stores the reject-to-sleep cause.
func (o *RTC_CNTL_Type) SetSLP_REJECT_CAUSE_REJECT_CAUSE(value uint32) {
	volatile.StoreUint32(&o.SLP_REJECT_CAUSE.Reg, volatile.LoadUint32(&o.SLP_REJECT_CAUSE.Reg)&^(0x1ffff)|value)
}
func (o *RTC_CNTL_Type) GetSLP_REJECT_CAUSE_REJECT_CAUSE() uint32 {
	return volatile.LoadUint32(&o.SLP_REJECT_CAUSE.Reg) & 0x1ffff
}

// RTC_CNTL.OPTIONS1: RTC option register
func (o *RTC_CNTL_Type) SetOPTIONS1_FORCE_DOWNLOAD_BOOT(value uint32) {
	volatile.StoreUint32(&o.OPTIONS1.Reg, volatile.LoadUint32(&o.OPTIONS1.Reg)&^(0x1)|value)
}
func (o *RTC_CNTL_Type) GetOPTIONS1_FORCE_DOWNLOAD_BOOT() uint32 {
	return volatile.LoadUint32(&o.OPTIONS1.Reg) & 0x1
}

// RTC_CNTL.SLP_WAKEUP_CAUSE: Stores the sleep-to-wakeup cause.
func (o *RTC_CNTL_Type) SetSLP_WAKEUP_CAUSE_WAKEUP_CAUSE(value uint32) {
	volatile.StoreUint32(&o.SLP_WAKEUP_CAUSE.Reg, volatile.LoadUint32(&o.SLP_WAKEUP_CAUSE.Reg)&^(0x1ffff)|value)
}
func (o *RTC_CNTL_Type) GetSLP_WAKEUP_CAUSE_WAKEUP_CAUSE() uint32 {
	return volatile.LoadUint32(&o.SLP_WAKEUP_CAUSE.Reg) & 0x1ffff
}

// RTC_CNTL.ULP_CP_TIMER_1: Configure sleep cycle of the timer
func (o *RTC_CNTL_Type) SetULP_CP_TIMER_1_ULP_CP_TIMER_SLP_CYCLE(value uint32) {
	volatile.StoreUint32(&o.ULP_CP_TIMER_1.Reg, volatile.LoadUint32(&o.ULP_CP_TIMER_1.Reg)&^(0xffffff00)|value<<8)
}
func (o *RTC_CNTL_Type) GetULP_CP_TIMER_1_ULP_CP_TIMER_SLP_CYCLE() uint32 {
	return (volatile.LoadUint32(&o.ULP_CP_TIMER_1.Reg) & 0xffffff00) >> 8
}

// RTC_CNTL.DATE
func (o *RTC_CNTL_Type) SetDATE_CNTL_DATE(value uint32) {
	volatile.StoreUint32(&o.DATE.Reg, volatile.LoadUint32(&o.DATE.Reg)&^(0xfffffff)|value)
}
func (o *RTC_CNTL_Type) GetDATE_CNTL_DATE() uint32 {
	return volatile.LoadUint32(&o.DATE.Reg) & 0xfffffff
}

// Peripheral SENS
type SENS_Type struct {
	SAR_READER1_CTRL   volatile.Register32 // 0x0
	SAR_READER1_STATUS volatile.Register32 // 0x4
	SAR_MEAS1_CTRL1    volatile.Register32 // 0x8
	SAR_MEAS1_CTRL2    volatile.Register32 // 0xC
	SAR_MEAS1_MUX      volatile.Register32 // 0x10
	SAR_ATTEN1         volatile.Register32 // 0x14
	SAR_AMP_CTRL1      volatile.Register32 // 0x18
	SAR_AMP_CTRL2      volatile.Register32 // 0x1C
	SAR_AMP_CTRL3      volatile.Register32 // 0x20
	SAR_READER2_CTRL   volatile.Register32 // 0x24
	SAR_READER2_STATUS volatile.Register32 // 0x28
	SAR_MEAS2_CTRL1    volatile.Register32 // 0x2C
	SAR_MEAS2_CTRL2    volatile.Register32 // 0x30
	SAR_MEAS2_MUX      volatile.Register32 // 0x34
	SAR_ATTEN2         volatile.Register32 // 0x38
	SAR_POWER_XPD_SAR  volatile.Register32 // 0x3C
	SAR_SLAVE_ADDR1    volatile.Register32 // 0x40
	SAR_SLAVE_ADDR2    volatile.Register32 // 0x44
	SAR_SLAVE_ADDR3    volatile.Register32 // 0x48
	SAR_SLAVE_ADDR4    volatile.Register32 // 0x4C
	SAR_TSENS_CTRL     volatile.Register32 // 0x50
	SAR_TSENS_CTRL2    volatile.Register32 // 0x54
	SAR_I2C_CTRL       volatile.Register32 // 0x58
	SAR_TOUCH_CONF     volatile.Register32 // 0x5C
	SAR_TOUCH_THRES1   volatile.Register32 // 0x60
	SAR_TOUCH_THRES2   volatile.Register32 // 0x64
	SAR_TOUCH_THRES3   volatile.Register32 // 0x68
	SAR_TOUCH_THRES4   volatile.Register32 // 0x6C
	SAR_TOUCH_THRES5   volatile.Register32 // 0x70
	SAR_TOUCH_THRES6   volatile.Register32 // 0x74
	SAR_TOUCH_THRES7   volatile.Register32 // 0x78
	SAR_TOUCH_THRES8   volatile.Register32 // 0x7C
	SAR_TOUCH_THRES9   volatile.Register32 // 0x80
	SAR_TOUCH_THRES10  volatile.Register32 // 0x84
	SAR_TOUCH_THRES11  volatile.Register32 // 0x88
	SAR_TOUCH_THRES12  volatile.Register32 // 0x8C
	SAR_TOUCH_THRES13  volatile.Register32 // 0x90
	SAR_TOUCH_THRES14  volatile.Register32 // 0x94
	_                  [60]byte
	SAR_TOUCH_CHN_ST   volatile.Register32 // 0xD4
	SAR_TOUCH_STATUS0  volatile.Register32 // 0xD8
	SAR_TOUCH_STATUS1  volatile.Register32 // 0xDC
	SAR_TOUCH_STATUS2  volatile.Register32 // 0xE0
	SAR_TOUCH_STATUS3  volatile.Register32 // 0xE4
	SAR_TOUCH_STATUS4  volatile.Register32 // 0xE8
	SAR_TOUCH_STATUS5  volatile.Register32 // 0xEC
	SAR_TOUCH_STATUS6  volatile.Register32 // 0xF0
	SAR_TOUCH_STATUS7  volatile.Register32 // 0xF4
	SAR_TOUCH_STATUS8  volatile.Register32 // 0xF8
	SAR_TOUCH_STATUS9  volatile.Register32 // 0xFC
	SAR_TOUCH_STATUS10 volatile.Register32 // 0x100
	SAR_TOUCH_STATUS11 volatile.Register32 // 0x104
	SAR_TOUCH_STATUS12 volatile.Register32 // 0x108
	SAR_TOUCH_STATUS13 volatile.Register32 // 0x10C
	SAR_TOUCH_STATUS14 volatile.Register32 // 0x110
	SAR_TOUCH_STATUS15 volatile.Register32 // 0x114
	SAR_TOUCH_STATUS16 volatile.Register32 // 0x118
	SAR_DAC_CTRL1      volatile.Register32 // 0x11C
	SAR_DAC_CTRL2      volatile.Register32 // 0x120
	SAR_COCPU_STATE    volatile.Register32 // 0x124
	SAR_COCPU_INT_RAW  volatile.Register32 // 0x128
	SAR_COCPU_INT_ENA  volatile.Register32 // 0x12C
	SAR_COCPU_INT_ST   volatile.Register32 // 0x130
	SAR_COCPU_INT_CLR  volatile.Register32 // 0x134
	SAR_COCPU_DEBUG    volatile.Register32 // 0x138
	SAR_HALL_CTRL      volatile.Register32 // 0x13C
	SAR_NOUSE          volatile.Register32 // 0x140
	SAR_IO_MUX_CONF    volatile.Register32 // 0x144
	SARDATE            volatile.Register32 // 0x148
}

// SENS.SAR_READER1_CTRL: RTC ADC1 data and sampling control
func (o *SENS_Type) SetSAR_READER1_CTRL_SAR1_CLK_DIV(value uint32) {
	volatile.StoreUint32(&o.SAR_READER1_CTRL.Reg, volatile.LoadUint32(&o.SAR_READER1_CTRL.Reg)&^(0xff)|value)
}
func (o *SENS_Type) GetSAR_READER1_CTRL_SAR1_CLK_DIV() uint32 {
	return volatile.LoadUint32(&o.SAR_READER1_CTRL.Reg) & 0xff
}
func (o *SENS_Type) SetSAR_READER1_CTRL_SAR1_CLK_GATED(value uint32) {
	volatile.StoreUint32(&o.SAR_READER1_CTRL.Reg, volatile.LoadUint32(&o.SAR_READER1_CTRL.Reg)&^(0x40000)|value<<18)
}
func (o *SENS_Type) GetSAR_READER1_CTRL_SAR1_CLK_GATED() uint32 {
	return (volatile.LoadUint32(&o.SAR_READER1_CTRL.Reg) & 0x40000) >> 18
}
func (o *SENS_Type) SetSAR_READER1_CTRL_SAR1_SAMPLE_NUM(value uint32) {
	volatile.StoreUint32(&o.SAR_READER1_CTRL.Reg, volatile.LoadUint32(&o.SAR_READER1_CTRL.Reg)&^(0x7f80000)|value<<19)
}
func (o *SENS_Type) GetSAR_READER1_CTRL_SAR1_SAMPLE_NUM() uint32 {
	return (volatile.LoadUint32(&o.SAR_READER1_CTRL.Reg) & 0x7f80000) >> 19
}
func (o *SENS_Type) SetSAR_READER1_CTRL_SAR1_DATA_INV(value uint32) {
	volatile.StoreUint32(&o.SAR_READER1_CTRL.Reg, volatile.LoadUint32(&o.SAR_READER1_CTRL.Reg)&^(0x10000000)|value<<28)
}
func (o *SENS_Type) GetSAR_READER1_CTRL_SAR1_DATA_INV() uint32 {
	return (volatile.LoadUint32(&o.SAR_READER1_CTRL.Reg) & 0x10000000) >> 28
}
func (o *SENS_Type) SetSAR_READER1_CTRL_SAR1_INT_EN(value uint32) {
	volatile.StoreUint32(&o.SAR_READER1_CTRL.Reg, volatile.LoadUint32(&o.SAR_READER1_CTRL.Reg)&^(0x20000000)|value<<29)
}
func (o *SENS_Type) GetSAR_READER1_CTRL_SAR1_INT_EN() uint32 {
	return (volatile.LoadUint32(&o.SAR_READER1_CTRL.Reg) & 0x20000000) >> 29
}

// SENS.SAR_READER1_STATUS: saradc1 status for debug
func (o *SENS_Type) SetSAR_READER1_STATUS(value uint32) {
	volatile.StoreUint32(&o.SAR_READER1_STATUS.Reg, value)
}
func (o *SENS_Type) GetSAR_READER1_STATUS() uint32 {
	return volatile.LoadUint32(&o.SAR_READER1_STATUS.Reg)
}

// SENS.SAR_MEAS1_CTRL1: Configure RTC ADC1 controller
func (o *SENS_Type) SetSAR_MEAS1_CTRL1_RTC_SARADC_RESET(value uint32) {
	volatile.StoreUint32(&o.SAR_MEAS1_CTRL1.Reg, volatile.LoadUint32(&o.SAR_MEAS1_CTRL1.Reg)&^(0x400000)|value<<22)
}
func (o *SENS_Type) GetSAR_MEAS1_CTRL1_RTC_SARADC_RESET() uint32 {
	return (volatile.LoadUint32(&o.SAR_MEAS1_CTRL1.Reg) & 0x400000) >> 22
}
func (o *SENS_Type) SetSAR_MEAS1_CTRL1_RTC_SARADC_CLKGATE_EN(value uint32) {
	volatile.StoreUint32(&o.SAR_MEAS1_CTRL1.Reg, volatile.LoadUint32(&o.SAR_MEAS1_CTRL1.Reg)&^(0x800000)|value<<23)
}
func (o *SENS_Type) GetSAR_MEAS1_CTRL1_RTC_SARADC_CLKGATE_EN() uint32 {
	return (volatile.LoadUint32(&o.SAR_MEAS1_CTRL1.Reg) & 0x800000) >> 23
}
func (o *SENS_Type) SetSAR_MEAS1_CTRL1_FORCE_XPD_AMP(value uint32) {
	volatile.StoreUint32(&o.SAR_MEAS1_CTRL1.Reg, volatile.LoadUint32(&o.SAR_MEAS1_CTRL1.Reg)&^(0x3000000)|value<<24)
}
func (o *SENS_Type) GetSAR_MEAS1_CTRL1_FORCE_XPD_AMP() uint32 {
	return (volatile.LoadUint32(&o.SAR_MEAS1_CTRL1.Reg) & 0x3000000) >> 24
}
func (o *SENS_Type) SetSAR_MEAS1_CTRL1_AMP_RST_FB_FORCE(value uint32) {
	volatile.StoreUint32(&o.SAR_MEAS1_CTRL1.Reg, volatile.LoadUint32(&o.SAR_MEAS1_CTRL1.Reg)&^(0xc000000)|value<<26)
}
func (o *SENS_Type) GetSAR_MEAS1_CTRL1_AMP_RST_FB_FORCE() uint32 {
	return (volatile.LoadUint32(&o.SAR_MEAS1_CTRL1.Reg) & 0xc000000) >> 26
}
func (o *SENS_Type) SetSAR_MEAS1_CTRL1_AMP_SHORT_REF_FORCE(value uint32) {
	volatile.StoreUint32(&o.SAR_MEAS1_CTRL1.Reg, volatile.LoadUint32(&o.SAR_MEAS1_CTRL1.Reg)&^(0x30000000)|value<<28)
}
func (o *SENS_Type) GetSAR_MEAS1_CTRL1_AMP_SHORT_REF_FORCE() uint32 {
	return (volatile.LoadUint32(&o.SAR_MEAS1_CTRL1.Reg) & 0x30000000) >> 28
}
func (o *SENS_Type) SetSAR_MEAS1_CTRL1_AMP_SHORT_REF_GND_FORCE(value uint32) {
	volatile.StoreUint32(&o.SAR_MEAS1_CTRL1.Reg, volatile.LoadUint32(&o.SAR_MEAS1_CTRL1.Reg)&^(0xc0000000)|value<<30)
}
func (o *SENS_Type) GetSAR_MEAS1_CTRL1_AMP_SHORT_REF_GND_FORCE() uint32 {
	return (volatile.LoadUint32(&o.SAR_MEAS1_CTRL1.Reg) & 0xc0000000) >> 30
}

// SENS.SAR_MEAS1_CTRL2: Control RTC ADC1 conversion and status
func (o *SENS_Type) SetSAR_MEAS1_CTRL2_MEAS1_DATA_SAR(value uint32) {
	volatile.StoreUint32(&o.SAR_MEAS1_CTRL2.Reg, volatile.LoadUint32(&o.SAR_MEAS1_CTRL2.Reg)&^(0xffff)|value)
}
func (o *SENS_Type) GetSAR_MEAS1_CTRL2_MEAS1_DATA_SAR() uint32 {
	return volatile.LoadUint32(&o.SAR_MEAS1_CTRL2.Reg) & 0xffff
}
func (o *SENS_Type) SetSAR_MEAS1_CTRL2_MEAS1_DONE_SAR(value uint32) {
	volatile.StoreUint32(&o.SAR_MEAS1_CTRL2.Reg, volatile.LoadUint32(&o.SAR_MEAS1_CTRL2.Reg)&^(0x10000)|value<<16)
}
func (o *SENS_Type) GetSAR_MEAS1_CTRL2_MEAS1_DONE_SAR() uint32 {
	return (volatile.LoadUint32(&o.SAR_MEAS1_CTRL2.Reg) & 0x10000) >> 16
}
func (o *SENS_Type) SetSAR_MEAS1_CTRL2_MEAS1_START_SAR(value uint32) {
	volatile.StoreUint32(&o.SAR_MEAS1_CTRL2.Reg, volatile.LoadUint32(&o.SAR_MEAS1_CTRL2.Reg)&^(0x20000)|value<<17)
}
func (o *SENS_Type) GetSAR_MEAS1_CTRL2_MEAS1_START_SAR() uint32 {
	return (volatile.LoadUint32(&o.SAR_MEAS1_CTRL2.Reg) & 0x20000) >> 17
}
func (o *SENS_Type) SetSAR_MEAS1_CTRL2_MEAS1_START_FORCE(value uint32) {
	volatile.StoreUint32(&o.SAR_MEAS1_CTRL2.Reg, volatile.LoadUint32(&o.SAR_MEAS1_CTRL2.Reg)&^(0x40000)|value<<18)
}
func (o *SENS_Type) GetSAR_MEAS1_CTRL2_MEAS1_START_FORCE() uint32 {
	return (volatile.LoadUint32(&o.SAR_MEAS1_CTRL2.Reg) & 0x40000) >> 18
}
func (o *SENS_Type) SetSAR_MEAS1_CTRL2_SAR1_EN_PAD(value uint32) {
	volatile.StoreUint32(&o.SAR_MEAS1_CTRL2.Reg, volatile.LoadUint32(&o.SAR_MEAS1_CTRL2.Reg)&^(0x7ff80000)|value<<19)
}
func (o *SENS_Type) GetSAR_MEAS1_CTRL2_SAR1_EN_PAD() uint32 {
	return (volatile.LoadUint32(&o.SAR_MEAS1_CTRL2.Reg) & 0x7ff80000) >> 19
}
func (o *SENS_Type) SetSAR_MEAS1_CTRL2_SAR1_EN_PAD_FORCE(value uint32) {
	volatile.StoreUint32(&o.SAR_MEAS1_CTRL2.Reg, volatile.LoadUint32(&o.SAR_MEAS1_CTRL2.Reg)&^(0x80000000)|value<<31)
}
func (o *SENS_Type) GetSAR_MEAS1_CTRL2_SAR1_EN_PAD_FORCE() uint32 {
	return (volatile.LoadUint32(&o.SAR_MEAS1_CTRL2.Reg) & 0x80000000) >> 31
}

// SENS.SAR_MEAS1_MUX: Select the controller for SAR ADC1
func (o *SENS_Type) SetSAR_MEAS1_MUX_SAR1_DIG_FORCE(value uint32) {
	volatile.StoreUint32(&o.SAR_MEAS1_MUX.Reg, volatile.LoadUint32(&o.SAR_MEAS1_MUX.Reg)&^(0x80000000)|value<<31)
}
func (o *SENS_Type) GetSAR_MEAS1_MUX_SAR1_DIG_FORCE() uint32 {
	return (volatile.LoadUint32(&o.SAR_MEAS1_MUX.Reg) & 0x80000000) >> 31
}

// SENS.SAR_ATTEN1: Configure SAR ADC1 attenuation
func (o *SENS_Type) SetSAR_ATTEN1(value uint32) {
	volatile.StoreUint32(&o.SAR_ATTEN1.Reg, value)
}
func (o *SENS_Type) GetSAR_ATTEN1() uint32 {
	return volatile.LoadUint32(&o.SAR_ATTEN1.Reg)
}

// SENS.SAR_AMP_CTRL1: AMP control
func (o *SENS_Type) SetSAR_AMP_CTRL1_SAR_AMP_WAIT1(value uint32) {
	volatile.StoreUint32(&o.SAR_AMP_CTRL1.Reg, volatile.LoadUint32(&o.SAR_AMP_CTRL1.Reg)&^(0xffff)|value)
}
func (o *SENS_Type) GetSAR_AMP_CTRL1_SAR_AMP_WAIT1() uint32 {
	return volatile.LoadUint32(&o.SAR_AMP_CTRL1.Reg) & 0xffff
}
func (o *SENS_Type) SetSAR_AMP_CTRL1_SAR_AMP_WAIT2(value uint32) {
	volatile.StoreUint32(&o.SAR_AMP_CTRL1.Reg, volatile.LoadUint32(&o.SAR_AMP_CTRL1.Reg)&^(0xffff0000)|value<<16)
}
func (o *SENS_Type) GetSAR_AMP_CTRL1_SAR_AMP_WAIT2() uint32 {
	return (volatile.LoadUint32(&o.SAR_AMP_CTRL1.Reg) & 0xffff0000) >> 16
}

// SENS.SAR_AMP_CTRL2: AMP control
func (o *SENS_Type) SetSAR_AMP_CTRL2_SAR1_DAC_XPD_FSM_IDLE(value uint32) {
	volatile.StoreUint32(&o.SAR_AMP_CTRL2.Reg, volatile.LoadUint32(&o.SAR_AMP_CTRL2.Reg)&^(0x1)|value)
}
func (o *SENS_Type) GetSAR_AMP_CTRL2_SAR1_DAC_XPD_FSM_IDLE() uint32 {
	return volatile.LoadUint32(&o.SAR_AMP_CTRL2.Reg) & 0x1
}
func (o *SENS_Type) SetSAR_AMP_CTRL2_XPD_SAR_AMP_FSM_IDLE(value uint32) {
	volatile.StoreUint32(&o.SAR_AMP_CTRL2.Reg, volatile.LoadUint32(&o.SAR_AMP_CTRL2.Reg)&^(0x2)|value<<1)
}
func (o *SENS_Type) GetSAR_AMP_CTRL2_XPD_SAR_AMP_FSM_IDLE() uint32 {
	return (volatile.LoadUint32(&o.SAR_AMP_CTRL2.Reg) & 0x2) >> 1
}
func (o *SENS_Type) SetSAR_AMP_CTRL2_AMP_RST_FB_FSM_IDLE(value uint32) {
	volatile.StoreUint32(&o.SAR_AMP_CTRL2.Reg, volatile.LoadUint32(&o.SAR_AMP_CTRL2.Reg)&^(0x4)|value<<2)
}
func (o *SENS_Type) GetSAR_AMP_CTRL2_AMP_RST_FB_FSM_IDLE() uint32 {
	return (volatile.LoadUint32(&o.SAR_AMP_CTRL2.Reg) & 0x4) >> 2
}
func (o *SENS_Type) SetSAR_AMP_CTRL2_AMP_SHORT_REF_FSM_IDLE(value uint32) {
	volatile.StoreUint32(&o.SAR_AMP_CTRL2.Reg, volatile.LoadUint32(&o.SAR_AMP_CTRL2.Reg)&^(0x8)|value<<3)
}
func (o *SENS_Type) GetSAR_AMP_CTRL2_AMP_SHORT_REF_FSM_IDLE() uint32 {
	return (volatile.LoadUint32(&o.SAR_AMP_CTRL2.Reg) & 0x8) >> 3
}
func (o *SENS_Type) SetSAR_AMP_CTRL2_AMP_SHORT_REF_GND_FSM_IDLE(value uint32) {
	volatile.StoreUint32(&o.SAR_AMP_CTRL2.Reg, volatile.LoadUint32(&o.SAR_AMP_CTRL2.Reg)&^(0x10)|value<<4)
}
func (o *SENS_Type) GetSAR_AMP_CTRL2_AMP_SHORT_REF_GND_FSM_IDLE() uint32 {
	return (volatile.LoadUint32(&o.SAR_AMP_CTRL2.Reg) & 0x10) >> 4
}
func (o *SENS_Type) SetSAR_AMP_CTRL2_XPD_SAR_FSM_IDLE(value uint32) {
	volatile.StoreUint32(&o.SAR_AMP_CTRL2.Reg, volatile.LoadUint32(&o.SAR_AMP_CTRL2.Reg)&^(0x20)|value<<5)
}
func (o *SENS_Type) GetSAR_AMP_CTRL2_XPD_SAR_FSM_IDLE() uint32 {
	return (volatile.LoadUint32(&o.SAR_AMP_CTRL2.Reg) & 0x20) >> 5
}
func (o *SENS_Type) SetSAR_AMP_CTRL2_SAR_RSTB_FSM_IDLE(value uint32) {
	volatile.StoreUint32(&o.SAR_AMP_CTRL2.Reg, volatile.LoadUint32(&o.SAR_AMP_CTRL2.Reg)&^(0x40)|value<<6)
}
func (o *SENS_Type) GetSAR_AMP_CTRL2_SAR_RSTB_FSM_IDLE() uint32 {
	return (volatile.LoadUint32(&o.SAR_AMP_CTRL2.Reg) & 0x40) >> 6
}
func (o *SENS_Type) SetSAR_AMP_CTRL2_SAR_AMP_WAIT3(value uint32) {
	volatile.StoreUint32(&o.SAR_AMP_CTRL2.Reg, volatile.LoadUint32(&o.SAR_AMP_CTRL2.Reg)&^(0xffff0000)|value<<16)
}
func (o *SENS_Type) GetSAR_AMP_CTRL2_SAR_AMP_WAIT3() uint32 {
	return (volatile.LoadUint32(&o.SAR_AMP_CTRL2.Reg) & 0xffff0000) >> 16
}

// SENS.SAR_AMP_CTRL3: AMP control register
func (o *SENS_Type) SetSAR_AMP_CTRL3_SAR1_DAC_XPD_FSM(value uint32) {
	volatile.StoreUint32(&o.SAR_AMP_CTRL3.Reg, volatile.LoadUint32(&o.SAR_AMP_CTRL3.Reg)&^(0xf)|value)
}
func (o *SENS_Type) GetSAR_AMP_CTRL3_SAR1_DAC_XPD_FSM() uint32 {
	return volatile.LoadUint32(&o.SAR_AMP_CTRL3.Reg) & 0xf
}
func (o *SENS_Type) SetSAR_AMP_CTRL3_XPD_SAR_AMP_FSM(value uint32) {
	volatile.StoreUint32(&o.SAR_AMP_CTRL3.Reg, volatile.LoadUint32(&o.SAR_AMP_CTRL3.Reg)&^(0xf0)|value<<4)
}
func (o *SENS_Type) GetSAR_AMP_CTRL3_XPD_SAR_AMP_FSM() uint32 {
	return (volatile.LoadUint32(&o.SAR_AMP_CTRL3.Reg) & 0xf0) >> 4
}
func (o *SENS_Type) SetSAR_AMP_CTRL3_AMP_RST_FB_FSM(value uint32) {
	volatile.StoreUint32(&o.SAR_AMP_CTRL3.Reg, volatile.LoadUint32(&o.SAR_AMP_CTRL3.Reg)&^(0xf00)|value<<8)
}
func (o *SENS_Type) GetSAR_AMP_CTRL3_AMP_RST_FB_FSM() uint32 {
	return (volatile.LoadUint32(&o.SAR_AMP_CTRL3.Reg) & 0xf00) >> 8
}
func (o *SENS_Type) SetSAR_AMP_CTRL3_AMP_SHORT_REF_FSM(value uint32) {
	volatile.StoreUint32(&o.SAR_AMP_CTRL3.Reg, volatile.LoadUint32(&o.SAR_AMP_CTRL3.Reg)&^(0xf000)|value<<12)
}
func (o *SENS_Type) GetSAR_AMP_CTRL3_AMP_SHORT_REF_FSM() uint32 {
	return (volatile.LoadUint32(&o.SAR_AMP_CTRL3.Reg) & 0xf000) >> 12
}
func (o *SENS_Type) SetSAR_AMP_CTRL3_AMP_SHORT_REF_GND_FSM(value uint32) {
	volatile.StoreUint32(&o.SAR_AMP_CTRL3.Reg, volatile.LoadUint32(&o.SAR_AMP_CTRL3.Reg)&^(0xf0000)|value<<16)
}
func (o *SENS_Type) GetSAR_AMP_CTRL3_AMP_SHORT_REF_GND_FSM() uint32 {
	return (volatile.LoadUint32(&o.SAR_AMP_CTRL3.Reg) & 0xf0000) >> 16
}
func (o *SENS_Type) SetSAR_AMP_CTRL3_XPD_SAR_FSM(value uint32) {
	volatile.StoreUint32(&o.SAR_AMP_CTRL3.Reg, volatile.LoadUint32(&o.SAR_AMP_CTRL3.Reg)&^(0xf00000)|value<<20)
}
func (o *SENS_Type) GetSAR_AMP_CTRL3_XPD_SAR_FSM() uint32 {
	return (volatile.LoadUint32(&o.SAR_AMP_CTRL3.Reg) & 0xf00000) >> 20
}
func (o *SENS_Type) SetSAR_AMP_CTRL3_SAR_RSTB_FSM(value uint32) {
	volatile.StoreUint32(&o.SAR_AMP_CTRL3.Reg, volatile.LoadUint32(&o.SAR_AMP_CTRL3.Reg)&^(0xf000000)|value<<24)
}
func (o *SENS_Type) GetSAR_AMP_CTRL3_SAR_RSTB_FSM() uint32 {
	return (volatile.LoadUint32(&o.SAR_AMP_CTRL3.Reg) & 0xf000000) >> 24
}

// SENS.SAR_READER2_CTRL: RTC ADC2 data and sampling control
func (o *SENS_Type) SetSAR_READER2_CTRL_SAR2_CLK_DIV(value uint32) {
	volatile.StoreUint32(&o.SAR_READER2_CTRL.Reg, volatile.LoadUint32(&o.SAR_READER2_CTRL.Reg)&^(0xff)|value)
}
func (o *SENS_Type) GetSAR_READER2_CTRL_SAR2_CLK_DIV() uint32 {
	return volatile.LoadUint32(&o.SAR_READER2_CTRL.Reg) & 0xff
}
func (o *SENS_Type) SetSAR_READER2_CTRL_SAR2_WAIT_ARB_CYCLE(value uint32) {
	volatile.StoreUint32(&o.SAR_READER2_CTRL.Reg, volatile.LoadUint32(&o.SAR_READER2_CTRL.Reg)&^(0x30000)|value<<16)
}
func (o *SENS_Type) GetSAR_READER2_CTRL_SAR2_WAIT_ARB_CYCLE() uint32 {
	return (volatile.LoadUint32(&o.SAR_READER2_CTRL.Reg) & 0x30000) >> 16
}
func (o *SENS_Type) SetSAR_READER2_CTRL_SAR2_CLK_GATED(value uint32) {
	volatile.StoreUint32(&o.SAR_READER2_CTRL.Reg, volatile.LoadUint32(&o.SAR_READER2_CTRL.Reg)&^(0x40000)|value<<18)
}
func (o *SENS_Type) GetSAR_READER2_CTRL_SAR2_CLK_GATED() uint32 {
	return (volatile.LoadUint32(&o.SAR_READER2_CTRL.Reg) & 0x40000) >> 18
}
func (o *SENS_Type) SetSAR_READER2_CTRL_SAR2_SAMPLE_NUM(value uint32) {
	volatile.StoreUint32(&o.SAR_READER2_CTRL.Reg, volatile.LoadUint32(&o.SAR_READER2_CTRL.Reg)&^(0x7f80000)|value<<19)
}
func (o *SENS_Type) GetSAR_READER2_CTRL_SAR2_SAMPLE_NUM() uint32 {
	return (volatile.LoadUint32(&o.SAR_READER2_CTRL.Reg) & 0x7f80000) >> 19
}
func (o *SENS_Type) SetSAR_READER2_CTRL_SAR2_DATA_INV(value uint32) {
	volatile.StoreUint32(&o.SAR_READER2_CTRL.Reg, volatile.LoadUint32(&o.SAR_READER2_CTRL.Reg)&^(0x20000000)|value<<29)
}
func (o *SENS_Type) GetSAR_READER2_CTRL_SAR2_DATA_INV() uint32 {
	return (volatile.LoadUint32(&o.SAR_READER2_CTRL.Reg) & 0x20000000) >> 29
}
func (o *SENS_Type) SetSAR_READER2_CTRL_SAR2_INT_EN(value uint32) {
	volatile.StoreUint32(&o.SAR_READER2_CTRL.Reg, volatile.LoadUint32(&o.SAR_READER2_CTRL.Reg)&^(0x40000000)|value<<30)
}
func (o *SENS_Type) GetSAR_READER2_CTRL_SAR2_INT_EN() uint32 {
	return (volatile.LoadUint32(&o.SAR_READER2_CTRL.Reg) & 0x40000000) >> 30
}

// SENS.SAR_READER2_STATUS: saradc2 status for debug
func (o *SENS_Type) SetSAR_READER2_STATUS(value uint32) {
	volatile.StoreUint32(&o.SAR_READER2_STATUS.Reg, value)
}
func (o *SENS_Type) GetSAR_READER2_STATUS() uint32 {
	return volatile.LoadUint32(&o.SAR_READER2_STATUS.Reg)
}

// SENS.SAR_MEAS2_CTRL1: configure rtc saradc2
func (o *SENS_Type) SetSAR_MEAS2_CTRL1_SAR2_CNTL_STATE(value uint32) {
	volatile.StoreUint32(&o.SAR_MEAS2_CTRL1.Reg, volatile.LoadUint32(&o.SAR_MEAS2_CTRL1.Reg)&^(0x7)|value)
}
func (o *SENS_Type) GetSAR_MEAS2_CTRL1_SAR2_CNTL_STATE() uint32 {
	return volatile.LoadUint32(&o.SAR_MEAS2_CTRL1.Reg) & 0x7
}
func (o *SENS_Type) SetSAR_MEAS2_CTRL1_SAR2_PWDET_CAL_EN(value uint32) {
	volatile.StoreUint32(&o.SAR_MEAS2_CTRL1.Reg, volatile.LoadUint32(&o.SAR_MEAS2_CTRL1.Reg)&^(0x8)|value<<3)
}
func (o *SENS_Type) GetSAR_MEAS2_CTRL1_SAR2_PWDET_CAL_EN() uint32 {
	return (volatile.LoadUint32(&o.SAR_MEAS2_CTRL1.Reg) & 0x8) >> 3
}
func (o *SENS_Type) SetSAR_MEAS2_CTRL1_SAR2_PKDET_CAL_EN(value uint32) {
	volatile.StoreUint32(&o.SAR_MEAS2_CTRL1.Reg, volatile.LoadUint32(&o.SAR_MEAS2_CTRL1.Reg)&^(0x10)|value<<4)
}
func (o *SENS_Type) GetSAR_MEAS2_CTRL1_SAR2_PKDET_CAL_EN() uint32 {
	return (volatile.LoadUint32(&o.SAR_MEAS2_CTRL1.Reg) & 0x10) >> 4
}
func (o *SENS_Type) SetSAR_MEAS2_CTRL1_SAR2_EN_TEST(value uint32) {
	volatile.StoreUint32(&o.SAR_MEAS2_CTRL1.Reg, volatile.LoadUint32(&o.SAR_MEAS2_CTRL1.Reg)&^(0x20)|value<<5)
}
func (o *SENS_Type) GetSAR_MEAS2_CTRL1_SAR2_EN_TEST() uint32 {
	return (volatile.LoadUint32(&o.SAR_MEAS2_CTRL1.Reg) & 0x20) >> 5
}
func (o *SENS_Type) SetSAR_MEAS2_CTRL1_SAR2_RSTB_FORCE(value uint32) {
	volatile.StoreUint32(&o.SAR_MEAS2_CTRL1.Reg, volatile.LoadUint32(&o.SAR_MEAS2_CTRL1.Reg)&^(0xc0)|value<<6)
}
func (o *SENS_Type) GetSAR_MEAS2_CTRL1_SAR2_RSTB_FORCE() uint32 {
	return (volatile.LoadUint32(&o.SAR_MEAS2_CTRL1.Reg) & 0xc0) >> 6
}
func (o *SENS_Type) SetSAR_MEAS2_CTRL1_SAR2_STANDBY_WAIT(value uint32) {
	volatile.StoreUint32(&o.SAR_MEAS2_CTRL1.Reg, volatile.LoadUint32(&o.SAR_MEAS2_CTRL1.Reg)&^(0xff00)|value<<8)
}
func (o *SENS_Type) GetSAR_MEAS2_CTRL1_SAR2_STANDBY_WAIT() uint32 {
	return (volatile.LoadUint32(&o.SAR_MEAS2_CTRL1.Reg) & 0xff00) >> 8
}
func (o *SENS_Type) SetSAR_MEAS2_CTRL1_SAR2_RSTB_WAIT(value uint32) {
	volatile.StoreUint32(&o.SAR_MEAS2_CTRL1.Reg, volatile.LoadUint32(&o.SAR_MEAS2_CTRL1.Reg)&^(0xff0000)|value<<16)
}
func (o *SENS_Type) GetSAR_MEAS2_CTRL1_SAR2_RSTB_WAIT() uint32 {
	return (volatile.LoadUint32(&o.SAR_MEAS2_CTRL1.Reg) & 0xff0000) >> 16
}
func (o *SENS_Type) SetSAR_MEAS2_CTRL1_SAR2_XPD_WAIT(value uint32) {
	volatile.StoreUint32(&o.SAR_MEAS2_CTRL1.Reg, volatile.LoadUint32(&o.SAR_MEAS2_CTRL1.Reg)&^(0xff000000)|value<<24)
}
func (o *SENS_Type) GetSAR_MEAS2_CTRL1_SAR2_XPD_WAIT() uint32 {
	return (volatile.LoadUint32(&o.SAR_MEAS2_CTRL1.Reg) & 0xff000000) >> 24
}

// SENS.SAR_MEAS2_CTRL2: Control RTC ADC2 conversion and status
func (o *SENS_Type) SetSAR_MEAS2_CTRL2_MEAS2_DATA_SAR(value uint32) {
	volatile.StoreUint32(&o.SAR_MEAS2_CTRL2.Reg, volatile.LoadUint32(&o.SAR_MEAS2_CTRL2.Reg)&^(0xffff)|value)
}
func (o *SENS_Type) GetSAR_MEAS2_CTRL2_MEAS2_DATA_SAR() uint32 {
	return volatile.LoadUint32(&o.SAR_MEAS2_CTRL2.Reg) & 0xffff
}
func (o *SENS_Type) SetSAR_MEAS2_CTRL2_MEAS2_DONE_SAR(value uint32) {
	volatile.StoreUint32(&o.SAR_MEAS2_CTRL2.Reg, volatile.LoadUint32(&o.SAR_MEAS2_CTRL2.Reg)&^(0x10000)|value<<16)
}
func (o *SENS_Type) GetSAR_MEAS2_CTRL2_MEAS2_DONE_SAR() uint32 {
	return (volatile.LoadUint32(&o.SAR_MEAS2_CTRL2.Reg) & 0x10000) >> 16
}
func (o *SENS_Type) SetSAR_MEAS2_CTRL2_MEAS2_START_SAR(value uint32) {
	volatile.StoreUint32(&o.SAR_MEAS2_CTRL2.Reg, volatile.LoadUint32(&o.SAR_MEAS2_CTRL2.Reg)&^(0x20000)|value<<17)
}
func (o *SENS_Type) GetSAR_MEAS2_CTRL2_MEAS2_START_SAR() uint32 {
	return (volatile.LoadUint32(&o.SAR_MEAS2_CTRL2.Reg) & 0x20000) >> 17
}
func (o *SENS_Type) SetSAR_MEAS2_CTRL2_MEAS2_START_FORCE(value uint32) {
	volatile.StoreUint32(&o.SAR_MEAS2_CTRL2.Reg, volatile.LoadUint32(&o.SAR_MEAS2_CTRL2.Reg)&^(0x40000)|value<<18)
}
func (o *SENS_Type) GetSAR_MEAS2_CTRL2_MEAS2_START_FORCE() uint32 {
	return (volatile.LoadUint32(&o.SAR_MEAS2_CTRL2.Reg) & 0x40000) >> 18
}
func (o *SENS_Type) SetSAR_MEAS2_CTRL2_SAR2_EN_PAD(value uint32) {
	volatile.StoreUint32(&o.SAR_MEAS2_CTRL2.Reg, volatile.LoadUint32(&o.SAR_MEAS2_CTRL2.Reg)&^(0x7ff80000)|value<<19)
}
func (o *SENS_Type) GetSAR_MEAS2_CTRL2_SAR2_EN_PAD() uint32 {
	return (volatile.LoadUint32(&o.SAR_MEAS2_CTRL2.Reg) & 0x7ff80000) >> 19
}
func (o *SENS_Type) SetSAR_MEAS2_CTRL2_SAR2_EN_PAD_FORCE(value uint32) {
	volatile.StoreUint32(&o.SAR_MEAS2_CTRL2.Reg, volatile.LoadUint32(&o.SAR_MEAS2_CTRL2.Reg)&^(0x80000000)|value<<31)
}
func (o *SENS_Type) GetSAR_MEAS2_CTRL2_SAR2_EN_PAD_FORCE() uint32 {
	return (volatile.LoadUint32(&o.SAR_MEAS2_CTRL2.Reg) & 0x80000000) >> 31
}

// SENS.SAR_MEAS2_MUX: Select the controller for SAR ADC2
func (o *SENS_Type) SetSAR_MEAS2_MUX_SAR2_PWDET_CCT(value uint32) {
	volatile.StoreUint32(&o.SAR_MEAS2_MUX.Reg, volatile.LoadUint32(&o.SAR_MEAS2_MUX.Reg)&^(0x70000000)|value<<28)
}
func (o *SENS_Type) GetSAR_MEAS2_MUX_SAR2_PWDET_CCT() uint32 {
	return (volatile.LoadUint32(&o.SAR_MEAS2_MUX.Reg) & 0x70000000) >> 28
}
func (o *SENS_Type) SetSAR_MEAS2_MUX_SAR2_RTC_FORCE(value uint32) {
	volatile.StoreUint32(&o.SAR_MEAS2_MUX.Reg, volatile.LoadUint32(&o.SAR_MEAS2_MUX.Reg)&^(0x80000000)|value<<31)
}
func (o *SENS_Type) GetSAR_MEAS2_MUX_SAR2_RTC_FORCE() uint32 {
	return (volatile.LoadUint32(&o.SAR_MEAS2_MUX.Reg) & 0x80000000) >> 31
}

// SENS.SAR_ATTEN2: Configure SAR ADC2 attenuation
func (o *SENS_Type) SetSAR_ATTEN2(value uint32) {
	volatile.StoreUint32(&o.SAR_ATTEN2.Reg, value)
}
func (o *SENS_Type) GetSAR_ATTEN2() uint32 {
	return volatile.LoadUint32(&o.SAR_ATTEN2.Reg)
}

// SENS.SAR_POWER_XPD_SAR: configure saradc’s power by sw
func (o *SENS_Type) SetSAR_POWER_XPD_SAR_FORCE_XPD_SAR(value uint32) {
	volatile.StoreUint32(&o.SAR_POWER_XPD_SAR.Reg, volatile.LoadUint32(&o.SAR_POWER_XPD_SAR.Reg)&^(0x60000000)|value<<29)
}
func (o *SENS_Type) GetSAR_POWER_XPD_SAR_FORCE_XPD_SAR() uint32 {
	return (volatile.LoadUint32(&o.SAR_POWER_XPD_SAR.Reg) & 0x60000000) >> 29
}
func (o *SENS_Type) SetSAR_POWER_XPD_SAR_SARCLK_EN(value uint32) {
	volatile.StoreUint32(&o.SAR_POWER_XPD_SAR.Reg, volatile.LoadUint32(&o.SAR_POWER_XPD_SAR.Reg)&^(0x80000000)|value<<31)
}
func (o *SENS_Type) GetSAR_POWER_XPD_SAR_SARCLK_EN() uint32 {
	return (volatile.LoadUint32(&o.SAR_POWER_XPD_SAR.Reg) & 0x80000000) >> 31
}

// SENS.SAR_SLAVE_ADDR1: Configure slave addresses 0-1 of RTC I2C
func (o *SENS_Type) SetSAR_SLAVE_ADDR1_I2C_SLAVE_ADDR1(value uint32) {
	volatile.StoreUint32(&o.SAR_SLAVE_ADDR1.Reg, volatile.LoadUint32(&o.SAR_SLAVE_ADDR1.Reg)&^(0x7ff)|value)
}
func (o *SENS_Type) GetSAR_SLAVE_ADDR1_I2C_SLAVE_ADDR1() uint32 {
	return volatile.LoadUint32(&o.SAR_SLAVE_ADDR1.Reg) & 0x7ff
}
func (o *SENS_Type) SetSAR_SLAVE_ADDR1_I2C_SLAVE_ADDR0(value uint32) {
	volatile.StoreUint32(&o.SAR_SLAVE_ADDR1.Reg, volatile.LoadUint32(&o.SAR_SLAVE_ADDR1.Reg)&^(0x3ff800)|value<<11)
}
func (o *SENS_Type) GetSAR_SLAVE_ADDR1_I2C_SLAVE_ADDR0() uint32 {
	return (volatile.LoadUint32(&o.SAR_SLAVE_ADDR1.Reg) & 0x3ff800) >> 11
}
func (o *SENS_Type) SetSAR_SLAVE_ADDR1_MEAS_STATUS(value uint32) {
	volatile.StoreUint32(&o.SAR_SLAVE_ADDR1.Reg, volatile.LoadUint32(&o.SAR_SLAVE_ADDR1.Reg)&^(0x3fc00000)|value<<22)
}
func (o *SENS_Type) GetSAR_SLAVE_ADDR1_MEAS_STATUS() uint32 {
	return (volatile.LoadUint32(&o.SAR_SLAVE_ADDR1.Reg) & 0x3fc00000) >> 22
}

// SENS.SAR_SLAVE_ADDR2: Configure slave addresses 2-3 of RTC I2C
func (o *SENS_Type) SetSAR_SLAVE_ADDR2_I2C_SLAVE_ADDR3(value uint32) {
	volatile.StoreUint32(&o.SAR_SLAVE_ADDR2.Reg, volatile.LoadUint32(&o.SAR_SLAVE_ADDR2.Reg)&^(0x7ff)|value)
}
func (o *SENS_Type) GetSAR_SLAVE_ADDR2_I2C_SLAVE_ADDR3() uint32 {
	return volatile.LoadUint32(&o.SAR_SLAVE_ADDR2.Reg) & 0x7ff
}
func (o *SENS_Type) SetSAR_SLAVE_ADDR2_I2C_SLAVE_ADDR2(value uint32) {
	volatile.StoreUint32(&o.SAR_SLAVE_ADDR2.Reg, volatile.LoadUint32(&o.SAR_SLAVE_ADDR2.Reg)&^(0x3ff800)|value<<11)
}
func (o *SENS_Type) GetSAR_SLAVE_ADDR2_I2C_SLAVE_ADDR2() uint32 {
	return (volatile.LoadUint32(&o.SAR_SLAVE_ADDR2.Reg) & 0x3ff800) >> 11
}

// SENS.SAR_SLAVE_ADDR3: Configure slave addresses 4-5 of RTC I2C
func (o *SENS_Type) SetSAR_SLAVE_ADDR3_I2C_SLAVE_ADDR5(value uint32) {
	volatile.StoreUint32(&o.SAR_SLAVE_ADDR3.Reg, volatile.LoadUint32(&o.SAR_SLAVE_ADDR3.Reg)&^(0x7ff)|value)
}
func (o *SENS_Type) GetSAR_SLAVE_ADDR3_I2C_SLAVE_ADDR5() uint32 {
	return volatile.LoadUint32(&o.SAR_SLAVE_ADDR3.Reg) & 0x7ff
}
func (o *SENS_Type) SetSAR_SLAVE_ADDR3_I2C_SLAVE_ADDR4(value uint32) {
	volatile.StoreUint32(&o.SAR_SLAVE_ADDR3.Reg, volatile.LoadUint32(&o.SAR_SLAVE_ADDR3.Reg)&^(0x3ff800)|value<<11)
}
func (o *SENS_Type) GetSAR_SLAVE_ADDR3_I2C_SLAVE_ADDR4() uint32 {
	return (volatile.LoadUint32(&o.SAR_SLAVE_ADDR3.Reg) & 0x3ff800) >> 11
}

// SENS.SAR_SLAVE_ADDR4: Configure slave addresses 6-7 of RTC I2C
func (o *SENS_Type) SetSAR_SLAVE_ADDR4_I2C_SLAVE_ADDR7(value uint32) {
	volatile.StoreUint32(&o.SAR_SLAVE_ADDR4.Reg, volatile.LoadUint32(&o.SAR_SLAVE_ADDR4.Reg)&^(0x7ff)|value)
}
func (o *SENS_Type) GetSAR_SLAVE_ADDR4_I2C_SLAVE_ADDR7() uint32 {
	return volatile.LoadUint32(&o.SAR_SLAVE_ADDR4.Reg) & 0x7ff
}
func (o *SENS_Type) SetSAR_SLAVE_ADDR4_I2C_SLAVE_ADDR6(value uint32) {
	volatile.StoreUint32(&o.SAR_SLAVE_ADDR4.Reg, volatile.LoadUint32(&o.SAR_SLAVE_ADDR4.Reg)&^(0x3ff800)|value<<11)
}
func (o *SENS_Type) GetSAR_SLAVE_ADDR4_I2C_SLAVE_ADDR6() uint32 {
	return (volatile.LoadUint32(&o.SAR_SLAVE_ADDR4.Reg) & 0x3ff800) >> 11
}

// SENS.SAR_TSENS_CTRL: Temperature sensor data control
func (o *SENS_Type) SetSAR_TSENS_CTRL_TSENS_OUT(value uint32) {
	volatile.StoreUint32(&o.SAR_TSENS_CTRL.Reg, volatile.LoadUint32(&o.SAR_TSENS_CTRL.Reg)&^(0xff)|value)
}
func (o *SENS_Type) GetSAR_TSENS_CTRL_TSENS_OUT() uint32 {
	return volatile.LoadUint32(&o.SAR_TSENS_CTRL.Reg) & 0xff
}
func (o *SENS_Type) SetSAR_TSENS_CTRL_TSENS_READY(value uint32) {
	volatile.StoreUint32(&o.SAR_TSENS_CTRL.Reg, volatile.LoadUint32(&o.SAR_TSENS_CTRL.Reg)&^(0x100)|value<<8)
}
func (o *SENS_Type) GetSAR_TSENS_CTRL_TSENS_READY() uint32 {
	return (volatile.LoadUint32(&o.SAR_TSENS_CTRL.Reg) & 0x100) >> 8
}
func (o *SENS_Type) SetSAR_TSENS_CTRL_TSENS_INT_EN(value uint32) {
	volatile.StoreUint32(&o.SAR_TSENS_CTRL.Reg, volatile.LoadUint32(&o.SAR_TSENS_CTRL.Reg)&^(0x1000)|value<<12)
}
func (o *SENS_Type) GetSAR_TSENS_CTRL_TSENS_INT_EN() uint32 {
	return (volatile.LoadUint32(&o.SAR_TSENS_CTRL.Reg) & 0x1000) >> 12
}
func (o *SENS_Type) SetSAR_TSENS_CTRL_TSENS_IN_INV(value uint32) {
	volatile.StoreUint32(&o.SAR_TSENS_CTRL.Reg, volatile.LoadUint32(&o.SAR_TSENS_CTRL.Reg)&^(0x2000)|value<<13)
}
func (o *SENS_Type) GetSAR_TSENS_CTRL_TSENS_IN_INV() uint32 {
	return (volatile.LoadUint32(&o.SAR_TSENS_CTRL.Reg) & 0x2000) >> 13
}
func (o *SENS_Type) SetSAR_TSENS_CTRL_TSENS_CLK_DIV(value uint32) {
	volatile.StoreUint32(&o.SAR_TSENS_CTRL.Reg, volatile.LoadUint32(&o.SAR_TSENS_CTRL.Reg)&^(0x3fc000)|value<<14)
}
func (o *SENS_Type) GetSAR_TSENS_CTRL_TSENS_CLK_DIV() uint32 {
	return (volatile.LoadUint32(&o.SAR_TSENS_CTRL.Reg) & 0x3fc000) >> 14
}
func (o *SENS_Type) SetSAR_TSENS_CTRL_TSENS_POWER_UP(value uint32) {
	volatile.StoreUint32(&o.SAR_TSENS_CTRL.Reg, volatile.LoadUint32(&o.SAR_TSENS_CTRL.Reg)&^(0x400000)|value<<22)
}
func (o *SENS_Type) GetSAR_TSENS_CTRL_TSENS_POWER_UP() uint32 {
	return (volatile.LoadUint32(&o.SAR_TSENS_CTRL.Reg) & 0x400000) >> 22
}
func (o *SENS_Type) SetSAR_TSENS_CTRL_TSENS_POWER_UP_FORCE(value uint32) {
	volatile.StoreUint32(&o.SAR_TSENS_CTRL.Reg, volatile.LoadUint32(&o.SAR_TSENS_CTRL.Reg)&^(0x800000)|value<<23)
}
func (o *SENS_Type) GetSAR_TSENS_CTRL_TSENS_POWER_UP_FORCE() uint32 {
	return (volatile.LoadUint32(&o.SAR_TSENS_CTRL.Reg) & 0x800000) >> 23
}
func (o *SENS_Type) SetSAR_TSENS_CTRL_TSENS_DUMP_OUT(value uint32) {
	volatile.StoreUint32(&o.SAR_TSENS_CTRL.Reg, volatile.LoadUint32(&o.SAR_TSENS_CTRL.Reg)&^(0x1000000)|value<<24)
}
func (o *SENS_Type) GetSAR_TSENS_CTRL_TSENS_DUMP_OUT() uint32 {
	return (volatile.LoadUint32(&o.SAR_TSENS_CTRL.Reg) & 0x1000000) >> 24
}

// SENS.SAR_TSENS_CTRL2: Temperature sensor control
func (o *SENS_Type) SetSAR_TSENS_CTRL2_TSENS_XPD_WAIT(value uint32) {
	volatile.StoreUint32(&o.SAR_TSENS_CTRL2.Reg, volatile.LoadUint32(&o.SAR_TSENS_CTRL2.Reg)&^(0xfff)|value)
}
func (o *SENS_Type) GetSAR_TSENS_CTRL2_TSENS_XPD_WAIT() uint32 {
	return volatile.LoadUint32(&o.SAR_TSENS_CTRL2.Reg) & 0xfff
}
func (o *SENS_Type) SetSAR_TSENS_CTRL2_TSENS_XPD_FORCE(value uint32) {
	volatile.StoreUint32(&o.SAR_TSENS_CTRL2.Reg, volatile.LoadUint32(&o.SAR_TSENS_CTRL2.Reg)&^(0x3000)|value<<12)
}
func (o *SENS_Type) GetSAR_TSENS_CTRL2_TSENS_XPD_FORCE() uint32 {
	return (volatile.LoadUint32(&o.SAR_TSENS_CTRL2.Reg) & 0x3000) >> 12
}
func (o *SENS_Type) SetSAR_TSENS_CTRL2_TSENS_CLK_INV(value uint32) {
	volatile.StoreUint32(&o.SAR_TSENS_CTRL2.Reg, volatile.LoadUint32(&o.SAR_TSENS_CTRL2.Reg)&^(0x4000)|value<<14)
}
func (o *SENS_Type) GetSAR_TSENS_CTRL2_TSENS_CLK_INV() uint32 {
	return (volatile.LoadUint32(&o.SAR_TSENS_CTRL2.Reg) & 0x4000) >> 14
}
func (o *SENS_Type) SetSAR_TSENS_CTRL2_TSENS_CLKGATE_EN(value uint32) {
	volatile.StoreUint32(&o.SAR_TSENS_CTRL2.Reg, volatile.LoadUint32(&o.SAR_TSENS_CTRL2.Reg)&^(0x8000)|value<<15)
}
func (o *SENS_Type) GetSAR_TSENS_CTRL2_TSENS_CLKGATE_EN() uint32 {
	return (volatile.LoadUint32(&o.SAR_TSENS_CTRL2.Reg) & 0x8000) >> 15
}
func (o *SENS_Type) SetSAR_TSENS_CTRL2_TSENS_RESET(value uint32) {
	volatile.StoreUint32(&o.SAR_TSENS_CTRL2.Reg, volatile.LoadUint32(&o.SAR_TSENS_CTRL2.Reg)&^(0x10000)|value<<16)
}
func (o *SENS_Type) GetSAR_TSENS_CTRL2_TSENS_RESET() uint32 {
	return (volatile.LoadUint32(&o.SAR_TSENS_CTRL2.Reg) & 0x10000) >> 16
}

// SENS.SAR_I2C_CTRL: Configure RTC I2C transmission
func (o *SENS_Type) SetSAR_I2C_CTRL(value uint32) {
	volatile.StoreUint32(&o.SAR_I2C_CTRL.Reg, volatile.LoadUint32(&o.SAR_I2C_CTRL.Reg)&^(0xfffffff)|value)
}
func (o *SENS_Type) GetSAR_I2C_CTRL() uint32 {
	return volatile.LoadUint32(&o.SAR_I2C_CTRL.Reg) & 0xfffffff
}
func (o *SENS_Type) SetSAR_I2C_CTRL_SAR_I2C_START(value uint32) {
	volatile.StoreUint32(&o.SAR_I2C_CTRL.Reg, volatile.LoadUint32(&o.SAR_I2C_CTRL.Reg)&^(0x10000000)|value<<28)
}
func (o *SENS_Type) GetSAR_I2C_CTRL_SAR_I2C_START() uint32 {
	return (volatile.LoadUint32(&o.SAR_I2C_CTRL.Reg) & 0x10000000) >> 28
}
func (o *SENS_Type) SetSAR_I2C_CTRL_SAR_I2C_START_FORCE(value uint32) {
	volatile.StoreUint32(&o.SAR_I2C_CTRL.Reg, volatile.LoadUint32(&o.SAR_I2C_CTRL.Reg)&^(0x20000000)|value<<29)
}
func (o *SENS_Type) GetSAR_I2C_CTRL_SAR_I2C_START_FORCE() uint32 {
	return (volatile.LoadUint32(&o.SAR_I2C_CTRL.Reg) & 0x20000000) >> 29
}

// SENS.SAR_TOUCH_CONF: Touch sensor configuration register
func (o *SENS_Type) SetSAR_TOUCH_CONF_TOUCH_OUTEN(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_CONF.Reg, volatile.LoadUint32(&o.SAR_TOUCH_CONF.Reg)&^(0x7fff)|value)
}
func (o *SENS_Type) GetSAR_TOUCH_CONF_TOUCH_OUTEN() uint32 {
	return volatile.LoadUint32(&o.SAR_TOUCH_CONF.Reg) & 0x7fff
}
func (o *SENS_Type) SetSAR_TOUCH_CONF_TOUCH_STATUS_CLR(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_CONF.Reg, volatile.LoadUint32(&o.SAR_TOUCH_CONF.Reg)&^(0x8000)|value<<15)
}
func (o *SENS_Type) GetSAR_TOUCH_CONF_TOUCH_STATUS_CLR() uint32 {
	return (volatile.LoadUint32(&o.SAR_TOUCH_CONF.Reg) & 0x8000) >> 15
}
func (o *SENS_Type) SetSAR_TOUCH_CONF_TOUCH_DATA_SEL(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_CONF.Reg, volatile.LoadUint32(&o.SAR_TOUCH_CONF.Reg)&^(0x30000)|value<<16)
}
func (o *SENS_Type) GetSAR_TOUCH_CONF_TOUCH_DATA_SEL() uint32 {
	return (volatile.LoadUint32(&o.SAR_TOUCH_CONF.Reg) & 0x30000) >> 16
}
func (o *SENS_Type) SetSAR_TOUCH_CONF_TOUCH_DENOISE_END(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_CONF.Reg, volatile.LoadUint32(&o.SAR_TOUCH_CONF.Reg)&^(0x40000)|value<<18)
}
func (o *SENS_Type) GetSAR_TOUCH_CONF_TOUCH_DENOISE_END() uint32 {
	return (volatile.LoadUint32(&o.SAR_TOUCH_CONF.Reg) & 0x40000) >> 18
}
func (o *SENS_Type) SetSAR_TOUCH_CONF_TOUCH_UNIT_END(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_CONF.Reg, volatile.LoadUint32(&o.SAR_TOUCH_CONF.Reg)&^(0x80000)|value<<19)
}
func (o *SENS_Type) GetSAR_TOUCH_CONF_TOUCH_UNIT_END() uint32 {
	return (volatile.LoadUint32(&o.SAR_TOUCH_CONF.Reg) & 0x80000) >> 19
}
func (o *SENS_Type) SetSAR_TOUCH_CONF_TOUCH_APPROACH_PAD2(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_CONF.Reg, volatile.LoadUint32(&o.SAR_TOUCH_CONF.Reg)&^(0xf00000)|value<<20)
}
func (o *SENS_Type) GetSAR_TOUCH_CONF_TOUCH_APPROACH_PAD2() uint32 {
	return (volatile.LoadUint32(&o.SAR_TOUCH_CONF.Reg) & 0xf00000) >> 20
}
func (o *SENS_Type) SetSAR_TOUCH_CONF_TOUCH_APPROACH_PAD1(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_CONF.Reg, volatile.LoadUint32(&o.SAR_TOUCH_CONF.Reg)&^(0xf000000)|value<<24)
}
func (o *SENS_Type) GetSAR_TOUCH_CONF_TOUCH_APPROACH_PAD1() uint32 {
	return (volatile.LoadUint32(&o.SAR_TOUCH_CONF.Reg) & 0xf000000) >> 24
}
func (o *SENS_Type) SetSAR_TOUCH_CONF_TOUCH_APPROACH_PAD0(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_CONF.Reg, volatile.LoadUint32(&o.SAR_TOUCH_CONF.Reg)&^(0xf0000000)|value<<28)
}
func (o *SENS_Type) GetSAR_TOUCH_CONF_TOUCH_APPROACH_PAD0() uint32 {
	return (volatile.LoadUint32(&o.SAR_TOUCH_CONF.Reg) & 0xf0000000) >> 28
}

// SENS.SAR_TOUCH_THRES1: Finger threshold for touch pad 1
func (o *SENS_Type) SetSAR_TOUCH_THRES1_TOUCH_OUT_TH1(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_THRES1.Reg, volatile.LoadUint32(&o.SAR_TOUCH_THRES1.Reg)&^(0x3fffff)|value)
}
func (o *SENS_Type) GetSAR_TOUCH_THRES1_TOUCH_OUT_TH1() uint32 {
	return volatile.LoadUint32(&o.SAR_TOUCH_THRES1.Reg) & 0x3fffff
}

// SENS.SAR_TOUCH_THRES2: Finger threshold for touch pad 2
func (o *SENS_Type) SetSAR_TOUCH_THRES2_TOUCH_OUT_TH2(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_THRES2.Reg, volatile.LoadUint32(&o.SAR_TOUCH_THRES2.Reg)&^(0x3fffff)|value)
}
func (o *SENS_Type) GetSAR_TOUCH_THRES2_TOUCH_OUT_TH2() uint32 {
	return volatile.LoadUint32(&o.SAR_TOUCH_THRES2.Reg) & 0x3fffff
}

// SENS.SAR_TOUCH_THRES3: Finger threshold for touch pad 3
func (o *SENS_Type) SetSAR_TOUCH_THRES3_TOUCH_OUT_TH3(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_THRES3.Reg, volatile.LoadUint32(&o.SAR_TOUCH_THRES3.Reg)&^(0x3fffff)|value)
}
func (o *SENS_Type) GetSAR_TOUCH_THRES3_TOUCH_OUT_TH3() uint32 {
	return volatile.LoadUint32(&o.SAR_TOUCH_THRES3.Reg) & 0x3fffff
}

// SENS.SAR_TOUCH_THRES4: Finger threshold for touch pad 4
func (o *SENS_Type) SetSAR_TOUCH_THRES4_TOUCH_OUT_TH4(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_THRES4.Reg, volatile.LoadUint32(&o.SAR_TOUCH_THRES4.Reg)&^(0x3fffff)|value)
}
func (o *SENS_Type) GetSAR_TOUCH_THRES4_TOUCH_OUT_TH4() uint32 {
	return volatile.LoadUint32(&o.SAR_TOUCH_THRES4.Reg) & 0x3fffff
}

// SENS.SAR_TOUCH_THRES5: Finger threshold for touch pad 5
func (o *SENS_Type) SetSAR_TOUCH_THRES5_TOUCH_OUT_TH5(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_THRES5.Reg, volatile.LoadUint32(&o.SAR_TOUCH_THRES5.Reg)&^(0x3fffff)|value)
}
func (o *SENS_Type) GetSAR_TOUCH_THRES5_TOUCH_OUT_TH5() uint32 {
	return volatile.LoadUint32(&o.SAR_TOUCH_THRES5.Reg) & 0x3fffff
}

// SENS.SAR_TOUCH_THRES6: Finger threshold for touch pad 6
func (o *SENS_Type) SetSAR_TOUCH_THRES6_TOUCH_OUT_TH6(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_THRES6.Reg, volatile.LoadUint32(&o.SAR_TOUCH_THRES6.Reg)&^(0x3fffff)|value)
}
func (o *SENS_Type) GetSAR_TOUCH_THRES6_TOUCH_OUT_TH6() uint32 {
	return volatile.LoadUint32(&o.SAR_TOUCH_THRES6.Reg) & 0x3fffff
}

// SENS.SAR_TOUCH_THRES7: Finger threshold for touch pad 7
func (o *SENS_Type) SetSAR_TOUCH_THRES7_TOUCH_OUT_TH7(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_THRES7.Reg, volatile.LoadUint32(&o.SAR_TOUCH_THRES7.Reg)&^(0x3fffff)|value)
}
func (o *SENS_Type) GetSAR_TOUCH_THRES7_TOUCH_OUT_TH7() uint32 {
	return volatile.LoadUint32(&o.SAR_TOUCH_THRES7.Reg) & 0x3fffff
}

// SENS.SAR_TOUCH_THRES8: Finger threshold for touch pad 8
func (o *SENS_Type) SetSAR_TOUCH_THRES8_TOUCH_OUT_TH8(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_THRES8.Reg, volatile.LoadUint32(&o.SAR_TOUCH_THRES8.Reg)&^(0x3fffff)|value)
}
func (o *SENS_Type) GetSAR_TOUCH_THRES8_TOUCH_OUT_TH8() uint32 {
	return volatile.LoadUint32(&o.SAR_TOUCH_THRES8.Reg) & 0x3fffff
}

// SENS.SAR_TOUCH_THRES9: Finger threshold for touch pad 9
func (o *SENS_Type) SetSAR_TOUCH_THRES9_TOUCH_OUT_TH9(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_THRES9.Reg, volatile.LoadUint32(&o.SAR_TOUCH_THRES9.Reg)&^(0x3fffff)|value)
}
func (o *SENS_Type) GetSAR_TOUCH_THRES9_TOUCH_OUT_TH9() uint32 {
	return volatile.LoadUint32(&o.SAR_TOUCH_THRES9.Reg) & 0x3fffff
}

// SENS.SAR_TOUCH_THRES10: Finger threshold for touch pad 10
func (o *SENS_Type) SetSAR_TOUCH_THRES10_TOUCH_OUT_TH10(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_THRES10.Reg, volatile.LoadUint32(&o.SAR_TOUCH_THRES10.Reg)&^(0x3fffff)|value)
}
func (o *SENS_Type) GetSAR_TOUCH_THRES10_TOUCH_OUT_TH10() uint32 {
	return volatile.LoadUint32(&o.SAR_TOUCH_THRES10.Reg) & 0x3fffff
}

// SENS.SAR_TOUCH_THRES11: Finger threshold for touch pad 11
func (o *SENS_Type) SetSAR_TOUCH_THRES11_TOUCH_OUT_TH11(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_THRES11.Reg, volatile.LoadUint32(&o.SAR_TOUCH_THRES11.Reg)&^(0x3fffff)|value)
}
func (o *SENS_Type) GetSAR_TOUCH_THRES11_TOUCH_OUT_TH11() uint32 {
	return volatile.LoadUint32(&o.SAR_TOUCH_THRES11.Reg) & 0x3fffff
}

// SENS.SAR_TOUCH_THRES12: Finger threshold for touch pad 12
func (o *SENS_Type) SetSAR_TOUCH_THRES12_TOUCH_OUT_TH12(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_THRES12.Reg, volatile.LoadUint32(&o.SAR_TOUCH_THRES12.Reg)&^(0x3fffff)|value)
}
func (o *SENS_Type) GetSAR_TOUCH_THRES12_TOUCH_OUT_TH12() uint32 {
	return volatile.LoadUint32(&o.SAR_TOUCH_THRES12.Reg) & 0x3fffff
}

// SENS.SAR_TOUCH_THRES13: Finger threshold for touch pad 13
func (o *SENS_Type) SetSAR_TOUCH_THRES13_TOUCH_OUT_TH13(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_THRES13.Reg, volatile.LoadUint32(&o.SAR_TOUCH_THRES13.Reg)&^(0x3fffff)|value)
}
func (o *SENS_Type) GetSAR_TOUCH_THRES13_TOUCH_OUT_TH13() uint32 {
	return volatile.LoadUint32(&o.SAR_TOUCH_THRES13.Reg) & 0x3fffff
}

// SENS.SAR_TOUCH_THRES14: Finger threshold for touch pad 14
func (o *SENS_Type) SetSAR_TOUCH_THRES14_TOUCH_OUT_TH14(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_THRES14.Reg, volatile.LoadUint32(&o.SAR_TOUCH_THRES14.Reg)&^(0x3fffff)|value)
}
func (o *SENS_Type) GetSAR_TOUCH_THRES14_TOUCH_OUT_TH14() uint32 {
	return volatile.LoadUint32(&o.SAR_TOUCH_THRES14.Reg) & 0x3fffff
}

// SENS.SAR_TOUCH_CHN_ST: Touch channel status register
func (o *SENS_Type) SetSAR_TOUCH_CHN_ST_TOUCH_PAD_ACTIVE(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_CHN_ST.Reg, volatile.LoadUint32(&o.SAR_TOUCH_CHN_ST.Reg)&^(0x7fff)|value)
}
func (o *SENS_Type) GetSAR_TOUCH_CHN_ST_TOUCH_PAD_ACTIVE() uint32 {
	return volatile.LoadUint32(&o.SAR_TOUCH_CHN_ST.Reg) & 0x7fff
}
func (o *SENS_Type) SetSAR_TOUCH_CHN_ST_TOUCH_CHANNEL_CLR(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_CHN_ST.Reg, volatile.LoadUint32(&o.SAR_TOUCH_CHN_ST.Reg)&^(0x3fff8000)|value<<15)
}
func (o *SENS_Type) GetSAR_TOUCH_CHN_ST_TOUCH_CHANNEL_CLR() uint32 {
	return (volatile.LoadUint32(&o.SAR_TOUCH_CHN_ST.Reg) & 0x3fff8000) >> 15
}
func (o *SENS_Type) SetSAR_TOUCH_CHN_ST_TOUCH_MEAS_DONE(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_CHN_ST.Reg, volatile.LoadUint32(&o.SAR_TOUCH_CHN_ST.Reg)&^(0x80000000)|value<<31)
}
func (o *SENS_Type) GetSAR_TOUCH_CHN_ST_TOUCH_MEAS_DONE() uint32 {
	return (volatile.LoadUint32(&o.SAR_TOUCH_CHN_ST.Reg) & 0x80000000) >> 31
}

// SENS.SAR_TOUCH_STATUS0: Status of touch controller
func (o *SENS_Type) SetSAR_TOUCH_STATUS0_TOUCH_DENOISE_DATA(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_STATUS0.Reg, volatile.LoadUint32(&o.SAR_TOUCH_STATUS0.Reg)&^(0x3fffff)|value)
}
func (o *SENS_Type) GetSAR_TOUCH_STATUS0_TOUCH_DENOISE_DATA() uint32 {
	return volatile.LoadUint32(&o.SAR_TOUCH_STATUS0.Reg) & 0x3fffff
}
func (o *SENS_Type) SetSAR_TOUCH_STATUS0_TOUCH_SCAN_CURR(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_STATUS0.Reg, volatile.LoadUint32(&o.SAR_TOUCH_STATUS0.Reg)&^(0x3c00000)|value<<22)
}
func (o *SENS_Type) GetSAR_TOUCH_STATUS0_TOUCH_SCAN_CURR() uint32 {
	return (volatile.LoadUint32(&o.SAR_TOUCH_STATUS0.Reg) & 0x3c00000) >> 22
}

// SENS.SAR_TOUCH_STATUS1: Touch pad 1 status
func (o *SENS_Type) SetSAR_TOUCH_STATUS1_TOUCH_PAD1_DATA(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_STATUS1.Reg, volatile.LoadUint32(&o.SAR_TOUCH_STATUS1.Reg)&^(0x3fffff)|value)
}
func (o *SENS_Type) GetSAR_TOUCH_STATUS1_TOUCH_PAD1_DATA() uint32 {
	return volatile.LoadUint32(&o.SAR_TOUCH_STATUS1.Reg) & 0x3fffff
}
func (o *SENS_Type) SetSAR_TOUCH_STATUS1_TOUCH_PAD1_DEBOUNCE(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_STATUS1.Reg, volatile.LoadUint32(&o.SAR_TOUCH_STATUS1.Reg)&^(0xe0000000)|value<<29)
}
func (o *SENS_Type) GetSAR_TOUCH_STATUS1_TOUCH_PAD1_DEBOUNCE() uint32 {
	return (volatile.LoadUint32(&o.SAR_TOUCH_STATUS1.Reg) & 0xe0000000) >> 29
}

// SENS.SAR_TOUCH_STATUS2: Touch pad 2 status
func (o *SENS_Type) SetSAR_TOUCH_STATUS2_TOUCH_PAD2_DATA(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_STATUS2.Reg, volatile.LoadUint32(&o.SAR_TOUCH_STATUS2.Reg)&^(0x3fffff)|value)
}
func (o *SENS_Type) GetSAR_TOUCH_STATUS2_TOUCH_PAD2_DATA() uint32 {
	return volatile.LoadUint32(&o.SAR_TOUCH_STATUS2.Reg) & 0x3fffff
}
func (o *SENS_Type) SetSAR_TOUCH_STATUS2_TOUCH_PAD2_DEBOUNCE(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_STATUS2.Reg, volatile.LoadUint32(&o.SAR_TOUCH_STATUS2.Reg)&^(0xe0000000)|value<<29)
}
func (o *SENS_Type) GetSAR_TOUCH_STATUS2_TOUCH_PAD2_DEBOUNCE() uint32 {
	return (volatile.LoadUint32(&o.SAR_TOUCH_STATUS2.Reg) & 0xe0000000) >> 29
}

// SENS.SAR_TOUCH_STATUS3: Touch pad 3 status
func (o *SENS_Type) SetSAR_TOUCH_STATUS3_TOUCH_PAD3_DATA(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_STATUS3.Reg, volatile.LoadUint32(&o.SAR_TOUCH_STATUS3.Reg)&^(0x3fffff)|value)
}
func (o *SENS_Type) GetSAR_TOUCH_STATUS3_TOUCH_PAD3_DATA() uint32 {
	return volatile.LoadUint32(&o.SAR_TOUCH_STATUS3.Reg) & 0x3fffff
}
func (o *SENS_Type) SetSAR_TOUCH_STATUS3_TOUCH_PAD3_DEBOUNCE(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_STATUS3.Reg, volatile.LoadUint32(&o.SAR_TOUCH_STATUS3.Reg)&^(0xe0000000)|value<<29)
}
func (o *SENS_Type) GetSAR_TOUCH_STATUS3_TOUCH_PAD3_DEBOUNCE() uint32 {
	return (volatile.LoadUint32(&o.SAR_TOUCH_STATUS3.Reg) & 0xe0000000) >> 29
}

// SENS.SAR_TOUCH_STATUS4: Touch pad 4 status
func (o *SENS_Type) SetSAR_TOUCH_STATUS4_TOUCH_PAD4_DATA(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_STATUS4.Reg, volatile.LoadUint32(&o.SAR_TOUCH_STATUS4.Reg)&^(0x3fffff)|value)
}
func (o *SENS_Type) GetSAR_TOUCH_STATUS4_TOUCH_PAD4_DATA() uint32 {
	return volatile.LoadUint32(&o.SAR_TOUCH_STATUS4.Reg) & 0x3fffff
}
func (o *SENS_Type) SetSAR_TOUCH_STATUS4_TOUCH_PAD4_DEBOUNCE(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_STATUS4.Reg, volatile.LoadUint32(&o.SAR_TOUCH_STATUS4.Reg)&^(0xe0000000)|value<<29)
}
func (o *SENS_Type) GetSAR_TOUCH_STATUS4_TOUCH_PAD4_DEBOUNCE() uint32 {
	return (volatile.LoadUint32(&o.SAR_TOUCH_STATUS4.Reg) & 0xe0000000) >> 29
}

// SENS.SAR_TOUCH_STATUS5: Touch pad 5 status
func (o *SENS_Type) SetSAR_TOUCH_STATUS5_TOUCH_PAD5_DATA(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_STATUS5.Reg, volatile.LoadUint32(&o.SAR_TOUCH_STATUS5.Reg)&^(0x3fffff)|value)
}
func (o *SENS_Type) GetSAR_TOUCH_STATUS5_TOUCH_PAD5_DATA() uint32 {
	return volatile.LoadUint32(&o.SAR_TOUCH_STATUS5.Reg) & 0x3fffff
}
func (o *SENS_Type) SetSAR_TOUCH_STATUS5_TOUCH_PAD5_DEBOUNCE(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_STATUS5.Reg, volatile.LoadUint32(&o.SAR_TOUCH_STATUS5.Reg)&^(0xe0000000)|value<<29)
}
func (o *SENS_Type) GetSAR_TOUCH_STATUS5_TOUCH_PAD5_DEBOUNCE() uint32 {
	return (volatile.LoadUint32(&o.SAR_TOUCH_STATUS5.Reg) & 0xe0000000) >> 29
}

// SENS.SAR_TOUCH_STATUS6: Touch pad 6 status
func (o *SENS_Type) SetSAR_TOUCH_STATUS6_TOUCH_PAD6_DATA(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_STATUS6.Reg, volatile.LoadUint32(&o.SAR_TOUCH_STATUS6.Reg)&^(0x3fffff)|value)
}
func (o *SENS_Type) GetSAR_TOUCH_STATUS6_TOUCH_PAD6_DATA() uint32 {
	return volatile.LoadUint32(&o.SAR_TOUCH_STATUS6.Reg) & 0x3fffff
}
func (o *SENS_Type) SetSAR_TOUCH_STATUS6_TOUCH_PAD6_DEBOUNCE(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_STATUS6.Reg, volatile.LoadUint32(&o.SAR_TOUCH_STATUS6.Reg)&^(0xe0000000)|value<<29)
}
func (o *SENS_Type) GetSAR_TOUCH_STATUS6_TOUCH_PAD6_DEBOUNCE() uint32 {
	return (volatile.LoadUint32(&o.SAR_TOUCH_STATUS6.Reg) & 0xe0000000) >> 29
}

// SENS.SAR_TOUCH_STATUS7: Touch pad 7 status
func (o *SENS_Type) SetSAR_TOUCH_STATUS7_TOUCH_PAD7_DATA(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_STATUS7.Reg, volatile.LoadUint32(&o.SAR_TOUCH_STATUS7.Reg)&^(0x3fffff)|value)
}
func (o *SENS_Type) GetSAR_TOUCH_STATUS7_TOUCH_PAD7_DATA() uint32 {
	return volatile.LoadUint32(&o.SAR_TOUCH_STATUS7.Reg) & 0x3fffff
}
func (o *SENS_Type) SetSAR_TOUCH_STATUS7_TOUCH_PAD7_DEBOUNCE(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_STATUS7.Reg, volatile.LoadUint32(&o.SAR_TOUCH_STATUS7.Reg)&^(0xe0000000)|value<<29)
}
func (o *SENS_Type) GetSAR_TOUCH_STATUS7_TOUCH_PAD7_DEBOUNCE() uint32 {
	return (volatile.LoadUint32(&o.SAR_TOUCH_STATUS7.Reg) & 0xe0000000) >> 29
}

// SENS.SAR_TOUCH_STATUS8: Touch pad 8 status
func (o *SENS_Type) SetSAR_TOUCH_STATUS8_TOUCH_PAD8_DATA(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_STATUS8.Reg, volatile.LoadUint32(&o.SAR_TOUCH_STATUS8.Reg)&^(0x3fffff)|value)
}
func (o *SENS_Type) GetSAR_TOUCH_STATUS8_TOUCH_PAD8_DATA() uint32 {
	return volatile.LoadUint32(&o.SAR_TOUCH_STATUS8.Reg) & 0x3fffff
}
func (o *SENS_Type) SetSAR_TOUCH_STATUS8_TOUCH_PAD8_DEBOUNCE(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_STATUS8.Reg, volatile.LoadUint32(&o.SAR_TOUCH_STATUS8.Reg)&^(0xe0000000)|value<<29)
}
func (o *SENS_Type) GetSAR_TOUCH_STATUS8_TOUCH_PAD8_DEBOUNCE() uint32 {
	return (volatile.LoadUint32(&o.SAR_TOUCH_STATUS8.Reg) & 0xe0000000) >> 29
}

// SENS.SAR_TOUCH_STATUS9: Touch pad 9 status
func (o *SENS_Type) SetSAR_TOUCH_STATUS9_TOUCH_PAD9_DATA(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_STATUS9.Reg, volatile.LoadUint32(&o.SAR_TOUCH_STATUS9.Reg)&^(0x3fffff)|value)
}
func (o *SENS_Type) GetSAR_TOUCH_STATUS9_TOUCH_PAD9_DATA() uint32 {
	return volatile.LoadUint32(&o.SAR_TOUCH_STATUS9.Reg) & 0x3fffff
}
func (o *SENS_Type) SetSAR_TOUCH_STATUS9_TOUCH_PAD9_DEBOUNCE(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_STATUS9.Reg, volatile.LoadUint32(&o.SAR_TOUCH_STATUS9.Reg)&^(0xe0000000)|value<<29)
}
func (o *SENS_Type) GetSAR_TOUCH_STATUS9_TOUCH_PAD9_DEBOUNCE() uint32 {
	return (volatile.LoadUint32(&o.SAR_TOUCH_STATUS9.Reg) & 0xe0000000) >> 29
}

// SENS.SAR_TOUCH_STATUS10: Touch pad 10 status
func (o *SENS_Type) SetSAR_TOUCH_STATUS10_TOUCH_PAD10_DATA(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_STATUS10.Reg, volatile.LoadUint32(&o.SAR_TOUCH_STATUS10.Reg)&^(0x3fffff)|value)
}
func (o *SENS_Type) GetSAR_TOUCH_STATUS10_TOUCH_PAD10_DATA() uint32 {
	return volatile.LoadUint32(&o.SAR_TOUCH_STATUS10.Reg) & 0x3fffff
}
func (o *SENS_Type) SetSAR_TOUCH_STATUS10_TOUCH_PAD10_DEBOUNCE(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_STATUS10.Reg, volatile.LoadUint32(&o.SAR_TOUCH_STATUS10.Reg)&^(0xe0000000)|value<<29)
}
func (o *SENS_Type) GetSAR_TOUCH_STATUS10_TOUCH_PAD10_DEBOUNCE() uint32 {
	return (volatile.LoadUint32(&o.SAR_TOUCH_STATUS10.Reg) & 0xe0000000) >> 29
}

// SENS.SAR_TOUCH_STATUS11: Touch pad 11 status
func (o *SENS_Type) SetSAR_TOUCH_STATUS11_TOUCH_PAD11_DATA(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_STATUS11.Reg, volatile.LoadUint32(&o.SAR_TOUCH_STATUS11.Reg)&^(0x3fffff)|value)
}
func (o *SENS_Type) GetSAR_TOUCH_STATUS11_TOUCH_PAD11_DATA() uint32 {
	return volatile.LoadUint32(&o.SAR_TOUCH_STATUS11.Reg) & 0x3fffff
}
func (o *SENS_Type) SetSAR_TOUCH_STATUS11_TOUCH_PAD11_DEBOUNCE(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_STATUS11.Reg, volatile.LoadUint32(&o.SAR_TOUCH_STATUS11.Reg)&^(0xe0000000)|value<<29)
}
func (o *SENS_Type) GetSAR_TOUCH_STATUS11_TOUCH_PAD11_DEBOUNCE() uint32 {
	return (volatile.LoadUint32(&o.SAR_TOUCH_STATUS11.Reg) & 0xe0000000) >> 29
}

// SENS.SAR_TOUCH_STATUS12: Touch pad 12 status
func (o *SENS_Type) SetSAR_TOUCH_STATUS12_TOUCH_PAD12_DATA(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_STATUS12.Reg, volatile.LoadUint32(&o.SAR_TOUCH_STATUS12.Reg)&^(0x3fffff)|value)
}
func (o *SENS_Type) GetSAR_TOUCH_STATUS12_TOUCH_PAD12_DATA() uint32 {
	return volatile.LoadUint32(&o.SAR_TOUCH_STATUS12.Reg) & 0x3fffff
}
func (o *SENS_Type) SetSAR_TOUCH_STATUS12_TOUCH_PAD12_DEBOUNCE(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_STATUS12.Reg, volatile.LoadUint32(&o.SAR_TOUCH_STATUS12.Reg)&^(0xe0000000)|value<<29)
}
func (o *SENS_Type) GetSAR_TOUCH_STATUS12_TOUCH_PAD12_DEBOUNCE() uint32 {
	return (volatile.LoadUint32(&o.SAR_TOUCH_STATUS12.Reg) & 0xe0000000) >> 29
}

// SENS.SAR_TOUCH_STATUS13: Touch pad 13 status
func (o *SENS_Type) SetSAR_TOUCH_STATUS13_TOUCH_PAD13_DATA(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_STATUS13.Reg, volatile.LoadUint32(&o.SAR_TOUCH_STATUS13.Reg)&^(0x3fffff)|value)
}
func (o *SENS_Type) GetSAR_TOUCH_STATUS13_TOUCH_PAD13_DATA() uint32 {
	return volatile.LoadUint32(&o.SAR_TOUCH_STATUS13.Reg) & 0x3fffff
}
func (o *SENS_Type) SetSAR_TOUCH_STATUS13_TOUCH_PAD13_DEBOUNCE(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_STATUS13.Reg, volatile.LoadUint32(&o.SAR_TOUCH_STATUS13.Reg)&^(0xe0000000)|value<<29)
}
func (o *SENS_Type) GetSAR_TOUCH_STATUS13_TOUCH_PAD13_DEBOUNCE() uint32 {
	return (volatile.LoadUint32(&o.SAR_TOUCH_STATUS13.Reg) & 0xe0000000) >> 29
}

// SENS.SAR_TOUCH_STATUS14: Touch pad 14 status
func (o *SENS_Type) SetSAR_TOUCH_STATUS14_TOUCH_PAD14_DATA(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_STATUS14.Reg, volatile.LoadUint32(&o.SAR_TOUCH_STATUS14.Reg)&^(0x3fffff)|value)
}
func (o *SENS_Type) GetSAR_TOUCH_STATUS14_TOUCH_PAD14_DATA() uint32 {
	return volatile.LoadUint32(&o.SAR_TOUCH_STATUS14.Reg) & 0x3fffff
}
func (o *SENS_Type) SetSAR_TOUCH_STATUS14_TOUCH_PAD14_DEBOUNCE(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_STATUS14.Reg, volatile.LoadUint32(&o.SAR_TOUCH_STATUS14.Reg)&^(0xe0000000)|value<<29)
}
func (o *SENS_Type) GetSAR_TOUCH_STATUS14_TOUCH_PAD14_DEBOUNCE() uint32 {
	return (volatile.LoadUint32(&o.SAR_TOUCH_STATUS14.Reg) & 0xe0000000) >> 29
}

// SENS.SAR_TOUCH_STATUS15: Touch sleep pad status
func (o *SENS_Type) SetSAR_TOUCH_STATUS15_TOUCH_SLP_DATA(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_STATUS15.Reg, volatile.LoadUint32(&o.SAR_TOUCH_STATUS15.Reg)&^(0x3fffff)|value)
}
func (o *SENS_Type) GetSAR_TOUCH_STATUS15_TOUCH_SLP_DATA() uint32 {
	return volatile.LoadUint32(&o.SAR_TOUCH_STATUS15.Reg) & 0x3fffff
}
func (o *SENS_Type) SetSAR_TOUCH_STATUS15_TOUCH_SLP_DEBOUNCE(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_STATUS15.Reg, volatile.LoadUint32(&o.SAR_TOUCH_STATUS15.Reg)&^(0xe0000000)|value<<29)
}
func (o *SENS_Type) GetSAR_TOUCH_STATUS15_TOUCH_SLP_DEBOUNCE() uint32 {
	return (volatile.LoadUint32(&o.SAR_TOUCH_STATUS15.Reg) & 0xe0000000) >> 29
}

// SENS.SAR_TOUCH_STATUS16: Touch approach count status
func (o *SENS_Type) SetSAR_TOUCH_STATUS16_TOUCH_APPROACH_PAD2_CNT(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_STATUS16.Reg, volatile.LoadUint32(&o.SAR_TOUCH_STATUS16.Reg)&^(0xff)|value)
}
func (o *SENS_Type) GetSAR_TOUCH_STATUS16_TOUCH_APPROACH_PAD2_CNT() uint32 {
	return volatile.LoadUint32(&o.SAR_TOUCH_STATUS16.Reg) & 0xff
}
func (o *SENS_Type) SetSAR_TOUCH_STATUS16_TOUCH_APPROACH_PAD1_CNT(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_STATUS16.Reg, volatile.LoadUint32(&o.SAR_TOUCH_STATUS16.Reg)&^(0xff00)|value<<8)
}
func (o *SENS_Type) GetSAR_TOUCH_STATUS16_TOUCH_APPROACH_PAD1_CNT() uint32 {
	return (volatile.LoadUint32(&o.SAR_TOUCH_STATUS16.Reg) & 0xff00) >> 8
}
func (o *SENS_Type) SetSAR_TOUCH_STATUS16_TOUCH_APPROACH_PAD0_CNT(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_STATUS16.Reg, volatile.LoadUint32(&o.SAR_TOUCH_STATUS16.Reg)&^(0xff0000)|value<<16)
}
func (o *SENS_Type) GetSAR_TOUCH_STATUS16_TOUCH_APPROACH_PAD0_CNT() uint32 {
	return (volatile.LoadUint32(&o.SAR_TOUCH_STATUS16.Reg) & 0xff0000) >> 16
}
func (o *SENS_Type) SetSAR_TOUCH_STATUS16_TOUCH_SLP_APPROACH_CNT(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_STATUS16.Reg, volatile.LoadUint32(&o.SAR_TOUCH_STATUS16.Reg)&^(0xff000000)|value<<24)
}
func (o *SENS_Type) GetSAR_TOUCH_STATUS16_TOUCH_SLP_APPROACH_CNT() uint32 {
	return (volatile.LoadUint32(&o.SAR_TOUCH_STATUS16.Reg) & 0xff000000) >> 24
}

// SENS.SAR_DAC_CTRL1: DAC control
func (o *SENS_Type) SetSAR_DAC_CTRL1_SW_FSTEP(value uint32) {
	volatile.StoreUint32(&o.SAR_DAC_CTRL1.Reg, volatile.LoadUint32(&o.SAR_DAC_CTRL1.Reg)&^(0xffff)|value)
}
func (o *SENS_Type) GetSAR_DAC_CTRL1_SW_FSTEP() uint32 {
	return volatile.LoadUint32(&o.SAR_DAC_CTRL1.Reg) & 0xffff
}
func (o *SENS_Type) SetSAR_DAC_CTRL1_SW_TONE_EN(value uint32) {
	volatile.StoreUint32(&o.SAR_DAC_CTRL1.Reg, volatile.LoadUint32(&o.SAR_DAC_CTRL1.Reg)&^(0x10000)|value<<16)
}
func (o *SENS_Type) GetSAR_DAC_CTRL1_SW_TONE_EN() uint32 {
	return (volatile.LoadUint32(&o.SAR_DAC_CTRL1.Reg) & 0x10000) >> 16
}
func (o *SENS_Type) SetSAR_DAC_CTRL1_DEBUG_BIT_SEL(value uint32) {
	volatile.StoreUint32(&o.SAR_DAC_CTRL1.Reg, volatile.LoadUint32(&o.SAR_DAC_CTRL1.Reg)&^(0x3e0000)|value<<17)
}
func (o *SENS_Type) GetSAR_DAC_CTRL1_DEBUG_BIT_SEL() uint32 {
	return (volatile.LoadUint32(&o.SAR_DAC_CTRL1.Reg) & 0x3e0000) >> 17
}
func (o *SENS_Type) SetSAR_DAC_CTRL1_DAC_DIG_FORCE(value uint32) {
	volatile.StoreUint32(&o.SAR_DAC_CTRL1.Reg, volatile.LoadUint32(&o.SAR_DAC_CTRL1.Reg)&^(0x400000)|value<<22)
}
func (o *SENS_Type) GetSAR_DAC_CTRL1_DAC_DIG_FORCE() uint32 {
	return (volatile.LoadUint32(&o.SAR_DAC_CTRL1.Reg) & 0x400000) >> 22
}
func (o *SENS_Type) SetSAR_DAC_CTRL1_DAC_CLK_FORCE_LOW(value uint32) {
	volatile.StoreUint32(&o.SAR_DAC_CTRL1.Reg, volatile.LoadUint32(&o.SAR_DAC_CTRL1.Reg)&^(0x800000)|value<<23)
}
func (o *SENS_Type) GetSAR_DAC_CTRL1_DAC_CLK_FORCE_LOW() uint32 {
	return (volatile.LoadUint32(&o.SAR_DAC_CTRL1.Reg) & 0x800000) >> 23
}
func (o *SENS_Type) SetSAR_DAC_CTRL1_DAC_CLK_FORCE_HIGH(value uint32) {
	volatile.StoreUint32(&o.SAR_DAC_CTRL1.Reg, volatile.LoadUint32(&o.SAR_DAC_CTRL1.Reg)&^(0x1000000)|value<<24)
}
func (o *SENS_Type) GetSAR_DAC_CTRL1_DAC_CLK_FORCE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.SAR_DAC_CTRL1.Reg) & 0x1000000) >> 24
}
func (o *SENS_Type) SetSAR_DAC_CTRL1_DAC_CLK_INV(value uint32) {
	volatile.StoreUint32(&o.SAR_DAC_CTRL1.Reg, volatile.LoadUint32(&o.SAR_DAC_CTRL1.Reg)&^(0x2000000)|value<<25)
}
func (o *SENS_Type) GetSAR_DAC_CTRL1_DAC_CLK_INV() uint32 {
	return (volatile.LoadUint32(&o.SAR_DAC_CTRL1.Reg) & 0x2000000) >> 25
}
func (o *SENS_Type) SetSAR_DAC_CTRL1_DAC_RESET(value uint32) {
	volatile.StoreUint32(&o.SAR_DAC_CTRL1.Reg, volatile.LoadUint32(&o.SAR_DAC_CTRL1.Reg)&^(0x4000000)|value<<26)
}
func (o *SENS_Type) GetSAR_DAC_CTRL1_DAC_RESET() uint32 {
	return (volatile.LoadUint32(&o.SAR_DAC_CTRL1.Reg) & 0x4000000) >> 26
}
func (o *SENS_Type) SetSAR_DAC_CTRL1_DAC_CLKGATE_EN(value uint32) {
	volatile.StoreUint32(&o.SAR_DAC_CTRL1.Reg, volatile.LoadUint32(&o.SAR_DAC_CTRL1.Reg)&^(0x8000000)|value<<27)
}
func (o *SENS_Type) GetSAR_DAC_CTRL1_DAC_CLKGATE_EN() uint32 {
	return (volatile.LoadUint32(&o.SAR_DAC_CTRL1.Reg) & 0x8000000) >> 27
}

// SENS.SAR_DAC_CTRL2: DAC output control
func (o *SENS_Type) SetSAR_DAC_CTRL2_DAC_DC1(value uint32) {
	volatile.StoreUint32(&o.SAR_DAC_CTRL2.Reg, volatile.LoadUint32(&o.SAR_DAC_CTRL2.Reg)&^(0xff)|value)
}
func (o *SENS_Type) GetSAR_DAC_CTRL2_DAC_DC1() uint32 {
	return volatile.LoadUint32(&o.SAR_DAC_CTRL2.Reg) & 0xff
}
func (o *SENS_Type) SetSAR_DAC_CTRL2_DAC_DC2(value uint32) {
	volatile.StoreUint32(&o.SAR_DAC_CTRL2.Reg, volatile.LoadUint32(&o.SAR_DAC_CTRL2.Reg)&^(0xff00)|value<<8)
}
func (o *SENS_Type) GetSAR_DAC_CTRL2_DAC_DC2() uint32 {
	return (volatile.LoadUint32(&o.SAR_DAC_CTRL2.Reg) & 0xff00) >> 8
}
func (o *SENS_Type) SetSAR_DAC_CTRL2_DAC_SCALE1(value uint32) {
	volatile.StoreUint32(&o.SAR_DAC_CTRL2.Reg, volatile.LoadUint32(&o.SAR_DAC_CTRL2.Reg)&^(0x30000)|value<<16)
}
func (o *SENS_Type) GetSAR_DAC_CTRL2_DAC_SCALE1() uint32 {
	return (volatile.LoadUint32(&o.SAR_DAC_CTRL2.Reg) & 0x30000) >> 16
}
func (o *SENS_Type) SetSAR_DAC_CTRL2_DAC_SCALE2(value uint32) {
	volatile.StoreUint32(&o.SAR_DAC_CTRL2.Reg, volatile.LoadUint32(&o.SAR_DAC_CTRL2.Reg)&^(0xc0000)|value<<18)
}
func (o *SENS_Type) GetSAR_DAC_CTRL2_DAC_SCALE2() uint32 {
	return (volatile.LoadUint32(&o.SAR_DAC_CTRL2.Reg) & 0xc0000) >> 18
}
func (o *SENS_Type) SetSAR_DAC_CTRL2_DAC_INV1(value uint32) {
	volatile.StoreUint32(&o.SAR_DAC_CTRL2.Reg, volatile.LoadUint32(&o.SAR_DAC_CTRL2.Reg)&^(0x300000)|value<<20)
}
func (o *SENS_Type) GetSAR_DAC_CTRL2_DAC_INV1() uint32 {
	return (volatile.LoadUint32(&o.SAR_DAC_CTRL2.Reg) & 0x300000) >> 20
}
func (o *SENS_Type) SetSAR_DAC_CTRL2_DAC_INV2(value uint32) {
	volatile.StoreUint32(&o.SAR_DAC_CTRL2.Reg, volatile.LoadUint32(&o.SAR_DAC_CTRL2.Reg)&^(0xc00000)|value<<22)
}
func (o *SENS_Type) GetSAR_DAC_CTRL2_DAC_INV2() uint32 {
	return (volatile.LoadUint32(&o.SAR_DAC_CTRL2.Reg) & 0xc00000) >> 22
}
func (o *SENS_Type) SetSAR_DAC_CTRL2_DAC_CW_EN1(value uint32) {
	volatile.StoreUint32(&o.SAR_DAC_CTRL2.Reg, volatile.LoadUint32(&o.SAR_DAC_CTRL2.Reg)&^(0x1000000)|value<<24)
}
func (o *SENS_Type) GetSAR_DAC_CTRL2_DAC_CW_EN1() uint32 {
	return (volatile.LoadUint32(&o.SAR_DAC_CTRL2.Reg) & 0x1000000) >> 24
}
func (o *SENS_Type) SetSAR_DAC_CTRL2_DAC_CW_EN2(value uint32) {
	volatile.StoreUint32(&o.SAR_DAC_CTRL2.Reg, volatile.LoadUint32(&o.SAR_DAC_CTRL2.Reg)&^(0x2000000)|value<<25)
}
func (o *SENS_Type) GetSAR_DAC_CTRL2_DAC_CW_EN2() uint32 {
	return (volatile.LoadUint32(&o.SAR_DAC_CTRL2.Reg) & 0x2000000) >> 25
}

// SENS.SAR_COCPU_STATE: ULP-RISCV status
func (o *SENS_Type) SetSAR_COCPU_STATE_COCPU_DBG_TRIGGER(value uint32) {
	volatile.StoreUint32(&o.SAR_COCPU_STATE.Reg, volatile.LoadUint32(&o.SAR_COCPU_STATE.Reg)&^(0x2000000)|value<<25)
}
func (o *SENS_Type) GetSAR_COCPU_STATE_COCPU_DBG_TRIGGER() uint32 {
	return (volatile.LoadUint32(&o.SAR_COCPU_STATE.Reg) & 0x2000000) >> 25
}
func (o *SENS_Type) SetSAR_COCPU_STATE_COCPU_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.SAR_COCPU_STATE.Reg, volatile.LoadUint32(&o.SAR_COCPU_STATE.Reg)&^(0x4000000)|value<<26)
}
func (o *SENS_Type) GetSAR_COCPU_STATE_COCPU_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.SAR_COCPU_STATE.Reg) & 0x4000000) >> 26
}
func (o *SENS_Type) SetSAR_COCPU_STATE_COCPU_RESET_N(value uint32) {
	volatile.StoreUint32(&o.SAR_COCPU_STATE.Reg, volatile.LoadUint32(&o.SAR_COCPU_STATE.Reg)&^(0x8000000)|value<<27)
}
func (o *SENS_Type) GetSAR_COCPU_STATE_COCPU_RESET_N() uint32 {
	return (volatile.LoadUint32(&o.SAR_COCPU_STATE.Reg) & 0x8000000) >> 27
}
func (o *SENS_Type) SetSAR_COCPU_STATE_COCPU_EOI(value uint32) {
	volatile.StoreUint32(&o.SAR_COCPU_STATE.Reg, volatile.LoadUint32(&o.SAR_COCPU_STATE.Reg)&^(0x10000000)|value<<28)
}
func (o *SENS_Type) GetSAR_COCPU_STATE_COCPU_EOI() uint32 {
	return (volatile.LoadUint32(&o.SAR_COCPU_STATE.Reg) & 0x10000000) >> 28
}
func (o *SENS_Type) SetSAR_COCPU_STATE_COCPU_TRAP(value uint32) {
	volatile.StoreUint32(&o.SAR_COCPU_STATE.Reg, volatile.LoadUint32(&o.SAR_COCPU_STATE.Reg)&^(0x20000000)|value<<29)
}
func (o *SENS_Type) GetSAR_COCPU_STATE_COCPU_TRAP() uint32 {
	return (volatile.LoadUint32(&o.SAR_COCPU_STATE.Reg) & 0x20000000) >> 29
}
func (o *SENS_Type) SetSAR_COCPU_STATE_COCPU_EBREAK(value uint32) {
	volatile.StoreUint32(&o.SAR_COCPU_STATE.Reg, volatile.LoadUint32(&o.SAR_COCPU_STATE.Reg)&^(0x40000000)|value<<30)
}
func (o *SENS_Type) GetSAR_COCPU_STATE_COCPU_EBREAK() uint32 {
	return (volatile.LoadUint32(&o.SAR_COCPU_STATE.Reg) & 0x40000000) >> 30
}

// SENS.SAR_COCPU_INT_RAW: Interrupt raw bit of ULP-RISCV
func (o *SENS_Type) SetSAR_COCPU_INT_RAW_COCPU_TOUCH_DONE_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.SAR_COCPU_INT_RAW.Reg, volatile.LoadUint32(&o.SAR_COCPU_INT_RAW.Reg)&^(0x1)|value)
}
func (o *SENS_Type) GetSAR_COCPU_INT_RAW_COCPU_TOUCH_DONE_INT_RAW() uint32 {
	return volatile.LoadUint32(&o.SAR_COCPU_INT_RAW.Reg) & 0x1
}
func (o *SENS_Type) SetSAR_COCPU_INT_RAW_COCPU_TOUCH_INACTIVE_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.SAR_COCPU_INT_RAW.Reg, volatile.LoadUint32(&o.SAR_COCPU_INT_RAW.Reg)&^(0x2)|value<<1)
}
func (o *SENS_Type) GetSAR_COCPU_INT_RAW_COCPU_TOUCH_INACTIVE_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.SAR_COCPU_INT_RAW.Reg) & 0x2) >> 1
}
func (o *SENS_Type) SetSAR_COCPU_INT_RAW_COCPU_TOUCH_ACTIVE_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.SAR_COCPU_INT_RAW.Reg, volatile.LoadUint32(&o.SAR_COCPU_INT_RAW.Reg)&^(0x4)|value<<2)
}
func (o *SENS_Type) GetSAR_COCPU_INT_RAW_COCPU_TOUCH_ACTIVE_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.SAR_COCPU_INT_RAW.Reg) & 0x4) >> 2
}
func (o *SENS_Type) SetSAR_COCPU_INT_RAW_COCPU_SARADC1_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.SAR_COCPU_INT_RAW.Reg, volatile.LoadUint32(&o.SAR_COCPU_INT_RAW.Reg)&^(0x8)|value<<3)
}
func (o *SENS_Type) GetSAR_COCPU_INT_RAW_COCPU_SARADC1_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.SAR_COCPU_INT_RAW.Reg) & 0x8) >> 3
}
func (o *SENS_Type) SetSAR_COCPU_INT_RAW_COCPU_SARADC2_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.SAR_COCPU_INT_RAW.Reg, volatile.LoadUint32(&o.SAR_COCPU_INT_RAW.Reg)&^(0x10)|value<<4)
}
func (o *SENS_Type) GetSAR_COCPU_INT_RAW_COCPU_SARADC2_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.SAR_COCPU_INT_RAW.Reg) & 0x10) >> 4
}
func (o *SENS_Type) SetSAR_COCPU_INT_RAW_COCPU_TSENS_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.SAR_COCPU_INT_RAW.Reg, volatile.LoadUint32(&o.SAR_COCPU_INT_RAW.Reg)&^(0x20)|value<<5)
}
func (o *SENS_Type) GetSAR_COCPU_INT_RAW_COCPU_TSENS_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.SAR_COCPU_INT_RAW.Reg) & 0x20) >> 5
}
func (o *SENS_Type) SetSAR_COCPU_INT_RAW_COCPU_START_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.SAR_COCPU_INT_RAW.Reg, volatile.LoadUint32(&o.SAR_COCPU_INT_RAW.Reg)&^(0x40)|value<<6)
}
func (o *SENS_Type) GetSAR_COCPU_INT_RAW_COCPU_START_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.SAR_COCPU_INT_RAW.Reg) & 0x40) >> 6
}
func (o *SENS_Type) SetSAR_COCPU_INT_RAW_COCPU_SW_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.SAR_COCPU_INT_RAW.Reg, volatile.LoadUint32(&o.SAR_COCPU_INT_RAW.Reg)&^(0x80)|value<<7)
}
func (o *SENS_Type) GetSAR_COCPU_INT_RAW_COCPU_SW_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.SAR_COCPU_INT_RAW.Reg) & 0x80) >> 7
}
func (o *SENS_Type) SetSAR_COCPU_INT_RAW_COCPU_SWD_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.SAR_COCPU_INT_RAW.Reg, volatile.LoadUint32(&o.SAR_COCPU_INT_RAW.Reg)&^(0x100)|value<<8)
}
func (o *SENS_Type) GetSAR_COCPU_INT_RAW_COCPU_SWD_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.SAR_COCPU_INT_RAW.Reg) & 0x100) >> 8
}

// SENS.SAR_COCPU_INT_ENA: Interrupt enable bit of ULP-RISCV
func (o *SENS_Type) SetSAR_COCPU_INT_ENA_COCPU_TOUCH_DONE_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.SAR_COCPU_INT_ENA.Reg, volatile.LoadUint32(&o.SAR_COCPU_INT_ENA.Reg)&^(0x1)|value)
}
func (o *SENS_Type) GetSAR_COCPU_INT_ENA_COCPU_TOUCH_DONE_INT_ENA() uint32 {
	return volatile.LoadUint32(&o.SAR_COCPU_INT_ENA.Reg) & 0x1
}
func (o *SENS_Type) SetSAR_COCPU_INT_ENA_COCPU_TOUCH_INACTIVE_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.SAR_COCPU_INT_ENA.Reg, volatile.LoadUint32(&o.SAR_COCPU_INT_ENA.Reg)&^(0x2)|value<<1)
}
func (o *SENS_Type) GetSAR_COCPU_INT_ENA_COCPU_TOUCH_INACTIVE_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.SAR_COCPU_INT_ENA.Reg) & 0x2) >> 1
}
func (o *SENS_Type) SetSAR_COCPU_INT_ENA_COCPU_TOUCH_ACTIVE_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.SAR_COCPU_INT_ENA.Reg, volatile.LoadUint32(&o.SAR_COCPU_INT_ENA.Reg)&^(0x4)|value<<2)
}
func (o *SENS_Type) GetSAR_COCPU_INT_ENA_COCPU_TOUCH_ACTIVE_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.SAR_COCPU_INT_ENA.Reg) & 0x4) >> 2
}
func (o *SENS_Type) SetSAR_COCPU_INT_ENA_COCPU_SARADC1_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.SAR_COCPU_INT_ENA.Reg, volatile.LoadUint32(&o.SAR_COCPU_INT_ENA.Reg)&^(0x8)|value<<3)
}
func (o *SENS_Type) GetSAR_COCPU_INT_ENA_COCPU_SARADC1_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.SAR_COCPU_INT_ENA.Reg) & 0x8) >> 3
}
func (o *SENS_Type) SetSAR_COCPU_INT_ENA_COCPU_SARADC2_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.SAR_COCPU_INT_ENA.Reg, volatile.LoadUint32(&o.SAR_COCPU_INT_ENA.Reg)&^(0x10)|value<<4)
}
func (o *SENS_Type) GetSAR_COCPU_INT_ENA_COCPU_SARADC2_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.SAR_COCPU_INT_ENA.Reg) & 0x10) >> 4
}
func (o *SENS_Type) SetSAR_COCPU_INT_ENA_COCPU_TSENS_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.SAR_COCPU_INT_ENA.Reg, volatile.LoadUint32(&o.SAR_COCPU_INT_ENA.Reg)&^(0x20)|value<<5)
}
func (o *SENS_Type) GetSAR_COCPU_INT_ENA_COCPU_TSENS_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.SAR_COCPU_INT_ENA.Reg) & 0x20) >> 5
}
func (o *SENS_Type) SetSAR_COCPU_INT_ENA_COCPU_START_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.SAR_COCPU_INT_ENA.Reg, volatile.LoadUint32(&o.SAR_COCPU_INT_ENA.Reg)&^(0x40)|value<<6)
}
func (o *SENS_Type) GetSAR_COCPU_INT_ENA_COCPU_START_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.SAR_COCPU_INT_ENA.Reg) & 0x40) >> 6
}
func (o *SENS_Type) SetSAR_COCPU_INT_ENA_COCPU_SW_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.SAR_COCPU_INT_ENA.Reg, volatile.LoadUint32(&o.SAR_COCPU_INT_ENA.Reg)&^(0x80)|value<<7)
}
func (o *SENS_Type) GetSAR_COCPU_INT_ENA_COCPU_SW_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.SAR_COCPU_INT_ENA.Reg) & 0x80) >> 7
}
func (o *SENS_Type) SetSAR_COCPU_INT_ENA_COCPU_SWD_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.SAR_COCPU_INT_ENA.Reg, volatile.LoadUint32(&o.SAR_COCPU_INT_ENA.Reg)&^(0x100)|value<<8)
}
func (o *SENS_Type) GetSAR_COCPU_INT_ENA_COCPU_SWD_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.SAR_COCPU_INT_ENA.Reg) & 0x100) >> 8
}

// SENS.SAR_COCPU_INT_ST: Interrupt status bit of ULP-RISCV
func (o *SENS_Type) SetSAR_COCPU_INT_ST_COCPU_TOUCH_DONE_INT_ST(value uint32) {
	volatile.StoreUint32(&o.SAR_COCPU_INT_ST.Reg, volatile.LoadUint32(&o.SAR_COCPU_INT_ST.Reg)&^(0x1)|value)
}
func (o *SENS_Type) GetSAR_COCPU_INT_ST_COCPU_TOUCH_DONE_INT_ST() uint32 {
	return volatile.LoadUint32(&o.SAR_COCPU_INT_ST.Reg) & 0x1
}
func (o *SENS_Type) SetSAR_COCPU_INT_ST_COCPU_TOUCH_INACTIVE_INT_ST(value uint32) {
	volatile.StoreUint32(&o.SAR_COCPU_INT_ST.Reg, volatile.LoadUint32(&o.SAR_COCPU_INT_ST.Reg)&^(0x2)|value<<1)
}
func (o *SENS_Type) GetSAR_COCPU_INT_ST_COCPU_TOUCH_INACTIVE_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.SAR_COCPU_INT_ST.Reg) & 0x2) >> 1
}
func (o *SENS_Type) SetSAR_COCPU_INT_ST_COCPU_TOUCH_ACTIVE_INT_ST(value uint32) {
	volatile.StoreUint32(&o.SAR_COCPU_INT_ST.Reg, volatile.LoadUint32(&o.SAR_COCPU_INT_ST.Reg)&^(0x4)|value<<2)
}
func (o *SENS_Type) GetSAR_COCPU_INT_ST_COCPU_TOUCH_ACTIVE_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.SAR_COCPU_INT_ST.Reg) & 0x4) >> 2
}
func (o *SENS_Type) SetSAR_COCPU_INT_ST_COCPU_SARADC1_INT_ST(value uint32) {
	volatile.StoreUint32(&o.SAR_COCPU_INT_ST.Reg, volatile.LoadUint32(&o.SAR_COCPU_INT_ST.Reg)&^(0x8)|value<<3)
}
func (o *SENS_Type) GetSAR_COCPU_INT_ST_COCPU_SARADC1_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.SAR_COCPU_INT_ST.Reg) & 0x8) >> 3
}
func (o *SENS_Type) SetSAR_COCPU_INT_ST_COCPU_SARADC2_INT_ST(value uint32) {
	volatile.StoreUint32(&o.SAR_COCPU_INT_ST.Reg, volatile.LoadUint32(&o.SAR_COCPU_INT_ST.Reg)&^(0x10)|value<<4)
}
func (o *SENS_Type) GetSAR_COCPU_INT_ST_COCPU_SARADC2_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.SAR_COCPU_INT_ST.Reg) & 0x10) >> 4
}
func (o *SENS_Type) SetSAR_COCPU_INT_ST_COCPU_TSENS_INT_ST(value uint32) {
	volatile.StoreUint32(&o.SAR_COCPU_INT_ST.Reg, volatile.LoadUint32(&o.SAR_COCPU_INT_ST.Reg)&^(0x20)|value<<5)
}
func (o *SENS_Type) GetSAR_COCPU_INT_ST_COCPU_TSENS_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.SAR_COCPU_INT_ST.Reg) & 0x20) >> 5
}
func (o *SENS_Type) SetSAR_COCPU_INT_ST_COCPU_START_INT_ST(value uint32) {
	volatile.StoreUint32(&o.SAR_COCPU_INT_ST.Reg, volatile.LoadUint32(&o.SAR_COCPU_INT_ST.Reg)&^(0x40)|value<<6)
}
func (o *SENS_Type) GetSAR_COCPU_INT_ST_COCPU_START_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.SAR_COCPU_INT_ST.Reg) & 0x40) >> 6
}
func (o *SENS_Type) SetSAR_COCPU_INT_ST_COCPU_SW_INT_ST(value uint32) {
	volatile.StoreUint32(&o.SAR_COCPU_INT_ST.Reg, volatile.LoadUint32(&o.SAR_COCPU_INT_ST.Reg)&^(0x80)|value<<7)
}
func (o *SENS_Type) GetSAR_COCPU_INT_ST_COCPU_SW_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.SAR_COCPU_INT_ST.Reg) & 0x80) >> 7
}
func (o *SENS_Type) SetSAR_COCPU_INT_ST_COCPU_SWD_INT_ST(value uint32) {
	volatile.StoreUint32(&o.SAR_COCPU_INT_ST.Reg, volatile.LoadUint32(&o.SAR_COCPU_INT_ST.Reg)&^(0x100)|value<<8)
}
func (o *SENS_Type) GetSAR_COCPU_INT_ST_COCPU_SWD_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.SAR_COCPU_INT_ST.Reg) & 0x100) >> 8
}

// SENS.SAR_COCPU_INT_CLR: Interrupt clear bit of ULP-RISCV
func (o *SENS_Type) SetSAR_COCPU_INT_CLR_COCPU_TOUCH_DONE_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.SAR_COCPU_INT_CLR.Reg, volatile.LoadUint32(&o.SAR_COCPU_INT_CLR.Reg)&^(0x1)|value)
}
func (o *SENS_Type) GetSAR_COCPU_INT_CLR_COCPU_TOUCH_DONE_INT_CLR() uint32 {
	return volatile.LoadUint32(&o.SAR_COCPU_INT_CLR.Reg) & 0x1
}
func (o *SENS_Type) SetSAR_COCPU_INT_CLR_COCPU_TOUCH_INACTIVE_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.SAR_COCPU_INT_CLR.Reg, volatile.LoadUint32(&o.SAR_COCPU_INT_CLR.Reg)&^(0x2)|value<<1)
}
func (o *SENS_Type) GetSAR_COCPU_INT_CLR_COCPU_TOUCH_INACTIVE_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.SAR_COCPU_INT_CLR.Reg) & 0x2) >> 1
}
func (o *SENS_Type) SetSAR_COCPU_INT_CLR_COCPU_TOUCH_ACTIVE_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.SAR_COCPU_INT_CLR.Reg, volatile.LoadUint32(&o.SAR_COCPU_INT_CLR.Reg)&^(0x4)|value<<2)
}
func (o *SENS_Type) GetSAR_COCPU_INT_CLR_COCPU_TOUCH_ACTIVE_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.SAR_COCPU_INT_CLR.Reg) & 0x4) >> 2
}
func (o *SENS_Type) SetSAR_COCPU_INT_CLR_COCPU_SARADC1_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.SAR_COCPU_INT_CLR.Reg, volatile.LoadUint32(&o.SAR_COCPU_INT_CLR.Reg)&^(0x8)|value<<3)
}
func (o *SENS_Type) GetSAR_COCPU_INT_CLR_COCPU_SARADC1_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.SAR_COCPU_INT_CLR.Reg) & 0x8) >> 3
}
func (o *SENS_Type) SetSAR_COCPU_INT_CLR_COCPU_SARADC2_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.SAR_COCPU_INT_CLR.Reg, volatile.LoadUint32(&o.SAR_COCPU_INT_CLR.Reg)&^(0x10)|value<<4)
}
func (o *SENS_Type) GetSAR_COCPU_INT_CLR_COCPU_SARADC2_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.SAR_COCPU_INT_CLR.Reg) & 0x10) >> 4
}
func (o *SENS_Type) SetSAR_COCPU_INT_CLR_COCPU_TSENS_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.SAR_COCPU_INT_CLR.Reg, volatile.LoadUint32(&o.SAR_COCPU_INT_CLR.Reg)&^(0x20)|value<<5)
}
func (o *SENS_Type) GetSAR_COCPU_INT_CLR_COCPU_TSENS_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.SAR_COCPU_INT_CLR.Reg) & 0x20) >> 5
}
func (o *SENS_Type) SetSAR_COCPU_INT_CLR_COCPU_START_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.SAR_COCPU_INT_CLR.Reg, volatile.LoadUint32(&o.SAR_COCPU_INT_CLR.Reg)&^(0x40)|value<<6)
}
func (o *SENS_Type) GetSAR_COCPU_INT_CLR_COCPU_START_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.SAR_COCPU_INT_CLR.Reg) & 0x40) >> 6
}
func (o *SENS_Type) SetSAR_COCPU_INT_CLR_COCPU_SW_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.SAR_COCPU_INT_CLR.Reg, volatile.LoadUint32(&o.SAR_COCPU_INT_CLR.Reg)&^(0x80)|value<<7)
}
func (o *SENS_Type) GetSAR_COCPU_INT_CLR_COCPU_SW_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.SAR_COCPU_INT_CLR.Reg) & 0x80) >> 7
}
func (o *SENS_Type) SetSAR_COCPU_INT_CLR_COCPU_SWD_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.SAR_COCPU_INT_CLR.Reg, volatile.LoadUint32(&o.SAR_COCPU_INT_CLR.Reg)&^(0x100)|value<<8)
}
func (o *SENS_Type) GetSAR_COCPU_INT_CLR_COCPU_SWD_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.SAR_COCPU_INT_CLR.Reg) & 0x100) >> 8
}

// SENS.SAR_COCPU_DEBUG: ULP-RISCV debug register
func (o *SENS_Type) SetSAR_COCPU_DEBUG_COCPU_PC(value uint32) {
	volatile.StoreUint32(&o.SAR_COCPU_DEBUG.Reg, volatile.LoadUint32(&o.SAR_COCPU_DEBUG.Reg)&^(0x1fff)|value)
}
func (o *SENS_Type) GetSAR_COCPU_DEBUG_COCPU_PC() uint32 {
	return volatile.LoadUint32(&o.SAR_COCPU_DEBUG.Reg) & 0x1fff
}
func (o *SENS_Type) SetSAR_COCPU_DEBUG_COCPU_MEM_VLD(value uint32) {
	volatile.StoreUint32(&o.SAR_COCPU_DEBUG.Reg, volatile.LoadUint32(&o.SAR_COCPU_DEBUG.Reg)&^(0x2000)|value<<13)
}
func (o *SENS_Type) GetSAR_COCPU_DEBUG_COCPU_MEM_VLD() uint32 {
	return (volatile.LoadUint32(&o.SAR_COCPU_DEBUG.Reg) & 0x2000) >> 13
}
func (o *SENS_Type) SetSAR_COCPU_DEBUG_COCPU_MEM_RDY(value uint32) {
	volatile.StoreUint32(&o.SAR_COCPU_DEBUG.Reg, volatile.LoadUint32(&o.SAR_COCPU_DEBUG.Reg)&^(0x4000)|value<<14)
}
func (o *SENS_Type) GetSAR_COCPU_DEBUG_COCPU_MEM_RDY() uint32 {
	return (volatile.LoadUint32(&o.SAR_COCPU_DEBUG.Reg) & 0x4000) >> 14
}
func (o *SENS_Type) SetSAR_COCPU_DEBUG_COCPU_MEM_WEN(value uint32) {
	volatile.StoreUint32(&o.SAR_COCPU_DEBUG.Reg, volatile.LoadUint32(&o.SAR_COCPU_DEBUG.Reg)&^(0x78000)|value<<15)
}
func (o *SENS_Type) GetSAR_COCPU_DEBUG_COCPU_MEM_WEN() uint32 {
	return (volatile.LoadUint32(&o.SAR_COCPU_DEBUG.Reg) & 0x78000) >> 15
}
func (o *SENS_Type) SetSAR_COCPU_DEBUG_COCPU_MEM_ADDR(value uint32) {
	volatile.StoreUint32(&o.SAR_COCPU_DEBUG.Reg, volatile.LoadUint32(&o.SAR_COCPU_DEBUG.Reg)&^(0xfff80000)|value<<19)
}
func (o *SENS_Type) GetSAR_COCPU_DEBUG_COCPU_MEM_ADDR() uint32 {
	return (volatile.LoadUint32(&o.SAR_COCPU_DEBUG.Reg) & 0xfff80000) >> 19
}

// SENS.SAR_HALL_CTRL: hall control
func (o *SENS_Type) SetSAR_HALL_CTRL_XPD_HALL(value uint32) {
	volatile.StoreUint32(&o.SAR_HALL_CTRL.Reg, volatile.LoadUint32(&o.SAR_HALL_CTRL.Reg)&^(0x10000000)|value<<28)
}
func (o *SENS_Type) GetSAR_HALL_CTRL_XPD_HALL() uint32 {
	return (volatile.LoadUint32(&o.SAR_HALL_CTRL.Reg) & 0x10000000) >> 28
}
func (o *SENS_Type) SetSAR_HALL_CTRL_XPD_HALL_FORCE(value uint32) {
	volatile.StoreUint32(&o.SAR_HALL_CTRL.Reg, volatile.LoadUint32(&o.SAR_HALL_CTRL.Reg)&^(0x20000000)|value<<29)
}
func (o *SENS_Type) GetSAR_HALL_CTRL_XPD_HALL_FORCE() uint32 {
	return (volatile.LoadUint32(&o.SAR_HALL_CTRL.Reg) & 0x20000000) >> 29
}
func (o *SENS_Type) SetSAR_HALL_CTRL_HALL_PHASE(value uint32) {
	volatile.StoreUint32(&o.SAR_HALL_CTRL.Reg, volatile.LoadUint32(&o.SAR_HALL_CTRL.Reg)&^(0x40000000)|value<<30)
}
func (o *SENS_Type) GetSAR_HALL_CTRL_HALL_PHASE() uint32 {
	return (volatile.LoadUint32(&o.SAR_HALL_CTRL.Reg) & 0x40000000) >> 30
}
func (o *SENS_Type) SetSAR_HALL_CTRL_HALL_PHASE_FORCE(value uint32) {
	volatile.StoreUint32(&o.SAR_HALL_CTRL.Reg, volatile.LoadUint32(&o.SAR_HALL_CTRL.Reg)&^(0x80000000)|value<<31)
}
func (o *SENS_Type) GetSAR_HALL_CTRL_HALL_PHASE_FORCE() uint32 {
	return (volatile.LoadUint32(&o.SAR_HALL_CTRL.Reg) & 0x80000000) >> 31
}

// SENS.SAR_NOUSE: sar nouse
func (o *SENS_Type) SetSAR_NOUSE(value uint32) {
	volatile.StoreUint32(&o.SAR_NOUSE.Reg, value)
}
func (o *SENS_Type) GetSAR_NOUSE() uint32 {
	return volatile.LoadUint32(&o.SAR_NOUSE.Reg)
}

// SENS.SAR_IO_MUX_CONF: Configure and reset IO MUX
func (o *SENS_Type) SetSAR_IO_MUX_CONF_IOMUX_RESET(value uint32) {
	volatile.StoreUint32(&o.SAR_IO_MUX_CONF.Reg, volatile.LoadUint32(&o.SAR_IO_MUX_CONF.Reg)&^(0x40000000)|value<<30)
}
func (o *SENS_Type) GetSAR_IO_MUX_CONF_IOMUX_RESET() uint32 {
	return (volatile.LoadUint32(&o.SAR_IO_MUX_CONF.Reg) & 0x40000000) >> 30
}
func (o *SENS_Type) SetSAR_IO_MUX_CONF_IOMUX_CLK_GATE_EN(value uint32) {
	volatile.StoreUint32(&o.SAR_IO_MUX_CONF.Reg, volatile.LoadUint32(&o.SAR_IO_MUX_CONF.Reg)&^(0x80000000)|value<<31)
}
func (o *SENS_Type) GetSAR_IO_MUX_CONF_IOMUX_CLK_GATE_EN() uint32 {
	return (volatile.LoadUint32(&o.SAR_IO_MUX_CONF.Reg) & 0x80000000) >> 31
}

// SENS.SARDATE: Version Control Register
func (o *SENS_Type) SetSARDATE_SAR_DATE(value uint32) {
	volatile.StoreUint32(&o.SARDATE.Reg, volatile.LoadUint32(&o.SARDATE.Reg)&^(0xfffffff)|value)
}
func (o *SENS_Type) GetSARDATE_SAR_DATE() uint32 {
	return volatile.LoadUint32(&o.SARDATE.Reg) & 0xfffffff
}

// Peripheral SHA
type SHA_Type struct {
	MODE          volatile.Register32 // 0x0
	T_STRING      volatile.Register32 // 0x4
	T_LENGTH      volatile.Register32 // 0x8
	DMA_BLOCK_NUM volatile.Register32 // 0xC
	START         volatile.Register32 // 0x10
	CONTINUE_OP   volatile.Register32 // 0x14
	BUSY          volatile.Register32 // 0x18
	DMA_START     volatile.Register32 // 0x1C
	DMA_CONTINUE  volatile.Register32 // 0x20
	INT_CLEAR     volatile.Register32 // 0x24
	INT_ENA       volatile.Register32 // 0x28
	DATE          volatile.Register32 // 0x2C
	_             [16]byte
	H_0           volatile.Register32 // 0x40
	H_1           volatile.Register32 // 0x44
	H_2           volatile.Register32 // 0x48
	H_3           volatile.Register32 // 0x4C
	H_4           volatile.Register32 // 0x50
	H_5           volatile.Register32 // 0x54
	H_6           volatile.Register32 // 0x58
	H_7           volatile.Register32 // 0x5C
	H_8           volatile.Register32 // 0x60
	H_9           volatile.Register32 // 0x64
	H_10          volatile.Register32 // 0x68
	H_11          volatile.Register32 // 0x6C
	H_12          volatile.Register32 // 0x70
	H_13          volatile.Register32 // 0x74
	H_14          volatile.Register32 // 0x78
	H_15          volatile.Register32 // 0x7C
	M_0           volatile.Register32 // 0x80
	M_1           volatile.Register32 // 0x84
	M_2           volatile.Register32 // 0x88
	M_3           volatile.Register32 // 0x8C
	M_4           volatile.Register32 // 0x90
	M_5           volatile.Register32 // 0x94
	M_6           volatile.Register32 // 0x98
	M_7           volatile.Register32 // 0x9C
	M_8           volatile.Register32 // 0xA0
	M_9           volatile.Register32 // 0xA4
	M_10          volatile.Register32 // 0xA8
	M_11          volatile.Register32 // 0xAC
	M_12          volatile.Register32 // 0xB0
	M_13          volatile.Register32 // 0xB4
	M_14          volatile.Register32 // 0xB8
	M_15          volatile.Register32 // 0xBC
	M_16          volatile.Register32 // 0xC0
	M_17          volatile.Register32 // 0xC4
	M_18          volatile.Register32 // 0xC8
	M_19          volatile.Register32 // 0xCC
	M_20          volatile.Register32 // 0xD0
	M_21          volatile.Register32 // 0xD4
	M_22          volatile.Register32 // 0xD8
	M_23          volatile.Register32 // 0xDC
	M_24          volatile.Register32 // 0xE0
	M_25          volatile.Register32 // 0xE4
	M_26          volatile.Register32 // 0xE8
	M_27          volatile.Register32 // 0xEC
	M_28          volatile.Register32 // 0xF0
	M_29          volatile.Register32 // 0xF4
	M_30          volatile.Register32 // 0xF8
	M_31          volatile.Register32 // 0xFC
}

// SHA.MODE: Defines the algorithm of SHA accelerator
func (o *SHA_Type) SetMODE(value uint32) {
	volatile.StoreUint32(&o.MODE.Reg, volatile.LoadUint32(&o.MODE.Reg)&^(0x7)|value)
}
func (o *SHA_Type) GetMODE() uint32 {
	return volatile.LoadUint32(&o.MODE.Reg) & 0x7
}

// SHA.T_STRING: String content register for calculating initial Hash Value (only effective for SHA-512/t)
func (o *SHA_Type) SetT_STRING(value uint32) {
	volatile.StoreUint32(&o.T_STRING.Reg, value)
}
func (o *SHA_Type) GetT_STRING() uint32 {
	return volatile.LoadUint32(&o.T_STRING.Reg)
}

// SHA.T_LENGTH: String length register for calculating initial Hash Value (only effective for SHA-512/t)
func (o *SHA_Type) SetT_LENGTH(value uint32) {
	volatile.StoreUint32(&o.T_LENGTH.Reg, volatile.LoadUint32(&o.T_LENGTH.Reg)&^(0x3f)|value)
}
func (o *SHA_Type) GetT_LENGTH() uint32 {
	return volatile.LoadUint32(&o.T_LENGTH.Reg) & 0x3f
}

// SHA.DMA_BLOCK_NUM: Block number register (only effective for DMA-SHA)
func (o *SHA_Type) SetDMA_BLOCK_NUM(value uint32) {
	volatile.StoreUint32(&o.DMA_BLOCK_NUM.Reg, volatile.LoadUint32(&o.DMA_BLOCK_NUM.Reg)&^(0x3f)|value)
}
func (o *SHA_Type) GetDMA_BLOCK_NUM() uint32 {
	return volatile.LoadUint32(&o.DMA_BLOCK_NUM.Reg) & 0x3f
}

// SHA.START: Starts the SHA accelerator for Typical SHA operation
func (o *SHA_Type) SetSTART(value uint32) {
	volatile.StoreUint32(&o.START.Reg, volatile.LoadUint32(&o.START.Reg)&^(0x1)|value)
}
func (o *SHA_Type) GetSTART() uint32 {
	return volatile.LoadUint32(&o.START.Reg) & 0x1
}

// SHA.CONTINUE_OP: Continues SHA operation (only effective in Typical SHA mode)
func (o *SHA_Type) SetCONTINUE_OP(value uint32) {
	volatile.StoreUint32(&o.CONTINUE_OP.Reg, volatile.LoadUint32(&o.CONTINUE_OP.Reg)&^(0x1)|value)
}
func (o *SHA_Type) GetCONTINUE_OP() uint32 {
	return volatile.LoadUint32(&o.CONTINUE_OP.Reg) & 0x1
}

// SHA.BUSY: Indicates if SHA Accelerator is busy or not
func (o *SHA_Type) SetBUSY_STATE(value uint32) {
	volatile.StoreUint32(&o.BUSY.Reg, volatile.LoadUint32(&o.BUSY.Reg)&^(0x1)|value)
}
func (o *SHA_Type) GetBUSY_STATE() uint32 {
	return volatile.LoadUint32(&o.BUSY.Reg) & 0x1
}

// SHA.DMA_START: Starts the SHA accelerator for DMA-SHA operation
func (o *SHA_Type) SetDMA_START(value uint32) {
	volatile.StoreUint32(&o.DMA_START.Reg, volatile.LoadUint32(&o.DMA_START.Reg)&^(0x1)|value)
}
func (o *SHA_Type) GetDMA_START() uint32 {
	return volatile.LoadUint32(&o.DMA_START.Reg) & 0x1
}

// SHA.DMA_CONTINUE: Continues SHA operation (only effective in DMA-SHA mode)
func (o *SHA_Type) SetDMA_CONTINUE(value uint32) {
	volatile.StoreUint32(&o.DMA_CONTINUE.Reg, volatile.LoadUint32(&o.DMA_CONTINUE.Reg)&^(0x1)|value)
}
func (o *SHA_Type) GetDMA_CONTINUE() uint32 {
	return volatile.LoadUint32(&o.DMA_CONTINUE.Reg) & 0x1
}

// SHA.INT_CLEAR: DMA-SHA interrupt clear register
func (o *SHA_Type) SetINT_CLEAR_CLEAR_INTERRUPT(value uint32) {
	volatile.StoreUint32(&o.INT_CLEAR.Reg, volatile.LoadUint32(&o.INT_CLEAR.Reg)&^(0x1)|value)
}
func (o *SHA_Type) GetINT_CLEAR_CLEAR_INTERRUPT() uint32 {
	return volatile.LoadUint32(&o.INT_CLEAR.Reg) & 0x1
}

// SHA.INT_ENA: DMA-SHA interrupt enable register
func (o *SHA_Type) SetINT_ENA_INTERRUPT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x1)|value)
}
func (o *SHA_Type) GetINT_ENA_INTERRUPT_ENA() uint32 {
	return volatile.LoadUint32(&o.INT_ENA.Reg) & 0x1
}

// SHA.DATE: Version control register.
func (o *SHA_Type) SetDATE(value uint32) {
	volatile.StoreUint32(&o.DATE.Reg, volatile.LoadUint32(&o.DATE.Reg)&^(0x3fffffff)|value)
}
func (o *SHA_Type) GetDATE() uint32 {
	return volatile.LoadUint32(&o.DATE.Reg) & 0x3fffffff
}

// SHA.H_0: Hash value
func (o *SHA_Type) SetH_0(value uint32) {
	volatile.StoreUint32(&o.H_0.Reg, value)
}
func (o *SHA_Type) GetH_0() uint32 {
	return volatile.LoadUint32(&o.H_0.Reg)
}

// SHA.H_1: Hash value
func (o *SHA_Type) SetH_1(value uint32) {
	volatile.StoreUint32(&o.H_1.Reg, value)
}
func (o *SHA_Type) GetH_1() uint32 {
	return volatile.LoadUint32(&o.H_1.Reg)
}

// SHA.H_2: Hash value
func (o *SHA_Type) SetH_2(value uint32) {
	volatile.StoreUint32(&o.H_2.Reg, value)
}
func (o *SHA_Type) GetH_2() uint32 {
	return volatile.LoadUint32(&o.H_2.Reg)
}

// SHA.H_3: Hash value
func (o *SHA_Type) SetH_3(value uint32) {
	volatile.StoreUint32(&o.H_3.Reg, value)
}
func (o *SHA_Type) GetH_3() uint32 {
	return volatile.LoadUint32(&o.H_3.Reg)
}

// SHA.H_4: Hash value
func (o *SHA_Type) SetH_4(value uint32) {
	volatile.StoreUint32(&o.H_4.Reg, value)
}
func (o *SHA_Type) GetH_4() uint32 {
	return volatile.LoadUint32(&o.H_4.Reg)
}

// SHA.H_5: Hash value
func (o *SHA_Type) SetH_5(value uint32) {
	volatile.StoreUint32(&o.H_5.Reg, value)
}
func (o *SHA_Type) GetH_5() uint32 {
	return volatile.LoadUint32(&o.H_5.Reg)
}

// SHA.H_6: Hash value
func (o *SHA_Type) SetH_6(value uint32) {
	volatile.StoreUint32(&o.H_6.Reg, value)
}
func (o *SHA_Type) GetH_6() uint32 {
	return volatile.LoadUint32(&o.H_6.Reg)
}

// SHA.H_7: Hash value
func (o *SHA_Type) SetH_7(value uint32) {
	volatile.StoreUint32(&o.H_7.Reg, value)
}
func (o *SHA_Type) GetH_7() uint32 {
	return volatile.LoadUint32(&o.H_7.Reg)
}

// SHA.H_8: Hash value
func (o *SHA_Type) SetH_8(value uint32) {
	volatile.StoreUint32(&o.H_8.Reg, value)
}
func (o *SHA_Type) GetH_8() uint32 {
	return volatile.LoadUint32(&o.H_8.Reg)
}

// SHA.H_9: Hash value
func (o *SHA_Type) SetH_9(value uint32) {
	volatile.StoreUint32(&o.H_9.Reg, value)
}
func (o *SHA_Type) GetH_9() uint32 {
	return volatile.LoadUint32(&o.H_9.Reg)
}

// SHA.H_10: Hash value
func (o *SHA_Type) SetH_10(value uint32) {
	volatile.StoreUint32(&o.H_10.Reg, value)
}
func (o *SHA_Type) GetH_10() uint32 {
	return volatile.LoadUint32(&o.H_10.Reg)
}

// SHA.H_11: Hash value
func (o *SHA_Type) SetH_11(value uint32) {
	volatile.StoreUint32(&o.H_11.Reg, value)
}
func (o *SHA_Type) GetH_11() uint32 {
	return volatile.LoadUint32(&o.H_11.Reg)
}

// SHA.H_12: Hash value
func (o *SHA_Type) SetH_12(value uint32) {
	volatile.StoreUint32(&o.H_12.Reg, value)
}
func (o *SHA_Type) GetH_12() uint32 {
	return volatile.LoadUint32(&o.H_12.Reg)
}

// SHA.H_13: Hash value
func (o *SHA_Type) SetH_13(value uint32) {
	volatile.StoreUint32(&o.H_13.Reg, value)
}
func (o *SHA_Type) GetH_13() uint32 {
	return volatile.LoadUint32(&o.H_13.Reg)
}

// SHA.H_14: Hash value
func (o *SHA_Type) SetH_14(value uint32) {
	volatile.StoreUint32(&o.H_14.Reg, value)
}
func (o *SHA_Type) GetH_14() uint32 {
	return volatile.LoadUint32(&o.H_14.Reg)
}

// SHA.H_15: Hash value
func (o *SHA_Type) SetH_15(value uint32) {
	volatile.StoreUint32(&o.H_15.Reg, value)
}
func (o *SHA_Type) GetH_15() uint32 {
	return volatile.LoadUint32(&o.H_15.Reg)
}

// SHA.M_0: Message
func (o *SHA_Type) SetM_0(value uint32) {
	volatile.StoreUint32(&o.M_0.Reg, value)
}
func (o *SHA_Type) GetM_0() uint32 {
	return volatile.LoadUint32(&o.M_0.Reg)
}

// SHA.M_1: Message
func (o *SHA_Type) SetM_1(value uint32) {
	volatile.StoreUint32(&o.M_1.Reg, value)
}
func (o *SHA_Type) GetM_1() uint32 {
	return volatile.LoadUint32(&o.M_1.Reg)
}

// SHA.M_2: Message
func (o *SHA_Type) SetM_2(value uint32) {
	volatile.StoreUint32(&o.M_2.Reg, value)
}
func (o *SHA_Type) GetM_2() uint32 {
	return volatile.LoadUint32(&o.M_2.Reg)
}

// SHA.M_3: Message
func (o *SHA_Type) SetM_3(value uint32) {
	volatile.StoreUint32(&o.M_3.Reg, value)
}
func (o *SHA_Type) GetM_3() uint32 {
	return volatile.LoadUint32(&o.M_3.Reg)
}

// SHA.M_4: Message
func (o *SHA_Type) SetM_4(value uint32) {
	volatile.StoreUint32(&o.M_4.Reg, value)
}
func (o *SHA_Type) GetM_4() uint32 {
	return volatile.LoadUint32(&o.M_4.Reg)
}

// SHA.M_5: Message
func (o *SHA_Type) SetM_5(value uint32) {
	volatile.StoreUint32(&o.M_5.Reg, value)
}
func (o *SHA_Type) GetM_5() uint32 {
	return volatile.LoadUint32(&o.M_5.Reg)
}

// SHA.M_6: Message
func (o *SHA_Type) SetM_6(value uint32) {
	volatile.StoreUint32(&o.M_6.Reg, value)
}
func (o *SHA_Type) GetM_6() uint32 {
	return volatile.LoadUint32(&o.M_6.Reg)
}

// SHA.M_7: Message
func (o *SHA_Type) SetM_7(value uint32) {
	volatile.StoreUint32(&o.M_7.Reg, value)
}
func (o *SHA_Type) GetM_7() uint32 {
	return volatile.LoadUint32(&o.M_7.Reg)
}

// SHA.M_8: Message
func (o *SHA_Type) SetM_8(value uint32) {
	volatile.StoreUint32(&o.M_8.Reg, value)
}
func (o *SHA_Type) GetM_8() uint32 {
	return volatile.LoadUint32(&o.M_8.Reg)
}

// SHA.M_9: Message
func (o *SHA_Type) SetM_9(value uint32) {
	volatile.StoreUint32(&o.M_9.Reg, value)
}
func (o *SHA_Type) GetM_9() uint32 {
	return volatile.LoadUint32(&o.M_9.Reg)
}

// SHA.M_10: Message
func (o *SHA_Type) SetM_10(value uint32) {
	volatile.StoreUint32(&o.M_10.Reg, value)
}
func (o *SHA_Type) GetM_10() uint32 {
	return volatile.LoadUint32(&o.M_10.Reg)
}

// SHA.M_11: Message
func (o *SHA_Type) SetM_11(value uint32) {
	volatile.StoreUint32(&o.M_11.Reg, value)
}
func (o *SHA_Type) GetM_11() uint32 {
	return volatile.LoadUint32(&o.M_11.Reg)
}

// SHA.M_12: Message
func (o *SHA_Type) SetM_12(value uint32) {
	volatile.StoreUint32(&o.M_12.Reg, value)
}
func (o *SHA_Type) GetM_12() uint32 {
	return volatile.LoadUint32(&o.M_12.Reg)
}

// SHA.M_13: Message
func (o *SHA_Type) SetM_13(value uint32) {
	volatile.StoreUint32(&o.M_13.Reg, value)
}
func (o *SHA_Type) GetM_13() uint32 {
	return volatile.LoadUint32(&o.M_13.Reg)
}

// SHA.M_14: Message
func (o *SHA_Type) SetM_14(value uint32) {
	volatile.StoreUint32(&o.M_14.Reg, value)
}
func (o *SHA_Type) GetM_14() uint32 {
	return volatile.LoadUint32(&o.M_14.Reg)
}

// SHA.M_15: Message
func (o *SHA_Type) SetM_15(value uint32) {
	volatile.StoreUint32(&o.M_15.Reg, value)
}
func (o *SHA_Type) GetM_15() uint32 {
	return volatile.LoadUint32(&o.M_15.Reg)
}

// SHA.M_16: Message
func (o *SHA_Type) SetM_16(value uint32) {
	volatile.StoreUint32(&o.M_16.Reg, value)
}
func (o *SHA_Type) GetM_16() uint32 {
	return volatile.LoadUint32(&o.M_16.Reg)
}

// SHA.M_17: Message
func (o *SHA_Type) SetM_17(value uint32) {
	volatile.StoreUint32(&o.M_17.Reg, value)
}
func (o *SHA_Type) GetM_17() uint32 {
	return volatile.LoadUint32(&o.M_17.Reg)
}

// SHA.M_18: Message
func (o *SHA_Type) SetM_18(value uint32) {
	volatile.StoreUint32(&o.M_18.Reg, value)
}
func (o *SHA_Type) GetM_18() uint32 {
	return volatile.LoadUint32(&o.M_18.Reg)
}

// SHA.M_19: Message
func (o *SHA_Type) SetM_19(value uint32) {
	volatile.StoreUint32(&o.M_19.Reg, value)
}
func (o *SHA_Type) GetM_19() uint32 {
	return volatile.LoadUint32(&o.M_19.Reg)
}

// SHA.M_20: Message
func (o *SHA_Type) SetM_20(value uint32) {
	volatile.StoreUint32(&o.M_20.Reg, value)
}
func (o *SHA_Type) GetM_20() uint32 {
	return volatile.LoadUint32(&o.M_20.Reg)
}

// SHA.M_21: Message
func (o *SHA_Type) SetM_21(value uint32) {
	volatile.StoreUint32(&o.M_21.Reg, value)
}
func (o *SHA_Type) GetM_21() uint32 {
	return volatile.LoadUint32(&o.M_21.Reg)
}

// SHA.M_22: Message
func (o *SHA_Type) SetM_22(value uint32) {
	volatile.StoreUint32(&o.M_22.Reg, value)
}
func (o *SHA_Type) GetM_22() uint32 {
	return volatile.LoadUint32(&o.M_22.Reg)
}

// SHA.M_23: Message
func (o *SHA_Type) SetM_23(value uint32) {
	volatile.StoreUint32(&o.M_23.Reg, value)
}
func (o *SHA_Type) GetM_23() uint32 {
	return volatile.LoadUint32(&o.M_23.Reg)
}

// SHA.M_24: Message
func (o *SHA_Type) SetM_24(value uint32) {
	volatile.StoreUint32(&o.M_24.Reg, value)
}
func (o *SHA_Type) GetM_24() uint32 {
	return volatile.LoadUint32(&o.M_24.Reg)
}

// SHA.M_25: Message
func (o *SHA_Type) SetM_25(value uint32) {
	volatile.StoreUint32(&o.M_25.Reg, value)
}
func (o *SHA_Type) GetM_25() uint32 {
	return volatile.LoadUint32(&o.M_25.Reg)
}

// SHA.M_26: Message
func (o *SHA_Type) SetM_26(value uint32) {
	volatile.StoreUint32(&o.M_26.Reg, value)
}
func (o *SHA_Type) GetM_26() uint32 {
	return volatile.LoadUint32(&o.M_26.Reg)
}

// SHA.M_27: Message
func (o *SHA_Type) SetM_27(value uint32) {
	volatile.StoreUint32(&o.M_27.Reg, value)
}
func (o *SHA_Type) GetM_27() uint32 {
	return volatile.LoadUint32(&o.M_27.Reg)
}

// SHA.M_28: Message
func (o *SHA_Type) SetM_28(value uint32) {
	volatile.StoreUint32(&o.M_28.Reg, value)
}
func (o *SHA_Type) GetM_28() uint32 {
	return volatile.LoadUint32(&o.M_28.Reg)
}

// SHA.M_29: Message
func (o *SHA_Type) SetM_29(value uint32) {
	volatile.StoreUint32(&o.M_29.Reg, value)
}
func (o *SHA_Type) GetM_29() uint32 {
	return volatile.LoadUint32(&o.M_29.Reg)
}

// SHA.M_30: Message
func (o *SHA_Type) SetM_30(value uint32) {
	volatile.StoreUint32(&o.M_30.Reg, value)
}
func (o *SHA_Type) GetM_30() uint32 {
	return volatile.LoadUint32(&o.M_30.Reg)
}

// SHA.M_31: Message
func (o *SHA_Type) SetM_31(value uint32) {
	volatile.StoreUint32(&o.M_31.Reg, value)
}
func (o *SHA_Type) GetM_31() uint32 {
	return volatile.LoadUint32(&o.M_31.Reg)
}

// Peripheral SYSTEM
type SYSTEM_Type struct {
	ROM_CTRL_0                              volatile.Register32 // 0x0
	ROM_CTRL_1                              volatile.Register32 // 0x4
	SRAM_CTRL_0                             volatile.Register32 // 0x8
	SRAM_CTRL_1                             volatile.Register32 // 0xC
	CPU_PERI_CLK_EN                         volatile.Register32 // 0x10
	CPU_PERI_RST_EN                         volatile.Register32 // 0x14
	CPU_PER_CONF                            volatile.Register32 // 0x18
	JTAG_CTRL_0                             volatile.Register32 // 0x1C
	JTAG_CTRL_1                             volatile.Register32 // 0x20
	JTAG_CTRL_2                             volatile.Register32 // 0x24
	JTAG_CTRL_3                             volatile.Register32 // 0x28
	JTAG_CTRL_4                             volatile.Register32 // 0x2C
	JTAG_CTRL_5                             volatile.Register32 // 0x30
	JTAG_CTRL_6                             volatile.Register32 // 0x34
	JTAG_CTRL_7                             volatile.Register32 // 0x38
	MEM_PD_MASK                             volatile.Register32 // 0x3C
	PERIP_CLK_EN0                           volatile.Register32 // 0x40
	PERIP_CLK_EN1                           volatile.Register32 // 0x44
	PERIP_RST_EN0                           volatile.Register32 // 0x48
	PERIP_RST_EN1                           volatile.Register32 // 0x4C
	LPCK_DIV_INT                            volatile.Register32 // 0x50
	BT_LPCK_DIV_FRAC                        volatile.Register32 // 0x54
	CPU_INTR_FROM_CPU_0                     volatile.Register32 // 0x58
	CPU_INTR_FROM_CPU_1                     volatile.Register32 // 0x5C
	CPU_INTR_FROM_CPU_2                     volatile.Register32 // 0x60
	CPU_INTR_FROM_CPU_3                     volatile.Register32 // 0x64
	RSA_PD_CTRL                             volatile.Register32 // 0x68
	BUSTOEXTMEM_ENA                         volatile.Register32 // 0x6C
	CACHE_CONTROL                           volatile.Register32 // 0x70
	EXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL volatile.Register32 // 0x74
	RTC_FASTMEM_CONFIG                      volatile.Register32 // 0x78
	RTC_FASTMEM_CRC                         volatile.Register32 // 0x7C
	Redundant_ECO_Ctrl                      volatile.Register32 // 0x80
	CLOCK_GATE                              volatile.Register32 // 0x84
	SRAM_CTRL_2                             volatile.Register32 // 0x88
	SYSCLK_CONF                             volatile.Register32 // 0x8C
	_                                       [3948]byte
	REG_DATE                                volatile.Register32 // 0xFFC
}

// SYSTEM.ROM_CTRL_0: System ROM configuration register 0
func (o *SYSTEM_Type) SetROM_CTRL_0_ROM_FO(value uint32) {
	volatile.StoreUint32(&o.ROM_CTRL_0.Reg, volatile.LoadUint32(&o.ROM_CTRL_0.Reg)&^(0x3)|value)
}
func (o *SYSTEM_Type) GetROM_CTRL_0_ROM_FO() uint32 {
	return volatile.LoadUint32(&o.ROM_CTRL_0.Reg) & 0x3
}

// SYSTEM.ROM_CTRL_1: System ROM configuration register 1
func (o *SYSTEM_Type) SetROM_CTRL_1_ROM_FORCE_PD(value uint32) {
	volatile.StoreUint32(&o.ROM_CTRL_1.Reg, volatile.LoadUint32(&o.ROM_CTRL_1.Reg)&^(0x3)|value)
}
func (o *SYSTEM_Type) GetROM_CTRL_1_ROM_FORCE_PD() uint32 {
	return volatile.LoadUint32(&o.ROM_CTRL_1.Reg) & 0x3
}
func (o *SYSTEM_Type) SetROM_CTRL_1_ROM_FORCE_PU(value uint32) {
	volatile.StoreUint32(&o.ROM_CTRL_1.Reg, volatile.LoadUint32(&o.ROM_CTRL_1.Reg)&^(0xc)|value<<2)
}
func (o *SYSTEM_Type) GetROM_CTRL_1_ROM_FORCE_PU() uint32 {
	return (volatile.LoadUint32(&o.ROM_CTRL_1.Reg) & 0xc) >> 2
}

// SYSTEM.SRAM_CTRL_0: System SRAM configuration register 0
func (o *SYSTEM_Type) SetSRAM_CTRL_0_SRAM_FO(value uint32) {
	volatile.StoreUint32(&o.SRAM_CTRL_0.Reg, volatile.LoadUint32(&o.SRAM_CTRL_0.Reg)&^(0x3fffff)|value)
}
func (o *SYSTEM_Type) GetSRAM_CTRL_0_SRAM_FO() uint32 {
	return volatile.LoadUint32(&o.SRAM_CTRL_0.Reg) & 0x3fffff
}

// SYSTEM.SRAM_CTRL_1: System SRAM configuration register 1
func (o *SYSTEM_Type) SetSRAM_CTRL_1_SRAM_FORCE_PD(value uint32) {
	volatile.StoreUint32(&o.SRAM_CTRL_1.Reg, volatile.LoadUint32(&o.SRAM_CTRL_1.Reg)&^(0x3fffff)|value)
}
func (o *SYSTEM_Type) GetSRAM_CTRL_1_SRAM_FORCE_PD() uint32 {
	return volatile.LoadUint32(&o.SRAM_CTRL_1.Reg) & 0x3fffff
}

// SYSTEM.CPU_PERI_CLK_EN: CPU peripheral clock enable register
func (o *SYSTEM_Type) SetCPU_PERI_CLK_EN_CLK_EN_DEDICATED_GPIO(value uint32) {
	volatile.StoreUint32(&o.CPU_PERI_CLK_EN.Reg, volatile.LoadUint32(&o.CPU_PERI_CLK_EN.Reg)&^(0x80)|value<<7)
}
func (o *SYSTEM_Type) GetCPU_PERI_CLK_EN_CLK_EN_DEDICATED_GPIO() uint32 {
	return (volatile.LoadUint32(&o.CPU_PERI_CLK_EN.Reg) & 0x80) >> 7
}

// SYSTEM.CPU_PERI_RST_EN: CPU peripheral reset register
func (o *SYSTEM_Type) SetCPU_PERI_RST_EN_RST_EN_DEDICATED_GPIO(value uint32) {
	volatile.StoreUint32(&o.CPU_PERI_RST_EN.Reg, volatile.LoadUint32(&o.CPU_PERI_RST_EN.Reg)&^(0x80)|value<<7)
}
func (o *SYSTEM_Type) GetCPU_PERI_RST_EN_RST_EN_DEDICATED_GPIO() uint32 {
	return (volatile.LoadUint32(&o.CPU_PERI_RST_EN.Reg) & 0x80) >> 7
}

// SYSTEM.CPU_PER_CONF: CPU peripheral clock configuration register
func (o *SYSTEM_Type) SetCPU_PER_CONF_CPUPERIOD_SEL(value uint32) {
	volatile.StoreUint32(&o.CPU_PER_CONF.Reg, volatile.LoadUint32(&o.CPU_PER_CONF.Reg)&^(0x3)|value)
}
func (o *SYSTEM_Type) GetCPU_PER_CONF_CPUPERIOD_SEL() uint32 {
	return volatile.LoadUint32(&o.CPU_PER_CONF.Reg) & 0x3
}
func (o *SYSTEM_Type) SetCPU_PER_CONF_PLL_FREQ_SEL(value uint32) {
	volatile.StoreUint32(&o.CPU_PER_CONF.Reg, volatile.LoadUint32(&o.CPU_PER_CONF.Reg)&^(0x4)|value<<2)
}
func (o *SYSTEM_Type) GetCPU_PER_CONF_PLL_FREQ_SEL() uint32 {
	return (volatile.LoadUint32(&o.CPU_PER_CONF.Reg) & 0x4) >> 2
}
func (o *SYSTEM_Type) SetCPU_PER_CONF_CPU_WAIT_MODE_FORCE_ON(value uint32) {
	volatile.StoreUint32(&o.CPU_PER_CONF.Reg, volatile.LoadUint32(&o.CPU_PER_CONF.Reg)&^(0x8)|value<<3)
}
func (o *SYSTEM_Type) GetCPU_PER_CONF_CPU_WAIT_MODE_FORCE_ON() uint32 {
	return (volatile.LoadUint32(&o.CPU_PER_CONF.Reg) & 0x8) >> 3
}
func (o *SYSTEM_Type) SetCPU_PER_CONF_CPU_WAITI_DELAY_NUM(value uint32) {
	volatile.StoreUint32(&o.CPU_PER_CONF.Reg, volatile.LoadUint32(&o.CPU_PER_CONF.Reg)&^(0xf0)|value<<4)
}
func (o *SYSTEM_Type) GetCPU_PER_CONF_CPU_WAITI_DELAY_NUM() uint32 {
	return (volatile.LoadUint32(&o.CPU_PER_CONF.Reg) & 0xf0) >> 4
}

// SYSTEM.JTAG_CTRL_0: JTAG configuration register 0
func (o *SYSTEM_Type) SetJTAG_CTRL_0(value uint32) {
	volatile.StoreUint32(&o.JTAG_CTRL_0.Reg, value)
}
func (o *SYSTEM_Type) GetJTAG_CTRL_0() uint32 {
	return volatile.LoadUint32(&o.JTAG_CTRL_0.Reg)
}

// SYSTEM.JTAG_CTRL_1: JTAG configuration register 1
func (o *SYSTEM_Type) SetJTAG_CTRL_1(value uint32) {
	volatile.StoreUint32(&o.JTAG_CTRL_1.Reg, value)
}
func (o *SYSTEM_Type) GetJTAG_CTRL_1() uint32 {
	return volatile.LoadUint32(&o.JTAG_CTRL_1.Reg)
}

// SYSTEM.JTAG_CTRL_2: JTAG configuration register 2
func (o *SYSTEM_Type) SetJTAG_CTRL_2(value uint32) {
	volatile.StoreUint32(&o.JTAG_CTRL_2.Reg, value)
}
func (o *SYSTEM_Type) GetJTAG_CTRL_2() uint32 {
	return volatile.LoadUint32(&o.JTAG_CTRL_2.Reg)
}

// SYSTEM.JTAG_CTRL_3: JTAG configuration register 3
func (o *SYSTEM_Type) SetJTAG_CTRL_3(value uint32) {
	volatile.StoreUint32(&o.JTAG_CTRL_3.Reg, value)
}
func (o *SYSTEM_Type) GetJTAG_CTRL_3() uint32 {
	return volatile.LoadUint32(&o.JTAG_CTRL_3.Reg)
}

// SYSTEM.JTAG_CTRL_4: JTAG configuration register 4
func (o *SYSTEM_Type) SetJTAG_CTRL_4(value uint32) {
	volatile.StoreUint32(&o.JTAG_CTRL_4.Reg, value)
}
func (o *SYSTEM_Type) GetJTAG_CTRL_4() uint32 {
	return volatile.LoadUint32(&o.JTAG_CTRL_4.Reg)
}

// SYSTEM.JTAG_CTRL_5: JTAG configuration register 5
func (o *SYSTEM_Type) SetJTAG_CTRL_5(value uint32) {
	volatile.StoreUint32(&o.JTAG_CTRL_5.Reg, value)
}
func (o *SYSTEM_Type) GetJTAG_CTRL_5() uint32 {
	return volatile.LoadUint32(&o.JTAG_CTRL_5.Reg)
}

// SYSTEM.JTAG_CTRL_6: JTAG configuration register 6
func (o *SYSTEM_Type) SetJTAG_CTRL_6(value uint32) {
	volatile.StoreUint32(&o.JTAG_CTRL_6.Reg, value)
}
func (o *SYSTEM_Type) GetJTAG_CTRL_6() uint32 {
	return volatile.LoadUint32(&o.JTAG_CTRL_6.Reg)
}

// SYSTEM.JTAG_CTRL_7: JTAG configuration register 7
func (o *SYSTEM_Type) SetJTAG_CTRL_7(value uint32) {
	volatile.StoreUint32(&o.JTAG_CTRL_7.Reg, value)
}
func (o *SYSTEM_Type) GetJTAG_CTRL_7() uint32 {
	return volatile.LoadUint32(&o.JTAG_CTRL_7.Reg)
}

// SYSTEM.MEM_PD_MASK: Memory power-related controlling register (under low-sleep)
func (o *SYSTEM_Type) SetMEM_PD_MASK_LSLP_MEM_PD_MASK(value uint32) {
	volatile.StoreUint32(&o.MEM_PD_MASK.Reg, volatile.LoadUint32(&o.MEM_PD_MASK.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetMEM_PD_MASK_LSLP_MEM_PD_MASK() uint32 {
	return volatile.LoadUint32(&o.MEM_PD_MASK.Reg) & 0x1
}

// SYSTEM.PERIP_CLK_EN0: System peripheral clock (for hardware accelerators) enable register
func (o *SYSTEM_Type) SetPERIP_CLK_EN0_TIMERS_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.PERIP_CLK_EN0.Reg, volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetPERIP_CLK_EN0_TIMERS_CLK_EN() uint32 {
	return volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg) & 0x1
}
func (o *SYSTEM_Type) SetPERIP_CLK_EN0_SPI01_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.PERIP_CLK_EN0.Reg, volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg)&^(0x2)|value<<1)
}
func (o *SYSTEM_Type) GetPERIP_CLK_EN0_SPI01_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg) & 0x2) >> 1
}
func (o *SYSTEM_Type) SetPERIP_CLK_EN0_UART_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.PERIP_CLK_EN0.Reg, volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg)&^(0x4)|value<<2)
}
func (o *SYSTEM_Type) GetPERIP_CLK_EN0_UART_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg) & 0x4) >> 2
}
func (o *SYSTEM_Type) SetPERIP_CLK_EN0_WDG_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.PERIP_CLK_EN0.Reg, volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg)&^(0x8)|value<<3)
}
func (o *SYSTEM_Type) GetPERIP_CLK_EN0_WDG_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg) & 0x8) >> 3
}
func (o *SYSTEM_Type) SetPERIP_CLK_EN0_I2S0_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.PERIP_CLK_EN0.Reg, volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg)&^(0x10)|value<<4)
}
func (o *SYSTEM_Type) GetPERIP_CLK_EN0_I2S0_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg) & 0x10) >> 4
}
func (o *SYSTEM_Type) SetPERIP_CLK_EN0_UART1_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.PERIP_CLK_EN0.Reg, volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg)&^(0x20)|value<<5)
}
func (o *SYSTEM_Type) GetPERIP_CLK_EN0_UART1_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg) & 0x20) >> 5
}
func (o *SYSTEM_Type) SetPERIP_CLK_EN0_SPI2_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.PERIP_CLK_EN0.Reg, volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg)&^(0x40)|value<<6)
}
func (o *SYSTEM_Type) GetPERIP_CLK_EN0_SPI2_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg) & 0x40) >> 6
}
func (o *SYSTEM_Type) SetPERIP_CLK_EN0_I2C_EXT0_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.PERIP_CLK_EN0.Reg, volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg)&^(0x80)|value<<7)
}
func (o *SYSTEM_Type) GetPERIP_CLK_EN0_I2C_EXT0_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg) & 0x80) >> 7
}
func (o *SYSTEM_Type) SetPERIP_CLK_EN0_UHCI0_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.PERIP_CLK_EN0.Reg, volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg)&^(0x100)|value<<8)
}
func (o *SYSTEM_Type) GetPERIP_CLK_EN0_UHCI0_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg) & 0x100) >> 8
}
func (o *SYSTEM_Type) SetPERIP_CLK_EN0_RMT_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.PERIP_CLK_EN0.Reg, volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg)&^(0x200)|value<<9)
}
func (o *SYSTEM_Type) GetPERIP_CLK_EN0_RMT_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg) & 0x200) >> 9
}
func (o *SYSTEM_Type) SetPERIP_CLK_EN0_PCNT_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.PERIP_CLK_EN0.Reg, volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg)&^(0x400)|value<<10)
}
func (o *SYSTEM_Type) GetPERIP_CLK_EN0_PCNT_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg) & 0x400) >> 10
}
func (o *SYSTEM_Type) SetPERIP_CLK_EN0_LEDC_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.PERIP_CLK_EN0.Reg, volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg)&^(0x800)|value<<11)
}
func (o *SYSTEM_Type) GetPERIP_CLK_EN0_LEDC_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg) & 0x800) >> 11
}
func (o *SYSTEM_Type) SetPERIP_CLK_EN0_UHCI1_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.PERIP_CLK_EN0.Reg, volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg)&^(0x1000)|value<<12)
}
func (o *SYSTEM_Type) GetPERIP_CLK_EN0_UHCI1_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg) & 0x1000) >> 12
}
func (o *SYSTEM_Type) SetPERIP_CLK_EN0_TIMERGROUP_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.PERIP_CLK_EN0.Reg, volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg)&^(0x2000)|value<<13)
}
func (o *SYSTEM_Type) GetPERIP_CLK_EN0_TIMERGROUP_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg) & 0x2000) >> 13
}
func (o *SYSTEM_Type) SetPERIP_CLK_EN0_EFUSE_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.PERIP_CLK_EN0.Reg, volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg)&^(0x4000)|value<<14)
}
func (o *SYSTEM_Type) GetPERIP_CLK_EN0_EFUSE_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg) & 0x4000) >> 14
}
func (o *SYSTEM_Type) SetPERIP_CLK_EN0_TIMERGROUP1_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.PERIP_CLK_EN0.Reg, volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg)&^(0x8000)|value<<15)
}
func (o *SYSTEM_Type) GetPERIP_CLK_EN0_TIMERGROUP1_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg) & 0x8000) >> 15
}
func (o *SYSTEM_Type) SetPERIP_CLK_EN0_SPI3_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.PERIP_CLK_EN0.Reg, volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg)&^(0x10000)|value<<16)
}
func (o *SYSTEM_Type) GetPERIP_CLK_EN0_SPI3_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg) & 0x10000) >> 16
}
func (o *SYSTEM_Type) SetPERIP_CLK_EN0_PWM0_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.PERIP_CLK_EN0.Reg, volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg)&^(0x20000)|value<<17)
}
func (o *SYSTEM_Type) GetPERIP_CLK_EN0_PWM0_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg) & 0x20000) >> 17
}
func (o *SYSTEM_Type) SetPERIP_CLK_EN0_I2C_EXT1_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.PERIP_CLK_EN0.Reg, volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg)&^(0x40000)|value<<18)
}
func (o *SYSTEM_Type) GetPERIP_CLK_EN0_I2C_EXT1_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg) & 0x40000) >> 18
}
func (o *SYSTEM_Type) SetPERIP_CLK_EN0_CAN_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.PERIP_CLK_EN0.Reg, volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg)&^(0x80000)|value<<19)
}
func (o *SYSTEM_Type) GetPERIP_CLK_EN0_CAN_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg) & 0x80000) >> 19
}
func (o *SYSTEM_Type) SetPERIP_CLK_EN0_PWM1_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.PERIP_CLK_EN0.Reg, volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg)&^(0x100000)|value<<20)
}
func (o *SYSTEM_Type) GetPERIP_CLK_EN0_PWM1_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg) & 0x100000) >> 20
}
func (o *SYSTEM_Type) SetPERIP_CLK_EN0_I2S1_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.PERIP_CLK_EN0.Reg, volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg)&^(0x200000)|value<<21)
}
func (o *SYSTEM_Type) GetPERIP_CLK_EN0_I2S1_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg) & 0x200000) >> 21
}
func (o *SYSTEM_Type) SetPERIP_CLK_EN0_SPI2_DMA_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.PERIP_CLK_EN0.Reg, volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg)&^(0x400000)|value<<22)
}
func (o *SYSTEM_Type) GetPERIP_CLK_EN0_SPI2_DMA_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg) & 0x400000) >> 22
}
func (o *SYSTEM_Type) SetPERIP_CLK_EN0_USB_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.PERIP_CLK_EN0.Reg, volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg)&^(0x800000)|value<<23)
}
func (o *SYSTEM_Type) GetPERIP_CLK_EN0_USB_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg) & 0x800000) >> 23
}
func (o *SYSTEM_Type) SetPERIP_CLK_EN0_UART_MEM_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.PERIP_CLK_EN0.Reg, volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg)&^(0x1000000)|value<<24)
}
func (o *SYSTEM_Type) GetPERIP_CLK_EN0_UART_MEM_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg) & 0x1000000) >> 24
}
func (o *SYSTEM_Type) SetPERIP_CLK_EN0_PWM2_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.PERIP_CLK_EN0.Reg, volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg)&^(0x2000000)|value<<25)
}
func (o *SYSTEM_Type) GetPERIP_CLK_EN0_PWM2_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg) & 0x2000000) >> 25
}
func (o *SYSTEM_Type) SetPERIP_CLK_EN0_PWM3_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.PERIP_CLK_EN0.Reg, volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg)&^(0x4000000)|value<<26)
}
func (o *SYSTEM_Type) GetPERIP_CLK_EN0_PWM3_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg) & 0x4000000) >> 26
}
func (o *SYSTEM_Type) SetPERIP_CLK_EN0_SPI3_DMA_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.PERIP_CLK_EN0.Reg, volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg)&^(0x8000000)|value<<27)
}
func (o *SYSTEM_Type) GetPERIP_CLK_EN0_SPI3_DMA_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg) & 0x8000000) >> 27
}
func (o *SYSTEM_Type) SetPERIP_CLK_EN0_APB_SARADC_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.PERIP_CLK_EN0.Reg, volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg)&^(0x10000000)|value<<28)
}
func (o *SYSTEM_Type) GetPERIP_CLK_EN0_APB_SARADC_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg) & 0x10000000) >> 28
}
func (o *SYSTEM_Type) SetPERIP_CLK_EN0_SYSTIMER_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.PERIP_CLK_EN0.Reg, volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg)&^(0x20000000)|value<<29)
}
func (o *SYSTEM_Type) GetPERIP_CLK_EN0_SYSTIMER_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg) & 0x20000000) >> 29
}
func (o *SYSTEM_Type) SetPERIP_CLK_EN0_ADC2_ARB_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.PERIP_CLK_EN0.Reg, volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg)&^(0x40000000)|value<<30)
}
func (o *SYSTEM_Type) GetPERIP_CLK_EN0_ADC2_ARB_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg) & 0x40000000) >> 30
}
func (o *SYSTEM_Type) SetPERIP_CLK_EN0_SPI4_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.PERIP_CLK_EN0.Reg, volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg)&^(0x80000000)|value<<31)
}
func (o *SYSTEM_Type) GetPERIP_CLK_EN0_SPI4_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg) & 0x80000000) >> 31
}

// SYSTEM.PERIP_CLK_EN1: System peripheral clock (for hardware accelerators) enable register 1
func (o *SYSTEM_Type) SetPERIP_CLK_EN1_CRYPTO_AES_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.PERIP_CLK_EN1.Reg, volatile.LoadUint32(&o.PERIP_CLK_EN1.Reg)&^(0x2)|value<<1)
}
func (o *SYSTEM_Type) GetPERIP_CLK_EN1_CRYPTO_AES_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.PERIP_CLK_EN1.Reg) & 0x2) >> 1
}
func (o *SYSTEM_Type) SetPERIP_CLK_EN1_CRYPTO_SHA_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.PERIP_CLK_EN1.Reg, volatile.LoadUint32(&o.PERIP_CLK_EN1.Reg)&^(0x4)|value<<2)
}
func (o *SYSTEM_Type) GetPERIP_CLK_EN1_CRYPTO_SHA_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.PERIP_CLK_EN1.Reg) & 0x4) >> 2
}
func (o *SYSTEM_Type) SetPERIP_CLK_EN1_CRYPTO_RSA_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.PERIP_CLK_EN1.Reg, volatile.LoadUint32(&o.PERIP_CLK_EN1.Reg)&^(0x8)|value<<3)
}
func (o *SYSTEM_Type) GetPERIP_CLK_EN1_CRYPTO_RSA_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.PERIP_CLK_EN1.Reg) & 0x8) >> 3
}
func (o *SYSTEM_Type) SetPERIP_CLK_EN1_CRYPTO_DS_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.PERIP_CLK_EN1.Reg, volatile.LoadUint32(&o.PERIP_CLK_EN1.Reg)&^(0x10)|value<<4)
}
func (o *SYSTEM_Type) GetPERIP_CLK_EN1_CRYPTO_DS_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.PERIP_CLK_EN1.Reg) & 0x10) >> 4
}
func (o *SYSTEM_Type) SetPERIP_CLK_EN1_CRYPTO_HMAC_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.PERIP_CLK_EN1.Reg, volatile.LoadUint32(&o.PERIP_CLK_EN1.Reg)&^(0x20)|value<<5)
}
func (o *SYSTEM_Type) GetPERIP_CLK_EN1_CRYPTO_HMAC_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.PERIP_CLK_EN1.Reg) & 0x20) >> 5
}
func (o *SYSTEM_Type) SetPERIP_CLK_EN1_CRYPTO_DMA_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.PERIP_CLK_EN1.Reg, volatile.LoadUint32(&o.PERIP_CLK_EN1.Reg)&^(0x40)|value<<6)
}
func (o *SYSTEM_Type) GetPERIP_CLK_EN1_CRYPTO_DMA_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.PERIP_CLK_EN1.Reg) & 0x40) >> 6
}

// SYSTEM.PERIP_RST_EN0: System peripheral (hardware accelerators) reset register 0
func (o *SYSTEM_Type) SetPERIP_RST_EN0_TIMERS_RST(value uint32) {
	volatile.StoreUint32(&o.PERIP_RST_EN0.Reg, volatile.LoadUint32(&o.PERIP_RST_EN0.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetPERIP_RST_EN0_TIMERS_RST() uint32 {
	return volatile.LoadUint32(&o.PERIP_RST_EN0.Reg) & 0x1
}
func (o *SYSTEM_Type) SetPERIP_RST_EN0_SPI01_RST(value uint32) {
	volatile.StoreUint32(&o.PERIP_RST_EN0.Reg, volatile.LoadUint32(&o.PERIP_RST_EN0.Reg)&^(0x2)|value<<1)
}
func (o *SYSTEM_Type) GetPERIP_RST_EN0_SPI01_RST() uint32 {
	return (volatile.LoadUint32(&o.PERIP_RST_EN0.Reg) & 0x2) >> 1
}
func (o *SYSTEM_Type) SetPERIP_RST_EN0_UART_RST(value uint32) {
	volatile.StoreUint32(&o.PERIP_RST_EN0.Reg, volatile.LoadUint32(&o.PERIP_RST_EN0.Reg)&^(0x4)|value<<2)
}
func (o *SYSTEM_Type) GetPERIP_RST_EN0_UART_RST() uint32 {
	return (volatile.LoadUint32(&o.PERIP_RST_EN0.Reg) & 0x4) >> 2
}
func (o *SYSTEM_Type) SetPERIP_RST_EN0_WDG_RST(value uint32) {
	volatile.StoreUint32(&o.PERIP_RST_EN0.Reg, volatile.LoadUint32(&o.PERIP_RST_EN0.Reg)&^(0x8)|value<<3)
}
func (o *SYSTEM_Type) GetPERIP_RST_EN0_WDG_RST() uint32 {
	return (volatile.LoadUint32(&o.PERIP_RST_EN0.Reg) & 0x8) >> 3
}
func (o *SYSTEM_Type) SetPERIP_RST_EN0_I2S0_RST(value uint32) {
	volatile.StoreUint32(&o.PERIP_RST_EN0.Reg, volatile.LoadUint32(&o.PERIP_RST_EN0.Reg)&^(0x10)|value<<4)
}
func (o *SYSTEM_Type) GetPERIP_RST_EN0_I2S0_RST() uint32 {
	return (volatile.LoadUint32(&o.PERIP_RST_EN0.Reg) & 0x10) >> 4
}
func (o *SYSTEM_Type) SetPERIP_RST_EN0_UART1_RST(value uint32) {
	volatile.StoreUint32(&o.PERIP_RST_EN0.Reg, volatile.LoadUint32(&o.PERIP_RST_EN0.Reg)&^(0x20)|value<<5)
}
func (o *SYSTEM_Type) GetPERIP_RST_EN0_UART1_RST() uint32 {
	return (volatile.LoadUint32(&o.PERIP_RST_EN0.Reg) & 0x20) >> 5
}
func (o *SYSTEM_Type) SetPERIP_RST_EN0_SPI2_RST(value uint32) {
	volatile.StoreUint32(&o.PERIP_RST_EN0.Reg, volatile.LoadUint32(&o.PERIP_RST_EN0.Reg)&^(0x40)|value<<6)
}
func (o *SYSTEM_Type) GetPERIP_RST_EN0_SPI2_RST() uint32 {
	return (volatile.LoadUint32(&o.PERIP_RST_EN0.Reg) & 0x40) >> 6
}
func (o *SYSTEM_Type) SetPERIP_RST_EN0_I2C_EXT0_RST(value uint32) {
	volatile.StoreUint32(&o.PERIP_RST_EN0.Reg, volatile.LoadUint32(&o.PERIP_RST_EN0.Reg)&^(0x80)|value<<7)
}
func (o *SYSTEM_Type) GetPERIP_RST_EN0_I2C_EXT0_RST() uint32 {
	return (volatile.LoadUint32(&o.PERIP_RST_EN0.Reg) & 0x80) >> 7
}
func (o *SYSTEM_Type) SetPERIP_RST_EN0_UHCI0_RST(value uint32) {
	volatile.StoreUint32(&o.PERIP_RST_EN0.Reg, volatile.LoadUint32(&o.PERIP_RST_EN0.Reg)&^(0x100)|value<<8)
}
func (o *SYSTEM_Type) GetPERIP_RST_EN0_UHCI0_RST() uint32 {
	return (volatile.LoadUint32(&o.PERIP_RST_EN0.Reg) & 0x100) >> 8
}
func (o *SYSTEM_Type) SetPERIP_RST_EN0_RMT_RST(value uint32) {
	volatile.StoreUint32(&o.PERIP_RST_EN0.Reg, volatile.LoadUint32(&o.PERIP_RST_EN0.Reg)&^(0x200)|value<<9)
}
func (o *SYSTEM_Type) GetPERIP_RST_EN0_RMT_RST() uint32 {
	return (volatile.LoadUint32(&o.PERIP_RST_EN0.Reg) & 0x200) >> 9
}
func (o *SYSTEM_Type) SetPERIP_RST_EN0_PCNT_RST(value uint32) {
	volatile.StoreUint32(&o.PERIP_RST_EN0.Reg, volatile.LoadUint32(&o.PERIP_RST_EN0.Reg)&^(0x400)|value<<10)
}
func (o *SYSTEM_Type) GetPERIP_RST_EN0_PCNT_RST() uint32 {
	return (volatile.LoadUint32(&o.PERIP_RST_EN0.Reg) & 0x400) >> 10
}
func (o *SYSTEM_Type) SetPERIP_RST_EN0_LEDC_RST(value uint32) {
	volatile.StoreUint32(&o.PERIP_RST_EN0.Reg, volatile.LoadUint32(&o.PERIP_RST_EN0.Reg)&^(0x800)|value<<11)
}
func (o *SYSTEM_Type) GetPERIP_RST_EN0_LEDC_RST() uint32 {
	return (volatile.LoadUint32(&o.PERIP_RST_EN0.Reg) & 0x800) >> 11
}
func (o *SYSTEM_Type) SetPERIP_RST_EN0_UHCI1_RST(value uint32) {
	volatile.StoreUint32(&o.PERIP_RST_EN0.Reg, volatile.LoadUint32(&o.PERIP_RST_EN0.Reg)&^(0x1000)|value<<12)
}
func (o *SYSTEM_Type) GetPERIP_RST_EN0_UHCI1_RST() uint32 {
	return (volatile.LoadUint32(&o.PERIP_RST_EN0.Reg) & 0x1000) >> 12
}
func (o *SYSTEM_Type) SetPERIP_RST_EN0_TIMERGROUP_RST(value uint32) {
	volatile.StoreUint32(&o.PERIP_RST_EN0.Reg, volatile.LoadUint32(&o.PERIP_RST_EN0.Reg)&^(0x2000)|value<<13)
}
func (o *SYSTEM_Type) GetPERIP_RST_EN0_TIMERGROUP_RST() uint32 {
	return (volatile.LoadUint32(&o.PERIP_RST_EN0.Reg) & 0x2000) >> 13
}
func (o *SYSTEM_Type) SetPERIP_RST_EN0_EFUSE_RST(value uint32) {
	volatile.StoreUint32(&o.PERIP_RST_EN0.Reg, volatile.LoadUint32(&o.PERIP_RST_EN0.Reg)&^(0x4000)|value<<14)
}
func (o *SYSTEM_Type) GetPERIP_RST_EN0_EFUSE_RST() uint32 {
	return (volatile.LoadUint32(&o.PERIP_RST_EN0.Reg) & 0x4000) >> 14
}
func (o *SYSTEM_Type) SetPERIP_RST_EN0_TIMERGROUP1_RST(value uint32) {
	volatile.StoreUint32(&o.PERIP_RST_EN0.Reg, volatile.LoadUint32(&o.PERIP_RST_EN0.Reg)&^(0x8000)|value<<15)
}
func (o *SYSTEM_Type) GetPERIP_RST_EN0_TIMERGROUP1_RST() uint32 {
	return (volatile.LoadUint32(&o.PERIP_RST_EN0.Reg) & 0x8000) >> 15
}
func (o *SYSTEM_Type) SetPERIP_RST_EN0_SPI3_RST(value uint32) {
	volatile.StoreUint32(&o.PERIP_RST_EN0.Reg, volatile.LoadUint32(&o.PERIP_RST_EN0.Reg)&^(0x10000)|value<<16)
}
func (o *SYSTEM_Type) GetPERIP_RST_EN0_SPI3_RST() uint32 {
	return (volatile.LoadUint32(&o.PERIP_RST_EN0.Reg) & 0x10000) >> 16
}
func (o *SYSTEM_Type) SetPERIP_RST_EN0_PWM0_RST(value uint32) {
	volatile.StoreUint32(&o.PERIP_RST_EN0.Reg, volatile.LoadUint32(&o.PERIP_RST_EN0.Reg)&^(0x20000)|value<<17)
}
func (o *SYSTEM_Type) GetPERIP_RST_EN0_PWM0_RST() uint32 {
	return (volatile.LoadUint32(&o.PERIP_RST_EN0.Reg) & 0x20000) >> 17
}
func (o *SYSTEM_Type) SetPERIP_RST_EN0_I2C_EXT1_RST(value uint32) {
	volatile.StoreUint32(&o.PERIP_RST_EN0.Reg, volatile.LoadUint32(&o.PERIP_RST_EN0.Reg)&^(0x40000)|value<<18)
}
func (o *SYSTEM_Type) GetPERIP_RST_EN0_I2C_EXT1_RST() uint32 {
	return (volatile.LoadUint32(&o.PERIP_RST_EN0.Reg) & 0x40000) >> 18
}
func (o *SYSTEM_Type) SetPERIP_RST_EN0_CAN_RST(value uint32) {
	volatile.StoreUint32(&o.PERIP_RST_EN0.Reg, volatile.LoadUint32(&o.PERIP_RST_EN0.Reg)&^(0x80000)|value<<19)
}
func (o *SYSTEM_Type) GetPERIP_RST_EN0_CAN_RST() uint32 {
	return (volatile.LoadUint32(&o.PERIP_RST_EN0.Reg) & 0x80000) >> 19
}
func (o *SYSTEM_Type) SetPERIP_RST_EN0_PWM1_RST(value uint32) {
	volatile.StoreUint32(&o.PERIP_RST_EN0.Reg, volatile.LoadUint32(&o.PERIP_RST_EN0.Reg)&^(0x100000)|value<<20)
}
func (o *SYSTEM_Type) GetPERIP_RST_EN0_PWM1_RST() uint32 {
	return (volatile.LoadUint32(&o.PERIP_RST_EN0.Reg) & 0x100000) >> 20
}
func (o *SYSTEM_Type) SetPERIP_RST_EN0_I2S1_RST(value uint32) {
	volatile.StoreUint32(&o.PERIP_RST_EN0.Reg, volatile.LoadUint32(&o.PERIP_RST_EN0.Reg)&^(0x200000)|value<<21)
}
func (o *SYSTEM_Type) GetPERIP_RST_EN0_I2S1_RST() uint32 {
	return (volatile.LoadUint32(&o.PERIP_RST_EN0.Reg) & 0x200000) >> 21
}
func (o *SYSTEM_Type) SetPERIP_RST_EN0_SPI2_DMA_RST(value uint32) {
	volatile.StoreUint32(&o.PERIP_RST_EN0.Reg, volatile.LoadUint32(&o.PERIP_RST_EN0.Reg)&^(0x400000)|value<<22)
}
func (o *SYSTEM_Type) GetPERIP_RST_EN0_SPI2_DMA_RST() uint32 {
	return (volatile.LoadUint32(&o.PERIP_RST_EN0.Reg) & 0x400000) >> 22
}
func (o *SYSTEM_Type) SetPERIP_RST_EN0_USB_RST(value uint32) {
	volatile.StoreUint32(&o.PERIP_RST_EN0.Reg, volatile.LoadUint32(&o.PERIP_RST_EN0.Reg)&^(0x800000)|value<<23)
}
func (o *SYSTEM_Type) GetPERIP_RST_EN0_USB_RST() uint32 {
	return (volatile.LoadUint32(&o.PERIP_RST_EN0.Reg) & 0x800000) >> 23
}
func (o *SYSTEM_Type) SetPERIP_RST_EN0_UART_MEM_RST(value uint32) {
	volatile.StoreUint32(&o.PERIP_RST_EN0.Reg, volatile.LoadUint32(&o.PERIP_RST_EN0.Reg)&^(0x1000000)|value<<24)
}
func (o *SYSTEM_Type) GetPERIP_RST_EN0_UART_MEM_RST() uint32 {
	return (volatile.LoadUint32(&o.PERIP_RST_EN0.Reg) & 0x1000000) >> 24
}
func (o *SYSTEM_Type) SetPERIP_RST_EN0_PWM2_RST(value uint32) {
	volatile.StoreUint32(&o.PERIP_RST_EN0.Reg, volatile.LoadUint32(&o.PERIP_RST_EN0.Reg)&^(0x2000000)|value<<25)
}
func (o *SYSTEM_Type) GetPERIP_RST_EN0_PWM2_RST() uint32 {
	return (volatile.LoadUint32(&o.PERIP_RST_EN0.Reg) & 0x2000000) >> 25
}
func (o *SYSTEM_Type) SetPERIP_RST_EN0_PWM3_RST(value uint32) {
	volatile.StoreUint32(&o.PERIP_RST_EN0.Reg, volatile.LoadUint32(&o.PERIP_RST_EN0.Reg)&^(0x4000000)|value<<26)
}
func (o *SYSTEM_Type) GetPERIP_RST_EN0_PWM3_RST() uint32 {
	return (volatile.LoadUint32(&o.PERIP_RST_EN0.Reg) & 0x4000000) >> 26
}
func (o *SYSTEM_Type) SetPERIP_RST_EN0_SPI3_DMA_RST(value uint32) {
	volatile.StoreUint32(&o.PERIP_RST_EN0.Reg, volatile.LoadUint32(&o.PERIP_RST_EN0.Reg)&^(0x8000000)|value<<27)
}
func (o *SYSTEM_Type) GetPERIP_RST_EN0_SPI3_DMA_RST() uint32 {
	return (volatile.LoadUint32(&o.PERIP_RST_EN0.Reg) & 0x8000000) >> 27
}
func (o *SYSTEM_Type) SetPERIP_RST_EN0_APB_SARADC_RST(value uint32) {
	volatile.StoreUint32(&o.PERIP_RST_EN0.Reg, volatile.LoadUint32(&o.PERIP_RST_EN0.Reg)&^(0x10000000)|value<<28)
}
func (o *SYSTEM_Type) GetPERIP_RST_EN0_APB_SARADC_RST() uint32 {
	return (volatile.LoadUint32(&o.PERIP_RST_EN0.Reg) & 0x10000000) >> 28
}
func (o *SYSTEM_Type) SetPERIP_RST_EN0_SYSTIMER_RST(value uint32) {
	volatile.StoreUint32(&o.PERIP_RST_EN0.Reg, volatile.LoadUint32(&o.PERIP_RST_EN0.Reg)&^(0x20000000)|value<<29)
}
func (o *SYSTEM_Type) GetPERIP_RST_EN0_SYSTIMER_RST() uint32 {
	return (volatile.LoadUint32(&o.PERIP_RST_EN0.Reg) & 0x20000000) >> 29
}
func (o *SYSTEM_Type) SetPERIP_RST_EN0_ADC2_ARB_RST(value uint32) {
	volatile.StoreUint32(&o.PERIP_RST_EN0.Reg, volatile.LoadUint32(&o.PERIP_RST_EN0.Reg)&^(0x40000000)|value<<30)
}
func (o *SYSTEM_Type) GetPERIP_RST_EN0_ADC2_ARB_RST() uint32 {
	return (volatile.LoadUint32(&o.PERIP_RST_EN0.Reg) & 0x40000000) >> 30
}
func (o *SYSTEM_Type) SetPERIP_RST_EN0_SPI4_RST(value uint32) {
	volatile.StoreUint32(&o.PERIP_RST_EN0.Reg, volatile.LoadUint32(&o.PERIP_RST_EN0.Reg)&^(0x80000000)|value<<31)
}
func (o *SYSTEM_Type) GetPERIP_RST_EN0_SPI4_RST() uint32 {
	return (volatile.LoadUint32(&o.PERIP_RST_EN0.Reg) & 0x80000000) >> 31
}

// SYSTEM.PERIP_RST_EN1: System peripheral (hardware accelerators) reset register 1
func (o *SYSTEM_Type) SetPERIP_RST_EN1_CRYPTO_AES_RST(value uint32) {
	volatile.StoreUint32(&o.PERIP_RST_EN1.Reg, volatile.LoadUint32(&o.PERIP_RST_EN1.Reg)&^(0x2)|value<<1)
}
func (o *SYSTEM_Type) GetPERIP_RST_EN1_CRYPTO_AES_RST() uint32 {
	return (volatile.LoadUint32(&o.PERIP_RST_EN1.Reg) & 0x2) >> 1
}
func (o *SYSTEM_Type) SetPERIP_RST_EN1_CRYPTO_SHA_RST(value uint32) {
	volatile.StoreUint32(&o.PERIP_RST_EN1.Reg, volatile.LoadUint32(&o.PERIP_RST_EN1.Reg)&^(0x4)|value<<2)
}
func (o *SYSTEM_Type) GetPERIP_RST_EN1_CRYPTO_SHA_RST() uint32 {
	return (volatile.LoadUint32(&o.PERIP_RST_EN1.Reg) & 0x4) >> 2
}
func (o *SYSTEM_Type) SetPERIP_RST_EN1_CRYPTO_RSA_RST(value uint32) {
	volatile.StoreUint32(&o.PERIP_RST_EN1.Reg, volatile.LoadUint32(&o.PERIP_RST_EN1.Reg)&^(0x8)|value<<3)
}
func (o *SYSTEM_Type) GetPERIP_RST_EN1_CRYPTO_RSA_RST() uint32 {
	return (volatile.LoadUint32(&o.PERIP_RST_EN1.Reg) & 0x8) >> 3
}
func (o *SYSTEM_Type) SetPERIP_RST_EN1_CRYPTO_DS_RST(value uint32) {
	volatile.StoreUint32(&o.PERIP_RST_EN1.Reg, volatile.LoadUint32(&o.PERIP_RST_EN1.Reg)&^(0x10)|value<<4)
}
func (o *SYSTEM_Type) GetPERIP_RST_EN1_CRYPTO_DS_RST() uint32 {
	return (volatile.LoadUint32(&o.PERIP_RST_EN1.Reg) & 0x10) >> 4
}
func (o *SYSTEM_Type) SetPERIP_RST_EN1_CRYPTO_HMAC_RST(value uint32) {
	volatile.StoreUint32(&o.PERIP_RST_EN1.Reg, volatile.LoadUint32(&o.PERIP_RST_EN1.Reg)&^(0x20)|value<<5)
}
func (o *SYSTEM_Type) GetPERIP_RST_EN1_CRYPTO_HMAC_RST() uint32 {
	return (volatile.LoadUint32(&o.PERIP_RST_EN1.Reg) & 0x20) >> 5
}
func (o *SYSTEM_Type) SetPERIP_RST_EN1_CRYPTO_DMA_RST(value uint32) {
	volatile.StoreUint32(&o.PERIP_RST_EN1.Reg, volatile.LoadUint32(&o.PERIP_RST_EN1.Reg)&^(0x40)|value<<6)
}
func (o *SYSTEM_Type) GetPERIP_RST_EN1_CRYPTO_DMA_RST() uint32 {
	return (volatile.LoadUint32(&o.PERIP_RST_EN1.Reg) & 0x40) >> 6
}

// SYSTEM.LPCK_DIV_INT: Low power clock divider integer register
func (o *SYSTEM_Type) SetLPCK_DIV_INT_LPCK_DIV_NUM(value uint32) {
	volatile.StoreUint32(&o.LPCK_DIV_INT.Reg, volatile.LoadUint32(&o.LPCK_DIV_INT.Reg)&^(0xfff)|value)
}
func (o *SYSTEM_Type) GetLPCK_DIV_INT_LPCK_DIV_NUM() uint32 {
	return volatile.LoadUint32(&o.LPCK_DIV_INT.Reg) & 0xfff
}

// SYSTEM.BT_LPCK_DIV_FRAC: Divider fraction configuration register for low-power clock
func (o *SYSTEM_Type) SetBT_LPCK_DIV_FRAC_LPCLK_SEL_RTC_SLOW(value uint32) {
	volatile.StoreUint32(&o.BT_LPCK_DIV_FRAC.Reg, volatile.LoadUint32(&o.BT_LPCK_DIV_FRAC.Reg)&^(0x1000000)|value<<24)
}
func (o *SYSTEM_Type) GetBT_LPCK_DIV_FRAC_LPCLK_SEL_RTC_SLOW() uint32 {
	return (volatile.LoadUint32(&o.BT_LPCK_DIV_FRAC.Reg) & 0x1000000) >> 24
}
func (o *SYSTEM_Type) SetBT_LPCK_DIV_FRAC_LPCLK_SEL_8M(value uint32) {
	volatile.StoreUint32(&o.BT_LPCK_DIV_FRAC.Reg, volatile.LoadUint32(&o.BT_LPCK_DIV_FRAC.Reg)&^(0x2000000)|value<<25)
}
func (o *SYSTEM_Type) GetBT_LPCK_DIV_FRAC_LPCLK_SEL_8M() uint32 {
	return (volatile.LoadUint32(&o.BT_LPCK_DIV_FRAC.Reg) & 0x2000000) >> 25
}
func (o *SYSTEM_Type) SetBT_LPCK_DIV_FRAC_LPCLK_SEL_XTAL(value uint32) {
	volatile.StoreUint32(&o.BT_LPCK_DIV_FRAC.Reg, volatile.LoadUint32(&o.BT_LPCK_DIV_FRAC.Reg)&^(0x4000000)|value<<26)
}
func (o *SYSTEM_Type) GetBT_LPCK_DIV_FRAC_LPCLK_SEL_XTAL() uint32 {
	return (volatile.LoadUint32(&o.BT_LPCK_DIV_FRAC.Reg) & 0x4000000) >> 26
}
func (o *SYSTEM_Type) SetBT_LPCK_DIV_FRAC_LPCLK_SEL_XTAL32K(value uint32) {
	volatile.StoreUint32(&o.BT_LPCK_DIV_FRAC.Reg, volatile.LoadUint32(&o.BT_LPCK_DIV_FRAC.Reg)&^(0x8000000)|value<<27)
}
func (o *SYSTEM_Type) GetBT_LPCK_DIV_FRAC_LPCLK_SEL_XTAL32K() uint32 {
	return (volatile.LoadUint32(&o.BT_LPCK_DIV_FRAC.Reg) & 0x8000000) >> 27
}
func (o *SYSTEM_Type) SetBT_LPCK_DIV_FRAC_LPCLK_RTC_EN(value uint32) {
	volatile.StoreUint32(&o.BT_LPCK_DIV_FRAC.Reg, volatile.LoadUint32(&o.BT_LPCK_DIV_FRAC.Reg)&^(0x10000000)|value<<28)
}
func (o *SYSTEM_Type) GetBT_LPCK_DIV_FRAC_LPCLK_RTC_EN() uint32 {
	return (volatile.LoadUint32(&o.BT_LPCK_DIV_FRAC.Reg) & 0x10000000) >> 28
}

// SYSTEM.CPU_INTR_FROM_CPU_0: CPU interrupt controlling register 0
func (o *SYSTEM_Type) SetCPU_INTR_FROM_CPU_0(value uint32) {
	volatile.StoreUint32(&o.CPU_INTR_FROM_CPU_0.Reg, volatile.LoadUint32(&o.CPU_INTR_FROM_CPU_0.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetCPU_INTR_FROM_CPU_0() uint32 {
	return volatile.LoadUint32(&o.CPU_INTR_FROM_CPU_0.Reg) & 0x1
}

// SYSTEM.CPU_INTR_FROM_CPU_1: CPU interrupt controlling register 1
func (o *SYSTEM_Type) SetCPU_INTR_FROM_CPU_1(value uint32) {
	volatile.StoreUint32(&o.CPU_INTR_FROM_CPU_1.Reg, volatile.LoadUint32(&o.CPU_INTR_FROM_CPU_1.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetCPU_INTR_FROM_CPU_1() uint32 {
	return volatile.LoadUint32(&o.CPU_INTR_FROM_CPU_1.Reg) & 0x1
}

// SYSTEM.CPU_INTR_FROM_CPU_2: CPU interrupt controlling register 2
func (o *SYSTEM_Type) SetCPU_INTR_FROM_CPU_2(value uint32) {
	volatile.StoreUint32(&o.CPU_INTR_FROM_CPU_2.Reg, volatile.LoadUint32(&o.CPU_INTR_FROM_CPU_2.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetCPU_INTR_FROM_CPU_2() uint32 {
	return volatile.LoadUint32(&o.CPU_INTR_FROM_CPU_2.Reg) & 0x1
}

// SYSTEM.CPU_INTR_FROM_CPU_3: CPU interrupt controlling register 3
func (o *SYSTEM_Type) SetCPU_INTR_FROM_CPU_3(value uint32) {
	volatile.StoreUint32(&o.CPU_INTR_FROM_CPU_3.Reg, volatile.LoadUint32(&o.CPU_INTR_FROM_CPU_3.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetCPU_INTR_FROM_CPU_3() uint32 {
	return volatile.LoadUint32(&o.CPU_INTR_FROM_CPU_3.Reg) & 0x1
}

// SYSTEM.RSA_PD_CTRL: RSA memory remapping register
func (o *SYSTEM_Type) SetRSA_PD_CTRL_RSA_MEM_PD(value uint32) {
	volatile.StoreUint32(&o.RSA_PD_CTRL.Reg, volatile.LoadUint32(&o.RSA_PD_CTRL.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetRSA_PD_CTRL_RSA_MEM_PD() uint32 {
	return volatile.LoadUint32(&o.RSA_PD_CTRL.Reg) & 0x1
}
func (o *SYSTEM_Type) SetRSA_PD_CTRL_RSA_MEM_FORCE_PU(value uint32) {
	volatile.StoreUint32(&o.RSA_PD_CTRL.Reg, volatile.LoadUint32(&o.RSA_PD_CTRL.Reg)&^(0x2)|value<<1)
}
func (o *SYSTEM_Type) GetRSA_PD_CTRL_RSA_MEM_FORCE_PU() uint32 {
	return (volatile.LoadUint32(&o.RSA_PD_CTRL.Reg) & 0x2) >> 1
}
func (o *SYSTEM_Type) SetRSA_PD_CTRL_RSA_MEM_FORCE_PD(value uint32) {
	volatile.StoreUint32(&o.RSA_PD_CTRL.Reg, volatile.LoadUint32(&o.RSA_PD_CTRL.Reg)&^(0x4)|value<<2)
}
func (o *SYSTEM_Type) GetRSA_PD_CTRL_RSA_MEM_FORCE_PD() uint32 {
	return (volatile.LoadUint32(&o.RSA_PD_CTRL.Reg) & 0x4) >> 2
}

// SYSTEM.BUSTOEXTMEM_ENA: EDMA enable register
func (o *SYSTEM_Type) SetBUSTOEXTMEM_ENA(value uint32) {
	volatile.StoreUint32(&o.BUSTOEXTMEM_ENA.Reg, volatile.LoadUint32(&o.BUSTOEXTMEM_ENA.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetBUSTOEXTMEM_ENA() uint32 {
	return volatile.LoadUint32(&o.BUSTOEXTMEM_ENA.Reg) & 0x1
}

// SYSTEM.CACHE_CONTROL: Cache control register
func (o *SYSTEM_Type) SetCACHE_CONTROL_PRO_ICACHE_CLK_ON(value uint32) {
	volatile.StoreUint32(&o.CACHE_CONTROL.Reg, volatile.LoadUint32(&o.CACHE_CONTROL.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetCACHE_CONTROL_PRO_ICACHE_CLK_ON() uint32 {
	return volatile.LoadUint32(&o.CACHE_CONTROL.Reg) & 0x1
}
func (o *SYSTEM_Type) SetCACHE_CONTROL_PRO_DCACHE_CLK_ON(value uint32) {
	volatile.StoreUint32(&o.CACHE_CONTROL.Reg, volatile.LoadUint32(&o.CACHE_CONTROL.Reg)&^(0x2)|value<<1)
}
func (o *SYSTEM_Type) GetCACHE_CONTROL_PRO_DCACHE_CLK_ON() uint32 {
	return (volatile.LoadUint32(&o.CACHE_CONTROL.Reg) & 0x2) >> 1
}
func (o *SYSTEM_Type) SetCACHE_CONTROL_PRO_CACHE_RESET(value uint32) {
	volatile.StoreUint32(&o.CACHE_CONTROL.Reg, volatile.LoadUint32(&o.CACHE_CONTROL.Reg)&^(0x4)|value<<2)
}
func (o *SYSTEM_Type) GetCACHE_CONTROL_PRO_CACHE_RESET() uint32 {
	return (volatile.LoadUint32(&o.CACHE_CONTROL.Reg) & 0x4) >> 2
}

// SYSTEM.EXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL: External memory encrypt and decrypt controlling register
func (o *SYSTEM_Type) SetEXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL_ENABLE_SPI_MANUAL_ENCRYPT(value uint32) {
	volatile.StoreUint32(&o.EXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL.Reg, volatile.LoadUint32(&o.EXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetEXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL_ENABLE_SPI_MANUAL_ENCRYPT() uint32 {
	return volatile.LoadUint32(&o.EXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL.Reg) & 0x1
}
func (o *SYSTEM_Type) SetEXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL_ENABLE_DOWNLOAD_DB_ENCRYPT(value uint32) {
	volatile.StoreUint32(&o.EXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL.Reg, volatile.LoadUint32(&o.EXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL.Reg)&^(0x2)|value<<1)
}
func (o *SYSTEM_Type) GetEXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL_ENABLE_DOWNLOAD_DB_ENCRYPT() uint32 {
	return (volatile.LoadUint32(&o.EXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL.Reg) & 0x2) >> 1
}
func (o *SYSTEM_Type) SetEXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL_ENABLE_DOWNLOAD_G0CB_DECRYPT(value uint32) {
	volatile.StoreUint32(&o.EXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL.Reg, volatile.LoadUint32(&o.EXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL.Reg)&^(0x4)|value<<2)
}
func (o *SYSTEM_Type) GetEXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL_ENABLE_DOWNLOAD_G0CB_DECRYPT() uint32 {
	return (volatile.LoadUint32(&o.EXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL.Reg) & 0x4) >> 2
}
func (o *SYSTEM_Type) SetEXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL_ENABLE_DOWNLOAD_MANUAL_ENCRYPT(value uint32) {
	volatile.StoreUint32(&o.EXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL.Reg, volatile.LoadUint32(&o.EXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL.Reg)&^(0x8)|value<<3)
}
func (o *SYSTEM_Type) GetEXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL_ENABLE_DOWNLOAD_MANUAL_ENCRYPT() uint32 {
	return (volatile.LoadUint32(&o.EXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL.Reg) & 0x8) >> 3
}

// SYSTEM.RTC_FASTMEM_CONFIG: RTC fast memory configuration register
func (o *SYSTEM_Type) SetRTC_FASTMEM_CONFIG_RTC_MEM_CRC_START(value uint32) {
	volatile.StoreUint32(&o.RTC_FASTMEM_CONFIG.Reg, volatile.LoadUint32(&o.RTC_FASTMEM_CONFIG.Reg)&^(0x100)|value<<8)
}
func (o *SYSTEM_Type) GetRTC_FASTMEM_CONFIG_RTC_MEM_CRC_START() uint32 {
	return (volatile.LoadUint32(&o.RTC_FASTMEM_CONFIG.Reg) & 0x100) >> 8
}
func (o *SYSTEM_Type) SetRTC_FASTMEM_CONFIG_RTC_MEM_CRC_ADDR(value uint32) {
	volatile.StoreUint32(&o.RTC_FASTMEM_CONFIG.Reg, volatile.LoadUint32(&o.RTC_FASTMEM_CONFIG.Reg)&^(0xffe00)|value<<9)
}
func (o *SYSTEM_Type) GetRTC_FASTMEM_CONFIG_RTC_MEM_CRC_ADDR() uint32 {
	return (volatile.LoadUint32(&o.RTC_FASTMEM_CONFIG.Reg) & 0xffe00) >> 9
}
func (o *SYSTEM_Type) SetRTC_FASTMEM_CONFIG_RTC_MEM_CRC_LEN(value uint32) {
	volatile.StoreUint32(&o.RTC_FASTMEM_CONFIG.Reg, volatile.LoadUint32(&o.RTC_FASTMEM_CONFIG.Reg)&^(0x7ff00000)|value<<20)
}
func (o *SYSTEM_Type) GetRTC_FASTMEM_CONFIG_RTC_MEM_CRC_LEN() uint32 {
	return (volatile.LoadUint32(&o.RTC_FASTMEM_CONFIG.Reg) & 0x7ff00000) >> 20
}
func (o *SYSTEM_Type) SetRTC_FASTMEM_CONFIG_RTC_MEM_CRC_FINISH(value uint32) {
	volatile.StoreUint32(&o.RTC_FASTMEM_CONFIG.Reg, volatile.LoadUint32(&o.RTC_FASTMEM_CONFIG.Reg)&^(0x80000000)|value<<31)
}
func (o *SYSTEM_Type) GetRTC_FASTMEM_CONFIG_RTC_MEM_CRC_FINISH() uint32 {
	return (volatile.LoadUint32(&o.RTC_FASTMEM_CONFIG.Reg) & 0x80000000) >> 31
}

// SYSTEM.RTC_FASTMEM_CRC: RTC fast memory CRC controlling register
func (o *SYSTEM_Type) SetRTC_FASTMEM_CRC(value uint32) {
	volatile.StoreUint32(&o.RTC_FASTMEM_CRC.Reg, value)
}
func (o *SYSTEM_Type) GetRTC_FASTMEM_CRC() uint32 {
	return volatile.LoadUint32(&o.RTC_FASTMEM_CRC.Reg)
}

// SYSTEM.Redundant_ECO_Ctrl: Redundant ECO control register
func (o *SYSTEM_Type) SetRedundant_ECO_Ctrl_REDUNDANT_ECO_DRIVE(value uint32) {
	volatile.StoreUint32(&o.Redundant_ECO_Ctrl.Reg, volatile.LoadUint32(&o.Redundant_ECO_Ctrl.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetRedundant_ECO_Ctrl_REDUNDANT_ECO_DRIVE() uint32 {
	return volatile.LoadUint32(&o.Redundant_ECO_Ctrl.Reg) & 0x1
}
func (o *SYSTEM_Type) SetRedundant_ECO_Ctrl_REDUNDANT_ECO_RESULT(value uint32) {
	volatile.StoreUint32(&o.Redundant_ECO_Ctrl.Reg, volatile.LoadUint32(&o.Redundant_ECO_Ctrl.Reg)&^(0x2)|value<<1)
}
func (o *SYSTEM_Type) GetRedundant_ECO_Ctrl_REDUNDANT_ECO_RESULT() uint32 {
	return (volatile.LoadUint32(&o.Redundant_ECO_Ctrl.Reg) & 0x2) >> 1
}

// SYSTEM.CLOCK_GATE: Clock gate control register
func (o *SYSTEM_Type) SetCLOCK_GATE_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.CLOCK_GATE.Reg, volatile.LoadUint32(&o.CLOCK_GATE.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetCLOCK_GATE_CLK_EN() uint32 {
	return volatile.LoadUint32(&o.CLOCK_GATE.Reg) & 0x1
}

// SYSTEM.SRAM_CTRL_2: System SRAM configuration register 2
func (o *SYSTEM_Type) SetSRAM_CTRL_2_SRAM_FORCE_PU(value uint32) {
	volatile.StoreUint32(&o.SRAM_CTRL_2.Reg, volatile.LoadUint32(&o.SRAM_CTRL_2.Reg)&^(0x3fffff)|value)
}
func (o *SYSTEM_Type) GetSRAM_CTRL_2_SRAM_FORCE_PU() uint32 {
	return volatile.LoadUint32(&o.SRAM_CTRL_2.Reg) & 0x3fffff
}

// SYSTEM.SYSCLK_CONF: SoC clock configuration register
func (o *SYSTEM_Type) SetSYSCLK_CONF_PRE_DIV_CNT(value uint32) {
	volatile.StoreUint32(&o.SYSCLK_CONF.Reg, volatile.LoadUint32(&o.SYSCLK_CONF.Reg)&^(0x3ff)|value)
}
func (o *SYSTEM_Type) GetSYSCLK_CONF_PRE_DIV_CNT() uint32 {
	return volatile.LoadUint32(&o.SYSCLK_CONF.Reg) & 0x3ff
}
func (o *SYSTEM_Type) SetSYSCLK_CONF_SOC_CLK_SEL(value uint32) {
	volatile.StoreUint32(&o.SYSCLK_CONF.Reg, volatile.LoadUint32(&o.SYSCLK_CONF.Reg)&^(0xc00)|value<<10)
}
func (o *SYSTEM_Type) GetSYSCLK_CONF_SOC_CLK_SEL() uint32 {
	return (volatile.LoadUint32(&o.SYSCLK_CONF.Reg) & 0xc00) >> 10
}
func (o *SYSTEM_Type) SetSYSCLK_CONF_CLK_XTAL_FREQ(value uint32) {
	volatile.StoreUint32(&o.SYSCLK_CONF.Reg, volatile.LoadUint32(&o.SYSCLK_CONF.Reg)&^(0x7f000)|value<<12)
}
func (o *SYSTEM_Type) GetSYSCLK_CONF_CLK_XTAL_FREQ() uint32 {
	return (volatile.LoadUint32(&o.SYSCLK_CONF.Reg) & 0x7f000) >> 12
}
func (o *SYSTEM_Type) SetSYSCLK_CONF_CLK_DIV_EN(value uint32) {
	volatile.StoreUint32(&o.SYSCLK_CONF.Reg, volatile.LoadUint32(&o.SYSCLK_CONF.Reg)&^(0x80000)|value<<19)
}
func (o *SYSTEM_Type) GetSYSCLK_CONF_CLK_DIV_EN() uint32 {
	return (volatile.LoadUint32(&o.SYSCLK_CONF.Reg) & 0x80000) >> 19
}

// SYSTEM.REG_DATE: Version control register
func (o *SYSTEM_Type) SetREG_DATE_SYSTEM_REG_DATE(value uint32) {
	volatile.StoreUint32(&o.REG_DATE.Reg, volatile.LoadUint32(&o.REG_DATE.Reg)&^(0xfffffff)|value)
}
func (o *SYSTEM_Type) GetREG_DATE_SYSTEM_REG_DATE() uint32 {
	return volatile.LoadUint32(&o.REG_DATE.Reg) & 0xfffffff
}

// Peripheral SYSTIMER
type SYSTIMER_Type struct {
	CONF         volatile.Register32 // 0x0
	LOAD         volatile.Register32 // 0x4
	LOAD_HI      volatile.Register32 // 0x8
	LOAD_LO      volatile.Register32 // 0xC
	STEP         volatile.Register32 // 0x10
	TARGET0_HI   volatile.Register32 // 0x14
	TARGET0_LO   volatile.Register32 // 0x18
	TARGET1_HI   volatile.Register32 // 0x1C
	TARGET1_LO   volatile.Register32 // 0x20
	TARGET2_HI   volatile.Register32 // 0x24
	TARGET2_LO   volatile.Register32 // 0x28
	TARGET0_CONF volatile.Register32 // 0x2C
	TARGET1_CONF volatile.Register32 // 0x30
	TARGET2_CONF volatile.Register32 // 0x34
	UPDATE       volatile.Register32 // 0x38
	VALUE_HI     volatile.Register32 // 0x3C
	VALUE_LO     volatile.Register32 // 0x40
	INT_ENA      volatile.Register32 // 0x44
	INT_RAW      volatile.Register32 // 0x48
	INT_CLR      volatile.Register32 // 0x4C
	_            [172]byte
	DATE         volatile.Register32 // 0xFC
}

// SYSTIMER.CONF: Configure system timer clock
func (o *SYSTIMER_Type) SetCONF_CLK_FO(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0x1)|value)
}
func (o *SYSTIMER_Type) GetCONF_CLK_FO() uint32 {
	return volatile.LoadUint32(&o.CONF.Reg) & 0x1
}
func (o *SYSTIMER_Type) SetCONF_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0x80000000)|value<<31)
}
func (o *SYSTIMER_Type) GetCONF_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.CONF.Reg) & 0x80000000) >> 31
}

// SYSTIMER.LOAD: Load value to system timer
func (o *SYSTIMER_Type) SetLOAD_TIMER_LOAD(value uint32) {
	volatile.StoreUint32(&o.LOAD.Reg, volatile.LoadUint32(&o.LOAD.Reg)&^(0x80000000)|value<<31)
}
func (o *SYSTIMER_Type) GetLOAD_TIMER_LOAD() uint32 {
	return (volatile.LoadUint32(&o.LOAD.Reg) & 0x80000000) >> 31
}

// SYSTIMER.LOAD_HI: High 32 bits to be loaded to system timer
func (o *SYSTIMER_Type) SetLOAD_HI(value uint32) {
	volatile.StoreUint32(&o.LOAD_HI.Reg, value)
}
func (o *SYSTIMER_Type) GetLOAD_HI() uint32 {
	return volatile.LoadUint32(&o.LOAD_HI.Reg)
}

// SYSTIMER.LOAD_LO: Low 32 bits to be loaded to system timer
func (o *SYSTIMER_Type) SetLOAD_LO(value uint32) {
	volatile.StoreUint32(&o.LOAD_LO.Reg, value)
}
func (o *SYSTIMER_Type) GetLOAD_LO() uint32 {
	return volatile.LoadUint32(&o.LOAD_LO.Reg)
}

// SYSTIMER.STEP: System timer accumulation step
func (o *SYSTIMER_Type) SetSTEP_TIMER_XTAL_STEP(value uint32) {
	volatile.StoreUint32(&o.STEP.Reg, volatile.LoadUint32(&o.STEP.Reg)&^(0x3ff)|value)
}
func (o *SYSTIMER_Type) GetSTEP_TIMER_XTAL_STEP() uint32 {
	return volatile.LoadUint32(&o.STEP.Reg) & 0x3ff
}
func (o *SYSTIMER_Type) SetSTEP_TIMER_PLL_STEP(value uint32) {
	volatile.StoreUint32(&o.STEP.Reg, volatile.LoadUint32(&o.STEP.Reg)&^(0xffc00)|value<<10)
}
func (o *SYSTIMER_Type) GetSTEP_TIMER_PLL_STEP() uint32 {
	return (volatile.LoadUint32(&o.STEP.Reg) & 0xffc00) >> 10
}

// SYSTIMER.TARGET0_HI: System timer target 0, high 32 bits
func (o *SYSTIMER_Type) SetTARGET0_HI(value uint32) {
	volatile.StoreUint32(&o.TARGET0_HI.Reg, value)
}
func (o *SYSTIMER_Type) GetTARGET0_HI() uint32 {
	return volatile.LoadUint32(&o.TARGET0_HI.Reg)
}

// SYSTIMER.TARGET0_LO: System timer target 0, low 32 bits
func (o *SYSTIMER_Type) SetTARGET0_LO(value uint32) {
	volatile.StoreUint32(&o.TARGET0_LO.Reg, value)
}
func (o *SYSTIMER_Type) GetTARGET0_LO() uint32 {
	return volatile.LoadUint32(&o.TARGET0_LO.Reg)
}

// SYSTIMER.TARGET1_HI: System timer target 1, high 32 bits
func (o *SYSTIMER_Type) SetTARGET1_HI(value uint32) {
	volatile.StoreUint32(&o.TARGET1_HI.Reg, value)
}
func (o *SYSTIMER_Type) GetTARGET1_HI() uint32 {
	return volatile.LoadUint32(&o.TARGET1_HI.Reg)
}

// SYSTIMER.TARGET1_LO: System timer target 1, low 32 bits
func (o *SYSTIMER_Type) SetTARGET1_LO(value uint32) {
	volatile.StoreUint32(&o.TARGET1_LO.Reg, value)
}
func (o *SYSTIMER_Type) GetTARGET1_LO() uint32 {
	return volatile.LoadUint32(&o.TARGET1_LO.Reg)
}

// SYSTIMER.TARGET2_HI: System timer target 2, high 32 bits
func (o *SYSTIMER_Type) SetTARGET2_HI(value uint32) {
	volatile.StoreUint32(&o.TARGET2_HI.Reg, value)
}
func (o *SYSTIMER_Type) GetTARGET2_HI() uint32 {
	return volatile.LoadUint32(&o.TARGET2_HI.Reg)
}

// SYSTIMER.TARGET2_LO: System timer target 2, low 32 bits
func (o *SYSTIMER_Type) SetTARGET2_LO(value uint32) {
	volatile.StoreUint32(&o.TARGET2_LO.Reg, value)
}
func (o *SYSTIMER_Type) GetTARGET2_LO() uint32 {
	return volatile.LoadUint32(&o.TARGET2_LO.Reg)
}

// SYSTIMER.TARGET0_CONF: Configure work mode for system timer target 0
func (o *SYSTIMER_Type) SetTARGET0_CONF_TARGET0_PERIOD(value uint32) {
	volatile.StoreUint32(&o.TARGET0_CONF.Reg, volatile.LoadUint32(&o.TARGET0_CONF.Reg)&^(0x3fffffff)|value)
}
func (o *SYSTIMER_Type) GetTARGET0_CONF_TARGET0_PERIOD() uint32 {
	return volatile.LoadUint32(&o.TARGET0_CONF.Reg) & 0x3fffffff
}
func (o *SYSTIMER_Type) SetTARGET0_CONF_TARGET0_PERIOD_MODE(value uint32) {
	volatile.StoreUint32(&o.TARGET0_CONF.Reg, volatile.LoadUint32(&o.TARGET0_CONF.Reg)&^(0x40000000)|value<<30)
}
func (o *SYSTIMER_Type) GetTARGET0_CONF_TARGET0_PERIOD_MODE() uint32 {
	return (volatile.LoadUint32(&o.TARGET0_CONF.Reg) & 0x40000000) >> 30
}
func (o *SYSTIMER_Type) SetTARGET0_CONF_TARGET0_WORK_EN(value uint32) {
	volatile.StoreUint32(&o.TARGET0_CONF.Reg, volatile.LoadUint32(&o.TARGET0_CONF.Reg)&^(0x80000000)|value<<31)
}
func (o *SYSTIMER_Type) GetTARGET0_CONF_TARGET0_WORK_EN() uint32 {
	return (volatile.LoadUint32(&o.TARGET0_CONF.Reg) & 0x80000000) >> 31
}

// SYSTIMER.TARGET1_CONF: Configure work mode for system timer target 1
func (o *SYSTIMER_Type) SetTARGET1_CONF_TARGET1_PERIOD(value uint32) {
	volatile.StoreUint32(&o.TARGET1_CONF.Reg, volatile.LoadUint32(&o.TARGET1_CONF.Reg)&^(0x3fffffff)|value)
}
func (o *SYSTIMER_Type) GetTARGET1_CONF_TARGET1_PERIOD() uint32 {
	return volatile.LoadUint32(&o.TARGET1_CONF.Reg) & 0x3fffffff
}
func (o *SYSTIMER_Type) SetTARGET1_CONF_TARGET1_PERIOD_MODE(value uint32) {
	volatile.StoreUint32(&o.TARGET1_CONF.Reg, volatile.LoadUint32(&o.TARGET1_CONF.Reg)&^(0x40000000)|value<<30)
}
func (o *SYSTIMER_Type) GetTARGET1_CONF_TARGET1_PERIOD_MODE() uint32 {
	return (volatile.LoadUint32(&o.TARGET1_CONF.Reg) & 0x40000000) >> 30
}
func (o *SYSTIMER_Type) SetTARGET1_CONF_TARGET1_WORK_EN(value uint32) {
	volatile.StoreUint32(&o.TARGET1_CONF.Reg, volatile.LoadUint32(&o.TARGET1_CONF.Reg)&^(0x80000000)|value<<31)
}
func (o *SYSTIMER_Type) GetTARGET1_CONF_TARGET1_WORK_EN() uint32 {
	return (volatile.LoadUint32(&o.TARGET1_CONF.Reg) & 0x80000000) >> 31
}

// SYSTIMER.TARGET2_CONF: Configure work mode for system timer target 2
func (o *SYSTIMER_Type) SetTARGET2_CONF_TARGET2_PERIOD(value uint32) {
	volatile.StoreUint32(&o.TARGET2_CONF.Reg, volatile.LoadUint32(&o.TARGET2_CONF.Reg)&^(0x3fffffff)|value)
}
func (o *SYSTIMER_Type) GetTARGET2_CONF_TARGET2_PERIOD() uint32 {
	return volatile.LoadUint32(&o.TARGET2_CONF.Reg) & 0x3fffffff
}
func (o *SYSTIMER_Type) SetTARGET2_CONF_TARGET2_PERIOD_MODE(value uint32) {
	volatile.StoreUint32(&o.TARGET2_CONF.Reg, volatile.LoadUint32(&o.TARGET2_CONF.Reg)&^(0x40000000)|value<<30)
}
func (o *SYSTIMER_Type) GetTARGET2_CONF_TARGET2_PERIOD_MODE() uint32 {
	return (volatile.LoadUint32(&o.TARGET2_CONF.Reg) & 0x40000000) >> 30
}
func (o *SYSTIMER_Type) SetTARGET2_CONF_TARGET2_WORK_EN(value uint32) {
	volatile.StoreUint32(&o.TARGET2_CONF.Reg, volatile.LoadUint32(&o.TARGET2_CONF.Reg)&^(0x80000000)|value<<31)
}
func (o *SYSTIMER_Type) GetTARGET2_CONF_TARGET2_WORK_EN() uint32 {
	return (volatile.LoadUint32(&o.TARGET2_CONF.Reg) & 0x80000000) >> 31
}

// SYSTIMER.UPDATE: Read out system timer value
func (o *SYSTIMER_Type) SetUPDATE_TIMER_VALUE_VALID(value uint32) {
	volatile.StoreUint32(&o.UPDATE.Reg, volatile.LoadUint32(&o.UPDATE.Reg)&^(0x40000000)|value<<30)
}
func (o *SYSTIMER_Type) GetUPDATE_TIMER_VALUE_VALID() uint32 {
	return (volatile.LoadUint32(&o.UPDATE.Reg) & 0x40000000) >> 30
}
func (o *SYSTIMER_Type) SetUPDATE_TIMER_UPDATE(value uint32) {
	volatile.StoreUint32(&o.UPDATE.Reg, volatile.LoadUint32(&o.UPDATE.Reg)&^(0x80000000)|value<<31)
}
func (o *SYSTIMER_Type) GetUPDATE_TIMER_UPDATE() uint32 {
	return (volatile.LoadUint32(&o.UPDATE.Reg) & 0x80000000) >> 31
}

// SYSTIMER.VALUE_HI: System timer value, high 32 bits
func (o *SYSTIMER_Type) SetVALUE_HI(value uint32) {
	volatile.StoreUint32(&o.VALUE_HI.Reg, value)
}
func (o *SYSTIMER_Type) GetVALUE_HI() uint32 {
	return volatile.LoadUint32(&o.VALUE_HI.Reg)
}

// SYSTIMER.VALUE_LO: System timer value, low 32 bits
func (o *SYSTIMER_Type) SetVALUE_LO(value uint32) {
	volatile.StoreUint32(&o.VALUE_LO.Reg, value)
}
func (o *SYSTIMER_Type) GetVALUE_LO() uint32 {
	return volatile.LoadUint32(&o.VALUE_LO.Reg)
}

// SYSTIMER.INT_ENA: System timer interrupt enable
func (o *SYSTIMER_Type) SetINT_ENA_INT0_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x1)|value)
}
func (o *SYSTIMER_Type) GetINT_ENA_INT0_ENA() uint32 {
	return volatile.LoadUint32(&o.INT_ENA.Reg) & 0x1
}
func (o *SYSTIMER_Type) SetINT_ENA_INT1_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x2)|value<<1)
}
func (o *SYSTIMER_Type) GetINT_ENA_INT1_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x2) >> 1
}
func (o *SYSTIMER_Type) SetINT_ENA_INT2_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x4)|value<<2)
}
func (o *SYSTIMER_Type) GetINT_ENA_INT2_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x4) >> 2
}

// SYSTIMER.INT_RAW: System timer interrupt raw
func (o *SYSTIMER_Type) SetINT_RAW_INT0_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x1)|value)
}
func (o *SYSTIMER_Type) GetINT_RAW_INT0_RAW() uint32 {
	return volatile.LoadUint32(&o.INT_RAW.Reg) & 0x1
}
func (o *SYSTIMER_Type) SetINT_RAW_INT1_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x2)|value<<1)
}
func (o *SYSTIMER_Type) GetINT_RAW_INT1_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x2) >> 1
}
func (o *SYSTIMER_Type) SetINT_RAW_INT2_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x4)|value<<2)
}
func (o *SYSTIMER_Type) GetINT_RAW_INT2_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x4) >> 2
}

// SYSTIMER.INT_CLR: System timer interrupt clear
func (o *SYSTIMER_Type) SetINT_CLR_INT0_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x1)|value)
}
func (o *SYSTIMER_Type) GetINT_CLR_INT0_CLR() uint32 {
	return volatile.LoadUint32(&o.INT_CLR.Reg) & 0x1
}
func (o *SYSTIMER_Type) SetINT_CLR_INT1_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x2)|value<<1)
}
func (o *SYSTIMER_Type) GetINT_CLR_INT1_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x2) >> 1
}
func (o *SYSTIMER_Type) SetINT_CLR_INT2_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x4)|value<<2)
}
func (o *SYSTIMER_Type) GetINT_CLR_INT2_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x4) >> 2
}

// SYSTIMER.DATE: Version control register
func (o *SYSTIMER_Type) SetDATE(value uint32) {
	volatile.StoreUint32(&o.DATE.Reg, value)
}
func (o *SYSTIMER_Type) GetDATE() uint32 {
	return volatile.LoadUint32(&o.DATE.Reg)
}

// Peripheral TIMG
type TIMG0_Type struct {
	T0CONFIG       volatile.Register32 // 0x0
	T0LO           volatile.Register32 // 0x4
	T0HI           volatile.Register32 // 0x8
	T0UPDATE       volatile.Register32 // 0xC
	T0ALARMLO      volatile.Register32 // 0x10
	T0ALARMHI      volatile.Register32 // 0x14
	T0LOADLO       volatile.Register32 // 0x18
	T0LOADHI       volatile.Register32 // 0x1C
	T0LOAD         volatile.Register32 // 0x20
	T1CONFIG       volatile.Register32 // 0x24
	T1LO           volatile.Register32 // 0x28
	T1HI           volatile.Register32 // 0x2C
	T1UPDATE       volatile.Register32 // 0x30
	T1ALARMLO      volatile.Register32 // 0x34
	T1ALARMHI      volatile.Register32 // 0x38
	T1LOADLO       volatile.Register32 // 0x3C
	T1LOADHI       volatile.Register32 // 0x40
	T1LOAD         volatile.Register32 // 0x44
	WDTCONFIG0     volatile.Register32 // 0x48
	WDTCONFIG1     volatile.Register32 // 0x4C
	WDTCONFIG2     volatile.Register32 // 0x50
	WDTCONFIG3     volatile.Register32 // 0x54
	WDTCONFIG4     volatile.Register32 // 0x58
	WDTCONFIG5     volatile.Register32 // 0x5C
	WDTFEED        volatile.Register32 // 0x60
	WDTWPROTECT    volatile.Register32 // 0x64
	RTCCALICFG     volatile.Register32 // 0x68
	RTCCALICFG1    volatile.Register32 // 0x6C
	LACTCONFIG     volatile.Register32 // 0x70
	LACTRTC        volatile.Register32 // 0x74
	LACTLO         volatile.Register32 // 0x78
	LACTHI         volatile.Register32 // 0x7C
	LACTUPDATE     volatile.Register32 // 0x80
	LACTALARMLO    volatile.Register32 // 0x84
	LACTALARMHI    volatile.Register32 // 0x88
	LACTLOADLO     volatile.Register32 // 0x8C
	LACTLOADHI     volatile.Register32 // 0x90
	LACTLOAD       volatile.Register32 // 0x94
	INT_ENA_TIMERS volatile.Register32 // 0x98
	INT_RAW_TIMERS volatile.Register32 // 0x9C
	INT_ST_TIMERS  volatile.Register32 // 0xA0
	INT_CLR_TIMERS volatile.Register32 // 0xA4
	RTCCALICFG2    volatile.Register32 // 0xA8
	_              [76]byte
	TIMERS_DATE    volatile.Register32 // 0xF8
	REGCLK         volatile.Register32 // 0xFC
}

// TIMG0.T0CONFIG: Timer %s configuration register
func (o *TIMG0_Type) SetT0CONFIG_T0_USE_XTAL(value uint32) {
	volatile.StoreUint32(&o.T0CONFIG.Reg, volatile.LoadUint32(&o.T0CONFIG.Reg)&^(0x200)|value<<9)
}
func (o *TIMG0_Type) GetT0CONFIG_T0_USE_XTAL() uint32 {
	return (volatile.LoadUint32(&o.T0CONFIG.Reg) & 0x200) >> 9
}
func (o *TIMG0_Type) SetT0CONFIG_T0_ALARM_EN(value uint32) {
	volatile.StoreUint32(&o.T0CONFIG.Reg, volatile.LoadUint32(&o.T0CONFIG.Reg)&^(0x400)|value<<10)
}
func (o *TIMG0_Type) GetT0CONFIG_T0_ALARM_EN() uint32 {
	return (volatile.LoadUint32(&o.T0CONFIG.Reg) & 0x400) >> 10
}
func (o *TIMG0_Type) SetT0CONFIG_T0_LEVEL_INT_EN(value uint32) {
	volatile.StoreUint32(&o.T0CONFIG.Reg, volatile.LoadUint32(&o.T0CONFIG.Reg)&^(0x800)|value<<11)
}
func (o *TIMG0_Type) GetT0CONFIG_T0_LEVEL_INT_EN() uint32 {
	return (volatile.LoadUint32(&o.T0CONFIG.Reg) & 0x800) >> 11
}
func (o *TIMG0_Type) SetT0CONFIG_T0_EDGE_INT_EN(value uint32) {
	volatile.StoreUint32(&o.T0CONFIG.Reg, volatile.LoadUint32(&o.T0CONFIG.Reg)&^(0x1000)|value<<12)
}
func (o *TIMG0_Type) GetT0CONFIG_T0_EDGE_INT_EN() uint32 {
	return (volatile.LoadUint32(&o.T0CONFIG.Reg) & 0x1000) >> 12
}
func (o *TIMG0_Type) SetT0CONFIG_T0_DIVIDER(value uint32) {
	volatile.StoreUint32(&o.T0CONFIG.Reg, volatile.LoadUint32(&o.T0CONFIG.Reg)&^(0x1fffe000)|value<<13)
}
func (o *TIMG0_Type) GetT0CONFIG_T0_DIVIDER() uint32 {
	return (volatile.LoadUint32(&o.T0CONFIG.Reg) & 0x1fffe000) >> 13
}
func (o *TIMG0_Type) SetT0CONFIG_T0_AUTORELOAD(value uint32) {
	volatile.StoreUint32(&o.T0CONFIG.Reg, volatile.LoadUint32(&o.T0CONFIG.Reg)&^(0x20000000)|value<<29)
}
func (o *TIMG0_Type) GetT0CONFIG_T0_AUTORELOAD() uint32 {
	return (volatile.LoadUint32(&o.T0CONFIG.Reg) & 0x20000000) >> 29
}
func (o *TIMG0_Type) SetT0CONFIG_T0_INCREASE(value uint32) {
	volatile.StoreUint32(&o.T0CONFIG.Reg, volatile.LoadUint32(&o.T0CONFIG.Reg)&^(0x40000000)|value<<30)
}
func (o *TIMG0_Type) GetT0CONFIG_T0_INCREASE() uint32 {
	return (volatile.LoadUint32(&o.T0CONFIG.Reg) & 0x40000000) >> 30
}
func (o *TIMG0_Type) SetT0CONFIG_T0_EN(value uint32) {
	volatile.StoreUint32(&o.T0CONFIG.Reg, volatile.LoadUint32(&o.T0CONFIG.Reg)&^(0x80000000)|value<<31)
}
func (o *TIMG0_Type) GetT0CONFIG_T0_EN() uint32 {
	return (volatile.LoadUint32(&o.T0CONFIG.Reg) & 0x80000000) >> 31
}

// TIMG0.T0LO: Timer %s current value, low 32 bits
func (o *TIMG0_Type) SetT0LO(value uint32) {
	volatile.StoreUint32(&o.T0LO.Reg, value)
}
func (o *TIMG0_Type) GetT0LO() uint32 {
	return volatile.LoadUint32(&o.T0LO.Reg)
}

// TIMG0.T0HI: Timer %s current value, high 32 bits
func (o *TIMG0_Type) SetT0HI(value uint32) {
	volatile.StoreUint32(&o.T0HI.Reg, value)
}
func (o *TIMG0_Type) GetT0HI() uint32 {
	return volatile.LoadUint32(&o.T0HI.Reg)
}

// TIMG0.T0UPDATE: Write to copy current timer value to TIMGn_T%s_(LO/HI)_REG
func (o *TIMG0_Type) SetT0UPDATE_T0_UPDATE(value uint32) {
	volatile.StoreUint32(&o.T0UPDATE.Reg, volatile.LoadUint32(&o.T0UPDATE.Reg)&^(0x80000000)|value<<31)
}
func (o *TIMG0_Type) GetT0UPDATE_T0_UPDATE() uint32 {
	return (volatile.LoadUint32(&o.T0UPDATE.Reg) & 0x80000000) >> 31
}

// TIMG0.T0ALARMLO: Timer %s alarm value, low 32 bits
func (o *TIMG0_Type) SetT0ALARMLO(value uint32) {
	volatile.StoreUint32(&o.T0ALARMLO.Reg, value)
}
func (o *TIMG0_Type) GetT0ALARMLO() uint32 {
	return volatile.LoadUint32(&o.T0ALARMLO.Reg)
}

// TIMG0.T0ALARMHI: Timer %s alarm value, high bits
func (o *TIMG0_Type) SetT0ALARMHI(value uint32) {
	volatile.StoreUint32(&o.T0ALARMHI.Reg, value)
}
func (o *TIMG0_Type) GetT0ALARMHI() uint32 {
	return volatile.LoadUint32(&o.T0ALARMHI.Reg)
}

// TIMG0.T0LOADLO: Timer %s reload value, low 32 bits
func (o *TIMG0_Type) SetT0LOADLO(value uint32) {
	volatile.StoreUint32(&o.T0LOADLO.Reg, value)
}
func (o *TIMG0_Type) GetT0LOADLO() uint32 {
	return volatile.LoadUint32(&o.T0LOADLO.Reg)
}

// TIMG0.T0LOADHI: Timer %s reload value, high 32 bits
func (o *TIMG0_Type) SetT0LOADHI(value uint32) {
	volatile.StoreUint32(&o.T0LOADHI.Reg, value)
}
func (o *TIMG0_Type) GetT0LOADHI() uint32 {
	return volatile.LoadUint32(&o.T0LOADHI.Reg)
}

// TIMG0.T0LOAD: Write to reload timer from TIMG_T0_(LOADLOLOADHI)_REG
func (o *TIMG0_Type) SetT0LOAD(value uint32) {
	volatile.StoreUint32(&o.T0LOAD.Reg, value)
}
func (o *TIMG0_Type) GetT0LOAD() uint32 {
	return volatile.LoadUint32(&o.T0LOAD.Reg)
}

// TIMG0.T1CONFIG: Timer %s configuration register
func (o *TIMG0_Type) SetT1CONFIG_T0_USE_XTAL(value uint32) {
	volatile.StoreUint32(&o.T1CONFIG.Reg, volatile.LoadUint32(&o.T1CONFIG.Reg)&^(0x200)|value<<9)
}
func (o *TIMG0_Type) GetT1CONFIG_T0_USE_XTAL() uint32 {
	return (volatile.LoadUint32(&o.T1CONFIG.Reg) & 0x200) >> 9
}
func (o *TIMG0_Type) SetT1CONFIG_T0_ALARM_EN(value uint32) {
	volatile.StoreUint32(&o.T1CONFIG.Reg, volatile.LoadUint32(&o.T1CONFIG.Reg)&^(0x400)|value<<10)
}
func (o *TIMG0_Type) GetT1CONFIG_T0_ALARM_EN() uint32 {
	return (volatile.LoadUint32(&o.T1CONFIG.Reg) & 0x400) >> 10
}
func (o *TIMG0_Type) SetT1CONFIG_T0_LEVEL_INT_EN(value uint32) {
	volatile.StoreUint32(&o.T1CONFIG.Reg, volatile.LoadUint32(&o.T1CONFIG.Reg)&^(0x800)|value<<11)
}
func (o *TIMG0_Type) GetT1CONFIG_T0_LEVEL_INT_EN() uint32 {
	return (volatile.LoadUint32(&o.T1CONFIG.Reg) & 0x800) >> 11
}
func (o *TIMG0_Type) SetT1CONFIG_T0_EDGE_INT_EN(value uint32) {
	volatile.StoreUint32(&o.T1CONFIG.Reg, volatile.LoadUint32(&o.T1CONFIG.Reg)&^(0x1000)|value<<12)
}
func (o *TIMG0_Type) GetT1CONFIG_T0_EDGE_INT_EN() uint32 {
	return (volatile.LoadUint32(&o.T1CONFIG.Reg) & 0x1000) >> 12
}
func (o *TIMG0_Type) SetT1CONFIG_T0_DIVIDER(value uint32) {
	volatile.StoreUint32(&o.T1CONFIG.Reg, volatile.LoadUint32(&o.T1CONFIG.Reg)&^(0x1fffe000)|value<<13)
}
func (o *TIMG0_Type) GetT1CONFIG_T0_DIVIDER() uint32 {
	return (volatile.LoadUint32(&o.T1CONFIG.Reg) & 0x1fffe000) >> 13
}
func (o *TIMG0_Type) SetT1CONFIG_T0_AUTORELOAD(value uint32) {
	volatile.StoreUint32(&o.T1CONFIG.Reg, volatile.LoadUint32(&o.T1CONFIG.Reg)&^(0x20000000)|value<<29)
}
func (o *TIMG0_Type) GetT1CONFIG_T0_AUTORELOAD() uint32 {
	return (volatile.LoadUint32(&o.T1CONFIG.Reg) & 0x20000000) >> 29
}
func (o *TIMG0_Type) SetT1CONFIG_T0_INCREASE(value uint32) {
	volatile.StoreUint32(&o.T1CONFIG.Reg, volatile.LoadUint32(&o.T1CONFIG.Reg)&^(0x40000000)|value<<30)
}
func (o *TIMG0_Type) GetT1CONFIG_T0_INCREASE() uint32 {
	return (volatile.LoadUint32(&o.T1CONFIG.Reg) & 0x40000000) >> 30
}
func (o *TIMG0_Type) SetT1CONFIG_T0_EN(value uint32) {
	volatile.StoreUint32(&o.T1CONFIG.Reg, volatile.LoadUint32(&o.T1CONFIG.Reg)&^(0x80000000)|value<<31)
}
func (o *TIMG0_Type) GetT1CONFIG_T0_EN() uint32 {
	return (volatile.LoadUint32(&o.T1CONFIG.Reg) & 0x80000000) >> 31
}

// TIMG0.T1LO: Timer %s current value, low 32 bits
func (o *TIMG0_Type) SetT1LO(value uint32) {
	volatile.StoreUint32(&o.T1LO.Reg, value)
}
func (o *TIMG0_Type) GetT1LO() uint32 {
	return volatile.LoadUint32(&o.T1LO.Reg)
}

// TIMG0.T1HI: Timer %s current value, high 32 bits
func (o *TIMG0_Type) SetT1HI(value uint32) {
	volatile.StoreUint32(&o.T1HI.Reg, value)
}
func (o *TIMG0_Type) GetT1HI() uint32 {
	return volatile.LoadUint32(&o.T1HI.Reg)
}

// TIMG0.T1UPDATE: Write to copy current timer value to TIMGn_T%s_(LO/HI)_REG
func (o *TIMG0_Type) SetT1UPDATE_T0_UPDATE(value uint32) {
	volatile.StoreUint32(&o.T1UPDATE.Reg, volatile.LoadUint32(&o.T1UPDATE.Reg)&^(0x80000000)|value<<31)
}
func (o *TIMG0_Type) GetT1UPDATE_T0_UPDATE() uint32 {
	return (volatile.LoadUint32(&o.T1UPDATE.Reg) & 0x80000000) >> 31
}

// TIMG0.T1ALARMLO: Timer %s alarm value, low 32 bits
func (o *TIMG0_Type) SetT1ALARMLO(value uint32) {
	volatile.StoreUint32(&o.T1ALARMLO.Reg, value)
}
func (o *TIMG0_Type) GetT1ALARMLO() uint32 {
	return volatile.LoadUint32(&o.T1ALARMLO.Reg)
}

// TIMG0.T1ALARMHI: Timer %s alarm value, high bits
func (o *TIMG0_Type) SetT1ALARMHI(value uint32) {
	volatile.StoreUint32(&o.T1ALARMHI.Reg, value)
}
func (o *TIMG0_Type) GetT1ALARMHI() uint32 {
	return volatile.LoadUint32(&o.T1ALARMHI.Reg)
}

// TIMG0.T1LOADLO: Timer %s reload value, low 32 bits
func (o *TIMG0_Type) SetT1LOADLO(value uint32) {
	volatile.StoreUint32(&o.T1LOADLO.Reg, value)
}
func (o *TIMG0_Type) GetT1LOADLO() uint32 {
	return volatile.LoadUint32(&o.T1LOADLO.Reg)
}

// TIMG0.T1LOADHI: Timer %s reload value, high 32 bits
func (o *TIMG0_Type) SetT1LOADHI(value uint32) {
	volatile.StoreUint32(&o.T1LOADHI.Reg, value)
}
func (o *TIMG0_Type) GetT1LOADHI() uint32 {
	return volatile.LoadUint32(&o.T1LOADHI.Reg)
}

// TIMG0.T1LOAD: Write to reload timer from TIMG_T0_(LOADLOLOADHI)_REG
func (o *TIMG0_Type) SetT1LOAD(value uint32) {
	volatile.StoreUint32(&o.T1LOAD.Reg, value)
}
func (o *TIMG0_Type) GetT1LOAD() uint32 {
	return volatile.LoadUint32(&o.T1LOAD.Reg)
}

// TIMG0.WDTCONFIG0: Watchdog timer configuration register
func (o *TIMG0_Type) SetWDTCONFIG0_WDT_APPCPU_RESET_EN(value uint32) {
	volatile.StoreUint32(&o.WDTCONFIG0.Reg, volatile.LoadUint32(&o.WDTCONFIG0.Reg)&^(0x1000)|value<<12)
}
func (o *TIMG0_Type) GetWDTCONFIG0_WDT_APPCPU_RESET_EN() uint32 {
	return (volatile.LoadUint32(&o.WDTCONFIG0.Reg) & 0x1000) >> 12
}
func (o *TIMG0_Type) SetWDTCONFIG0_WDT_PROCPU_RESET_EN(value uint32) {
	volatile.StoreUint32(&o.WDTCONFIG0.Reg, volatile.LoadUint32(&o.WDTCONFIG0.Reg)&^(0x2000)|value<<13)
}
func (o *TIMG0_Type) GetWDTCONFIG0_WDT_PROCPU_RESET_EN() uint32 {
	return (volatile.LoadUint32(&o.WDTCONFIG0.Reg) & 0x2000) >> 13
}
func (o *TIMG0_Type) SetWDTCONFIG0_WDT_FLASHBOOT_MOD_EN(value uint32) {
	volatile.StoreUint32(&o.WDTCONFIG0.Reg, volatile.LoadUint32(&o.WDTCONFIG0.Reg)&^(0x4000)|value<<14)
}
func (o *TIMG0_Type) GetWDTCONFIG0_WDT_FLASHBOOT_MOD_EN() uint32 {
	return (volatile.LoadUint32(&o.WDTCONFIG0.Reg) & 0x4000) >> 14
}
func (o *TIMG0_Type) SetWDTCONFIG0_WDT_SYS_RESET_LENGTH(value uint32) {
	volatile.StoreUint32(&o.WDTCONFIG0.Reg, volatile.LoadUint32(&o.WDTCONFIG0.Reg)&^(0x38000)|value<<15)
}
func (o *TIMG0_Type) GetWDTCONFIG0_WDT_SYS_RESET_LENGTH() uint32 {
	return (volatile.LoadUint32(&o.WDTCONFIG0.Reg) & 0x38000) >> 15
}
func (o *TIMG0_Type) SetWDTCONFIG0_WDT_CPU_RESET_LENGTH(value uint32) {
	volatile.StoreUint32(&o.WDTCONFIG0.Reg, volatile.LoadUint32(&o.WDTCONFIG0.Reg)&^(0x1c0000)|value<<18)
}
func (o *TIMG0_Type) GetWDTCONFIG0_WDT_CPU_RESET_LENGTH() uint32 {
	return (volatile.LoadUint32(&o.WDTCONFIG0.Reg) & 0x1c0000) >> 18
}
func (o *TIMG0_Type) SetWDTCONFIG0_WDT_LEVEL_INT_EN(value uint32) {
	volatile.StoreUint32(&o.WDTCONFIG0.Reg, volatile.LoadUint32(&o.WDTCONFIG0.Reg)&^(0x200000)|value<<21)
}
func (o *TIMG0_Type) GetWDTCONFIG0_WDT_LEVEL_INT_EN() uint32 {
	return (volatile.LoadUint32(&o.WDTCONFIG0.Reg) & 0x200000) >> 21
}
func (o *TIMG0_Type) SetWDTCONFIG0_WDT_EDGE_INT_EN(value uint32) {
	volatile.StoreUint32(&o.WDTCONFIG0.Reg, volatile.LoadUint32(&o.WDTCONFIG0.Reg)&^(0x400000)|value<<22)
}
func (o *TIMG0_Type) GetWDTCONFIG0_WDT_EDGE_INT_EN() uint32 {
	return (volatile.LoadUint32(&o.WDTCONFIG0.Reg) & 0x400000) >> 22
}
func (o *TIMG0_Type) SetWDTCONFIG0_WDT_STG3(value uint32) {
	volatile.StoreUint32(&o.WDTCONFIG0.Reg, volatile.LoadUint32(&o.WDTCONFIG0.Reg)&^(0x1800000)|value<<23)
}
func (o *TIMG0_Type) GetWDTCONFIG0_WDT_STG3() uint32 {
	return (volatile.LoadUint32(&o.WDTCONFIG0.Reg) & 0x1800000) >> 23
}
func (o *TIMG0_Type) SetWDTCONFIG0_WDT_STG2(value uint32) {
	volatile.StoreUint32(&o.WDTCONFIG0.Reg, volatile.LoadUint32(&o.WDTCONFIG0.Reg)&^(0x6000000)|value<<25)
}
func (o *TIMG0_Type) GetWDTCONFIG0_WDT_STG2() uint32 {
	return (volatile.LoadUint32(&o.WDTCONFIG0.Reg) & 0x6000000) >> 25
}
func (o *TIMG0_Type) SetWDTCONFIG0_WDT_STG1(value uint32) {
	volatile.StoreUint32(&o.WDTCONFIG0.Reg, volatile.LoadUint32(&o.WDTCONFIG0.Reg)&^(0x18000000)|value<<27)
}
func (o *TIMG0_Type) GetWDTCONFIG0_WDT_STG1() uint32 {
	return (volatile.LoadUint32(&o.WDTCONFIG0.Reg) & 0x18000000) >> 27
}
func (o *TIMG0_Type) SetWDTCONFIG0_WDT_STG0(value uint32) {
	volatile.StoreUint32(&o.WDTCONFIG0.Reg, volatile.LoadUint32(&o.WDTCONFIG0.Reg)&^(0x60000000)|value<<29)
}
func (o *TIMG0_Type) GetWDTCONFIG0_WDT_STG0() uint32 {
	return (volatile.LoadUint32(&o.WDTCONFIG0.Reg) & 0x60000000) >> 29
}
func (o *TIMG0_Type) SetWDTCONFIG0_WDT_EN(value uint32) {
	volatile.StoreUint32(&o.WDTCONFIG0.Reg, volatile.LoadUint32(&o.WDTCONFIG0.Reg)&^(0x80000000)|value<<31)
}
func (o *TIMG0_Type) GetWDTCONFIG0_WDT_EN() uint32 {
	return (volatile.LoadUint32(&o.WDTCONFIG0.Reg) & 0x80000000) >> 31
}

// TIMG0.WDTCONFIG1: Watchdog timer prescaler register
func (o *TIMG0_Type) SetWDTCONFIG1_WDT_CLK_PRESCALER(value uint32) {
	volatile.StoreUint32(&o.WDTCONFIG1.Reg, volatile.LoadUint32(&o.WDTCONFIG1.Reg)&^(0xffff0000)|value<<16)
}
func (o *TIMG0_Type) GetWDTCONFIG1_WDT_CLK_PRESCALER() uint32 {
	return (volatile.LoadUint32(&o.WDTCONFIG1.Reg) & 0xffff0000) >> 16
}

// TIMG0.WDTCONFIG2: Watchdog timer stage 0 timeout value
func (o *TIMG0_Type) SetWDTCONFIG2(value uint32) {
	volatile.StoreUint32(&o.WDTCONFIG2.Reg, value)
}
func (o *TIMG0_Type) GetWDTCONFIG2() uint32 {
	return volatile.LoadUint32(&o.WDTCONFIG2.Reg)
}

// TIMG0.WDTCONFIG3: Watchdog timer stage 1 timeout value
func (o *TIMG0_Type) SetWDTCONFIG3(value uint32) {
	volatile.StoreUint32(&o.WDTCONFIG3.Reg, value)
}
func (o *TIMG0_Type) GetWDTCONFIG3() uint32 {
	return volatile.LoadUint32(&o.WDTCONFIG3.Reg)
}

// TIMG0.WDTCONFIG4: Watchdog timer stage 2 timeout value
func (o *TIMG0_Type) SetWDTCONFIG4(value uint32) {
	volatile.StoreUint32(&o.WDTCONFIG4.Reg, value)
}
func (o *TIMG0_Type) GetWDTCONFIG4() uint32 {
	return volatile.LoadUint32(&o.WDTCONFIG4.Reg)
}

// TIMG0.WDTCONFIG5: Watchdog timer stage 3 timeout value
func (o *TIMG0_Type) SetWDTCONFIG5(value uint32) {
	volatile.StoreUint32(&o.WDTCONFIG5.Reg, value)
}
func (o *TIMG0_Type) GetWDTCONFIG5() uint32 {
	return volatile.LoadUint32(&o.WDTCONFIG5.Reg)
}

// TIMG0.WDTFEED: Write to feed the watchdog timer
func (o *TIMG0_Type) SetWDTFEED(value uint32) {
	volatile.StoreUint32(&o.WDTFEED.Reg, value)
}
func (o *TIMG0_Type) GetWDTFEED() uint32 {
	return volatile.LoadUint32(&o.WDTFEED.Reg)
}

// TIMG0.WDTWPROTECT: Watchdog write protect register
func (o *TIMG0_Type) SetWDTWPROTECT(value uint32) {
	volatile.StoreUint32(&o.WDTWPROTECT.Reg, value)
}
func (o *TIMG0_Type) GetWDTWPROTECT() uint32 {
	return volatile.LoadUint32(&o.WDTWPROTECT.Reg)
}

// TIMG0.RTCCALICFG: RTC calibration configuration register
func (o *TIMG0_Type) SetRTCCALICFG_RTC_CALI_START_CYCLING(value uint32) {
	volatile.StoreUint32(&o.RTCCALICFG.Reg, volatile.LoadUint32(&o.RTCCALICFG.Reg)&^(0x1000)|value<<12)
}
func (o *TIMG0_Type) GetRTCCALICFG_RTC_CALI_START_CYCLING() uint32 {
	return (volatile.LoadUint32(&o.RTCCALICFG.Reg) & 0x1000) >> 12
}
func (o *TIMG0_Type) SetRTCCALICFG_RTC_CALI_CLK_SEL(value uint32) {
	volatile.StoreUint32(&o.RTCCALICFG.Reg, volatile.LoadUint32(&o.RTCCALICFG.Reg)&^(0x6000)|value<<13)
}
func (o *TIMG0_Type) GetRTCCALICFG_RTC_CALI_CLK_SEL() uint32 {
	return (volatile.LoadUint32(&o.RTCCALICFG.Reg) & 0x6000) >> 13
}
func (o *TIMG0_Type) SetRTCCALICFG_RTC_CALI_RDY(value uint32) {
	volatile.StoreUint32(&o.RTCCALICFG.Reg, volatile.LoadUint32(&o.RTCCALICFG.Reg)&^(0x8000)|value<<15)
}
func (o *TIMG0_Type) GetRTCCALICFG_RTC_CALI_RDY() uint32 {
	return (volatile.LoadUint32(&o.RTCCALICFG.Reg) & 0x8000) >> 15
}
func (o *TIMG0_Type) SetRTCCALICFG_RTC_CALI_MAX(value uint32) {
	volatile.StoreUint32(&o.RTCCALICFG.Reg, volatile.LoadUint32(&o.RTCCALICFG.Reg)&^(0x7fff0000)|value<<16)
}
func (o *TIMG0_Type) GetRTCCALICFG_RTC_CALI_MAX() uint32 {
	return (volatile.LoadUint32(&o.RTCCALICFG.Reg) & 0x7fff0000) >> 16
}
func (o *TIMG0_Type) SetRTCCALICFG_RTC_CALI_START(value uint32) {
	volatile.StoreUint32(&o.RTCCALICFG.Reg, volatile.LoadUint32(&o.RTCCALICFG.Reg)&^(0x80000000)|value<<31)
}
func (o *TIMG0_Type) GetRTCCALICFG_RTC_CALI_START() uint32 {
	return (volatile.LoadUint32(&o.RTCCALICFG.Reg) & 0x80000000) >> 31
}

// TIMG0.RTCCALICFG1: RTC calibration configuration1 register
func (o *TIMG0_Type) SetRTCCALICFG1_RTC_CALI_CYCLING_DATA_VLD(value uint32) {
	volatile.StoreUint32(&o.RTCCALICFG1.Reg, volatile.LoadUint32(&o.RTCCALICFG1.Reg)&^(0x1)|value)
}
func (o *TIMG0_Type) GetRTCCALICFG1_RTC_CALI_CYCLING_DATA_VLD() uint32 {
	return volatile.LoadUint32(&o.RTCCALICFG1.Reg) & 0x1
}
func (o *TIMG0_Type) SetRTCCALICFG1_RTC_CALI_VALUE(value uint32) {
	volatile.StoreUint32(&o.RTCCALICFG1.Reg, volatile.LoadUint32(&o.RTCCALICFG1.Reg)&^(0xffffff80)|value<<7)
}
func (o *TIMG0_Type) GetRTCCALICFG1_RTC_CALI_VALUE() uint32 {
	return (volatile.LoadUint32(&o.RTCCALICFG1.Reg) & 0xffffff80) >> 7
}

// TIMG0.LACTCONFIG: LACT configuration register
func (o *TIMG0_Type) SetLACTCONFIG_LACT_USE_REFTICK(value uint32) {
	volatile.StoreUint32(&o.LACTCONFIG.Reg, volatile.LoadUint32(&o.LACTCONFIG.Reg)&^(0x40)|value<<6)
}
func (o *TIMG0_Type) GetLACTCONFIG_LACT_USE_REFTICK() uint32 {
	return (volatile.LoadUint32(&o.LACTCONFIG.Reg) & 0x40) >> 6
}
func (o *TIMG0_Type) SetLACTCONFIG_LACT_RTC_ONLY(value uint32) {
	volatile.StoreUint32(&o.LACTCONFIG.Reg, volatile.LoadUint32(&o.LACTCONFIG.Reg)&^(0x80)|value<<7)
}
func (o *TIMG0_Type) GetLACTCONFIG_LACT_RTC_ONLY() uint32 {
	return (volatile.LoadUint32(&o.LACTCONFIG.Reg) & 0x80) >> 7
}
func (o *TIMG0_Type) SetLACTCONFIG_LACT_CPST_EN(value uint32) {
	volatile.StoreUint32(&o.LACTCONFIG.Reg, volatile.LoadUint32(&o.LACTCONFIG.Reg)&^(0x100)|value<<8)
}
func (o *TIMG0_Type) GetLACTCONFIG_LACT_CPST_EN() uint32 {
	return (volatile.LoadUint32(&o.LACTCONFIG.Reg) & 0x100) >> 8
}
func (o *TIMG0_Type) SetLACTCONFIG_LACT_LAC_EN(value uint32) {
	volatile.StoreUint32(&o.LACTCONFIG.Reg, volatile.LoadUint32(&o.LACTCONFIG.Reg)&^(0x200)|value<<9)
}
func (o *TIMG0_Type) GetLACTCONFIG_LACT_LAC_EN() uint32 {
	return (volatile.LoadUint32(&o.LACTCONFIG.Reg) & 0x200) >> 9
}
func (o *TIMG0_Type) SetLACTCONFIG_LACT_ALARM_EN(value uint32) {
	volatile.StoreUint32(&o.LACTCONFIG.Reg, volatile.LoadUint32(&o.LACTCONFIG.Reg)&^(0x400)|value<<10)
}
func (o *TIMG0_Type) GetLACTCONFIG_LACT_ALARM_EN() uint32 {
	return (volatile.LoadUint32(&o.LACTCONFIG.Reg) & 0x400) >> 10
}
func (o *TIMG0_Type) SetLACTCONFIG_LACT_LEVEL_INT_EN(value uint32) {
	volatile.StoreUint32(&o.LACTCONFIG.Reg, volatile.LoadUint32(&o.LACTCONFIG.Reg)&^(0x800)|value<<11)
}
func (o *TIMG0_Type) GetLACTCONFIG_LACT_LEVEL_INT_EN() uint32 {
	return (volatile.LoadUint32(&o.LACTCONFIG.Reg) & 0x800) >> 11
}
func (o *TIMG0_Type) SetLACTCONFIG_LACT_EDGE_INT_EN(value uint32) {
	volatile.StoreUint32(&o.LACTCONFIG.Reg, volatile.LoadUint32(&o.LACTCONFIG.Reg)&^(0x1000)|value<<12)
}
func (o *TIMG0_Type) GetLACTCONFIG_LACT_EDGE_INT_EN() uint32 {
	return (volatile.LoadUint32(&o.LACTCONFIG.Reg) & 0x1000) >> 12
}
func (o *TIMG0_Type) SetLACTCONFIG_LACT_DIVIDER(value uint32) {
	volatile.StoreUint32(&o.LACTCONFIG.Reg, volatile.LoadUint32(&o.LACTCONFIG.Reg)&^(0x1fffe000)|value<<13)
}
func (o *TIMG0_Type) GetLACTCONFIG_LACT_DIVIDER() uint32 {
	return (volatile.LoadUint32(&o.LACTCONFIG.Reg) & 0x1fffe000) >> 13
}
func (o *TIMG0_Type) SetLACTCONFIG_LACT_AUTORELOAD(value uint32) {
	volatile.StoreUint32(&o.LACTCONFIG.Reg, volatile.LoadUint32(&o.LACTCONFIG.Reg)&^(0x20000000)|value<<29)
}
func (o *TIMG0_Type) GetLACTCONFIG_LACT_AUTORELOAD() uint32 {
	return (volatile.LoadUint32(&o.LACTCONFIG.Reg) & 0x20000000) >> 29
}
func (o *TIMG0_Type) SetLACTCONFIG_LACT_INCREASE(value uint32) {
	volatile.StoreUint32(&o.LACTCONFIG.Reg, volatile.LoadUint32(&o.LACTCONFIG.Reg)&^(0x40000000)|value<<30)
}
func (o *TIMG0_Type) GetLACTCONFIG_LACT_INCREASE() uint32 {
	return (volatile.LoadUint32(&o.LACTCONFIG.Reg) & 0x40000000) >> 30
}
func (o *TIMG0_Type) SetLACTCONFIG_LACT_EN(value uint32) {
	volatile.StoreUint32(&o.LACTCONFIG.Reg, volatile.LoadUint32(&o.LACTCONFIG.Reg)&^(0x80000000)|value<<31)
}
func (o *TIMG0_Type) GetLACTCONFIG_LACT_EN() uint32 {
	return (volatile.LoadUint32(&o.LACTCONFIG.Reg) & 0x80000000) >> 31
}

// TIMG0.LACTRTC: LACT RTC register
func (o *TIMG0_Type) SetLACTRTC_LACT_RTC_STEP_LEN(value uint32) {
	volatile.StoreUint32(&o.LACTRTC.Reg, volatile.LoadUint32(&o.LACTRTC.Reg)&^(0xffffffc0)|value<<6)
}
func (o *TIMG0_Type) GetLACTRTC_LACT_RTC_STEP_LEN() uint32 {
	return (volatile.LoadUint32(&o.LACTRTC.Reg) & 0xffffffc0) >> 6
}

// TIMG0.LACTLO: LACT low register
func (o *TIMG0_Type) SetLACTLO(value uint32) {
	volatile.StoreUint32(&o.LACTLO.Reg, value)
}
func (o *TIMG0_Type) GetLACTLO() uint32 {
	return volatile.LoadUint32(&o.LACTLO.Reg)
}

// TIMG0.LACTHI: LACT high register
func (o *TIMG0_Type) SetLACTHI(value uint32) {
	volatile.StoreUint32(&o.LACTHI.Reg, value)
}
func (o *TIMG0_Type) GetLACTHI() uint32 {
	return volatile.LoadUint32(&o.LACTHI.Reg)
}

// TIMG0.LACTUPDATE: LACT update register
func (o *TIMG0_Type) SetLACTUPDATE(value uint32) {
	volatile.StoreUint32(&o.LACTUPDATE.Reg, value)
}
func (o *TIMG0_Type) GetLACTUPDATE() uint32 {
	return volatile.LoadUint32(&o.LACTUPDATE.Reg)
}

// TIMG0.LACTALARMLO: LACT alarm low register
func (o *TIMG0_Type) SetLACTALARMLO(value uint32) {
	volatile.StoreUint32(&o.LACTALARMLO.Reg, value)
}
func (o *TIMG0_Type) GetLACTALARMLO() uint32 {
	return volatile.LoadUint32(&o.LACTALARMLO.Reg)
}

// TIMG0.LACTALARMHI: LACT alarm high register
func (o *TIMG0_Type) SetLACTALARMHI(value uint32) {
	volatile.StoreUint32(&o.LACTALARMHI.Reg, value)
}
func (o *TIMG0_Type) GetLACTALARMHI() uint32 {
	return volatile.LoadUint32(&o.LACTALARMHI.Reg)
}

// TIMG0.LACTLOADLO: LACT load low register
func (o *TIMG0_Type) SetLACTLOADLO(value uint32) {
	volatile.StoreUint32(&o.LACTLOADLO.Reg, value)
}
func (o *TIMG0_Type) GetLACTLOADLO() uint32 {
	return volatile.LoadUint32(&o.LACTLOADLO.Reg)
}

// TIMG0.LACTLOADHI: Timer LACT load high register
func (o *TIMG0_Type) SetLACTLOADHI(value uint32) {
	volatile.StoreUint32(&o.LACTLOADHI.Reg, value)
}
func (o *TIMG0_Type) GetLACTLOADHI() uint32 {
	return volatile.LoadUint32(&o.LACTLOADHI.Reg)
}

// TIMG0.LACTLOAD: Timer LACT load register
func (o *TIMG0_Type) SetLACTLOAD(value uint32) {
	volatile.StoreUint32(&o.LACTLOAD.Reg, value)
}
func (o *TIMG0_Type) GetLACTLOAD() uint32 {
	return volatile.LoadUint32(&o.LACTLOAD.Reg)
}

// TIMG0.INT_ENA_TIMERS: Interrupt enable bits
func (o *TIMG0_Type) SetINT_ENA_TIMERS_T0_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA_TIMERS.Reg, volatile.LoadUint32(&o.INT_ENA_TIMERS.Reg)&^(0x1)|value)
}
func (o *TIMG0_Type) GetINT_ENA_TIMERS_T0_INT_ENA() uint32 {
	return volatile.LoadUint32(&o.INT_ENA_TIMERS.Reg) & 0x1
}
func (o *TIMG0_Type) SetINT_ENA_TIMERS_T1_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA_TIMERS.Reg, volatile.LoadUint32(&o.INT_ENA_TIMERS.Reg)&^(0x2)|value<<1)
}
func (o *TIMG0_Type) GetINT_ENA_TIMERS_T1_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA_TIMERS.Reg) & 0x2) >> 1
}
func (o *TIMG0_Type) SetINT_ENA_TIMERS_WDT_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA_TIMERS.Reg, volatile.LoadUint32(&o.INT_ENA_TIMERS.Reg)&^(0x4)|value<<2)
}
func (o *TIMG0_Type) GetINT_ENA_TIMERS_WDT_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA_TIMERS.Reg) & 0x4) >> 2
}
func (o *TIMG0_Type) SetINT_ENA_TIMERS_LACT_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA_TIMERS.Reg, volatile.LoadUint32(&o.INT_ENA_TIMERS.Reg)&^(0x8)|value<<3)
}
func (o *TIMG0_Type) GetINT_ENA_TIMERS_LACT_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA_TIMERS.Reg) & 0x8) >> 3
}

// TIMG0.INT_RAW_TIMERS: Raw interrupt status
func (o *TIMG0_Type) SetINT_RAW_TIMERS_T0_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW_TIMERS.Reg, volatile.LoadUint32(&o.INT_RAW_TIMERS.Reg)&^(0x1)|value)
}
func (o *TIMG0_Type) GetINT_RAW_TIMERS_T0_INT_RAW() uint32 {
	return volatile.LoadUint32(&o.INT_RAW_TIMERS.Reg) & 0x1
}
func (o *TIMG0_Type) SetINT_RAW_TIMERS_T1_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW_TIMERS.Reg, volatile.LoadUint32(&o.INT_RAW_TIMERS.Reg)&^(0x2)|value<<1)
}
func (o *TIMG0_Type) GetINT_RAW_TIMERS_T1_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW_TIMERS.Reg) & 0x2) >> 1
}
func (o *TIMG0_Type) SetINT_RAW_TIMERS_WDT_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW_TIMERS.Reg, volatile.LoadUint32(&o.INT_RAW_TIMERS.Reg)&^(0x4)|value<<2)
}
func (o *TIMG0_Type) GetINT_RAW_TIMERS_WDT_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW_TIMERS.Reg) & 0x4) >> 2
}
func (o *TIMG0_Type) SetINT_RAW_TIMERS_LACT_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW_TIMERS.Reg, volatile.LoadUint32(&o.INT_RAW_TIMERS.Reg)&^(0x8)|value<<3)
}
func (o *TIMG0_Type) GetINT_RAW_TIMERS_LACT_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW_TIMERS.Reg) & 0x8) >> 3
}

// TIMG0.INT_ST_TIMERS: Masked interrupt status
func (o *TIMG0_Type) SetINT_ST_TIMERS_T0_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST_TIMERS.Reg, volatile.LoadUint32(&o.INT_ST_TIMERS.Reg)&^(0x1)|value)
}
func (o *TIMG0_Type) GetINT_ST_TIMERS_T0_INT_ST() uint32 {
	return volatile.LoadUint32(&o.INT_ST_TIMERS.Reg) & 0x1
}
func (o *TIMG0_Type) SetINT_ST_TIMERS_T1_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST_TIMERS.Reg, volatile.LoadUint32(&o.INT_ST_TIMERS.Reg)&^(0x2)|value<<1)
}
func (o *TIMG0_Type) GetINT_ST_TIMERS_T1_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST_TIMERS.Reg) & 0x2) >> 1
}
func (o *TIMG0_Type) SetINT_ST_TIMERS_WDT_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST_TIMERS.Reg, volatile.LoadUint32(&o.INT_ST_TIMERS.Reg)&^(0x4)|value<<2)
}
func (o *TIMG0_Type) GetINT_ST_TIMERS_WDT_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST_TIMERS.Reg) & 0x4) >> 2
}
func (o *TIMG0_Type) SetINT_ST_TIMERS_LACT_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST_TIMERS.Reg, volatile.LoadUint32(&o.INT_ST_TIMERS.Reg)&^(0x8)|value<<3)
}
func (o *TIMG0_Type) GetINT_ST_TIMERS_LACT_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST_TIMERS.Reg) & 0x8) >> 3
}

// TIMG0.INT_CLR_TIMERS: Interrupt clear bits
func (o *TIMG0_Type) SetINT_CLR_TIMERS_T0_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR_TIMERS.Reg, volatile.LoadUint32(&o.INT_CLR_TIMERS.Reg)&^(0x1)|value)
}
func (o *TIMG0_Type) GetINT_CLR_TIMERS_T0_INT_CLR() uint32 {
	return volatile.LoadUint32(&o.INT_CLR_TIMERS.Reg) & 0x1
}
func (o *TIMG0_Type) SetINT_CLR_TIMERS_T1_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR_TIMERS.Reg, volatile.LoadUint32(&o.INT_CLR_TIMERS.Reg)&^(0x2)|value<<1)
}
func (o *TIMG0_Type) GetINT_CLR_TIMERS_T1_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR_TIMERS.Reg) & 0x2) >> 1
}
func (o *TIMG0_Type) SetINT_CLR_TIMERS_WDT_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR_TIMERS.Reg, volatile.LoadUint32(&o.INT_CLR_TIMERS.Reg)&^(0x4)|value<<2)
}
func (o *TIMG0_Type) GetINT_CLR_TIMERS_WDT_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR_TIMERS.Reg) & 0x4) >> 2
}
func (o *TIMG0_Type) SetINT_CLR_TIMERS_LACT_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR_TIMERS.Reg, volatile.LoadUint32(&o.INT_CLR_TIMERS.Reg)&^(0x8)|value<<3)
}
func (o *TIMG0_Type) GetINT_CLR_TIMERS_LACT_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR_TIMERS.Reg) & 0x8) >> 3
}

// TIMG0.RTCCALICFG2: Timer group calibration register
func (o *TIMG0_Type) SetRTCCALICFG2_RTC_CALI_TIMEOUT(value uint32) {
	volatile.StoreUint32(&o.RTCCALICFG2.Reg, volatile.LoadUint32(&o.RTCCALICFG2.Reg)&^(0x1)|value)
}
func (o *TIMG0_Type) GetRTCCALICFG2_RTC_CALI_TIMEOUT() uint32 {
	return volatile.LoadUint32(&o.RTCCALICFG2.Reg) & 0x1
}
func (o *TIMG0_Type) SetRTCCALICFG2_RTC_CALI_TIMEOUT_RST_CNT(value uint32) {
	volatile.StoreUint32(&o.RTCCALICFG2.Reg, volatile.LoadUint32(&o.RTCCALICFG2.Reg)&^(0x78)|value<<3)
}
func (o *TIMG0_Type) GetRTCCALICFG2_RTC_CALI_TIMEOUT_RST_CNT() uint32 {
	return (volatile.LoadUint32(&o.RTCCALICFG2.Reg) & 0x78) >> 3
}
func (o *TIMG0_Type) SetRTCCALICFG2_RTC_CALI_TIMEOUT_THRES(value uint32) {
	volatile.StoreUint32(&o.RTCCALICFG2.Reg, volatile.LoadUint32(&o.RTCCALICFG2.Reg)&^(0xffffff80)|value<<7)
}
func (o *TIMG0_Type) GetRTCCALICFG2_RTC_CALI_TIMEOUT_THRES() uint32 {
	return (volatile.LoadUint32(&o.RTCCALICFG2.Reg) & 0xffffff80) >> 7
}

// TIMG0.TIMERS_DATE: Version control register
func (o *TIMG0_Type) SetTIMERS_DATE(value uint32) {
	volatile.StoreUint32(&o.TIMERS_DATE.Reg, volatile.LoadUint32(&o.TIMERS_DATE.Reg)&^(0xfffffff)|value)
}
func (o *TIMG0_Type) GetTIMERS_DATE() uint32 {
	return volatile.LoadUint32(&o.TIMERS_DATE.Reg) & 0xfffffff
}

// TIMG0.REGCLK: Timer group clock gate register
func (o *TIMG0_Type) SetREGCLK_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.REGCLK.Reg, volatile.LoadUint32(&o.REGCLK.Reg)&^(0x80000000)|value<<31)
}
func (o *TIMG0_Type) GetREGCLK_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.REGCLK.Reg) & 0x80000000) >> 31
}

// Peripheral UART
type UART0_Type struct {
	FIFO           volatile.Register32 // 0x0
	INT_RAW        volatile.Register32 // 0x4
	INT_ST         volatile.Register32 // 0x8
	INT_ENA        volatile.Register32 // 0xC
	INT_CLR        volatile.Register32 // 0x10
	CLKDIV         volatile.Register32 // 0x14
	AUTOBAUD       volatile.Register32 // 0x18
	STATUS         volatile.Register32 // 0x1C
	CONF0          volatile.Register32 // 0x20
	CONF1          volatile.Register32 // 0x24
	LOWPULSE       volatile.Register32 // 0x28
	HIGHPULSE      volatile.Register32 // 0x2C
	RXD_CNT        volatile.Register32 // 0x30
	FLOW_CONF      volatile.Register32 // 0x34
	SLEEP_CONF     volatile.Register32 // 0x38
	SWFC_CONF0     volatile.Register32 // 0x3C
	SWFC_CONF1     volatile.Register32 // 0x40
	IDLE_CONF      volatile.Register32 // 0x44
	RS485_CONF     volatile.Register32 // 0x48
	AT_CMD_PRECNT  volatile.Register32 // 0x4C
	AT_CMD_POSTCNT volatile.Register32 // 0x50
	AT_CMD_GAPTOUT volatile.Register32 // 0x54
	AT_CMD_CHAR    volatile.Register32 // 0x58
	MEM_CONF       volatile.Register32 // 0x5C
	MEM_TX_STATUS  volatile.Register32 // 0x60
	MEM_RX_STATUS  volatile.Register32 // 0x64
	FSM_STATUS     volatile.Register32 // 0x68
	POSPULSE       volatile.Register32 // 0x6C
	NEGPULSE       volatile.Register32 // 0x70
	DATE           volatile.Register32 // 0x74
	ID             volatile.Register32 // 0x78
}

// UART0.FIFO: FIFO data register
func (o *UART0_Type) SetFIFO_RXFIFO_RD_BYTE(value uint32) {
	volatile.StoreUint32(&o.FIFO.Reg, volatile.LoadUint32(&o.FIFO.Reg)&^(0xff)|value)
}
func (o *UART0_Type) GetFIFO_RXFIFO_RD_BYTE() uint32 {
	return volatile.LoadUint32(&o.FIFO.Reg) & 0xff
}

// UART0.INT_RAW: Raw interrupt status
func (o *UART0_Type) SetINT_RAW_RXFIFO_FULL_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x1)|value)
}
func (o *UART0_Type) GetINT_RAW_RXFIFO_FULL_INT_RAW() uint32 {
	return volatile.LoadUint32(&o.INT_RAW.Reg) & 0x1
}
func (o *UART0_Type) SetINT_RAW_TXFIFO_EMPTY_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x2)|value<<1)
}
func (o *UART0_Type) GetINT_RAW_TXFIFO_EMPTY_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x2) >> 1
}
func (o *UART0_Type) SetINT_RAW_PARITY_ERR_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x4)|value<<2)
}
func (o *UART0_Type) GetINT_RAW_PARITY_ERR_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x4) >> 2
}
func (o *UART0_Type) SetINT_RAW_FRM_ERR_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x8)|value<<3)
}
func (o *UART0_Type) GetINT_RAW_FRM_ERR_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x8) >> 3
}
func (o *UART0_Type) SetINT_RAW_RXFIFO_OVF_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x10)|value<<4)
}
func (o *UART0_Type) GetINT_RAW_RXFIFO_OVF_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x10) >> 4
}
func (o *UART0_Type) SetINT_RAW_DSR_CHG_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x20)|value<<5)
}
func (o *UART0_Type) GetINT_RAW_DSR_CHG_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x20) >> 5
}
func (o *UART0_Type) SetINT_RAW_CTS_CHG_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x40)|value<<6)
}
func (o *UART0_Type) GetINT_RAW_CTS_CHG_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x40) >> 6
}
func (o *UART0_Type) SetINT_RAW_BRK_DET_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x80)|value<<7)
}
func (o *UART0_Type) GetINT_RAW_BRK_DET_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x80) >> 7
}
func (o *UART0_Type) SetINT_RAW_RXFIFO_TOUT_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x100)|value<<8)
}
func (o *UART0_Type) GetINT_RAW_RXFIFO_TOUT_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x100) >> 8
}
func (o *UART0_Type) SetINT_RAW_SW_XON_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x200)|value<<9)
}
func (o *UART0_Type) GetINT_RAW_SW_XON_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x200) >> 9
}
func (o *UART0_Type) SetINT_RAW_SW_XOFF_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x400)|value<<10)
}
func (o *UART0_Type) GetINT_RAW_SW_XOFF_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x400) >> 10
}
func (o *UART0_Type) SetINT_RAW_GLITCH_DET_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x800)|value<<11)
}
func (o *UART0_Type) GetINT_RAW_GLITCH_DET_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x800) >> 11
}
func (o *UART0_Type) SetINT_RAW_TX_BRK_DONE_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x1000)|value<<12)
}
func (o *UART0_Type) GetINT_RAW_TX_BRK_DONE_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x1000) >> 12
}
func (o *UART0_Type) SetINT_RAW_TX_BRK_IDLE_DONE_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x2000)|value<<13)
}
func (o *UART0_Type) GetINT_RAW_TX_BRK_IDLE_DONE_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x2000) >> 13
}
func (o *UART0_Type) SetINT_RAW_TX_DONE_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x4000)|value<<14)
}
func (o *UART0_Type) GetINT_RAW_TX_DONE_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x4000) >> 14
}
func (o *UART0_Type) SetINT_RAW_RS485_PARITY_ERR_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x8000)|value<<15)
}
func (o *UART0_Type) GetINT_RAW_RS485_PARITY_ERR_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x8000) >> 15
}
func (o *UART0_Type) SetINT_RAW_RS485_FRM_ERR_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x10000)|value<<16)
}
func (o *UART0_Type) GetINT_RAW_RS485_FRM_ERR_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x10000) >> 16
}
func (o *UART0_Type) SetINT_RAW_RS485_CLASH_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x20000)|value<<17)
}
func (o *UART0_Type) GetINT_RAW_RS485_CLASH_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x20000) >> 17
}
func (o *UART0_Type) SetINT_RAW_AT_CMD_CHAR_DET_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x40000)|value<<18)
}
func (o *UART0_Type) GetINT_RAW_AT_CMD_CHAR_DET_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x40000) >> 18
}
func (o *UART0_Type) SetINT_RAW_WAKEUP_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x80000)|value<<19)
}
func (o *UART0_Type) GetINT_RAW_WAKEUP_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x80000) >> 19
}

// UART0.INT_ST: Masked interrupt status
func (o *UART0_Type) SetINT_ST_RXFIFO_FULL_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x1)|value)
}
func (o *UART0_Type) GetINT_ST_RXFIFO_FULL_INT_ST() uint32 {
	return volatile.LoadUint32(&o.INT_ST.Reg) & 0x1
}
func (o *UART0_Type) SetINT_ST_TXFIFO_EMPTY_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x2)|value<<1)
}
func (o *UART0_Type) GetINT_ST_TXFIFO_EMPTY_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x2) >> 1
}
func (o *UART0_Type) SetINT_ST_PARITY_ERR_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x4)|value<<2)
}
func (o *UART0_Type) GetINT_ST_PARITY_ERR_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x4) >> 2
}
func (o *UART0_Type) SetINT_ST_FRM_ERR_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x8)|value<<3)
}
func (o *UART0_Type) GetINT_ST_FRM_ERR_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x8) >> 3
}
func (o *UART0_Type) SetINT_ST_RXFIFO_OVF_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x10)|value<<4)
}
func (o *UART0_Type) GetINT_ST_RXFIFO_OVF_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x10) >> 4
}
func (o *UART0_Type) SetINT_ST_DSR_CHG_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x20)|value<<5)
}
func (o *UART0_Type) GetINT_ST_DSR_CHG_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x20) >> 5
}
func (o *UART0_Type) SetINT_ST_CTS_CHG_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x40)|value<<6)
}
func (o *UART0_Type) GetINT_ST_CTS_CHG_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x40) >> 6
}
func (o *UART0_Type) SetINT_ST_BRK_DET_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x80)|value<<7)
}
func (o *UART0_Type) GetINT_ST_BRK_DET_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x80) >> 7
}
func (o *UART0_Type) SetINT_ST_RXFIFO_TOUT_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x100)|value<<8)
}
func (o *UART0_Type) GetINT_ST_RXFIFO_TOUT_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x100) >> 8
}
func (o *UART0_Type) SetINT_ST_SW_XON_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x200)|value<<9)
}
func (o *UART0_Type) GetINT_ST_SW_XON_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x200) >> 9
}
func (o *UART0_Type) SetINT_ST_SW_XOFF_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x400)|value<<10)
}
func (o *UART0_Type) GetINT_ST_SW_XOFF_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x400) >> 10
}
func (o *UART0_Type) SetINT_ST_GLITCH_DET_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x800)|value<<11)
}
func (o *UART0_Type) GetINT_ST_GLITCH_DET_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x800) >> 11
}
func (o *UART0_Type) SetINT_ST_TX_BRK_DONE_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x1000)|value<<12)
}
func (o *UART0_Type) GetINT_ST_TX_BRK_DONE_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x1000) >> 12
}
func (o *UART0_Type) SetINT_ST_TX_BRK_IDLE_DONE_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x2000)|value<<13)
}
func (o *UART0_Type) GetINT_ST_TX_BRK_IDLE_DONE_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x2000) >> 13
}
func (o *UART0_Type) SetINT_ST_TX_DONE_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x4000)|value<<14)
}
func (o *UART0_Type) GetINT_ST_TX_DONE_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x4000) >> 14
}
func (o *UART0_Type) SetINT_ST_RS485_PARITY_ERR_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x8000)|value<<15)
}
func (o *UART0_Type) GetINT_ST_RS485_PARITY_ERR_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x8000) >> 15
}
func (o *UART0_Type) SetINT_ST_RS485_FRM_ERR_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x10000)|value<<16)
}
func (o *UART0_Type) GetINT_ST_RS485_FRM_ERR_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x10000) >> 16
}
func (o *UART0_Type) SetINT_ST_RS485_CLASH_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x20000)|value<<17)
}
func (o *UART0_Type) GetINT_ST_RS485_CLASH_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x20000) >> 17
}
func (o *UART0_Type) SetINT_ST_AT_CMD_CHAR_DET_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x40000)|value<<18)
}
func (o *UART0_Type) GetINT_ST_AT_CMD_CHAR_DET_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x40000) >> 18
}
func (o *UART0_Type) SetINT_ST_WAKEUP_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x80000)|value<<19)
}
func (o *UART0_Type) GetINT_ST_WAKEUP_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x80000) >> 19
}

// UART0.INT_ENA: Interrupt enable bits
func (o *UART0_Type) SetINT_ENA_RXFIFO_FULL_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x1)|value)
}
func (o *UART0_Type) GetINT_ENA_RXFIFO_FULL_INT_ENA() uint32 {
	return volatile.LoadUint32(&o.INT_ENA.Reg) & 0x1
}
func (o *UART0_Type) SetINT_ENA_TXFIFO_EMPTY_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x2)|value<<1)
}
func (o *UART0_Type) GetINT_ENA_TXFIFO_EMPTY_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x2) >> 1
}
func (o *UART0_Type) SetINT_ENA_PARITY_ERR_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x4)|value<<2)
}
func (o *UART0_Type) GetINT_ENA_PARITY_ERR_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x4) >> 2
}
func (o *UART0_Type) SetINT_ENA_FRM_ERR_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x8)|value<<3)
}
func (o *UART0_Type) GetINT_ENA_FRM_ERR_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x8) >> 3
}
func (o *UART0_Type) SetINT_ENA_RXFIFO_OVF_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x10)|value<<4)
}
func (o *UART0_Type) GetINT_ENA_RXFIFO_OVF_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x10) >> 4
}
func (o *UART0_Type) SetINT_ENA_DSR_CHG_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x20)|value<<5)
}
func (o *UART0_Type) GetINT_ENA_DSR_CHG_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x20) >> 5
}
func (o *UART0_Type) SetINT_ENA_CTS_CHG_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x40)|value<<6)
}
func (o *UART0_Type) GetINT_ENA_CTS_CHG_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x40) >> 6
}
func (o *UART0_Type) SetINT_ENA_BRK_DET_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x80)|value<<7)
}
func (o *UART0_Type) GetINT_ENA_BRK_DET_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x80) >> 7
}
func (o *UART0_Type) SetINT_ENA_RXFIFO_TOUT_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x100)|value<<8)
}
func (o *UART0_Type) GetINT_ENA_RXFIFO_TOUT_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x100) >> 8
}
func (o *UART0_Type) SetINT_ENA_SW_XON_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x200)|value<<9)
}
func (o *UART0_Type) GetINT_ENA_SW_XON_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x200) >> 9
}
func (o *UART0_Type) SetINT_ENA_SW_XOFF_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x400)|value<<10)
}
func (o *UART0_Type) GetINT_ENA_SW_XOFF_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x400) >> 10
}
func (o *UART0_Type) SetINT_ENA_GLITCH_DET_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x800)|value<<11)
}
func (o *UART0_Type) GetINT_ENA_GLITCH_DET_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x800) >> 11
}
func (o *UART0_Type) SetINT_ENA_TX_BRK_DONE_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x1000)|value<<12)
}
func (o *UART0_Type) GetINT_ENA_TX_BRK_DONE_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x1000) >> 12
}
func (o *UART0_Type) SetINT_ENA_TX_BRK_IDLE_DONE_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x2000)|value<<13)
}
func (o *UART0_Type) GetINT_ENA_TX_BRK_IDLE_DONE_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x2000) >> 13
}
func (o *UART0_Type) SetINT_ENA_TX_DONE_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x4000)|value<<14)
}
func (o *UART0_Type) GetINT_ENA_TX_DONE_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x4000) >> 14
}
func (o *UART0_Type) SetINT_ENA_RS485_PARITY_ERR_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x8000)|value<<15)
}
func (o *UART0_Type) GetINT_ENA_RS485_PARITY_ERR_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x8000) >> 15
}
func (o *UART0_Type) SetINT_ENA_RS485_FRM_ERR_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x10000)|value<<16)
}
func (o *UART0_Type) GetINT_ENA_RS485_FRM_ERR_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x10000) >> 16
}
func (o *UART0_Type) SetINT_ENA_RS485_CLASH_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x20000)|value<<17)
}
func (o *UART0_Type) GetINT_ENA_RS485_CLASH_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x20000) >> 17
}
func (o *UART0_Type) SetINT_ENA_AT_CMD_CHAR_DET_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x40000)|value<<18)
}
func (o *UART0_Type) GetINT_ENA_AT_CMD_CHAR_DET_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x40000) >> 18
}
func (o *UART0_Type) SetINT_ENA_WAKEUP_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x80000)|value<<19)
}
func (o *UART0_Type) GetINT_ENA_WAKEUP_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x80000) >> 19
}

// UART0.INT_CLR: Interrupt clear bits
func (o *UART0_Type) SetINT_CLR_RXFIFO_FULL_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x1)|value)
}
func (o *UART0_Type) GetINT_CLR_RXFIFO_FULL_INT_CLR() uint32 {
	return volatile.LoadUint32(&o.INT_CLR.Reg) & 0x1
}
func (o *UART0_Type) SetINT_CLR_TXFIFO_EMPTY_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x2)|value<<1)
}
func (o *UART0_Type) GetINT_CLR_TXFIFO_EMPTY_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x2) >> 1
}
func (o *UART0_Type) SetINT_CLR_PARITY_ERR_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x4)|value<<2)
}
func (o *UART0_Type) GetINT_CLR_PARITY_ERR_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x4) >> 2
}
func (o *UART0_Type) SetINT_CLR_FRM_ERR_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x8)|value<<3)
}
func (o *UART0_Type) GetINT_CLR_FRM_ERR_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x8) >> 3
}
func (o *UART0_Type) SetINT_CLR_RXFIFO_OVF_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x10)|value<<4)
}
func (o *UART0_Type) GetINT_CLR_RXFIFO_OVF_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x10) >> 4
}
func (o *UART0_Type) SetINT_CLR_DSR_CHG_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x20)|value<<5)
}
func (o *UART0_Type) GetINT_CLR_DSR_CHG_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x20) >> 5
}
func (o *UART0_Type) SetINT_CLR_CTS_CHG_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x40)|value<<6)
}
func (o *UART0_Type) GetINT_CLR_CTS_CHG_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x40) >> 6
}
func (o *UART0_Type) SetINT_CLR_BRK_DET_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x80)|value<<7)
}
func (o *UART0_Type) GetINT_CLR_BRK_DET_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x80) >> 7
}
func (o *UART0_Type) SetINT_CLR_RXFIFO_TOUT_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x100)|value<<8)
}
func (o *UART0_Type) GetINT_CLR_RXFIFO_TOUT_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x100) >> 8
}
func (o *UART0_Type) SetINT_CLR_SW_XON_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x200)|value<<9)
}
func (o *UART0_Type) GetINT_CLR_SW_XON_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x200) >> 9
}
func (o *UART0_Type) SetINT_CLR_SW_XOFF_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x400)|value<<10)
}
func (o *UART0_Type) GetINT_CLR_SW_XOFF_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x400) >> 10
}
func (o *UART0_Type) SetINT_CLR_GLITCH_DET_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x800)|value<<11)
}
func (o *UART0_Type) GetINT_CLR_GLITCH_DET_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x800) >> 11
}
func (o *UART0_Type) SetINT_CLR_TX_BRK_DONE_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x1000)|value<<12)
}
func (o *UART0_Type) GetINT_CLR_TX_BRK_DONE_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x1000) >> 12
}
func (o *UART0_Type) SetINT_CLR_TX_BRK_IDLE_DONE_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x2000)|value<<13)
}
func (o *UART0_Type) GetINT_CLR_TX_BRK_IDLE_DONE_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x2000) >> 13
}
func (o *UART0_Type) SetINT_CLR_TX_DONE_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x4000)|value<<14)
}
func (o *UART0_Type) GetINT_CLR_TX_DONE_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x4000) >> 14
}
func (o *UART0_Type) SetINT_CLR_RS485_PARITY_ERR_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x8000)|value<<15)
}
func (o *UART0_Type) GetINT_CLR_RS485_PARITY_ERR_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x8000) >> 15
}
func (o *UART0_Type) SetINT_CLR_RS485_FRM_ERR_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x10000)|value<<16)
}
func (o *UART0_Type) GetINT_CLR_RS485_FRM_ERR_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x10000) >> 16
}
func (o *UART0_Type) SetINT_CLR_RS485_CLASH_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x20000)|value<<17)
}
func (o *UART0_Type) GetINT_CLR_RS485_CLASH_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x20000) >> 17
}
func (o *UART0_Type) SetINT_CLR_AT_CMD_CHAR_DET_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x40000)|value<<18)
}
func (o *UART0_Type) GetINT_CLR_AT_CMD_CHAR_DET_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x40000) >> 18
}
func (o *UART0_Type) SetINT_CLR_WAKEUP_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x80000)|value<<19)
}
func (o *UART0_Type) GetINT_CLR_WAKEUP_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x80000) >> 19
}

// UART0.CLKDIV: Clock divider configuration
func (o *UART0_Type) SetCLKDIV(value uint32) {
	volatile.StoreUint32(&o.CLKDIV.Reg, volatile.LoadUint32(&o.CLKDIV.Reg)&^(0xfffff)|value)
}
func (o *UART0_Type) GetCLKDIV() uint32 {
	return volatile.LoadUint32(&o.CLKDIV.Reg) & 0xfffff
}
func (o *UART0_Type) SetCLKDIV_FRAG(value uint32) {
	volatile.StoreUint32(&o.CLKDIV.Reg, volatile.LoadUint32(&o.CLKDIV.Reg)&^(0xf00000)|value<<20)
}
func (o *UART0_Type) GetCLKDIV_FRAG() uint32 {
	return (volatile.LoadUint32(&o.CLKDIV.Reg) & 0xf00000) >> 20
}

// UART0.AUTOBAUD: Autobaud configuration register
func (o *UART0_Type) SetAUTOBAUD_EN(value uint32) {
	volatile.StoreUint32(&o.AUTOBAUD.Reg, volatile.LoadUint32(&o.AUTOBAUD.Reg)&^(0x1)|value)
}
func (o *UART0_Type) GetAUTOBAUD_EN() uint32 {
	return volatile.LoadUint32(&o.AUTOBAUD.Reg) & 0x1
}
func (o *UART0_Type) SetAUTOBAUD_GLITCH_FILT(value uint32) {
	volatile.StoreUint32(&o.AUTOBAUD.Reg, volatile.LoadUint32(&o.AUTOBAUD.Reg)&^(0xff00)|value<<8)
}
func (o *UART0_Type) GetAUTOBAUD_GLITCH_FILT() uint32 {
	return (volatile.LoadUint32(&o.AUTOBAUD.Reg) & 0xff00) >> 8
}

// UART0.STATUS: UART status register
func (o *UART0_Type) SetSTATUS_RXFIFO_CNT(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x3ff)|value)
}
func (o *UART0_Type) GetSTATUS_RXFIFO_CNT() uint32 {
	return volatile.LoadUint32(&o.STATUS.Reg) & 0x3ff
}
func (o *UART0_Type) SetSTATUS_DSRN(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x2000)|value<<13)
}
func (o *UART0_Type) GetSTATUS_DSRN() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x2000) >> 13
}
func (o *UART0_Type) SetSTATUS_CTSN(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x4000)|value<<14)
}
func (o *UART0_Type) GetSTATUS_CTSN() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x4000) >> 14
}
func (o *UART0_Type) SetSTATUS_RXD(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x8000)|value<<15)
}
func (o *UART0_Type) GetSTATUS_RXD() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x8000) >> 15
}
func (o *UART0_Type) SetSTATUS_TXFIFO_CNT(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x3ff0000)|value<<16)
}
func (o *UART0_Type) GetSTATUS_TXFIFO_CNT() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x3ff0000) >> 16
}
func (o *UART0_Type) SetSTATUS_DTRN(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x20000000)|value<<29)
}
func (o *UART0_Type) GetSTATUS_DTRN() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x20000000) >> 29
}
func (o *UART0_Type) SetSTATUS_RTSN(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x40000000)|value<<30)
}
func (o *UART0_Type) GetSTATUS_RTSN() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x40000000) >> 30
}
func (o *UART0_Type) SetSTATUS_TXD(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x80000000)|value<<31)
}
func (o *UART0_Type) GetSTATUS_TXD() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x80000000) >> 31
}

// UART0.CONF0: Configuration register 0
func (o *UART0_Type) SetCONF0_PARITY(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x1)|value)
}
func (o *UART0_Type) GetCONF0_PARITY() uint32 {
	return volatile.LoadUint32(&o.CONF0.Reg) & 0x1
}
func (o *UART0_Type) SetCONF0_PARITY_EN(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x2)|value<<1)
}
func (o *UART0_Type) GetCONF0_PARITY_EN() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x2) >> 1
}
func (o *UART0_Type) SetCONF0_BIT_NUM(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0xc)|value<<2)
}
func (o *UART0_Type) GetCONF0_BIT_NUM() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0xc) >> 2
}
func (o *UART0_Type) SetCONF0_STOP_BIT_NUM(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x30)|value<<4)
}
func (o *UART0_Type) GetCONF0_STOP_BIT_NUM() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x30) >> 4
}
func (o *UART0_Type) SetCONF0_SW_RTS(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x40)|value<<6)
}
func (o *UART0_Type) GetCONF0_SW_RTS() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x40) >> 6
}
func (o *UART0_Type) SetCONF0_SW_DTR(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x80)|value<<7)
}
func (o *UART0_Type) GetCONF0_SW_DTR() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x80) >> 7
}
func (o *UART0_Type) SetCONF0_TXD_BRK(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x100)|value<<8)
}
func (o *UART0_Type) GetCONF0_TXD_BRK() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x100) >> 8
}
func (o *UART0_Type) SetCONF0_IRDA_DPLX(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x200)|value<<9)
}
func (o *UART0_Type) GetCONF0_IRDA_DPLX() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x200) >> 9
}
func (o *UART0_Type) SetCONF0_IRDA_TX_EN(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x400)|value<<10)
}
func (o *UART0_Type) GetCONF0_IRDA_TX_EN() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x400) >> 10
}
func (o *UART0_Type) SetCONF0_IRDA_WCTL(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x800)|value<<11)
}
func (o *UART0_Type) GetCONF0_IRDA_WCTL() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x800) >> 11
}
func (o *UART0_Type) SetCONF0_IRDA_TX_INV(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x1000)|value<<12)
}
func (o *UART0_Type) GetCONF0_IRDA_TX_INV() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x1000) >> 12
}
func (o *UART0_Type) SetCONF0_IRDA_RX_INV(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x2000)|value<<13)
}
func (o *UART0_Type) GetCONF0_IRDA_RX_INV() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x2000) >> 13
}
func (o *UART0_Type) SetCONF0_LOOPBACK(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x4000)|value<<14)
}
func (o *UART0_Type) GetCONF0_LOOPBACK() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x4000) >> 14
}
func (o *UART0_Type) SetCONF0_TX_FLOW_EN(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x8000)|value<<15)
}
func (o *UART0_Type) GetCONF0_TX_FLOW_EN() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x8000) >> 15
}
func (o *UART0_Type) SetCONF0_IRDA_EN(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x10000)|value<<16)
}
func (o *UART0_Type) GetCONF0_IRDA_EN() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x10000) >> 16
}
func (o *UART0_Type) SetCONF0_RXFIFO_RST(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x20000)|value<<17)
}
func (o *UART0_Type) GetCONF0_RXFIFO_RST() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x20000) >> 17
}
func (o *UART0_Type) SetCONF0_TXFIFO_RST(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x40000)|value<<18)
}
func (o *UART0_Type) GetCONF0_TXFIFO_RST() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x40000) >> 18
}
func (o *UART0_Type) SetCONF0_RXD_INV(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x80000)|value<<19)
}
func (o *UART0_Type) GetCONF0_RXD_INV() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x80000) >> 19
}
func (o *UART0_Type) SetCONF0_CTS_INV(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x100000)|value<<20)
}
func (o *UART0_Type) GetCONF0_CTS_INV() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x100000) >> 20
}
func (o *UART0_Type) SetCONF0_DSR_INV(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x200000)|value<<21)
}
func (o *UART0_Type) GetCONF0_DSR_INV() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x200000) >> 21
}
func (o *UART0_Type) SetCONF0_TXD_INV(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x400000)|value<<22)
}
func (o *UART0_Type) GetCONF0_TXD_INV() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x400000) >> 22
}
func (o *UART0_Type) SetCONF0_RTS_INV(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x800000)|value<<23)
}
func (o *UART0_Type) GetCONF0_RTS_INV() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x800000) >> 23
}
func (o *UART0_Type) SetCONF0_DTR_INV(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x1000000)|value<<24)
}
func (o *UART0_Type) GetCONF0_DTR_INV() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x1000000) >> 24
}
func (o *UART0_Type) SetCONF0_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x2000000)|value<<25)
}
func (o *UART0_Type) GetCONF0_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x2000000) >> 25
}
func (o *UART0_Type) SetCONF0_ERR_WR_MASK(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x4000000)|value<<26)
}
func (o *UART0_Type) GetCONF0_ERR_WR_MASK() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x4000000) >> 26
}
func (o *UART0_Type) SetCONF0_TICK_REF_ALWAYS_ON(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x8000000)|value<<27)
}
func (o *UART0_Type) GetCONF0_TICK_REF_ALWAYS_ON() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x8000000) >> 27
}
func (o *UART0_Type) SetCONF0_MEM_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x10000000)|value<<28)
}
func (o *UART0_Type) GetCONF0_MEM_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x10000000) >> 28
}

// UART0.CONF1: Configuration register 1
func (o *UART0_Type) SetCONF1_RXFIFO_FULL_THRHD(value uint32) {
	volatile.StoreUint32(&o.CONF1.Reg, volatile.LoadUint32(&o.CONF1.Reg)&^(0x1ff)|value)
}
func (o *UART0_Type) GetCONF1_RXFIFO_FULL_THRHD() uint32 {
	return volatile.LoadUint32(&o.CONF1.Reg) & 0x1ff
}
func (o *UART0_Type) SetCONF1_TXFIFO_EMPTY_THRHD(value uint32) {
	volatile.StoreUint32(&o.CONF1.Reg, volatile.LoadUint32(&o.CONF1.Reg)&^(0x3fe00)|value<<9)
}
func (o *UART0_Type) GetCONF1_TXFIFO_EMPTY_THRHD() uint32 {
	return (volatile.LoadUint32(&o.CONF1.Reg) & 0x3fe00) >> 9
}
func (o *UART0_Type) SetCONF1_RX_TOUT_FLOW_DIS(value uint32) {
	volatile.StoreUint32(&o.CONF1.Reg, volatile.LoadUint32(&o.CONF1.Reg)&^(0x20000000)|value<<29)
}
func (o *UART0_Type) GetCONF1_RX_TOUT_FLOW_DIS() uint32 {
	return (volatile.LoadUint32(&o.CONF1.Reg) & 0x20000000) >> 29
}
func (o *UART0_Type) SetCONF1_RX_FLOW_EN(value uint32) {
	volatile.StoreUint32(&o.CONF1.Reg, volatile.LoadUint32(&o.CONF1.Reg)&^(0x40000000)|value<<30)
}
func (o *UART0_Type) GetCONF1_RX_FLOW_EN() uint32 {
	return (volatile.LoadUint32(&o.CONF1.Reg) & 0x40000000) >> 30
}
func (o *UART0_Type) SetCONF1_RX_TOUT_EN(value uint32) {
	volatile.StoreUint32(&o.CONF1.Reg, volatile.LoadUint32(&o.CONF1.Reg)&^(0x80000000)|value<<31)
}
func (o *UART0_Type) GetCONF1_RX_TOUT_EN() uint32 {
	return (volatile.LoadUint32(&o.CONF1.Reg) & 0x80000000) >> 31
}

// UART0.LOWPULSE: Autobaud minimum low pulse duration register
func (o *UART0_Type) SetLOWPULSE_MIN_CNT(value uint32) {
	volatile.StoreUint32(&o.LOWPULSE.Reg, volatile.LoadUint32(&o.LOWPULSE.Reg)&^(0xfffff)|value)
}
func (o *UART0_Type) GetLOWPULSE_MIN_CNT() uint32 {
	return volatile.LoadUint32(&o.LOWPULSE.Reg) & 0xfffff
}

// UART0.HIGHPULSE: Autobaud minimum high pulse duration register
func (o *UART0_Type) SetHIGHPULSE_MIN_CNT(value uint32) {
	volatile.StoreUint32(&o.HIGHPULSE.Reg, volatile.LoadUint32(&o.HIGHPULSE.Reg)&^(0xfffff)|value)
}
func (o *UART0_Type) GetHIGHPULSE_MIN_CNT() uint32 {
	return volatile.LoadUint32(&o.HIGHPULSE.Reg) & 0xfffff
}

// UART0.RXD_CNT: Autobaud edge change count register
func (o *UART0_Type) SetRXD_CNT_RXD_EDGE_CNT(value uint32) {
	volatile.StoreUint32(&o.RXD_CNT.Reg, volatile.LoadUint32(&o.RXD_CNT.Reg)&^(0x3ff)|value)
}
func (o *UART0_Type) GetRXD_CNT_RXD_EDGE_CNT() uint32 {
	return volatile.LoadUint32(&o.RXD_CNT.Reg) & 0x3ff
}

// UART0.FLOW_CONF: Software flow control configuration
func (o *UART0_Type) SetFLOW_CONF_SW_FLOW_CON_EN(value uint32) {
	volatile.StoreUint32(&o.FLOW_CONF.Reg, volatile.LoadUint32(&o.FLOW_CONF.Reg)&^(0x1)|value)
}
func (o *UART0_Type) GetFLOW_CONF_SW_FLOW_CON_EN() uint32 {
	return volatile.LoadUint32(&o.FLOW_CONF.Reg) & 0x1
}
func (o *UART0_Type) SetFLOW_CONF_XONOFF_DEL(value uint32) {
	volatile.StoreUint32(&o.FLOW_CONF.Reg, volatile.LoadUint32(&o.FLOW_CONF.Reg)&^(0x2)|value<<1)
}
func (o *UART0_Type) GetFLOW_CONF_XONOFF_DEL() uint32 {
	return (volatile.LoadUint32(&o.FLOW_CONF.Reg) & 0x2) >> 1
}
func (o *UART0_Type) SetFLOW_CONF_FORCE_XON(value uint32) {
	volatile.StoreUint32(&o.FLOW_CONF.Reg, volatile.LoadUint32(&o.FLOW_CONF.Reg)&^(0x4)|value<<2)
}
func (o *UART0_Type) GetFLOW_CONF_FORCE_XON() uint32 {
	return (volatile.LoadUint32(&o.FLOW_CONF.Reg) & 0x4) >> 2
}
func (o *UART0_Type) SetFLOW_CONF_FORCE_XOFF(value uint32) {
	volatile.StoreUint32(&o.FLOW_CONF.Reg, volatile.LoadUint32(&o.FLOW_CONF.Reg)&^(0x8)|value<<3)
}
func (o *UART0_Type) GetFLOW_CONF_FORCE_XOFF() uint32 {
	return (volatile.LoadUint32(&o.FLOW_CONF.Reg) & 0x8) >> 3
}
func (o *UART0_Type) SetFLOW_CONF_SEND_XON(value uint32) {
	volatile.StoreUint32(&o.FLOW_CONF.Reg, volatile.LoadUint32(&o.FLOW_CONF.Reg)&^(0x10)|value<<4)
}
func (o *UART0_Type) GetFLOW_CONF_SEND_XON() uint32 {
	return (volatile.LoadUint32(&o.FLOW_CONF.Reg) & 0x10) >> 4
}
func (o *UART0_Type) SetFLOW_CONF_SEND_XOFF(value uint32) {
	volatile.StoreUint32(&o.FLOW_CONF.Reg, volatile.LoadUint32(&o.FLOW_CONF.Reg)&^(0x20)|value<<5)
}
func (o *UART0_Type) GetFLOW_CONF_SEND_XOFF() uint32 {
	return (volatile.LoadUint32(&o.FLOW_CONF.Reg) & 0x20) >> 5
}

// UART0.SLEEP_CONF: Sleeping mode configuration
func (o *UART0_Type) SetSLEEP_CONF_ACTIVE_THRESHOLD(value uint32) {
	volatile.StoreUint32(&o.SLEEP_CONF.Reg, volatile.LoadUint32(&o.SLEEP_CONF.Reg)&^(0x3ff)|value)
}
func (o *UART0_Type) GetSLEEP_CONF_ACTIVE_THRESHOLD() uint32 {
	return volatile.LoadUint32(&o.SLEEP_CONF.Reg) & 0x3ff
}

// UART0.SWFC_CONF0: Software flow control character configuration
func (o *UART0_Type) SetSWFC_CONF0_XOFF_THRESHOLD(value uint32) {
	volatile.StoreUint32(&o.SWFC_CONF0.Reg, volatile.LoadUint32(&o.SWFC_CONF0.Reg)&^(0x1ff)|value)
}
func (o *UART0_Type) GetSWFC_CONF0_XOFF_THRESHOLD() uint32 {
	return volatile.LoadUint32(&o.SWFC_CONF0.Reg) & 0x1ff
}
func (o *UART0_Type) SetSWFC_CONF0_XOFF_CHAR(value uint32) {
	volatile.StoreUint32(&o.SWFC_CONF0.Reg, volatile.LoadUint32(&o.SWFC_CONF0.Reg)&^(0x1fe00)|value<<9)
}
func (o *UART0_Type) GetSWFC_CONF0_XOFF_CHAR() uint32 {
	return (volatile.LoadUint32(&o.SWFC_CONF0.Reg) & 0x1fe00) >> 9
}

// UART0.SWFC_CONF1: Software flow-control character configuration
func (o *UART0_Type) SetSWFC_CONF1_XON_THRESHOLD(value uint32) {
	volatile.StoreUint32(&o.SWFC_CONF1.Reg, volatile.LoadUint32(&o.SWFC_CONF1.Reg)&^(0x1ff)|value)
}
func (o *UART0_Type) GetSWFC_CONF1_XON_THRESHOLD() uint32 {
	return volatile.LoadUint32(&o.SWFC_CONF1.Reg) & 0x1ff
}
func (o *UART0_Type) SetSWFC_CONF1_XON_CHAR(value uint32) {
	volatile.StoreUint32(&o.SWFC_CONF1.Reg, volatile.LoadUint32(&o.SWFC_CONF1.Reg)&^(0x1fe00)|value<<9)
}
func (o *UART0_Type) GetSWFC_CONF1_XON_CHAR() uint32 {
	return (volatile.LoadUint32(&o.SWFC_CONF1.Reg) & 0x1fe00) >> 9
}

// UART0.IDLE_CONF: Frame-end idle configuration
func (o *UART0_Type) SetIDLE_CONF_RX_IDLE_THRHD(value uint32) {
	volatile.StoreUint32(&o.IDLE_CONF.Reg, volatile.LoadUint32(&o.IDLE_CONF.Reg)&^(0x3ff)|value)
}
func (o *UART0_Type) GetIDLE_CONF_RX_IDLE_THRHD() uint32 {
	return volatile.LoadUint32(&o.IDLE_CONF.Reg) & 0x3ff
}
func (o *UART0_Type) SetIDLE_CONF_TX_IDLE_NUM(value uint32) {
	volatile.StoreUint32(&o.IDLE_CONF.Reg, volatile.LoadUint32(&o.IDLE_CONF.Reg)&^(0xffc00)|value<<10)
}
func (o *UART0_Type) GetIDLE_CONF_TX_IDLE_NUM() uint32 {
	return (volatile.LoadUint32(&o.IDLE_CONF.Reg) & 0xffc00) >> 10
}
func (o *UART0_Type) SetIDLE_CONF_TX_BRK_NUM(value uint32) {
	volatile.StoreUint32(&o.IDLE_CONF.Reg, volatile.LoadUint32(&o.IDLE_CONF.Reg)&^(0xff00000)|value<<20)
}
func (o *UART0_Type) GetIDLE_CONF_TX_BRK_NUM() uint32 {
	return (volatile.LoadUint32(&o.IDLE_CONF.Reg) & 0xff00000) >> 20
}

// UART0.RS485_CONF: RS485 mode configuration
func (o *UART0_Type) SetRS485_CONF_RS485_EN(value uint32) {
	volatile.StoreUint32(&o.RS485_CONF.Reg, volatile.LoadUint32(&o.RS485_CONF.Reg)&^(0x1)|value)
}
func (o *UART0_Type) GetRS485_CONF_RS485_EN() uint32 {
	return volatile.LoadUint32(&o.RS485_CONF.Reg) & 0x1
}
func (o *UART0_Type) SetRS485_CONF_DL0_EN(value uint32) {
	volatile.StoreUint32(&o.RS485_CONF.Reg, volatile.LoadUint32(&o.RS485_CONF.Reg)&^(0x2)|value<<1)
}
func (o *UART0_Type) GetRS485_CONF_DL0_EN() uint32 {
	return (volatile.LoadUint32(&o.RS485_CONF.Reg) & 0x2) >> 1
}
func (o *UART0_Type) SetRS485_CONF_DL1_EN(value uint32) {
	volatile.StoreUint32(&o.RS485_CONF.Reg, volatile.LoadUint32(&o.RS485_CONF.Reg)&^(0x4)|value<<2)
}
func (o *UART0_Type) GetRS485_CONF_DL1_EN() uint32 {
	return (volatile.LoadUint32(&o.RS485_CONF.Reg) & 0x4) >> 2
}
func (o *UART0_Type) SetRS485_CONF_RS485TX_RX_EN(value uint32) {
	volatile.StoreUint32(&o.RS485_CONF.Reg, volatile.LoadUint32(&o.RS485_CONF.Reg)&^(0x8)|value<<3)
}
func (o *UART0_Type) GetRS485_CONF_RS485TX_RX_EN() uint32 {
	return (volatile.LoadUint32(&o.RS485_CONF.Reg) & 0x8) >> 3
}
func (o *UART0_Type) SetRS485_CONF_RS485RXBY_TX_EN(value uint32) {
	volatile.StoreUint32(&o.RS485_CONF.Reg, volatile.LoadUint32(&o.RS485_CONF.Reg)&^(0x10)|value<<4)
}
func (o *UART0_Type) GetRS485_CONF_RS485RXBY_TX_EN() uint32 {
	return (volatile.LoadUint32(&o.RS485_CONF.Reg) & 0x10) >> 4
}
func (o *UART0_Type) SetRS485_CONF_RS485_RX_DLY_NUM(value uint32) {
	volatile.StoreUint32(&o.RS485_CONF.Reg, volatile.LoadUint32(&o.RS485_CONF.Reg)&^(0x20)|value<<5)
}
func (o *UART0_Type) GetRS485_CONF_RS485_RX_DLY_NUM() uint32 {
	return (volatile.LoadUint32(&o.RS485_CONF.Reg) & 0x20) >> 5
}
func (o *UART0_Type) SetRS485_CONF_RS485_TX_DLY_NUM(value uint32) {
	volatile.StoreUint32(&o.RS485_CONF.Reg, volatile.LoadUint32(&o.RS485_CONF.Reg)&^(0x3c0)|value<<6)
}
func (o *UART0_Type) GetRS485_CONF_RS485_TX_DLY_NUM() uint32 {
	return (volatile.LoadUint32(&o.RS485_CONF.Reg) & 0x3c0) >> 6
}

// UART0.AT_CMD_PRECNT: Pre-sequence timing configuration
func (o *UART0_Type) SetAT_CMD_PRECNT_PRE_IDLE_NUM(value uint32) {
	volatile.StoreUint32(&o.AT_CMD_PRECNT.Reg, volatile.LoadUint32(&o.AT_CMD_PRECNT.Reg)&^(0xffff)|value)
}
func (o *UART0_Type) GetAT_CMD_PRECNT_PRE_IDLE_NUM() uint32 {
	return volatile.LoadUint32(&o.AT_CMD_PRECNT.Reg) & 0xffff
}

// UART0.AT_CMD_POSTCNT: Post-sequence timing configuration
func (o *UART0_Type) SetAT_CMD_POSTCNT_POST_IDLE_NUM(value uint32) {
	volatile.StoreUint32(&o.AT_CMD_POSTCNT.Reg, volatile.LoadUint32(&o.AT_CMD_POSTCNT.Reg)&^(0xffff)|value)
}
func (o *UART0_Type) GetAT_CMD_POSTCNT_POST_IDLE_NUM() uint32 {
	return volatile.LoadUint32(&o.AT_CMD_POSTCNT.Reg) & 0xffff
}

// UART0.AT_CMD_GAPTOUT: Timeout configuration
func (o *UART0_Type) SetAT_CMD_GAPTOUT_RX_GAP_TOUT(value uint32) {
	volatile.StoreUint32(&o.AT_CMD_GAPTOUT.Reg, volatile.LoadUint32(&o.AT_CMD_GAPTOUT.Reg)&^(0xffff)|value)
}
func (o *UART0_Type) GetAT_CMD_GAPTOUT_RX_GAP_TOUT() uint32 {
	return volatile.LoadUint32(&o.AT_CMD_GAPTOUT.Reg) & 0xffff
}

// UART0.AT_CMD_CHAR: AT Escape Sequence Selection Configuration
func (o *UART0_Type) SetAT_CMD_CHAR(value uint32) {
	volatile.StoreUint32(&o.AT_CMD_CHAR.Reg, volatile.LoadUint32(&o.AT_CMD_CHAR.Reg)&^(0xff)|value)
}
func (o *UART0_Type) GetAT_CMD_CHAR() uint32 {
	return volatile.LoadUint32(&o.AT_CMD_CHAR.Reg) & 0xff
}
func (o *UART0_Type) SetAT_CMD_CHAR_CHAR_NUM(value uint32) {
	volatile.StoreUint32(&o.AT_CMD_CHAR.Reg, volatile.LoadUint32(&o.AT_CMD_CHAR.Reg)&^(0xff00)|value<<8)
}
func (o *UART0_Type) GetAT_CMD_CHAR_CHAR_NUM() uint32 {
	return (volatile.LoadUint32(&o.AT_CMD_CHAR.Reg) & 0xff00) >> 8
}

// UART0.MEM_CONF: UART threshold and allocation configuration
func (o *UART0_Type) SetMEM_CONF_RX_SIZE(value uint32) {
	volatile.StoreUint32(&o.MEM_CONF.Reg, volatile.LoadUint32(&o.MEM_CONF.Reg)&^(0xe)|value<<1)
}
func (o *UART0_Type) GetMEM_CONF_RX_SIZE() uint32 {
	return (volatile.LoadUint32(&o.MEM_CONF.Reg) & 0xe) >> 1
}
func (o *UART0_Type) SetMEM_CONF_TX_SIZE(value uint32) {
	volatile.StoreUint32(&o.MEM_CONF.Reg, volatile.LoadUint32(&o.MEM_CONF.Reg)&^(0x70)|value<<4)
}
func (o *UART0_Type) GetMEM_CONF_TX_SIZE() uint32 {
	return (volatile.LoadUint32(&o.MEM_CONF.Reg) & 0x70) >> 4
}
func (o *UART0_Type) SetMEM_CONF_RX_FLOW_THRHD(value uint32) {
	volatile.StoreUint32(&o.MEM_CONF.Reg, volatile.LoadUint32(&o.MEM_CONF.Reg)&^(0xff80)|value<<7)
}
func (o *UART0_Type) GetMEM_CONF_RX_FLOW_THRHD() uint32 {
	return (volatile.LoadUint32(&o.MEM_CONF.Reg) & 0xff80) >> 7
}
func (o *UART0_Type) SetMEM_CONF_RX_TOUT_THRHD(value uint32) {
	volatile.StoreUint32(&o.MEM_CONF.Reg, volatile.LoadUint32(&o.MEM_CONF.Reg)&^(0x3ff0000)|value<<16)
}
func (o *UART0_Type) GetMEM_CONF_RX_TOUT_THRHD() uint32 {
	return (volatile.LoadUint32(&o.MEM_CONF.Reg) & 0x3ff0000) >> 16
}
func (o *UART0_Type) SetMEM_CONF_MEM_FORCE_PD(value uint32) {
	volatile.StoreUint32(&o.MEM_CONF.Reg, volatile.LoadUint32(&o.MEM_CONF.Reg)&^(0x4000000)|value<<26)
}
func (o *UART0_Type) GetMEM_CONF_MEM_FORCE_PD() uint32 {
	return (volatile.LoadUint32(&o.MEM_CONF.Reg) & 0x4000000) >> 26
}
func (o *UART0_Type) SetMEM_CONF_MEM_FORCE_PU(value uint32) {
	volatile.StoreUint32(&o.MEM_CONF.Reg, volatile.LoadUint32(&o.MEM_CONF.Reg)&^(0x8000000)|value<<27)
}
func (o *UART0_Type) GetMEM_CONF_MEM_FORCE_PU() uint32 {
	return (volatile.LoadUint32(&o.MEM_CONF.Reg) & 0x8000000) >> 27
}

// UART0.MEM_TX_STATUS: TX FIFO write and read offset address
func (o *UART0_Type) SetMEM_TX_STATUS_APB_TX_WADDR(value uint32) {
	volatile.StoreUint32(&o.MEM_TX_STATUS.Reg, volatile.LoadUint32(&o.MEM_TX_STATUS.Reg)&^(0x3ff)|value)
}
func (o *UART0_Type) GetMEM_TX_STATUS_APB_TX_WADDR() uint32 {
	return volatile.LoadUint32(&o.MEM_TX_STATUS.Reg) & 0x3ff
}
func (o *UART0_Type) SetMEM_TX_STATUS_TX_RADDR(value uint32) {
	volatile.StoreUint32(&o.MEM_TX_STATUS.Reg, volatile.LoadUint32(&o.MEM_TX_STATUS.Reg)&^(0x1ff800)|value<<11)
}
func (o *UART0_Type) GetMEM_TX_STATUS_TX_RADDR() uint32 {
	return (volatile.LoadUint32(&o.MEM_TX_STATUS.Reg) & 0x1ff800) >> 11
}

// UART0.MEM_RX_STATUS: RX FIFO write and read offset address
func (o *UART0_Type) SetMEM_RX_STATUS_APB_RX_RADDR(value uint32) {
	volatile.StoreUint32(&o.MEM_RX_STATUS.Reg, volatile.LoadUint32(&o.MEM_RX_STATUS.Reg)&^(0x3ff)|value)
}
func (o *UART0_Type) GetMEM_RX_STATUS_APB_RX_RADDR() uint32 {
	return volatile.LoadUint32(&o.MEM_RX_STATUS.Reg) & 0x3ff
}
func (o *UART0_Type) SetMEM_RX_STATUS_RX_WADDR(value uint32) {
	volatile.StoreUint32(&o.MEM_RX_STATUS.Reg, volatile.LoadUint32(&o.MEM_RX_STATUS.Reg)&^(0x1ff800)|value<<11)
}
func (o *UART0_Type) GetMEM_RX_STATUS_RX_WADDR() uint32 {
	return (volatile.LoadUint32(&o.MEM_RX_STATUS.Reg) & 0x1ff800) >> 11
}

// UART0.FSM_STATUS: UART transmit and receive status
func (o *UART0_Type) SetFSM_STATUS_ST_URX_OUT(value uint32) {
	volatile.StoreUint32(&o.FSM_STATUS.Reg, volatile.LoadUint32(&o.FSM_STATUS.Reg)&^(0xf)|value)
}
func (o *UART0_Type) GetFSM_STATUS_ST_URX_OUT() uint32 {
	return volatile.LoadUint32(&o.FSM_STATUS.Reg) & 0xf
}
func (o *UART0_Type) SetFSM_STATUS_ST_UTX_OUT(value uint32) {
	volatile.StoreUint32(&o.FSM_STATUS.Reg, volatile.LoadUint32(&o.FSM_STATUS.Reg)&^(0xf0)|value<<4)
}
func (o *UART0_Type) GetFSM_STATUS_ST_UTX_OUT() uint32 {
	return (volatile.LoadUint32(&o.FSM_STATUS.Reg) & 0xf0) >> 4
}

// UART0.POSPULSE: Autobaud high pulse register
func (o *UART0_Type) SetPOSPULSE_POSEDGE_MIN_CNT(value uint32) {
	volatile.StoreUint32(&o.POSPULSE.Reg, volatile.LoadUint32(&o.POSPULSE.Reg)&^(0xfffff)|value)
}
func (o *UART0_Type) GetPOSPULSE_POSEDGE_MIN_CNT() uint32 {
	return volatile.LoadUint32(&o.POSPULSE.Reg) & 0xfffff
}

// UART0.NEGPULSE: Autobaud low pulse register
func (o *UART0_Type) SetNEGPULSE_NEGEDGE_MIN_CNT(value uint32) {
	volatile.StoreUint32(&o.NEGPULSE.Reg, volatile.LoadUint32(&o.NEGPULSE.Reg)&^(0xfffff)|value)
}
func (o *UART0_Type) GetNEGPULSE_NEGEDGE_MIN_CNT() uint32 {
	return volatile.LoadUint32(&o.NEGPULSE.Reg) & 0xfffff
}

// UART0.DATE: UART version control register
func (o *UART0_Type) SetDATE(value uint32) {
	volatile.StoreUint32(&o.DATE.Reg, value)
}
func (o *UART0_Type) GetDATE() uint32 {
	return volatile.LoadUint32(&o.DATE.Reg)
}

// UART0.ID: UART ID register
func (o *UART0_Type) SetID(value uint32) {
	volatile.StoreUint32(&o.ID.Reg, value)
}
func (o *UART0_Type) GetID() uint32 {
	return volatile.LoadUint32(&o.ID.Reg)
}

// Peripheral UHCI0
type UHCI0_Type struct {
	CONF0                    volatile.Register32 // 0x0
	INT_RAW                  volatile.Register32 // 0x4
	INT_ST                   volatile.Register32 // 0x8
	INT_ENA                  volatile.Register32 // 0xC
	INT_CLR                  volatile.Register32 // 0x10
	DMA_OUT_STATUS           volatile.Register32 // 0x14
	DMA_OUT_PUSH             volatile.Register32 // 0x18
	DMA_IN_STATUS            volatile.Register32 // 0x1C
	DMA_IN_POP               volatile.Register32 // 0x20
	DMA_OUT_LINK             volatile.Register32 // 0x24
	DMA_IN_LINK              volatile.Register32 // 0x28
	CONF1                    volatile.Register32 // 0x2C
	STATE0                   volatile.Register32 // 0x30
	STATE1                   volatile.Register32 // 0x34
	DMA_OUT_EOF_DES_ADDR     volatile.Register32 // 0x38
	DMA_IN_SUC_EOF_DES_ADDR  volatile.Register32 // 0x3C
	DMA_IN_ERR_EOF_DES_ADDR  volatile.Register32 // 0x40
	DMA_OUT_EOF_BFR_DES_ADDR volatile.Register32 // 0x44
	AHB_TEST                 volatile.Register32 // 0x48
	DMA_IN_DSCR              volatile.Register32 // 0x4C
	DMA_IN_DSCR_BF0          volatile.Register32 // 0x50
	DMA_IN_DSCR_BF1          volatile.Register32 // 0x54
	DMA_OUT_DSCR             volatile.Register32 // 0x58
	DMA_OUT_DSCR_BF0         volatile.Register32 // 0x5C
	DMA_OUT_DSCR_BF1         volatile.Register32 // 0x60
	ESCAPE_CONF              volatile.Register32 // 0x64
	HUNG_CONF                volatile.Register32 // 0x68
	_                        [4]byte
	RX_HEAD                  volatile.Register32 // 0x70
	QUICK_SENT               volatile.Register32 // 0x74
	REG_Q0_WORD0             volatile.Register32 // 0x78
	REG_Q0_WORD1             volatile.Register32 // 0x7C
	REG_Q1_WORD0             volatile.Register32 // 0x80
	REG_Q1_WORD1             volatile.Register32 // 0x84
	REG_Q2_WORD0             volatile.Register32 // 0x88
	REG_Q2_WORD1             volatile.Register32 // 0x8C
	REG_Q3_WORD0             volatile.Register32 // 0x90
	REG_Q3_WORD1             volatile.Register32 // 0x94
	REG_Q4_WORD0             volatile.Register32 // 0x98
	REG_Q4_WORD1             volatile.Register32 // 0x9C
	REG_Q5_WORD0             volatile.Register32 // 0xA0
	REG_Q5_WORD1             volatile.Register32 // 0xA4
	REG_Q6_WORD0             volatile.Register32 // 0xA8
	REG_Q6_WORD1             volatile.Register32 // 0xAC
	ESC_CONF0                volatile.Register32 // 0xB0
	ESC_CONF1                volatile.Register32 // 0xB4
	ESC_CONF2                volatile.Register32 // 0xB8
	ESC_CONF3                volatile.Register32 // 0xBC
	PKT_THRES                volatile.Register32 // 0xC0
	_                        [56]byte
	DATE                     volatile.Register32 // 0xFC
}

// UHCI0.CONF0: UHCI configuration register
func (o *UHCI0_Type) SetCONF0_IN_RST(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x1)|value)
}
func (o *UHCI0_Type) GetCONF0_IN_RST() uint32 {
	return volatile.LoadUint32(&o.CONF0.Reg) & 0x1
}
func (o *UHCI0_Type) SetCONF0_OUT_RST(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x2)|value<<1)
}
func (o *UHCI0_Type) GetCONF0_OUT_RST() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x2) >> 1
}
func (o *UHCI0_Type) SetCONF0_AHBM_FIFO_RST(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x4)|value<<2)
}
func (o *UHCI0_Type) GetCONF0_AHBM_FIFO_RST() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x4) >> 2
}
func (o *UHCI0_Type) SetCONF0_AHBM_RST(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x8)|value<<3)
}
func (o *UHCI0_Type) GetCONF0_AHBM_RST() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x8) >> 3
}
func (o *UHCI0_Type) SetCONF0_IN_LOOP_TEST(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x10)|value<<4)
}
func (o *UHCI0_Type) GetCONF0_IN_LOOP_TEST() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x10) >> 4
}
func (o *UHCI0_Type) SetCONF0_OUT_LOOP_TEST(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x20)|value<<5)
}
func (o *UHCI0_Type) GetCONF0_OUT_LOOP_TEST() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x20) >> 5
}
func (o *UHCI0_Type) SetCONF0_OUT_AUTO_WRBACK(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x40)|value<<6)
}
func (o *UHCI0_Type) GetCONF0_OUT_AUTO_WRBACK() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x40) >> 6
}
func (o *UHCI0_Type) SetCONF0_OUT_NO_RESTART_CLR(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x80)|value<<7)
}
func (o *UHCI0_Type) GetCONF0_OUT_NO_RESTART_CLR() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x80) >> 7
}
func (o *UHCI0_Type) SetCONF0_OUT_EOF_MODE(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x100)|value<<8)
}
func (o *UHCI0_Type) GetCONF0_OUT_EOF_MODE() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x100) >> 8
}
func (o *UHCI0_Type) SetCONF0_UART0_CE(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x200)|value<<9)
}
func (o *UHCI0_Type) GetCONF0_UART0_CE() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x200) >> 9
}
func (o *UHCI0_Type) SetCONF0_UART1_CE(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x400)|value<<10)
}
func (o *UHCI0_Type) GetCONF0_UART1_CE() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x400) >> 10
}
func (o *UHCI0_Type) SetCONF0_OUTDSCR_BURST_EN(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x1000)|value<<12)
}
func (o *UHCI0_Type) GetCONF0_OUTDSCR_BURST_EN() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x1000) >> 12
}
func (o *UHCI0_Type) SetCONF0_INDSCR_BURST_EN(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x2000)|value<<13)
}
func (o *UHCI0_Type) GetCONF0_INDSCR_BURST_EN() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x2000) >> 13
}
func (o *UHCI0_Type) SetCONF0_OUT_DATA_BURST_EN(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x4000)|value<<14)
}
func (o *UHCI0_Type) GetCONF0_OUT_DATA_BURST_EN() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x4000) >> 14
}
func (o *UHCI0_Type) SetCONF0_MEM_TRANS_EN(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x8000)|value<<15)
}
func (o *UHCI0_Type) GetCONF0_MEM_TRANS_EN() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x8000) >> 15
}
func (o *UHCI0_Type) SetCONF0_SEPER_EN(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x10000)|value<<16)
}
func (o *UHCI0_Type) GetCONF0_SEPER_EN() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x10000) >> 16
}
func (o *UHCI0_Type) SetCONF0_HEAD_EN(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x20000)|value<<17)
}
func (o *UHCI0_Type) GetCONF0_HEAD_EN() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x20000) >> 17
}
func (o *UHCI0_Type) SetCONF0_CRC_REC_EN(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x40000)|value<<18)
}
func (o *UHCI0_Type) GetCONF0_CRC_REC_EN() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x40000) >> 18
}
func (o *UHCI0_Type) SetCONF0_UART_IDLE_EOF_EN(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x80000)|value<<19)
}
func (o *UHCI0_Type) GetCONF0_UART_IDLE_EOF_EN() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x80000) >> 19
}
func (o *UHCI0_Type) SetCONF0_LEN_EOF_EN(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x100000)|value<<20)
}
func (o *UHCI0_Type) GetCONF0_LEN_EOF_EN() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x100000) >> 20
}
func (o *UHCI0_Type) SetCONF0_ENCODE_CRC_EN(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x200000)|value<<21)
}
func (o *UHCI0_Type) GetCONF0_ENCODE_CRC_EN() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x200000) >> 21
}
func (o *UHCI0_Type) SetCONF0_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x400000)|value<<22)
}
func (o *UHCI0_Type) GetCONF0_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x400000) >> 22
}
func (o *UHCI0_Type) SetCONF0_UART_RX_BRK_EOF_EN(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x800000)|value<<23)
}
func (o *UHCI0_Type) GetCONF0_UART_RX_BRK_EOF_EN() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x800000) >> 23
}

// UHCI0.INT_RAW: Raw interrupt status
func (o *UHCI0_Type) SetINT_RAW_RX_START_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x1)|value)
}
func (o *UHCI0_Type) GetINT_RAW_RX_START_INT_RAW() uint32 {
	return volatile.LoadUint32(&o.INT_RAW.Reg) & 0x1
}
func (o *UHCI0_Type) SetINT_RAW_TX_START_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x2)|value<<1)
}
func (o *UHCI0_Type) GetINT_RAW_TX_START_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x2) >> 1
}
func (o *UHCI0_Type) SetINT_RAW_RX_HUNG_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x4)|value<<2)
}
func (o *UHCI0_Type) GetINT_RAW_RX_HUNG_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x4) >> 2
}
func (o *UHCI0_Type) SetINT_RAW_TX_HUNG_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x8)|value<<3)
}
func (o *UHCI0_Type) GetINT_RAW_TX_HUNG_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x8) >> 3
}
func (o *UHCI0_Type) SetINT_RAW_IN_DONE_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x10)|value<<4)
}
func (o *UHCI0_Type) GetINT_RAW_IN_DONE_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x10) >> 4
}
func (o *UHCI0_Type) SetINT_RAW_IN_SUC_EOF_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x20)|value<<5)
}
func (o *UHCI0_Type) GetINT_RAW_IN_SUC_EOF_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x20) >> 5
}
func (o *UHCI0_Type) SetINT_RAW_IN_ERR_EOF_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x40)|value<<6)
}
func (o *UHCI0_Type) GetINT_RAW_IN_ERR_EOF_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x40) >> 6
}
func (o *UHCI0_Type) SetINT_RAW_OUT_DONE_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x80)|value<<7)
}
func (o *UHCI0_Type) GetINT_RAW_OUT_DONE_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x80) >> 7
}
func (o *UHCI0_Type) SetINT_RAW_OUT_EOF_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x100)|value<<8)
}
func (o *UHCI0_Type) GetINT_RAW_OUT_EOF_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x100) >> 8
}
func (o *UHCI0_Type) SetINT_RAW_IN_DSCR_ERR_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x200)|value<<9)
}
func (o *UHCI0_Type) GetINT_RAW_IN_DSCR_ERR_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x200) >> 9
}
func (o *UHCI0_Type) SetINT_RAW_OUT_DSCR_ERR_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x400)|value<<10)
}
func (o *UHCI0_Type) GetINT_RAW_OUT_DSCR_ERR_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x400) >> 10
}
func (o *UHCI0_Type) SetINT_RAW_IN_DSCR_EMPTY_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x800)|value<<11)
}
func (o *UHCI0_Type) GetINT_RAW_IN_DSCR_EMPTY_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x800) >> 11
}
func (o *UHCI0_Type) SetINT_RAW_OUTLINK_EOF_ERR_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x1000)|value<<12)
}
func (o *UHCI0_Type) GetINT_RAW_OUTLINK_EOF_ERR_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x1000) >> 12
}
func (o *UHCI0_Type) SetINT_RAW_OUT_TOTAL_EOF_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x2000)|value<<13)
}
func (o *UHCI0_Type) GetINT_RAW_OUT_TOTAL_EOF_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x2000) >> 13
}
func (o *UHCI0_Type) SetINT_RAW_SEND_S_REG_Q_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x4000)|value<<14)
}
func (o *UHCI0_Type) GetINT_RAW_SEND_S_REG_Q_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x4000) >> 14
}
func (o *UHCI0_Type) SetINT_RAW_SEND_A_REG_Q_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x8000)|value<<15)
}
func (o *UHCI0_Type) GetINT_RAW_SEND_A_REG_Q_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x8000) >> 15
}
func (o *UHCI0_Type) SetINT_RAW_DMA_INFIFO_FULL_WM_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x10000)|value<<16)
}
func (o *UHCI0_Type) GetINT_RAW_DMA_INFIFO_FULL_WM_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x10000) >> 16
}

// UHCI0.INT_ST: Masked interrupt status
func (o *UHCI0_Type) SetINT_ST_RX_START_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x1)|value)
}
func (o *UHCI0_Type) GetINT_ST_RX_START_INT_ST() uint32 {
	return volatile.LoadUint32(&o.INT_ST.Reg) & 0x1
}
func (o *UHCI0_Type) SetINT_ST_TX_START_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x2)|value<<1)
}
func (o *UHCI0_Type) GetINT_ST_TX_START_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x2) >> 1
}
func (o *UHCI0_Type) SetINT_ST_RX_HUNG_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x4)|value<<2)
}
func (o *UHCI0_Type) GetINT_ST_RX_HUNG_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x4) >> 2
}
func (o *UHCI0_Type) SetINT_ST_TX_HUNG_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x8)|value<<3)
}
func (o *UHCI0_Type) GetINT_ST_TX_HUNG_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x8) >> 3
}
func (o *UHCI0_Type) SetINT_ST_IN_DONE_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x10)|value<<4)
}
func (o *UHCI0_Type) GetINT_ST_IN_DONE_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x10) >> 4
}
func (o *UHCI0_Type) SetINT_ST_IN_SUC_EOF_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x20)|value<<5)
}
func (o *UHCI0_Type) GetINT_ST_IN_SUC_EOF_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x20) >> 5
}
func (o *UHCI0_Type) SetINT_ST_IN_ERR_EOF_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x40)|value<<6)
}
func (o *UHCI0_Type) GetINT_ST_IN_ERR_EOF_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x40) >> 6
}
func (o *UHCI0_Type) SetINT_ST_OUT_DONE_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x80)|value<<7)
}
func (o *UHCI0_Type) GetINT_ST_OUT_DONE_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x80) >> 7
}
func (o *UHCI0_Type) SetINT_ST_OUT_EOF_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x100)|value<<8)
}
func (o *UHCI0_Type) GetINT_ST_OUT_EOF_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x100) >> 8
}
func (o *UHCI0_Type) SetINT_ST_IN_DSCR_ERR_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x200)|value<<9)
}
func (o *UHCI0_Type) GetINT_ST_IN_DSCR_ERR_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x200) >> 9
}
func (o *UHCI0_Type) SetINT_ST_OUT_DSCR_ERR_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x400)|value<<10)
}
func (o *UHCI0_Type) GetINT_ST_OUT_DSCR_ERR_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x400) >> 10
}
func (o *UHCI0_Type) SetINT_ST_IN_DSCR_EMPTY_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x800)|value<<11)
}
func (o *UHCI0_Type) GetINT_ST_IN_DSCR_EMPTY_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x800) >> 11
}
func (o *UHCI0_Type) SetINT_ST_OUTLINK_EOF_ERR_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x1000)|value<<12)
}
func (o *UHCI0_Type) GetINT_ST_OUTLINK_EOF_ERR_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x1000) >> 12
}
func (o *UHCI0_Type) SetINT_ST_OUT_TOTAL_EOF_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x2000)|value<<13)
}
func (o *UHCI0_Type) GetINT_ST_OUT_TOTAL_EOF_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x2000) >> 13
}
func (o *UHCI0_Type) SetINT_ST_SEND_S_REG_Q_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x4000)|value<<14)
}
func (o *UHCI0_Type) GetINT_ST_SEND_S_REG_Q_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x4000) >> 14
}
func (o *UHCI0_Type) SetINT_ST_SEND_A_REG_Q_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x8000)|value<<15)
}
func (o *UHCI0_Type) GetINT_ST_SEND_A_REG_Q_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x8000) >> 15
}
func (o *UHCI0_Type) SetINT_ST_DMA_INFIFO_FULL_WM_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x10000)|value<<16)
}
func (o *UHCI0_Type) GetINT_ST_DMA_INFIFO_FULL_WM_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x10000) >> 16
}

// UHCI0.INT_ENA: Interrupt enable bits
func (o *UHCI0_Type) SetINT_ENA_RX_START_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x1)|value)
}
func (o *UHCI0_Type) GetINT_ENA_RX_START_INT_ENA() uint32 {
	return volatile.LoadUint32(&o.INT_ENA.Reg) & 0x1
}
func (o *UHCI0_Type) SetINT_ENA_TX_START_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x2)|value<<1)
}
func (o *UHCI0_Type) GetINT_ENA_TX_START_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x2) >> 1
}
func (o *UHCI0_Type) SetINT_ENA_RX_HUNG_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x4)|value<<2)
}
func (o *UHCI0_Type) GetINT_ENA_RX_HUNG_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x4) >> 2
}
func (o *UHCI0_Type) SetINT_ENA_TX_HUNG_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x8)|value<<3)
}
func (o *UHCI0_Type) GetINT_ENA_TX_HUNG_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x8) >> 3
}
func (o *UHCI0_Type) SetINT_ENA_IN_DONE_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x10)|value<<4)
}
func (o *UHCI0_Type) GetINT_ENA_IN_DONE_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x10) >> 4
}
func (o *UHCI0_Type) SetINT_ENA_IN_SUC_EOF_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x20)|value<<5)
}
func (o *UHCI0_Type) GetINT_ENA_IN_SUC_EOF_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x20) >> 5
}
func (o *UHCI0_Type) SetINT_ENA_IN_ERR_EOF_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x40)|value<<6)
}
func (o *UHCI0_Type) GetINT_ENA_IN_ERR_EOF_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x40) >> 6
}
func (o *UHCI0_Type) SetINT_ENA_OUT_DONE_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x80)|value<<7)
}
func (o *UHCI0_Type) GetINT_ENA_OUT_DONE_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x80) >> 7
}
func (o *UHCI0_Type) SetINT_ENA_OUT_EOF_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x100)|value<<8)
}
func (o *UHCI0_Type) GetINT_ENA_OUT_EOF_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x100) >> 8
}
func (o *UHCI0_Type) SetINT_ENA_IN_DSCR_ERR_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x200)|value<<9)
}
func (o *UHCI0_Type) GetINT_ENA_IN_DSCR_ERR_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x200) >> 9
}
func (o *UHCI0_Type) SetINT_ENA_OUT_DSCR_ERR_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x400)|value<<10)
}
func (o *UHCI0_Type) GetINT_ENA_OUT_DSCR_ERR_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x400) >> 10
}
func (o *UHCI0_Type) SetINT_ENA_IN_DSCR_EMPTY_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x800)|value<<11)
}
func (o *UHCI0_Type) GetINT_ENA_IN_DSCR_EMPTY_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x800) >> 11
}
func (o *UHCI0_Type) SetINT_ENA_OUTLINK_EOF_ERR_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x1000)|value<<12)
}
func (o *UHCI0_Type) GetINT_ENA_OUTLINK_EOF_ERR_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x1000) >> 12
}
func (o *UHCI0_Type) SetINT_ENA_OUT_TOTAL_EOF_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x2000)|value<<13)
}
func (o *UHCI0_Type) GetINT_ENA_OUT_TOTAL_EOF_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x2000) >> 13
}
func (o *UHCI0_Type) SetINT_ENA_SEND_S_REG_Q_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x4000)|value<<14)
}
func (o *UHCI0_Type) GetINT_ENA_SEND_S_REG_Q_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x4000) >> 14
}
func (o *UHCI0_Type) SetINT_ENA_SEND_A_REG_Q_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x8000)|value<<15)
}
func (o *UHCI0_Type) GetINT_ENA_SEND_A_REG_Q_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x8000) >> 15
}
func (o *UHCI0_Type) SetINT_ENA_DMA_INFIFO_FULL_WM_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x10000)|value<<16)
}
func (o *UHCI0_Type) GetINT_ENA_DMA_INFIFO_FULL_WM_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x10000) >> 16
}

// UHCI0.INT_CLR: Interrupt clear bits
func (o *UHCI0_Type) SetINT_CLR_RX_START_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x1)|value)
}
func (o *UHCI0_Type) GetINT_CLR_RX_START_INT_CLR() uint32 {
	return volatile.LoadUint32(&o.INT_CLR.Reg) & 0x1
}
func (o *UHCI0_Type) SetINT_CLR_TX_START_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x2)|value<<1)
}
func (o *UHCI0_Type) GetINT_CLR_TX_START_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x2) >> 1
}
func (o *UHCI0_Type) SetINT_CLR_RX_HUNG_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x4)|value<<2)
}
func (o *UHCI0_Type) GetINT_CLR_RX_HUNG_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x4) >> 2
}
func (o *UHCI0_Type) SetINT_CLR_TX_HUNG_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x8)|value<<3)
}
func (o *UHCI0_Type) GetINT_CLR_TX_HUNG_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x8) >> 3
}
func (o *UHCI0_Type) SetINT_CLR_IN_DONE_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x10)|value<<4)
}
func (o *UHCI0_Type) GetINT_CLR_IN_DONE_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x10) >> 4
}
func (o *UHCI0_Type) SetINT_CLR_IN_SUC_EOF_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x20)|value<<5)
}
func (o *UHCI0_Type) GetINT_CLR_IN_SUC_EOF_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x20) >> 5
}
func (o *UHCI0_Type) SetINT_CLR_IN_ERR_EOF_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x40)|value<<6)
}
func (o *UHCI0_Type) GetINT_CLR_IN_ERR_EOF_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x40) >> 6
}
func (o *UHCI0_Type) SetINT_CLR_OUT_DONE_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x80)|value<<7)
}
func (o *UHCI0_Type) GetINT_CLR_OUT_DONE_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x80) >> 7
}
func (o *UHCI0_Type) SetINT_CLR_OUT_EOF_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x100)|value<<8)
}
func (o *UHCI0_Type) GetINT_CLR_OUT_EOF_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x100) >> 8
}
func (o *UHCI0_Type) SetINT_CLR_IN_DSCR_ERR_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x200)|value<<9)
}
func (o *UHCI0_Type) GetINT_CLR_IN_DSCR_ERR_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x200) >> 9
}
func (o *UHCI0_Type) SetINT_CLR_OUT_DSCR_ERR_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x400)|value<<10)
}
func (o *UHCI0_Type) GetINT_CLR_OUT_DSCR_ERR_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x400) >> 10
}
func (o *UHCI0_Type) SetINT_CLR_IN_DSCR_EMPTY_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x800)|value<<11)
}
func (o *UHCI0_Type) GetINT_CLR_IN_DSCR_EMPTY_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x800) >> 11
}
func (o *UHCI0_Type) SetINT_CLR_OUTLINK_EOF_ERR_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x1000)|value<<12)
}
func (o *UHCI0_Type) GetINT_CLR_OUTLINK_EOF_ERR_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x1000) >> 12
}
func (o *UHCI0_Type) SetINT_CLR_OUT_TOTAL_EOF_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x2000)|value<<13)
}
func (o *UHCI0_Type) GetINT_CLR_OUT_TOTAL_EOF_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x2000) >> 13
}
func (o *UHCI0_Type) SetINT_CLR_SEND_S_REG_Q_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x4000)|value<<14)
}
func (o *UHCI0_Type) GetINT_CLR_SEND_S_REG_Q_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x4000) >> 14
}
func (o *UHCI0_Type) SetINT_CLR_SEND_A_REG_Q_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x8000)|value<<15)
}
func (o *UHCI0_Type) GetINT_CLR_SEND_A_REG_Q_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x8000) >> 15
}
func (o *UHCI0_Type) SetINT_CLR_DMA_INFIFO_FULL_WM_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x10000)|value<<16)
}
func (o *UHCI0_Type) GetINT_CLR_DMA_INFIFO_FULL_WM_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x10000) >> 16
}

// UHCI0.DMA_OUT_STATUS: DMA data-output status register
func (o *UHCI0_Type) SetDMA_OUT_STATUS_OUT_FULL(value uint32) {
	volatile.StoreUint32(&o.DMA_OUT_STATUS.Reg, volatile.LoadUint32(&o.DMA_OUT_STATUS.Reg)&^(0x1)|value)
}
func (o *UHCI0_Type) GetDMA_OUT_STATUS_OUT_FULL() uint32 {
	return volatile.LoadUint32(&o.DMA_OUT_STATUS.Reg) & 0x1
}
func (o *UHCI0_Type) SetDMA_OUT_STATUS_OUT_EMPTY(value uint32) {
	volatile.StoreUint32(&o.DMA_OUT_STATUS.Reg, volatile.LoadUint32(&o.DMA_OUT_STATUS.Reg)&^(0x2)|value<<1)
}
func (o *UHCI0_Type) GetDMA_OUT_STATUS_OUT_EMPTY() uint32 {
	return (volatile.LoadUint32(&o.DMA_OUT_STATUS.Reg) & 0x2) >> 1
}

// UHCI0.DMA_OUT_PUSH: Push control register of data-output FIFO
func (o *UHCI0_Type) SetDMA_OUT_PUSH_OUTFIFO_WDATA(value uint32) {
	volatile.StoreUint32(&o.DMA_OUT_PUSH.Reg, volatile.LoadUint32(&o.DMA_OUT_PUSH.Reg)&^(0x1ff)|value)
}
func (o *UHCI0_Type) GetDMA_OUT_PUSH_OUTFIFO_WDATA() uint32 {
	return volatile.LoadUint32(&o.DMA_OUT_PUSH.Reg) & 0x1ff
}
func (o *UHCI0_Type) SetDMA_OUT_PUSH_OUTFIFO_PUSH(value uint32) {
	volatile.StoreUint32(&o.DMA_OUT_PUSH.Reg, volatile.LoadUint32(&o.DMA_OUT_PUSH.Reg)&^(0x10000)|value<<16)
}
func (o *UHCI0_Type) GetDMA_OUT_PUSH_OUTFIFO_PUSH() uint32 {
	return (volatile.LoadUint32(&o.DMA_OUT_PUSH.Reg) & 0x10000) >> 16
}

// UHCI0.DMA_IN_STATUS: UHCI data-input status register
func (o *UHCI0_Type) SetDMA_IN_STATUS_IN_FULL(value uint32) {
	volatile.StoreUint32(&o.DMA_IN_STATUS.Reg, volatile.LoadUint32(&o.DMA_IN_STATUS.Reg)&^(0x1)|value)
}
func (o *UHCI0_Type) GetDMA_IN_STATUS_IN_FULL() uint32 {
	return volatile.LoadUint32(&o.DMA_IN_STATUS.Reg) & 0x1
}
func (o *UHCI0_Type) SetDMA_IN_STATUS_IN_EMPTY(value uint32) {
	volatile.StoreUint32(&o.DMA_IN_STATUS.Reg, volatile.LoadUint32(&o.DMA_IN_STATUS.Reg)&^(0x2)|value<<1)
}
func (o *UHCI0_Type) GetDMA_IN_STATUS_IN_EMPTY() uint32 {
	return (volatile.LoadUint32(&o.DMA_IN_STATUS.Reg) & 0x2) >> 1
}
func (o *UHCI0_Type) SetDMA_IN_STATUS_RX_ERR_CAUSE(value uint32) {
	volatile.StoreUint32(&o.DMA_IN_STATUS.Reg, volatile.LoadUint32(&o.DMA_IN_STATUS.Reg)&^(0x70)|value<<4)
}
func (o *UHCI0_Type) GetDMA_IN_STATUS_RX_ERR_CAUSE() uint32 {
	return (volatile.LoadUint32(&o.DMA_IN_STATUS.Reg) & 0x70) >> 4
}

// UHCI0.DMA_IN_POP: Pop control register of data-input FIFO
func (o *UHCI0_Type) SetDMA_IN_POP_INFIFO_RDATA(value uint32) {
	volatile.StoreUint32(&o.DMA_IN_POP.Reg, volatile.LoadUint32(&o.DMA_IN_POP.Reg)&^(0xfff)|value)
}
func (o *UHCI0_Type) GetDMA_IN_POP_INFIFO_RDATA() uint32 {
	return volatile.LoadUint32(&o.DMA_IN_POP.Reg) & 0xfff
}
func (o *UHCI0_Type) SetDMA_IN_POP_INFIFO_POP(value uint32) {
	volatile.StoreUint32(&o.DMA_IN_POP.Reg, volatile.LoadUint32(&o.DMA_IN_POP.Reg)&^(0x10000)|value<<16)
}
func (o *UHCI0_Type) GetDMA_IN_POP_INFIFO_POP() uint32 {
	return (volatile.LoadUint32(&o.DMA_IN_POP.Reg) & 0x10000) >> 16
}

// UHCI0.DMA_OUT_LINK: Link descriptor address and control
func (o *UHCI0_Type) SetDMA_OUT_LINK_OUTLINK_ADDR(value uint32) {
	volatile.StoreUint32(&o.DMA_OUT_LINK.Reg, volatile.LoadUint32(&o.DMA_OUT_LINK.Reg)&^(0xfffff)|value)
}
func (o *UHCI0_Type) GetDMA_OUT_LINK_OUTLINK_ADDR() uint32 {
	return volatile.LoadUint32(&o.DMA_OUT_LINK.Reg) & 0xfffff
}
func (o *UHCI0_Type) SetDMA_OUT_LINK_OUTLINK_STOP(value uint32) {
	volatile.StoreUint32(&o.DMA_OUT_LINK.Reg, volatile.LoadUint32(&o.DMA_OUT_LINK.Reg)&^(0x10000000)|value<<28)
}
func (o *UHCI0_Type) GetDMA_OUT_LINK_OUTLINK_STOP() uint32 {
	return (volatile.LoadUint32(&o.DMA_OUT_LINK.Reg) & 0x10000000) >> 28
}
func (o *UHCI0_Type) SetDMA_OUT_LINK_OUTLINK_START(value uint32) {
	volatile.StoreUint32(&o.DMA_OUT_LINK.Reg, volatile.LoadUint32(&o.DMA_OUT_LINK.Reg)&^(0x20000000)|value<<29)
}
func (o *UHCI0_Type) GetDMA_OUT_LINK_OUTLINK_START() uint32 {
	return (volatile.LoadUint32(&o.DMA_OUT_LINK.Reg) & 0x20000000) >> 29
}
func (o *UHCI0_Type) SetDMA_OUT_LINK_OUTLINK_RESTART(value uint32) {
	volatile.StoreUint32(&o.DMA_OUT_LINK.Reg, volatile.LoadUint32(&o.DMA_OUT_LINK.Reg)&^(0x40000000)|value<<30)
}
func (o *UHCI0_Type) GetDMA_OUT_LINK_OUTLINK_RESTART() uint32 {
	return (volatile.LoadUint32(&o.DMA_OUT_LINK.Reg) & 0x40000000) >> 30
}
func (o *UHCI0_Type) SetDMA_OUT_LINK_OUTLINK_PARK(value uint32) {
	volatile.StoreUint32(&o.DMA_OUT_LINK.Reg, volatile.LoadUint32(&o.DMA_OUT_LINK.Reg)&^(0x80000000)|value<<31)
}
func (o *UHCI0_Type) GetDMA_OUT_LINK_OUTLINK_PARK() uint32 {
	return (volatile.LoadUint32(&o.DMA_OUT_LINK.Reg) & 0x80000000) >> 31
}

// UHCI0.DMA_IN_LINK: Link descriptor address and control
func (o *UHCI0_Type) SetDMA_IN_LINK_INLINK_ADDR(value uint32) {
	volatile.StoreUint32(&o.DMA_IN_LINK.Reg, volatile.LoadUint32(&o.DMA_IN_LINK.Reg)&^(0xfffff)|value)
}
func (o *UHCI0_Type) GetDMA_IN_LINK_INLINK_ADDR() uint32 {
	return volatile.LoadUint32(&o.DMA_IN_LINK.Reg) & 0xfffff
}
func (o *UHCI0_Type) SetDMA_IN_LINK_INLINK_AUTO_RET(value uint32) {
	volatile.StoreUint32(&o.DMA_IN_LINK.Reg, volatile.LoadUint32(&o.DMA_IN_LINK.Reg)&^(0x100000)|value<<20)
}
func (o *UHCI0_Type) GetDMA_IN_LINK_INLINK_AUTO_RET() uint32 {
	return (volatile.LoadUint32(&o.DMA_IN_LINK.Reg) & 0x100000) >> 20
}
func (o *UHCI0_Type) SetDMA_IN_LINK_INLINK_STOP(value uint32) {
	volatile.StoreUint32(&o.DMA_IN_LINK.Reg, volatile.LoadUint32(&o.DMA_IN_LINK.Reg)&^(0x10000000)|value<<28)
}
func (o *UHCI0_Type) GetDMA_IN_LINK_INLINK_STOP() uint32 {
	return (volatile.LoadUint32(&o.DMA_IN_LINK.Reg) & 0x10000000) >> 28
}
func (o *UHCI0_Type) SetDMA_IN_LINK_INLINK_START(value uint32) {
	volatile.StoreUint32(&o.DMA_IN_LINK.Reg, volatile.LoadUint32(&o.DMA_IN_LINK.Reg)&^(0x20000000)|value<<29)
}
func (o *UHCI0_Type) GetDMA_IN_LINK_INLINK_START() uint32 {
	return (volatile.LoadUint32(&o.DMA_IN_LINK.Reg) & 0x20000000) >> 29
}
func (o *UHCI0_Type) SetDMA_IN_LINK_INLINK_RESTART(value uint32) {
	volatile.StoreUint32(&o.DMA_IN_LINK.Reg, volatile.LoadUint32(&o.DMA_IN_LINK.Reg)&^(0x40000000)|value<<30)
}
func (o *UHCI0_Type) GetDMA_IN_LINK_INLINK_RESTART() uint32 {
	return (volatile.LoadUint32(&o.DMA_IN_LINK.Reg) & 0x40000000) >> 30
}
func (o *UHCI0_Type) SetDMA_IN_LINK_INLINK_PARK(value uint32) {
	volatile.StoreUint32(&o.DMA_IN_LINK.Reg, volatile.LoadUint32(&o.DMA_IN_LINK.Reg)&^(0x80000000)|value<<31)
}
func (o *UHCI0_Type) GetDMA_IN_LINK_INLINK_PARK() uint32 {
	return (volatile.LoadUint32(&o.DMA_IN_LINK.Reg) & 0x80000000) >> 31
}

// UHCI0.CONF1: UHCI configuration register
func (o *UHCI0_Type) SetCONF1_CHECK_SUM_EN(value uint32) {
	volatile.StoreUint32(&o.CONF1.Reg, volatile.LoadUint32(&o.CONF1.Reg)&^(0x1)|value)
}
func (o *UHCI0_Type) GetCONF1_CHECK_SUM_EN() uint32 {
	return volatile.LoadUint32(&o.CONF1.Reg) & 0x1
}
func (o *UHCI0_Type) SetCONF1_CHECK_SEQ_EN(value uint32) {
	volatile.StoreUint32(&o.CONF1.Reg, volatile.LoadUint32(&o.CONF1.Reg)&^(0x2)|value<<1)
}
func (o *UHCI0_Type) GetCONF1_CHECK_SEQ_EN() uint32 {
	return (volatile.LoadUint32(&o.CONF1.Reg) & 0x2) >> 1
}
func (o *UHCI0_Type) SetCONF1_CRC_DISABLE(value uint32) {
	volatile.StoreUint32(&o.CONF1.Reg, volatile.LoadUint32(&o.CONF1.Reg)&^(0x4)|value<<2)
}
func (o *UHCI0_Type) GetCONF1_CRC_DISABLE() uint32 {
	return (volatile.LoadUint32(&o.CONF1.Reg) & 0x4) >> 2
}
func (o *UHCI0_Type) SetCONF1_SAVE_HEAD(value uint32) {
	volatile.StoreUint32(&o.CONF1.Reg, volatile.LoadUint32(&o.CONF1.Reg)&^(0x8)|value<<3)
}
func (o *UHCI0_Type) GetCONF1_SAVE_HEAD() uint32 {
	return (volatile.LoadUint32(&o.CONF1.Reg) & 0x8) >> 3
}
func (o *UHCI0_Type) SetCONF1_TX_CHECK_SUM_RE(value uint32) {
	volatile.StoreUint32(&o.CONF1.Reg, volatile.LoadUint32(&o.CONF1.Reg)&^(0x10)|value<<4)
}
func (o *UHCI0_Type) GetCONF1_TX_CHECK_SUM_RE() uint32 {
	return (volatile.LoadUint32(&o.CONF1.Reg) & 0x10) >> 4
}
func (o *UHCI0_Type) SetCONF1_TX_ACK_NUM_RE(value uint32) {
	volatile.StoreUint32(&o.CONF1.Reg, volatile.LoadUint32(&o.CONF1.Reg)&^(0x20)|value<<5)
}
func (o *UHCI0_Type) GetCONF1_TX_ACK_NUM_RE() uint32 {
	return (volatile.LoadUint32(&o.CONF1.Reg) & 0x20) >> 5
}
func (o *UHCI0_Type) SetCONF1_CHECK_OWNER(value uint32) {
	volatile.StoreUint32(&o.CONF1.Reg, volatile.LoadUint32(&o.CONF1.Reg)&^(0x40)|value<<6)
}
func (o *UHCI0_Type) GetCONF1_CHECK_OWNER() uint32 {
	return (volatile.LoadUint32(&o.CONF1.Reg) & 0x40) >> 6
}
func (o *UHCI0_Type) SetCONF1_WAIT_SW_START(value uint32) {
	volatile.StoreUint32(&o.CONF1.Reg, volatile.LoadUint32(&o.CONF1.Reg)&^(0x80)|value<<7)
}
func (o *UHCI0_Type) GetCONF1_WAIT_SW_START() uint32 {
	return (volatile.LoadUint32(&o.CONF1.Reg) & 0x80) >> 7
}
func (o *UHCI0_Type) SetCONF1_SW_START(value uint32) {
	volatile.StoreUint32(&o.CONF1.Reg, volatile.LoadUint32(&o.CONF1.Reg)&^(0x100)|value<<8)
}
func (o *UHCI0_Type) GetCONF1_SW_START() uint32 {
	return (volatile.LoadUint32(&o.CONF1.Reg) & 0x100) >> 8
}
func (o *UHCI0_Type) SetCONF1_DMA_INFIFO_FULL_THRS(value uint32) {
	volatile.StoreUint32(&o.CONF1.Reg, volatile.LoadUint32(&o.CONF1.Reg)&^(0x1ffe00)|value<<9)
}
func (o *UHCI0_Type) GetCONF1_DMA_INFIFO_FULL_THRS() uint32 {
	return (volatile.LoadUint32(&o.CONF1.Reg) & 0x1ffe00) >> 9
}

// UHCI0.STATE0: UHCI decoder status register
func (o *UHCI0_Type) SetSTATE0_INLINK_DSCR_ADDR(value uint32) {
	volatile.StoreUint32(&o.STATE0.Reg, volatile.LoadUint32(&o.STATE0.Reg)&^(0x3ffff)|value)
}
func (o *UHCI0_Type) GetSTATE0_INLINK_DSCR_ADDR() uint32 {
	return volatile.LoadUint32(&o.STATE0.Reg) & 0x3ffff
}
func (o *UHCI0_Type) SetSTATE0_IN_DSCR_STATE(value uint32) {
	volatile.StoreUint32(&o.STATE0.Reg, volatile.LoadUint32(&o.STATE0.Reg)&^(0xc0000)|value<<18)
}
func (o *UHCI0_Type) GetSTATE0_IN_DSCR_STATE() uint32 {
	return (volatile.LoadUint32(&o.STATE0.Reg) & 0xc0000) >> 18
}
func (o *UHCI0_Type) SetSTATE0_IN_STATE(value uint32) {
	volatile.StoreUint32(&o.STATE0.Reg, volatile.LoadUint32(&o.STATE0.Reg)&^(0x700000)|value<<20)
}
func (o *UHCI0_Type) GetSTATE0_IN_STATE() uint32 {
	return (volatile.LoadUint32(&o.STATE0.Reg) & 0x700000) >> 20
}
func (o *UHCI0_Type) SetSTATE0_INFIFO_CNT_DEBUG(value uint32) {
	volatile.StoreUint32(&o.STATE0.Reg, volatile.LoadUint32(&o.STATE0.Reg)&^(0xf800000)|value<<23)
}
func (o *UHCI0_Type) GetSTATE0_INFIFO_CNT_DEBUG() uint32 {
	return (volatile.LoadUint32(&o.STATE0.Reg) & 0xf800000) >> 23
}
func (o *UHCI0_Type) SetSTATE0_DECODE_STATE(value uint32) {
	volatile.StoreUint32(&o.STATE0.Reg, volatile.LoadUint32(&o.STATE0.Reg)&^(0x70000000)|value<<28)
}
func (o *UHCI0_Type) GetSTATE0_DECODE_STATE() uint32 {
	return (volatile.LoadUint32(&o.STATE0.Reg) & 0x70000000) >> 28
}

// UHCI0.STATE1: UHCI encoder status register
func (o *UHCI0_Type) SetSTATE1_OUTLINK_DSCR_ADDR(value uint32) {
	volatile.StoreUint32(&o.STATE1.Reg, volatile.LoadUint32(&o.STATE1.Reg)&^(0x3ffff)|value)
}
func (o *UHCI0_Type) GetSTATE1_OUTLINK_DSCR_ADDR() uint32 {
	return volatile.LoadUint32(&o.STATE1.Reg) & 0x3ffff
}
func (o *UHCI0_Type) SetSTATE1_OUT_DSCR_STATE(value uint32) {
	volatile.StoreUint32(&o.STATE1.Reg, volatile.LoadUint32(&o.STATE1.Reg)&^(0xc0000)|value<<18)
}
func (o *UHCI0_Type) GetSTATE1_OUT_DSCR_STATE() uint32 {
	return (volatile.LoadUint32(&o.STATE1.Reg) & 0xc0000) >> 18
}
func (o *UHCI0_Type) SetSTATE1_OUT_STATE(value uint32) {
	volatile.StoreUint32(&o.STATE1.Reg, volatile.LoadUint32(&o.STATE1.Reg)&^(0x700000)|value<<20)
}
func (o *UHCI0_Type) GetSTATE1_OUT_STATE() uint32 {
	return (volatile.LoadUint32(&o.STATE1.Reg) & 0x700000) >> 20
}
func (o *UHCI0_Type) SetSTATE1_OUTFIFO_CNT(value uint32) {
	volatile.StoreUint32(&o.STATE1.Reg, volatile.LoadUint32(&o.STATE1.Reg)&^(0xf800000)|value<<23)
}
func (o *UHCI0_Type) GetSTATE1_OUTFIFO_CNT() uint32 {
	return (volatile.LoadUint32(&o.STATE1.Reg) & 0xf800000) >> 23
}
func (o *UHCI0_Type) SetSTATE1_ENCODE_STATE(value uint32) {
	volatile.StoreUint32(&o.STATE1.Reg, volatile.LoadUint32(&o.STATE1.Reg)&^(0x70000000)|value<<28)
}
func (o *UHCI0_Type) GetSTATE1_ENCODE_STATE() uint32 {
	return (volatile.LoadUint32(&o.STATE1.Reg) & 0x70000000) >> 28
}

// UHCI0.DMA_OUT_EOF_DES_ADDR: Outlink descriptor address when EOF occurs
func (o *UHCI0_Type) SetDMA_OUT_EOF_DES_ADDR(value uint32) {
	volatile.StoreUint32(&o.DMA_OUT_EOF_DES_ADDR.Reg, value)
}
func (o *UHCI0_Type) GetDMA_OUT_EOF_DES_ADDR() uint32 {
	return volatile.LoadUint32(&o.DMA_OUT_EOF_DES_ADDR.Reg)
}

// UHCI0.DMA_IN_SUC_EOF_DES_ADDR: Inlink descriptor address when EOF occurs
func (o *UHCI0_Type) SetDMA_IN_SUC_EOF_DES_ADDR(value uint32) {
	volatile.StoreUint32(&o.DMA_IN_SUC_EOF_DES_ADDR.Reg, value)
}
func (o *UHCI0_Type) GetDMA_IN_SUC_EOF_DES_ADDR() uint32 {
	return volatile.LoadUint32(&o.DMA_IN_SUC_EOF_DES_ADDR.Reg)
}

// UHCI0.DMA_IN_ERR_EOF_DES_ADDR: Inlink descriptor address when errors occur
func (o *UHCI0_Type) SetDMA_IN_ERR_EOF_DES_ADDR(value uint32) {
	volatile.StoreUint32(&o.DMA_IN_ERR_EOF_DES_ADDR.Reg, value)
}
func (o *UHCI0_Type) GetDMA_IN_ERR_EOF_DES_ADDR() uint32 {
	return volatile.LoadUint32(&o.DMA_IN_ERR_EOF_DES_ADDR.Reg)
}

// UHCI0.DMA_OUT_EOF_BFR_DES_ADDR: Outlink descriptor address before the last transmit descriptor
func (o *UHCI0_Type) SetDMA_OUT_EOF_BFR_DES_ADDR(value uint32) {
	volatile.StoreUint32(&o.DMA_OUT_EOF_BFR_DES_ADDR.Reg, value)
}
func (o *UHCI0_Type) GetDMA_OUT_EOF_BFR_DES_ADDR() uint32 {
	return volatile.LoadUint32(&o.DMA_OUT_EOF_BFR_DES_ADDR.Reg)
}

// UHCI0.AHB_TEST: AHB test register
func (o *UHCI0_Type) SetAHB_TEST_AHB_TESTMODE(value uint32) {
	volatile.StoreUint32(&o.AHB_TEST.Reg, volatile.LoadUint32(&o.AHB_TEST.Reg)&^(0x7)|value)
}
func (o *UHCI0_Type) GetAHB_TEST_AHB_TESTMODE() uint32 {
	return volatile.LoadUint32(&o.AHB_TEST.Reg) & 0x7
}
func (o *UHCI0_Type) SetAHB_TEST_AHB_TESTADDR(value uint32) {
	volatile.StoreUint32(&o.AHB_TEST.Reg, volatile.LoadUint32(&o.AHB_TEST.Reg)&^(0x30)|value<<4)
}
func (o *UHCI0_Type) GetAHB_TEST_AHB_TESTADDR() uint32 {
	return (volatile.LoadUint32(&o.AHB_TEST.Reg) & 0x30) >> 4
}

// UHCI0.DMA_IN_DSCR: The third word of the next receive descriptor
func (o *UHCI0_Type) SetDMA_IN_DSCR(value uint32) {
	volatile.StoreUint32(&o.DMA_IN_DSCR.Reg, value)
}
func (o *UHCI0_Type) GetDMA_IN_DSCR() uint32 {
	return volatile.LoadUint32(&o.DMA_IN_DSCR.Reg)
}

// UHCI0.DMA_IN_DSCR_BF0: The third word of current receive descriptor
func (o *UHCI0_Type) SetDMA_IN_DSCR_BF0(value uint32) {
	volatile.StoreUint32(&o.DMA_IN_DSCR_BF0.Reg, value)
}
func (o *UHCI0_Type) GetDMA_IN_DSCR_BF0() uint32 {
	return volatile.LoadUint32(&o.DMA_IN_DSCR_BF0.Reg)
}

// UHCI0.DMA_IN_DSCR_BF1: The second word of current receive descriptor
func (o *UHCI0_Type) SetDMA_IN_DSCR_BF1(value uint32) {
	volatile.StoreUint32(&o.DMA_IN_DSCR_BF1.Reg, value)
}
func (o *UHCI0_Type) GetDMA_IN_DSCR_BF1() uint32 {
	return volatile.LoadUint32(&o.DMA_IN_DSCR_BF1.Reg)
}

// UHCI0.DMA_OUT_DSCR: The third word of the next transmit descriptor
func (o *UHCI0_Type) SetDMA_OUT_DSCR(value uint32) {
	volatile.StoreUint32(&o.DMA_OUT_DSCR.Reg, value)
}
func (o *UHCI0_Type) GetDMA_OUT_DSCR() uint32 {
	return volatile.LoadUint32(&o.DMA_OUT_DSCR.Reg)
}

// UHCI0.DMA_OUT_DSCR_BF0: The third word of current transmit descriptor
func (o *UHCI0_Type) SetDMA_OUT_DSCR_BF0(value uint32) {
	volatile.StoreUint32(&o.DMA_OUT_DSCR_BF0.Reg, value)
}
func (o *UHCI0_Type) GetDMA_OUT_DSCR_BF0() uint32 {
	return volatile.LoadUint32(&o.DMA_OUT_DSCR_BF0.Reg)
}

// UHCI0.DMA_OUT_DSCR_BF1: The second word of current transmit descriptor
func (o *UHCI0_Type) SetDMA_OUT_DSCR_BF1(value uint32) {
	volatile.StoreUint32(&o.DMA_OUT_DSCR_BF1.Reg, value)
}
func (o *UHCI0_Type) GetDMA_OUT_DSCR_BF1() uint32 {
	return volatile.LoadUint32(&o.DMA_OUT_DSCR_BF1.Reg)
}

// UHCI0.ESCAPE_CONF: Escape characters configuration
func (o *UHCI0_Type) SetESCAPE_CONF_TX_C0_ESC_EN(value uint32) {
	volatile.StoreUint32(&o.ESCAPE_CONF.Reg, volatile.LoadUint32(&o.ESCAPE_CONF.Reg)&^(0x1)|value)
}
func (o *UHCI0_Type) GetESCAPE_CONF_TX_C0_ESC_EN() uint32 {
	return volatile.LoadUint32(&o.ESCAPE_CONF.Reg) & 0x1
}
func (o *UHCI0_Type) SetESCAPE_CONF_TX_DB_ESC_EN(value uint32) {
	volatile.StoreUint32(&o.ESCAPE_CONF.Reg, volatile.LoadUint32(&o.ESCAPE_CONF.Reg)&^(0x2)|value<<1)
}
func (o *UHCI0_Type) GetESCAPE_CONF_TX_DB_ESC_EN() uint32 {
	return (volatile.LoadUint32(&o.ESCAPE_CONF.Reg) & 0x2) >> 1
}
func (o *UHCI0_Type) SetESCAPE_CONF_TX_11_ESC_EN(value uint32) {
	volatile.StoreUint32(&o.ESCAPE_CONF.Reg, volatile.LoadUint32(&o.ESCAPE_CONF.Reg)&^(0x4)|value<<2)
}
func (o *UHCI0_Type) GetESCAPE_CONF_TX_11_ESC_EN() uint32 {
	return (volatile.LoadUint32(&o.ESCAPE_CONF.Reg) & 0x4) >> 2
}
func (o *UHCI0_Type) SetESCAPE_CONF_TX_13_ESC_EN(value uint32) {
	volatile.StoreUint32(&o.ESCAPE_CONF.Reg, volatile.LoadUint32(&o.ESCAPE_CONF.Reg)&^(0x8)|value<<3)
}
func (o *UHCI0_Type) GetESCAPE_CONF_TX_13_ESC_EN() uint32 {
	return (volatile.LoadUint32(&o.ESCAPE_CONF.Reg) & 0x8) >> 3
}
func (o *UHCI0_Type) SetESCAPE_CONF_RX_C0_ESC_EN(value uint32) {
	volatile.StoreUint32(&o.ESCAPE_CONF.Reg, volatile.LoadUint32(&o.ESCAPE_CONF.Reg)&^(0x10)|value<<4)
}
func (o *UHCI0_Type) GetESCAPE_CONF_RX_C0_ESC_EN() uint32 {
	return (volatile.LoadUint32(&o.ESCAPE_CONF.Reg) & 0x10) >> 4
}
func (o *UHCI0_Type) SetESCAPE_CONF_RX_DB_ESC_EN(value uint32) {
	volatile.StoreUint32(&o.ESCAPE_CONF.Reg, volatile.LoadUint32(&o.ESCAPE_CONF.Reg)&^(0x20)|value<<5)
}
func (o *UHCI0_Type) GetESCAPE_CONF_RX_DB_ESC_EN() uint32 {
	return (volatile.LoadUint32(&o.ESCAPE_CONF.Reg) & 0x20) >> 5
}
func (o *UHCI0_Type) SetESCAPE_CONF_RX_11_ESC_EN(value uint32) {
	volatile.StoreUint32(&o.ESCAPE_CONF.Reg, volatile.LoadUint32(&o.ESCAPE_CONF.Reg)&^(0x40)|value<<6)
}
func (o *UHCI0_Type) GetESCAPE_CONF_RX_11_ESC_EN() uint32 {
	return (volatile.LoadUint32(&o.ESCAPE_CONF.Reg) & 0x40) >> 6
}
func (o *UHCI0_Type) SetESCAPE_CONF_RX_13_ESC_EN(value uint32) {
	volatile.StoreUint32(&o.ESCAPE_CONF.Reg, volatile.LoadUint32(&o.ESCAPE_CONF.Reg)&^(0x80)|value<<7)
}
func (o *UHCI0_Type) GetESCAPE_CONF_RX_13_ESC_EN() uint32 {
	return (volatile.LoadUint32(&o.ESCAPE_CONF.Reg) & 0x80) >> 7
}

// UHCI0.HUNG_CONF: Timeout configuration
func (o *UHCI0_Type) SetHUNG_CONF_TXFIFO_TIMEOUT(value uint32) {
	volatile.StoreUint32(&o.HUNG_CONF.Reg, volatile.LoadUint32(&o.HUNG_CONF.Reg)&^(0xff)|value)
}
func (o *UHCI0_Type) GetHUNG_CONF_TXFIFO_TIMEOUT() uint32 {
	return volatile.LoadUint32(&o.HUNG_CONF.Reg) & 0xff
}
func (o *UHCI0_Type) SetHUNG_CONF_TXFIFO_TIMEOUT_SHIFT(value uint32) {
	volatile.StoreUint32(&o.HUNG_CONF.Reg, volatile.LoadUint32(&o.HUNG_CONF.Reg)&^(0x700)|value<<8)
}
func (o *UHCI0_Type) GetHUNG_CONF_TXFIFO_TIMEOUT_SHIFT() uint32 {
	return (volatile.LoadUint32(&o.HUNG_CONF.Reg) & 0x700) >> 8
}
func (o *UHCI0_Type) SetHUNG_CONF_TXFIFO_TIMEOUT_ENA(value uint32) {
	volatile.StoreUint32(&o.HUNG_CONF.Reg, volatile.LoadUint32(&o.HUNG_CONF.Reg)&^(0x800)|value<<11)
}
func (o *UHCI0_Type) GetHUNG_CONF_TXFIFO_TIMEOUT_ENA() uint32 {
	return (volatile.LoadUint32(&o.HUNG_CONF.Reg) & 0x800) >> 11
}
func (o *UHCI0_Type) SetHUNG_CONF_RXFIFO_TIMEOUT(value uint32) {
	volatile.StoreUint32(&o.HUNG_CONF.Reg, volatile.LoadUint32(&o.HUNG_CONF.Reg)&^(0xff000)|value<<12)
}
func (o *UHCI0_Type) GetHUNG_CONF_RXFIFO_TIMEOUT() uint32 {
	return (volatile.LoadUint32(&o.HUNG_CONF.Reg) & 0xff000) >> 12
}
func (o *UHCI0_Type) SetHUNG_CONF_RXFIFO_TIMEOUT_SHIFT(value uint32) {
	volatile.StoreUint32(&o.HUNG_CONF.Reg, volatile.LoadUint32(&o.HUNG_CONF.Reg)&^(0x700000)|value<<20)
}
func (o *UHCI0_Type) GetHUNG_CONF_RXFIFO_TIMEOUT_SHIFT() uint32 {
	return (volatile.LoadUint32(&o.HUNG_CONF.Reg) & 0x700000) >> 20
}
func (o *UHCI0_Type) SetHUNG_CONF_RXFIFO_TIMEOUT_ENA(value uint32) {
	volatile.StoreUint32(&o.HUNG_CONF.Reg, volatile.LoadUint32(&o.HUNG_CONF.Reg)&^(0x800000)|value<<23)
}
func (o *UHCI0_Type) GetHUNG_CONF_RXFIFO_TIMEOUT_ENA() uint32 {
	return (volatile.LoadUint32(&o.HUNG_CONF.Reg) & 0x800000) >> 23
}

// UHCI0.RX_HEAD: UHCI packet header register
func (o *UHCI0_Type) SetRX_HEAD(value uint32) {
	volatile.StoreUint32(&o.RX_HEAD.Reg, value)
}
func (o *UHCI0_Type) GetRX_HEAD() uint32 {
	return volatile.LoadUint32(&o.RX_HEAD.Reg)
}

// UHCI0.QUICK_SENT: UHCI quick send configuration register
func (o *UHCI0_Type) SetQUICK_SENT_SINGLE_SEND_NUM(value uint32) {
	volatile.StoreUint32(&o.QUICK_SENT.Reg, volatile.LoadUint32(&o.QUICK_SENT.Reg)&^(0x7)|value)
}
func (o *UHCI0_Type) GetQUICK_SENT_SINGLE_SEND_NUM() uint32 {
	return volatile.LoadUint32(&o.QUICK_SENT.Reg) & 0x7
}
func (o *UHCI0_Type) SetQUICK_SENT_SINGLE_SEND_EN(value uint32) {
	volatile.StoreUint32(&o.QUICK_SENT.Reg, volatile.LoadUint32(&o.QUICK_SENT.Reg)&^(0x8)|value<<3)
}
func (o *UHCI0_Type) GetQUICK_SENT_SINGLE_SEND_EN() uint32 {
	return (volatile.LoadUint32(&o.QUICK_SENT.Reg) & 0x8) >> 3
}
func (o *UHCI0_Type) SetQUICK_SENT_ALWAYS_SEND_NUM(value uint32) {
	volatile.StoreUint32(&o.QUICK_SENT.Reg, volatile.LoadUint32(&o.QUICK_SENT.Reg)&^(0x70)|value<<4)
}
func (o *UHCI0_Type) GetQUICK_SENT_ALWAYS_SEND_NUM() uint32 {
	return (volatile.LoadUint32(&o.QUICK_SENT.Reg) & 0x70) >> 4
}
func (o *UHCI0_Type) SetQUICK_SENT_ALWAYS_SEND_EN(value uint32) {
	volatile.StoreUint32(&o.QUICK_SENT.Reg, volatile.LoadUint32(&o.QUICK_SENT.Reg)&^(0x80)|value<<7)
}
func (o *UHCI0_Type) GetQUICK_SENT_ALWAYS_SEND_EN() uint32 {
	return (volatile.LoadUint32(&o.QUICK_SENT.Reg) & 0x80) >> 7
}

// UHCI0.REG_Q0_WORD0: Q0_WORD0 quick_sent register
func (o *UHCI0_Type) SetREG_Q0_WORD0(value uint32) {
	volatile.StoreUint32(&o.REG_Q0_WORD0.Reg, value)
}
func (o *UHCI0_Type) GetREG_Q0_WORD0() uint32 {
	return volatile.LoadUint32(&o.REG_Q0_WORD0.Reg)
}

// UHCI0.REG_Q0_WORD1: Q0_WORD1 quick_sent register
func (o *UHCI0_Type) SetREG_Q0_WORD1(value uint32) {
	volatile.StoreUint32(&o.REG_Q0_WORD1.Reg, value)
}
func (o *UHCI0_Type) GetREG_Q0_WORD1() uint32 {
	return volatile.LoadUint32(&o.REG_Q0_WORD1.Reg)
}

// UHCI0.REG_Q1_WORD0: Q1_WORD0 quick_sent register
func (o *UHCI0_Type) SetREG_Q1_WORD0(value uint32) {
	volatile.StoreUint32(&o.REG_Q1_WORD0.Reg, value)
}
func (o *UHCI0_Type) GetREG_Q1_WORD0() uint32 {
	return volatile.LoadUint32(&o.REG_Q1_WORD0.Reg)
}

// UHCI0.REG_Q1_WORD1: Q1_WORD1 quick_sent register
func (o *UHCI0_Type) SetREG_Q1_WORD1(value uint32) {
	volatile.StoreUint32(&o.REG_Q1_WORD1.Reg, value)
}
func (o *UHCI0_Type) GetREG_Q1_WORD1() uint32 {
	return volatile.LoadUint32(&o.REG_Q1_WORD1.Reg)
}

// UHCI0.REG_Q2_WORD0: Q2_WORD0 quick_sent register
func (o *UHCI0_Type) SetREG_Q2_WORD0(value uint32) {
	volatile.StoreUint32(&o.REG_Q2_WORD0.Reg, value)
}
func (o *UHCI0_Type) GetREG_Q2_WORD0() uint32 {
	return volatile.LoadUint32(&o.REG_Q2_WORD0.Reg)
}

// UHCI0.REG_Q2_WORD1: Q2_WORD1 quick_sent register
func (o *UHCI0_Type) SetREG_Q2_WORD1(value uint32) {
	volatile.StoreUint32(&o.REG_Q2_WORD1.Reg, value)
}
func (o *UHCI0_Type) GetREG_Q2_WORD1() uint32 {
	return volatile.LoadUint32(&o.REG_Q2_WORD1.Reg)
}

// UHCI0.REG_Q3_WORD0: Q3_WORD0 quick_sent register
func (o *UHCI0_Type) SetREG_Q3_WORD0(value uint32) {
	volatile.StoreUint32(&o.REG_Q3_WORD0.Reg, value)
}
func (o *UHCI0_Type) GetREG_Q3_WORD0() uint32 {
	return volatile.LoadUint32(&o.REG_Q3_WORD0.Reg)
}

// UHCI0.REG_Q3_WORD1: Q3_WORD1 quick_sent register
func (o *UHCI0_Type) SetREG_Q3_WORD1(value uint32) {
	volatile.StoreUint32(&o.REG_Q3_WORD1.Reg, value)
}
func (o *UHCI0_Type) GetREG_Q3_WORD1() uint32 {
	return volatile.LoadUint32(&o.REG_Q3_WORD1.Reg)
}

// UHCI0.REG_Q4_WORD0: Q4_WORD0 quick_sent register
func (o *UHCI0_Type) SetREG_Q4_WORD0(value uint32) {
	volatile.StoreUint32(&o.REG_Q4_WORD0.Reg, value)
}
func (o *UHCI0_Type) GetREG_Q4_WORD0() uint32 {
	return volatile.LoadUint32(&o.REG_Q4_WORD0.Reg)
}

// UHCI0.REG_Q4_WORD1: Q4_WORD1 quick_sent register
func (o *UHCI0_Type) SetREG_Q4_WORD1(value uint32) {
	volatile.StoreUint32(&o.REG_Q4_WORD1.Reg, value)
}
func (o *UHCI0_Type) GetREG_Q4_WORD1() uint32 {
	return volatile.LoadUint32(&o.REG_Q4_WORD1.Reg)
}

// UHCI0.REG_Q5_WORD0: Q5_WORD0 quick_sent register
func (o *UHCI0_Type) SetREG_Q5_WORD0(value uint32) {
	volatile.StoreUint32(&o.REG_Q5_WORD0.Reg, value)
}
func (o *UHCI0_Type) GetREG_Q5_WORD0() uint32 {
	return volatile.LoadUint32(&o.REG_Q5_WORD0.Reg)
}

// UHCI0.REG_Q5_WORD1: Q5_WORD1 quick_sent register
func (o *UHCI0_Type) SetREG_Q5_WORD1(value uint32) {
	volatile.StoreUint32(&o.REG_Q5_WORD1.Reg, value)
}
func (o *UHCI0_Type) GetREG_Q5_WORD1() uint32 {
	return volatile.LoadUint32(&o.REG_Q5_WORD1.Reg)
}

// UHCI0.REG_Q6_WORD0: Q6_WORD0 quick_sent register
func (o *UHCI0_Type) SetREG_Q6_WORD0(value uint32) {
	volatile.StoreUint32(&o.REG_Q6_WORD0.Reg, value)
}
func (o *UHCI0_Type) GetREG_Q6_WORD0() uint32 {
	return volatile.LoadUint32(&o.REG_Q6_WORD0.Reg)
}

// UHCI0.REG_Q6_WORD1: Q6_WORD1 quick_sent register
func (o *UHCI0_Type) SetREG_Q6_WORD1(value uint32) {
	volatile.StoreUint32(&o.REG_Q6_WORD1.Reg, value)
}
func (o *UHCI0_Type) GetREG_Q6_WORD1() uint32 {
	return volatile.LoadUint32(&o.REG_Q6_WORD1.Reg)
}

// UHCI0.ESC_CONF0: Escape sequence configuration register 0
func (o *UHCI0_Type) SetESC_CONF0_SEPER_CHAR(value uint32) {
	volatile.StoreUint32(&o.ESC_CONF0.Reg, volatile.LoadUint32(&o.ESC_CONF0.Reg)&^(0xff)|value)
}
func (o *UHCI0_Type) GetESC_CONF0_SEPER_CHAR() uint32 {
	return volatile.LoadUint32(&o.ESC_CONF0.Reg) & 0xff
}
func (o *UHCI0_Type) SetESC_CONF0_SEPER_ESC_CHAR0(value uint32) {
	volatile.StoreUint32(&o.ESC_CONF0.Reg, volatile.LoadUint32(&o.ESC_CONF0.Reg)&^(0xff00)|value<<8)
}
func (o *UHCI0_Type) GetESC_CONF0_SEPER_ESC_CHAR0() uint32 {
	return (volatile.LoadUint32(&o.ESC_CONF0.Reg) & 0xff00) >> 8
}
func (o *UHCI0_Type) SetESC_CONF0_SEPER_ESC_CHAR1(value uint32) {
	volatile.StoreUint32(&o.ESC_CONF0.Reg, volatile.LoadUint32(&o.ESC_CONF0.Reg)&^(0xff0000)|value<<16)
}
func (o *UHCI0_Type) GetESC_CONF0_SEPER_ESC_CHAR1() uint32 {
	return (volatile.LoadUint32(&o.ESC_CONF0.Reg) & 0xff0000) >> 16
}

// UHCI0.ESC_CONF1: Escape sequence configuration register 1
func (o *UHCI0_Type) SetESC_CONF1_ESC_SEQ0(value uint32) {
	volatile.StoreUint32(&o.ESC_CONF1.Reg, volatile.LoadUint32(&o.ESC_CONF1.Reg)&^(0xff)|value)
}
func (o *UHCI0_Type) GetESC_CONF1_ESC_SEQ0() uint32 {
	return volatile.LoadUint32(&o.ESC_CONF1.Reg) & 0xff
}
func (o *UHCI0_Type) SetESC_CONF1_ESC_SEQ0_CHAR0(value uint32) {
	volatile.StoreUint32(&o.ESC_CONF1.Reg, volatile.LoadUint32(&o.ESC_CONF1.Reg)&^(0xff00)|value<<8)
}
func (o *UHCI0_Type) GetESC_CONF1_ESC_SEQ0_CHAR0() uint32 {
	return (volatile.LoadUint32(&o.ESC_CONF1.Reg) & 0xff00) >> 8
}
func (o *UHCI0_Type) SetESC_CONF1_ESC_SEQ0_CHAR1(value uint32) {
	volatile.StoreUint32(&o.ESC_CONF1.Reg, volatile.LoadUint32(&o.ESC_CONF1.Reg)&^(0xff0000)|value<<16)
}
func (o *UHCI0_Type) GetESC_CONF1_ESC_SEQ0_CHAR1() uint32 {
	return (volatile.LoadUint32(&o.ESC_CONF1.Reg) & 0xff0000) >> 16
}

// UHCI0.ESC_CONF2: Escape sequence configuration register 2
func (o *UHCI0_Type) SetESC_CONF2_ESC_SEQ1(value uint32) {
	volatile.StoreUint32(&o.ESC_CONF2.Reg, volatile.LoadUint32(&o.ESC_CONF2.Reg)&^(0xff)|value)
}
func (o *UHCI0_Type) GetESC_CONF2_ESC_SEQ1() uint32 {
	return volatile.LoadUint32(&o.ESC_CONF2.Reg) & 0xff
}
func (o *UHCI0_Type) SetESC_CONF2_ESC_SEQ1_CHAR0(value uint32) {
	volatile.StoreUint32(&o.ESC_CONF2.Reg, volatile.LoadUint32(&o.ESC_CONF2.Reg)&^(0xff00)|value<<8)
}
func (o *UHCI0_Type) GetESC_CONF2_ESC_SEQ1_CHAR0() uint32 {
	return (volatile.LoadUint32(&o.ESC_CONF2.Reg) & 0xff00) >> 8
}
func (o *UHCI0_Type) SetESC_CONF2_ESC_SEQ1_CHAR1(value uint32) {
	volatile.StoreUint32(&o.ESC_CONF2.Reg, volatile.LoadUint32(&o.ESC_CONF2.Reg)&^(0xff0000)|value<<16)
}
func (o *UHCI0_Type) GetESC_CONF2_ESC_SEQ1_CHAR1() uint32 {
	return (volatile.LoadUint32(&o.ESC_CONF2.Reg) & 0xff0000) >> 16
}

// UHCI0.ESC_CONF3: Escape sequence configuration register 3
func (o *UHCI0_Type) SetESC_CONF3_ESC_SEQ2(value uint32) {
	volatile.StoreUint32(&o.ESC_CONF3.Reg, volatile.LoadUint32(&o.ESC_CONF3.Reg)&^(0xff)|value)
}
func (o *UHCI0_Type) GetESC_CONF3_ESC_SEQ2() uint32 {
	return volatile.LoadUint32(&o.ESC_CONF3.Reg) & 0xff
}
func (o *UHCI0_Type) SetESC_CONF3_ESC_SEQ2_CHAR0(value uint32) {
	volatile.StoreUint32(&o.ESC_CONF3.Reg, volatile.LoadUint32(&o.ESC_CONF3.Reg)&^(0xff00)|value<<8)
}
func (o *UHCI0_Type) GetESC_CONF3_ESC_SEQ2_CHAR0() uint32 {
	return (volatile.LoadUint32(&o.ESC_CONF3.Reg) & 0xff00) >> 8
}
func (o *UHCI0_Type) SetESC_CONF3_ESC_SEQ2_CHAR1(value uint32) {
	volatile.StoreUint32(&o.ESC_CONF3.Reg, volatile.LoadUint32(&o.ESC_CONF3.Reg)&^(0xff0000)|value<<16)
}
func (o *UHCI0_Type) GetESC_CONF3_ESC_SEQ2_CHAR1() uint32 {
	return (volatile.LoadUint32(&o.ESC_CONF3.Reg) & 0xff0000) >> 16
}

// UHCI0.PKT_THRES: Configure register for packet length
func (o *UHCI0_Type) SetPKT_THRES_PKT_THRS(value uint32) {
	volatile.StoreUint32(&o.PKT_THRES.Reg, volatile.LoadUint32(&o.PKT_THRES.Reg)&^(0x1fff)|value)
}
func (o *UHCI0_Type) GetPKT_THRES_PKT_THRS() uint32 {
	return volatile.LoadUint32(&o.PKT_THRES.Reg) & 0x1fff
}

// UHCI0.DATE: UHCI version control register
func (o *UHCI0_Type) SetDATE(value uint32) {
	volatile.StoreUint32(&o.DATE.Reg, value)
}
func (o *UHCI0_Type) GetDATE() uint32 {
	return volatile.LoadUint32(&o.DATE.Reg)
}

// Peripheral XTS_AES
type XTS_AES_Type struct {
	_                [256]byte
	PLAIN_0          volatile.Register32 // 0x100
	PLAIN_1          volatile.Register32 // 0x104
	PLAIN_2          volatile.Register32 // 0x108
	PLAIN_3          volatile.Register32 // 0x10C
	PLAIN_4          volatile.Register32 // 0x110
	PLAIN_5          volatile.Register32 // 0x114
	PLAIN_6          volatile.Register32 // 0x118
	PLAIN_7          volatile.Register32 // 0x11C
	PLAIN_8          volatile.Register32 // 0x120
	PLAIN_9          volatile.Register32 // 0x124
	PLAIN_10         volatile.Register32 // 0x128
	PLAIN_11         volatile.Register32 // 0x12C
	PLAIN_12         volatile.Register32 // 0x130
	PLAIN_13         volatile.Register32 // 0x134
	PLAIN_14         volatile.Register32 // 0x138
	PLAIN_15         volatile.Register32 // 0x13C
	LINESIZE         volatile.Register32 // 0x140
	DESTINATION      volatile.Register32 // 0x144
	PHYSICAL_ADDRESS volatile.Register32 // 0x148
	TRIGGER          volatile.Register32 // 0x14C
	RELEASE          volatile.Register32 // 0x150
	DESTROY          volatile.Register32 // 0x154
	STATE            volatile.Register32 // 0x158
	DATE             volatile.Register32 // 0x15C
}

// XTS_AES.PLAIN_0: Plaintext register %s
func (o *XTS_AES_Type) SetPLAIN_0(value uint32) {
	volatile.StoreUint32(&o.PLAIN_0.Reg, value)
}
func (o *XTS_AES_Type) GetPLAIN_0() uint32 {
	return volatile.LoadUint32(&o.PLAIN_0.Reg)
}

// XTS_AES.PLAIN_1: Plaintext register %s
func (o *XTS_AES_Type) SetPLAIN_1(value uint32) {
	volatile.StoreUint32(&o.PLAIN_1.Reg, value)
}
func (o *XTS_AES_Type) GetPLAIN_1() uint32 {
	return volatile.LoadUint32(&o.PLAIN_1.Reg)
}

// XTS_AES.PLAIN_2: Plaintext register %s
func (o *XTS_AES_Type) SetPLAIN_2(value uint32) {
	volatile.StoreUint32(&o.PLAIN_2.Reg, value)
}
func (o *XTS_AES_Type) GetPLAIN_2() uint32 {
	return volatile.LoadUint32(&o.PLAIN_2.Reg)
}

// XTS_AES.PLAIN_3: Plaintext register %s
func (o *XTS_AES_Type) SetPLAIN_3(value uint32) {
	volatile.StoreUint32(&o.PLAIN_3.Reg, value)
}
func (o *XTS_AES_Type) GetPLAIN_3() uint32 {
	return volatile.LoadUint32(&o.PLAIN_3.Reg)
}

// XTS_AES.PLAIN_4: Plaintext register %s
func (o *XTS_AES_Type) SetPLAIN_4(value uint32) {
	volatile.StoreUint32(&o.PLAIN_4.Reg, value)
}
func (o *XTS_AES_Type) GetPLAIN_4() uint32 {
	return volatile.LoadUint32(&o.PLAIN_4.Reg)
}

// XTS_AES.PLAIN_5: Plaintext register %s
func (o *XTS_AES_Type) SetPLAIN_5(value uint32) {
	volatile.StoreUint32(&o.PLAIN_5.Reg, value)
}
func (o *XTS_AES_Type) GetPLAIN_5() uint32 {
	return volatile.LoadUint32(&o.PLAIN_5.Reg)
}

// XTS_AES.PLAIN_6: Plaintext register %s
func (o *XTS_AES_Type) SetPLAIN_6(value uint32) {
	volatile.StoreUint32(&o.PLAIN_6.Reg, value)
}
func (o *XTS_AES_Type) GetPLAIN_6() uint32 {
	return volatile.LoadUint32(&o.PLAIN_6.Reg)
}

// XTS_AES.PLAIN_7: Plaintext register %s
func (o *XTS_AES_Type) SetPLAIN_7(value uint32) {
	volatile.StoreUint32(&o.PLAIN_7.Reg, value)
}
func (o *XTS_AES_Type) GetPLAIN_7() uint32 {
	return volatile.LoadUint32(&o.PLAIN_7.Reg)
}

// XTS_AES.PLAIN_8: Plaintext register %s
func (o *XTS_AES_Type) SetPLAIN_8(value uint32) {
	volatile.StoreUint32(&o.PLAIN_8.Reg, value)
}
func (o *XTS_AES_Type) GetPLAIN_8() uint32 {
	return volatile.LoadUint32(&o.PLAIN_8.Reg)
}

// XTS_AES.PLAIN_9: Plaintext register %s
func (o *XTS_AES_Type) SetPLAIN_9(value uint32) {
	volatile.StoreUint32(&o.PLAIN_9.Reg, value)
}
func (o *XTS_AES_Type) GetPLAIN_9() uint32 {
	return volatile.LoadUint32(&o.PLAIN_9.Reg)
}

// XTS_AES.PLAIN_10: Plaintext register %s
func (o *XTS_AES_Type) SetPLAIN_10(value uint32) {
	volatile.StoreUint32(&o.PLAIN_10.Reg, value)
}
func (o *XTS_AES_Type) GetPLAIN_10() uint32 {
	return volatile.LoadUint32(&o.PLAIN_10.Reg)
}

// XTS_AES.PLAIN_11: Plaintext register %s
func (o *XTS_AES_Type) SetPLAIN_11(value uint32) {
	volatile.StoreUint32(&o.PLAIN_11.Reg, value)
}
func (o *XTS_AES_Type) GetPLAIN_11() uint32 {
	return volatile.LoadUint32(&o.PLAIN_11.Reg)
}

// XTS_AES.PLAIN_12: Plaintext register %s
func (o *XTS_AES_Type) SetPLAIN_12(value uint32) {
	volatile.StoreUint32(&o.PLAIN_12.Reg, value)
}
func (o *XTS_AES_Type) GetPLAIN_12() uint32 {
	return volatile.LoadUint32(&o.PLAIN_12.Reg)
}

// XTS_AES.PLAIN_13: Plaintext register %s
func (o *XTS_AES_Type) SetPLAIN_13(value uint32) {
	volatile.StoreUint32(&o.PLAIN_13.Reg, value)
}
func (o *XTS_AES_Type) GetPLAIN_13() uint32 {
	return volatile.LoadUint32(&o.PLAIN_13.Reg)
}

// XTS_AES.PLAIN_14: Plaintext register %s
func (o *XTS_AES_Type) SetPLAIN_14(value uint32) {
	volatile.StoreUint32(&o.PLAIN_14.Reg, value)
}
func (o *XTS_AES_Type) GetPLAIN_14() uint32 {
	return volatile.LoadUint32(&o.PLAIN_14.Reg)
}

// XTS_AES.PLAIN_15: Plaintext register %s
func (o *XTS_AES_Type) SetPLAIN_15(value uint32) {
	volatile.StoreUint32(&o.PLAIN_15.Reg, value)
}
func (o *XTS_AES_Type) GetPLAIN_15() uint32 {
	return volatile.LoadUint32(&o.PLAIN_15.Reg)
}

// XTS_AES.LINESIZE: Configures the size of target memory space
func (o *XTS_AES_Type) SetLINESIZE(value uint32) {
	volatile.StoreUint32(&o.LINESIZE.Reg, volatile.LoadUint32(&o.LINESIZE.Reg)&^(0x3)|value)
}
func (o *XTS_AES_Type) GetLINESIZE() uint32 {
	return volatile.LoadUint32(&o.LINESIZE.Reg) & 0x3
}

// XTS_AES.DESTINATION: Configures the type of the external memory
func (o *XTS_AES_Type) SetDESTINATION(value uint32) {
	volatile.StoreUint32(&o.DESTINATION.Reg, volatile.LoadUint32(&o.DESTINATION.Reg)&^(0x1)|value)
}
func (o *XTS_AES_Type) GetDESTINATION() uint32 {
	return volatile.LoadUint32(&o.DESTINATION.Reg) & 0x1
}

// XTS_AES.PHYSICAL_ADDRESS: Physical address
func (o *XTS_AES_Type) SetPHYSICAL_ADDRESS(value uint32) {
	volatile.StoreUint32(&o.PHYSICAL_ADDRESS.Reg, volatile.LoadUint32(&o.PHYSICAL_ADDRESS.Reg)&^(0x3fffffff)|value)
}
func (o *XTS_AES_Type) GetPHYSICAL_ADDRESS() uint32 {
	return volatile.LoadUint32(&o.PHYSICAL_ADDRESS.Reg) & 0x3fffffff
}

// XTS_AES.TRIGGER: Activates AES algorithm
func (o *XTS_AES_Type) SetTRIGGER(value uint32) {
	volatile.StoreUint32(&o.TRIGGER.Reg, volatile.LoadUint32(&o.TRIGGER.Reg)&^(0x1)|value)
}
func (o *XTS_AES_Type) GetTRIGGER() uint32 {
	return volatile.LoadUint32(&o.TRIGGER.Reg) & 0x1
}

// XTS_AES.RELEASE: Release control
func (o *XTS_AES_Type) SetRELEASE(value uint32) {
	volatile.StoreUint32(&o.RELEASE.Reg, volatile.LoadUint32(&o.RELEASE.Reg)&^(0x1)|value)
}
func (o *XTS_AES_Type) GetRELEASE() uint32 {
	return volatile.LoadUint32(&o.RELEASE.Reg) & 0x1
}

// XTS_AES.DESTROY: Destroys control
func (o *XTS_AES_Type) SetDESTROY(value uint32) {
	volatile.StoreUint32(&o.DESTROY.Reg, volatile.LoadUint32(&o.DESTROY.Reg)&^(0x1)|value)
}
func (o *XTS_AES_Type) GetDESTROY() uint32 {
	return volatile.LoadUint32(&o.DESTROY.Reg) & 0x1
}

// XTS_AES.STATE: Status register
func (o *XTS_AES_Type) SetSTATE(value uint32) {
	volatile.StoreUint32(&o.STATE.Reg, volatile.LoadUint32(&o.STATE.Reg)&^(0x3)|value)
}
func (o *XTS_AES_Type) GetSTATE() uint32 {
	return volatile.LoadUint32(&o.STATE.Reg) & 0x3
}

// XTS_AES.DATE: Version register
func (o *XTS_AES_Type) SetDATE(value uint32) {
	volatile.StoreUint32(&o.DATE.Reg, volatile.LoadUint32(&o.DATE.Reg)&^(0x3fffffff)|value)
}
func (o *XTS_AES_Type) GetDATE() uint32 {
	return volatile.LoadUint32(&o.DATE.Reg) & 0x3fffffff
}

// Constants for AES: Peripheral AES
const (
	// KEY_0: AES key register %s
	// Position of KEY_0 field.
	AES_KEY_KEY_0_Pos = 0x0
	// Bit mask of KEY_0 field.
	AES_KEY_KEY_0_Msk = 0xffffffff

	// TEXT_IN_0: Source data register %s
	// Position of TEXT_IN_0 field.
	AES_TEXT_IN_TEXT_IN_0_Pos = 0x0
	// Bit mask of TEXT_IN_0 field.
	AES_TEXT_IN_TEXT_IN_0_Msk = 0xffffffff

	// TEXT_OUT_0: Result data register %s
	// Position of TEXT_OUT_0 field.
	AES_TEXT_OUT_TEXT_OUT_0_Pos = 0x0
	// Bit mask of TEXT_OUT_0 field.
	AES_TEXT_OUT_TEXT_OUT_0_Msk = 0xffffffff

	// MODE: AES working mode configuration register
	// Position of MODE field.
	AES_MODE_MODE_Pos = 0x0
	// Bit mask of MODE field.
	AES_MODE_MODE_Msk = 0x7

	// ENDIAN: Endian configuration register
	// Position of ENDIAN field.
	AES_ENDIAN_ENDIAN_Pos = 0x0
	// Bit mask of ENDIAN field.
	AES_ENDIAN_ENDIAN_Msk = 0x3f

	// TRIGGER: Operation start controlling register
	// Position of TRIGGER field.
	AES_TRIGGER_TRIGGER_Pos = 0x0
	// Bit mask of TRIGGER field.
	AES_TRIGGER_TRIGGER_Msk = 0x1
	// Bit TRIGGER.
	AES_TRIGGER_TRIGGER = 0x1

	// STATE: Operation status register
	// Position of STATE field.
	AES_STATE_STATE_Pos = 0x0
	// Bit mask of STATE field.
	AES_STATE_STATE_Msk = 0x3

	// IV_0: initialization vector
	// Position of IV_0 field.
	AES_IV_IV_0_Pos = 0x0
	// Bit mask of IV_0 field.
	AES_IV_IV_0_Msk = 0xffffffff

	// H_0: GCM hash subkey
	// Position of H_0 field.
	AES_H_H_0_Pos = 0x0
	// Bit mask of H_0 field.
	AES_H_H_0_Msk = 0xffffffff

	// J0_0: J0
	// Position of J0_0 field.
	AES_J0_J0_0_Pos = 0x0
	// Bit mask of J0_0 field.
	AES_J0_J0_0_Msk = 0xffffffff

	// T0_0: T0
	// Position of T0_0 field.
	AES_T0_T0_0_Pos = 0x0
	// Bit mask of T0_0 field.
	AES_T0_T0_0_Msk = 0xffffffff

	// DMA_ENABLE: DMA enable register
	// Position of DMA_ENABLE field.
	AES_DMA_ENABLE_DMA_ENABLE_Pos = 0x0
	// Bit mask of DMA_ENABLE field.
	AES_DMA_ENABLE_DMA_ENABLE_Msk = 0x1
	// Bit DMA_ENABLE.
	AES_DMA_ENABLE_DMA_ENABLE = 0x1

	// BLOCK_MODE: Block operation type register
	// Position of BLOCK_MODE field.
	AES_BLOCK_MODE_BLOCK_MODE_Pos = 0x0
	// Bit mask of BLOCK_MODE field.
	AES_BLOCK_MODE_BLOCK_MODE_Msk = 0x7

	// BLOCK_NUM: Block number configuration register
	// Position of BLOCK_NUM field.
	AES_BLOCK_NUM_BLOCK_NUM_Pos = 0x0
	// Bit mask of BLOCK_NUM field.
	AES_BLOCK_NUM_BLOCK_NUM_Msk = 0xffffffff

	// INC_SEL: Standard incrementing function register
	// Position of INC_SEL field.
	AES_INC_SEL_INC_SEL_Pos = 0x0
	// Bit mask of INC_SEL field.
	AES_INC_SEL_INC_SEL_Msk = 0x1
	// Bit INC_SEL.
	AES_INC_SEL_INC_SEL = 0x1

	// AAD_BLOCK_NUM: AAD block number configuration register
	// Position of AAD_BLOCK_NUM field.
	AES_AAD_BLOCK_NUM_AAD_BLOCK_NUM_Pos = 0x0
	// Bit mask of AAD_BLOCK_NUM field.
	AES_AAD_BLOCK_NUM_AAD_BLOCK_NUM_Msk = 0xffffffff

	// REMAINDER_BIT_NUM: Remainder bit number of plaintext/ciphertext
	// Position of REMAINDER_BIT_NUM field.
	AES_REMAINDER_BIT_NUM_REMAINDER_BIT_NUM_Pos = 0x0
	// Bit mask of REMAINDER_BIT_NUM field.
	AES_REMAINDER_BIT_NUM_REMAINDER_BIT_NUM_Msk = 0x7f

	// CONTINUE_OP: Operation continue controlling register
	// Position of CONTINUE_OP field.
	AES_CONTINUE_OP_CONTINUE_OP_Pos = 0x0
	// Bit mask of CONTINUE_OP field.
	AES_CONTINUE_OP_CONTINUE_OP_Msk = 0x1
	// Bit CONTINUE_OP.
	AES_CONTINUE_OP_CONTINUE_OP = 0x1

	// INT_CLR: DMA-AES interrupt clear register
	// Position of INT_CLR field.
	AES_INT_CLR_INT_CLR_Pos = 0x0
	// Bit mask of INT_CLR field.
	AES_INT_CLR_INT_CLR_Msk = 0x1
	// Bit INT_CLR.
	AES_INT_CLR_INT_CLR = 0x1

	// INT_ENA: DMA-AES interrupt enable register
	// Position of INT_ENA field.
	AES_INT_ENA_INT_ENA_Pos = 0x0
	// Bit mask of INT_ENA field.
	AES_INT_ENA_INT_ENA_Msk = 0x1
	// Bit INT_ENA.
	AES_INT_ENA_INT_ENA = 0x1

	// DATE: Version control register
	// Position of DATE field.
	AES_DATE_DATE_Pos = 0x0
	// Bit mask of DATE field.
	AES_DATE_DATE_Msk = 0x3fffffff

	// DMA_EXIT: Operation exit controlling register
	// Position of DMA_EXIT field.
	AES_DMA_EXIT_DMA_EXIT_Pos = 0x0
	// Bit mask of DMA_EXIT field.
	AES_DMA_EXIT_DMA_EXIT_Msk = 0x1
	// Bit DMA_EXIT.
	AES_DMA_EXIT_DMA_EXIT = 0x1
)

// Constants for APB_SARADC: Peripheral APB_SARADC
const (
	// CTRL: DIG ADC common configuration
	// Position of START_FORCE field.
	APB_SARADC_CTRL_START_FORCE_Pos = 0x0
	// Bit mask of START_FORCE field.
	APB_SARADC_CTRL_START_FORCE_Msk = 0x1
	// Bit START_FORCE.
	APB_SARADC_CTRL_START_FORCE = 0x1
	// Position of START field.
	APB_SARADC_CTRL_START_Pos = 0x1
	// Bit mask of START field.
	APB_SARADC_CTRL_START_Msk = 0x2
	// Bit START.
	APB_SARADC_CTRL_START = 0x2
	// Position of WORK_MODE field.
	APB_SARADC_CTRL_WORK_MODE_Pos = 0x3
	// Bit mask of WORK_MODE field.
	APB_SARADC_CTRL_WORK_MODE_Msk = 0x18
	// Position of SAR_SEL field.
	APB_SARADC_CTRL_SAR_SEL_Pos = 0x5
	// Bit mask of SAR_SEL field.
	APB_SARADC_CTRL_SAR_SEL_Msk = 0x20
	// Bit SAR_SEL.
	APB_SARADC_CTRL_SAR_SEL = 0x20
	// Position of SAR_CLK_GATED field.
	APB_SARADC_CTRL_SAR_CLK_GATED_Pos = 0x6
	// Bit mask of SAR_CLK_GATED field.
	APB_SARADC_CTRL_SAR_CLK_GATED_Msk = 0x40
	// Bit SAR_CLK_GATED.
	APB_SARADC_CTRL_SAR_CLK_GATED = 0x40
	// Position of SAR_CLK_DIV field.
	APB_SARADC_CTRL_SAR_CLK_DIV_Pos = 0x7
	// Bit mask of SAR_CLK_DIV field.
	APB_SARADC_CTRL_SAR_CLK_DIV_Msk = 0x7f80
	// Position of SAR1_PATT_LEN field.
	APB_SARADC_CTRL_SAR1_PATT_LEN_Pos = 0xf
	// Bit mask of SAR1_PATT_LEN field.
	APB_SARADC_CTRL_SAR1_PATT_LEN_Msk = 0x78000
	// Position of SAR2_PATT_LEN field.
	APB_SARADC_CTRL_SAR2_PATT_LEN_Pos = 0x13
	// Bit mask of SAR2_PATT_LEN field.
	APB_SARADC_CTRL_SAR2_PATT_LEN_Msk = 0x780000
	// Position of SAR1_PATT_P_CLEAR field.
	APB_SARADC_CTRL_SAR1_PATT_P_CLEAR_Pos = 0x17
	// Bit mask of SAR1_PATT_P_CLEAR field.
	APB_SARADC_CTRL_SAR1_PATT_P_CLEAR_Msk = 0x800000
	// Bit SAR1_PATT_P_CLEAR.
	APB_SARADC_CTRL_SAR1_PATT_P_CLEAR = 0x800000
	// Position of SAR2_PATT_P_CLEAR field.
	APB_SARADC_CTRL_SAR2_PATT_P_CLEAR_Pos = 0x18
	// Bit mask of SAR2_PATT_P_CLEAR field.
	APB_SARADC_CTRL_SAR2_PATT_P_CLEAR_Msk = 0x1000000
	// Bit SAR2_PATT_P_CLEAR.
	APB_SARADC_CTRL_SAR2_PATT_P_CLEAR = 0x1000000
	// Position of DATA_SAR_SEL field.
	APB_SARADC_CTRL_DATA_SAR_SEL_Pos = 0x19
	// Bit mask of DATA_SAR_SEL field.
	APB_SARADC_CTRL_DATA_SAR_SEL_Msk = 0x2000000
	// Bit DATA_SAR_SEL.
	APB_SARADC_CTRL_DATA_SAR_SEL = 0x2000000
	// Position of DATA_TO_I2S field.
	APB_SARADC_CTRL_DATA_TO_I2S_Pos = 0x1a
	// Bit mask of DATA_TO_I2S field.
	APB_SARADC_CTRL_DATA_TO_I2S_Msk = 0x4000000
	// Bit DATA_TO_I2S.
	APB_SARADC_CTRL_DATA_TO_I2S = 0x4000000
	// Position of XPD_SAR_FORCE field.
	APB_SARADC_CTRL_XPD_SAR_FORCE_Pos = 0x1b
	// Bit mask of XPD_SAR_FORCE field.
	APB_SARADC_CTRL_XPD_SAR_FORCE_Msk = 0x18000000
	// Position of WAIT_ARB_CYCLE field.
	APB_SARADC_CTRL_WAIT_ARB_CYCLE_Pos = 0x1e
	// Bit mask of WAIT_ARB_CYCLE field.
	APB_SARADC_CTRL_WAIT_ARB_CYCLE_Msk = 0xc0000000

	// CTRL2: DIG ADC common configuration
	// Position of MEAS_NUM_LIMIT field.
	APB_SARADC_CTRL2_MEAS_NUM_LIMIT_Pos = 0x0
	// Bit mask of MEAS_NUM_LIMIT field.
	APB_SARADC_CTRL2_MEAS_NUM_LIMIT_Msk = 0x1
	// Bit MEAS_NUM_LIMIT.
	APB_SARADC_CTRL2_MEAS_NUM_LIMIT = 0x1
	// Position of MAX_MEAS_NUM field.
	APB_SARADC_CTRL2_MAX_MEAS_NUM_Pos = 0x1
	// Bit mask of MAX_MEAS_NUM field.
	APB_SARADC_CTRL2_MAX_MEAS_NUM_Msk = 0x1fe
	// Position of SAR1_INV field.
	APB_SARADC_CTRL2_SAR1_INV_Pos = 0x9
	// Bit mask of SAR1_INV field.
	APB_SARADC_CTRL2_SAR1_INV_Msk = 0x200
	// Bit SAR1_INV.
	APB_SARADC_CTRL2_SAR1_INV = 0x200
	// Position of SAR2_INV field.
	APB_SARADC_CTRL2_SAR2_INV_Pos = 0xa
	// Bit mask of SAR2_INV field.
	APB_SARADC_CTRL2_SAR2_INV_Msk = 0x400
	// Bit SAR2_INV.
	APB_SARADC_CTRL2_SAR2_INV = 0x400
	// Position of TIMER_SEL field.
	APB_SARADC_CTRL2_TIMER_SEL_Pos = 0xb
	// Bit mask of TIMER_SEL field.
	APB_SARADC_CTRL2_TIMER_SEL_Msk = 0x800
	// Bit TIMER_SEL.
	APB_SARADC_CTRL2_TIMER_SEL = 0x800
	// Position of TIMER_TARGET field.
	APB_SARADC_CTRL2_TIMER_TARGET_Pos = 0xc
	// Bit mask of TIMER_TARGET field.
	APB_SARADC_CTRL2_TIMER_TARGET_Msk = 0xfff000
	// Position of TIMER_EN field.
	APB_SARADC_CTRL2_TIMER_EN_Pos = 0x18
	// Bit mask of TIMER_EN field.
	APB_SARADC_CTRL2_TIMER_EN_Msk = 0x1000000
	// Bit TIMER_EN.
	APB_SARADC_CTRL2_TIMER_EN = 0x1000000

	// FSM: digital adc control register
	// Position of SAMPLE_NUM field.
	APB_SARADC_FSM_SAMPLE_NUM_Pos = 0x10
	// Bit mask of SAMPLE_NUM field.
	APB_SARADC_FSM_SAMPLE_NUM_Msk = 0xff0000
	// Position of SAMPLE_CYCLE field.
	APB_SARADC_FSM_SAMPLE_CYCLE_Pos = 0x18
	// Bit mask of SAMPLE_CYCLE field.
	APB_SARADC_FSM_SAMPLE_CYCLE_Msk = 0xff000000

	// FSM_WAIT: configure saradc fsm internal parameter base on test
	// Position of XPD_WAIT field.
	APB_SARADC_FSM_WAIT_XPD_WAIT_Pos = 0x0
	// Bit mask of XPD_WAIT field.
	APB_SARADC_FSM_WAIT_XPD_WAIT_Msk = 0xff
	// Position of RSTB_WAIT field.
	APB_SARADC_FSM_WAIT_RSTB_WAIT_Pos = 0x8
	// Bit mask of RSTB_WAIT field.
	APB_SARADC_FSM_WAIT_RSTB_WAIT_Msk = 0xff00
	// Position of STANDBY_WAIT field.
	APB_SARADC_FSM_WAIT_STANDBY_WAIT_Pos = 0x10
	// Bit mask of STANDBY_WAIT field.
	APB_SARADC_FSM_WAIT_STANDBY_WAIT_Msk = 0xff0000

	// SAR1_STATUS: digital adc1 status
	// Position of SAR1_STATUS field.
	APB_SARADC_SAR1_STATUS_SAR1_STATUS_Pos = 0x0
	// Bit mask of SAR1_STATUS field.
	APB_SARADC_SAR1_STATUS_SAR1_STATUS_Msk = 0xffffffff

	// SAR2_STATUS: digital adc2 status
	// Position of SAR2_STATUS field.
	APB_SARADC_SAR2_STATUS_SAR2_STATUS_Pos = 0x0
	// Bit mask of SAR2_STATUS field.
	APB_SARADC_SAR2_STATUS_SAR2_STATUS_Msk = 0xffffffff

	// SAR1_PATT_TAB1: item 0 ~ 3 for pattern table 1 (each item one byte)
	// Position of SAR1_PATT_TAB1 field.
	APB_SARADC_SAR1_PATT_TAB1_SAR1_PATT_TAB1_Pos = 0x0
	// Bit mask of SAR1_PATT_TAB1 field.
	APB_SARADC_SAR1_PATT_TAB1_SAR1_PATT_TAB1_Msk = 0xffffffff

	// SAR1_PATT_TAB2: Item 4 ~ 7 for pattern table 1 (each item one byte)
	// Position of SAR1_PATT_TAB2 field.
	APB_SARADC_SAR1_PATT_TAB2_SAR1_PATT_TAB2_Pos = 0x0
	// Bit mask of SAR1_PATT_TAB2 field.
	APB_SARADC_SAR1_PATT_TAB2_SAR1_PATT_TAB2_Msk = 0xffffffff

	// SAR1_PATT_TAB3: Item 8 ~ 11 for pattern table 1 (each item one byte)
	// Position of SAR1_PATT_TAB3 field.
	APB_SARADC_SAR1_PATT_TAB3_SAR1_PATT_TAB3_Pos = 0x0
	// Bit mask of SAR1_PATT_TAB3 field.
	APB_SARADC_SAR1_PATT_TAB3_SAR1_PATT_TAB3_Msk = 0xffffffff

	// SAR1_PATT_TAB4: Item 12 ~ 15 for pattern table 1 (each item one byte)
	// Position of SAR1_PATT_TAB4 field.
	APB_SARADC_SAR1_PATT_TAB4_SAR1_PATT_TAB4_Pos = 0x0
	// Bit mask of SAR1_PATT_TAB4 field.
	APB_SARADC_SAR1_PATT_TAB4_SAR1_PATT_TAB4_Msk = 0xffffffff

	// SAR2_PATT_TAB1: item 0 ~ 3 for pattern table 2 (each item one byte)
	// Position of SAR2_PATT_TAB1 field.
	APB_SARADC_SAR2_PATT_TAB1_SAR2_PATT_TAB1_Pos = 0x0
	// Bit mask of SAR2_PATT_TAB1 field.
	APB_SARADC_SAR2_PATT_TAB1_SAR2_PATT_TAB1_Msk = 0xffffffff

	// SAR2_PATT_TAB2: Item 4 ~ 7 for pattern table 2 (each item one byte)
	// Position of SAR2_PATT_TAB2 field.
	APB_SARADC_SAR2_PATT_TAB2_SAR2_PATT_TAB2_Pos = 0x0
	// Bit mask of SAR2_PATT_TAB2 field.
	APB_SARADC_SAR2_PATT_TAB2_SAR2_PATT_TAB2_Msk = 0xffffffff

	// SAR2_PATT_TAB3: Item 8 ~ 11 for pattern table 2 (each item one byte)
	// Position of SAR2_PATT_TAB3 field.
	APB_SARADC_SAR2_PATT_TAB3_SAR2_PATT_TAB3_Pos = 0x0
	// Bit mask of SAR2_PATT_TAB3 field.
	APB_SARADC_SAR2_PATT_TAB3_SAR2_PATT_TAB3_Msk = 0xffffffff

	// SAR2_PATT_TAB4: Item 12 ~ 15 for pattern table 2 (each item one byte)
	// Position of SAR2_PATT_TAB4 field.
	APB_SARADC_SAR2_PATT_TAB4_SAR2_PATT_TAB4_Pos = 0x0
	// Bit mask of SAR2_PATT_TAB4 field.
	APB_SARADC_SAR2_PATT_TAB4_SAR2_PATT_TAB4_Msk = 0xffffffff

	// ARB_CTRL: Configure the settings of DIG ADC2 arbiter
	// Position of ADC_ARB_APB_FORCE field.
	APB_SARADC_ARB_CTRL_ADC_ARB_APB_FORCE_Pos = 0x2
	// Bit mask of ADC_ARB_APB_FORCE field.
	APB_SARADC_ARB_CTRL_ADC_ARB_APB_FORCE_Msk = 0x4
	// Bit ADC_ARB_APB_FORCE.
	APB_SARADC_ARB_CTRL_ADC_ARB_APB_FORCE = 0x4
	// Position of ADC_ARB_RTC_FORCE field.
	APB_SARADC_ARB_CTRL_ADC_ARB_RTC_FORCE_Pos = 0x3
	// Bit mask of ADC_ARB_RTC_FORCE field.
	APB_SARADC_ARB_CTRL_ADC_ARB_RTC_FORCE_Msk = 0x8
	// Bit ADC_ARB_RTC_FORCE.
	APB_SARADC_ARB_CTRL_ADC_ARB_RTC_FORCE = 0x8
	// Position of ADC_ARB_WIFI_FORCE field.
	APB_SARADC_ARB_CTRL_ADC_ARB_WIFI_FORCE_Pos = 0x4
	// Bit mask of ADC_ARB_WIFI_FORCE field.
	APB_SARADC_ARB_CTRL_ADC_ARB_WIFI_FORCE_Msk = 0x10
	// Bit ADC_ARB_WIFI_FORCE.
	APB_SARADC_ARB_CTRL_ADC_ARB_WIFI_FORCE = 0x10
	// Position of ADC_ARB_GRANT_FORCE field.
	APB_SARADC_ARB_CTRL_ADC_ARB_GRANT_FORCE_Pos = 0x5
	// Bit mask of ADC_ARB_GRANT_FORCE field.
	APB_SARADC_ARB_CTRL_ADC_ARB_GRANT_FORCE_Msk = 0x20
	// Bit ADC_ARB_GRANT_FORCE.
	APB_SARADC_ARB_CTRL_ADC_ARB_GRANT_FORCE = 0x20
	// Position of ADC_ARB_APB_PRIORITY field.
	APB_SARADC_ARB_CTRL_ADC_ARB_APB_PRIORITY_Pos = 0x6
	// Bit mask of ADC_ARB_APB_PRIORITY field.
	APB_SARADC_ARB_CTRL_ADC_ARB_APB_PRIORITY_Msk = 0xc0
	// Position of ADC_ARB_RTC_PRIORITY field.
	APB_SARADC_ARB_CTRL_ADC_ARB_RTC_PRIORITY_Pos = 0x8
	// Bit mask of ADC_ARB_RTC_PRIORITY field.
	APB_SARADC_ARB_CTRL_ADC_ARB_RTC_PRIORITY_Msk = 0x300
	// Position of ADC_ARB_WIFI_PRIORITY field.
	APB_SARADC_ARB_CTRL_ADC_ARB_WIFI_PRIORITY_Pos = 0xa
	// Bit mask of ADC_ARB_WIFI_PRIORITY field.
	APB_SARADC_ARB_CTRL_ADC_ARB_WIFI_PRIORITY_Msk = 0xc00
	// Position of ADC_ARB_FIX_PRIORITY field.
	APB_SARADC_ARB_CTRL_ADC_ARB_FIX_PRIORITY_Pos = 0xc
	// Bit mask of ADC_ARB_FIX_PRIORITY field.
	APB_SARADC_ARB_CTRL_ADC_ARB_FIX_PRIORITY_Msk = 0x1000
	// Bit ADC_ARB_FIX_PRIORITY.
	APB_SARADC_ARB_CTRL_ADC_ARB_FIX_PRIORITY = 0x1000

	// FILTER_CTRL: Configure the settings of DIG ADC2 filter
	// Position of ADC2_FILTER_RESET field.
	APB_SARADC_FILTER_CTRL_ADC2_FILTER_RESET_Pos = 0x0
	// Bit mask of ADC2_FILTER_RESET field.
	APB_SARADC_FILTER_CTRL_ADC2_FILTER_RESET_Msk = 0x1
	// Bit ADC2_FILTER_RESET.
	APB_SARADC_FILTER_CTRL_ADC2_FILTER_RESET = 0x1
	// Position of ADC1_FILTER_RESET field.
	APB_SARADC_FILTER_CTRL_ADC1_FILTER_RESET_Pos = 0x1
	// Bit mask of ADC1_FILTER_RESET field.
	APB_SARADC_FILTER_CTRL_ADC1_FILTER_RESET_Msk = 0x2
	// Bit ADC1_FILTER_RESET.
	APB_SARADC_FILTER_CTRL_ADC1_FILTER_RESET = 0x2
	// Position of ADC2_FILTER_FACTOR field.
	APB_SARADC_FILTER_CTRL_ADC2_FILTER_FACTOR_Pos = 0x10
	// Bit mask of ADC2_FILTER_FACTOR field.
	APB_SARADC_FILTER_CTRL_ADC2_FILTER_FACTOR_Msk = 0x7f0000
	// Position of ADC1_FILTER_FACTOR field.
	APB_SARADC_FILTER_CTRL_ADC1_FILTER_FACTOR_Pos = 0x17
	// Bit mask of ADC1_FILTER_FACTOR field.
	APB_SARADC_FILTER_CTRL_ADC1_FILTER_FACTOR_Msk = 0x3f800000
	// Position of ADC2_FILTER_EN field.
	APB_SARADC_FILTER_CTRL_ADC2_FILTER_EN_Pos = 0x1e
	// Bit mask of ADC2_FILTER_EN field.
	APB_SARADC_FILTER_CTRL_ADC2_FILTER_EN_Msk = 0x40000000
	// Bit ADC2_FILTER_EN.
	APB_SARADC_FILTER_CTRL_ADC2_FILTER_EN = 0x40000000
	// Position of ADC1_FILTER_EN field.
	APB_SARADC_FILTER_CTRL_ADC1_FILTER_EN_Pos = 0x1f
	// Bit mask of ADC1_FILTER_EN field.
	APB_SARADC_FILTER_CTRL_ADC1_FILTER_EN_Msk = 0x80000000
	// Bit ADC1_FILTER_EN.
	APB_SARADC_FILTER_CTRL_ADC1_FILTER_EN = 0x80000000

	// FILTER_STATUS: Data status of DIG ADC2 filter
	// Position of ADC2_FILTER_DATA field.
	APB_SARADC_FILTER_STATUS_ADC2_FILTER_DATA_Pos = 0x0
	// Bit mask of ADC2_FILTER_DATA field.
	APB_SARADC_FILTER_STATUS_ADC2_FILTER_DATA_Msk = 0xffff
	// Position of ADC1_FILTER_DATA field.
	APB_SARADC_FILTER_STATUS_ADC1_FILTER_DATA_Pos = 0x10
	// Bit mask of ADC1_FILTER_DATA field.
	APB_SARADC_FILTER_STATUS_ADC1_FILTER_DATA_Msk = 0xffff0000

	// THRES_CTRL: Configure monitor threshold for DIG ADC2
	// Position of CLK_EN field.
	APB_SARADC_THRES_CTRL_CLK_EN_Pos = 0x0
	// Bit mask of CLK_EN field.
	APB_SARADC_THRES_CTRL_CLK_EN_Msk = 0x1
	// Bit CLK_EN.
	APB_SARADC_THRES_CTRL_CLK_EN = 0x1
	// Position of ADC2_THRES_MODE field.
	APB_SARADC_THRES_CTRL_ADC2_THRES_MODE_Pos = 0x2
	// Bit mask of ADC2_THRES_MODE field.
	APB_SARADC_THRES_CTRL_ADC2_THRES_MODE_Msk = 0x4
	// Bit ADC2_THRES_MODE.
	APB_SARADC_THRES_CTRL_ADC2_THRES_MODE = 0x4
	// Position of ADC1_THRES_MODE field.
	APB_SARADC_THRES_CTRL_ADC1_THRES_MODE_Pos = 0x3
	// Bit mask of ADC1_THRES_MODE field.
	APB_SARADC_THRES_CTRL_ADC1_THRES_MODE_Msk = 0x8
	// Bit ADC1_THRES_MODE.
	APB_SARADC_THRES_CTRL_ADC1_THRES_MODE = 0x8
	// Position of ADC2_THRES field.
	APB_SARADC_THRES_CTRL_ADC2_THRES_Pos = 0x4
	// Bit mask of ADC2_THRES field.
	APB_SARADC_THRES_CTRL_ADC2_THRES_Msk = 0x1fff0
	// Position of ADC1_THRES field.
	APB_SARADC_THRES_CTRL_ADC1_THRES_Pos = 0x11
	// Bit mask of ADC1_THRES field.
	APB_SARADC_THRES_CTRL_ADC1_THRES_Msk = 0x3ffe0000
	// Position of ADC2_THRES_EN field.
	APB_SARADC_THRES_CTRL_ADC2_THRES_EN_Pos = 0x1e
	// Bit mask of ADC2_THRES_EN field.
	APB_SARADC_THRES_CTRL_ADC2_THRES_EN_Msk = 0x40000000
	// Bit ADC2_THRES_EN.
	APB_SARADC_THRES_CTRL_ADC2_THRES_EN = 0x40000000
	// Position of ADC1_THRES_EN field.
	APB_SARADC_THRES_CTRL_ADC1_THRES_EN_Pos = 0x1f
	// Bit mask of ADC1_THRES_EN field.
	APB_SARADC_THRES_CTRL_ADC1_THRES_EN_Msk = 0x80000000
	// Bit ADC1_THRES_EN.
	APB_SARADC_THRES_CTRL_ADC1_THRES_EN = 0x80000000

	// INT_ENA: Enable DIG ADC interrupts
	// Position of ADC2_THRES_INT_ENA field.
	APB_SARADC_INT_ENA_ADC2_THRES_INT_ENA_Pos = 0x1c
	// Bit mask of ADC2_THRES_INT_ENA field.
	APB_SARADC_INT_ENA_ADC2_THRES_INT_ENA_Msk = 0x10000000
	// Bit ADC2_THRES_INT_ENA.
	APB_SARADC_INT_ENA_ADC2_THRES_INT_ENA = 0x10000000
	// Position of ADC1_THRES_INT_ENA field.
	APB_SARADC_INT_ENA_ADC1_THRES_INT_ENA_Pos = 0x1d
	// Bit mask of ADC1_THRES_INT_ENA field.
	APB_SARADC_INT_ENA_ADC1_THRES_INT_ENA_Msk = 0x20000000
	// Bit ADC1_THRES_INT_ENA.
	APB_SARADC_INT_ENA_ADC1_THRES_INT_ENA = 0x20000000
	// Position of ADC2_DONE_INT_ENA field.
	APB_SARADC_INT_ENA_ADC2_DONE_INT_ENA_Pos = 0x1e
	// Bit mask of ADC2_DONE_INT_ENA field.
	APB_SARADC_INT_ENA_ADC2_DONE_INT_ENA_Msk = 0x40000000
	// Bit ADC2_DONE_INT_ENA.
	APB_SARADC_INT_ENA_ADC2_DONE_INT_ENA = 0x40000000
	// Position of ADC1_DONE_INT_ENA field.
	APB_SARADC_INT_ENA_ADC1_DONE_INT_ENA_Pos = 0x1f
	// Bit mask of ADC1_DONE_INT_ENA field.
	APB_SARADC_INT_ENA_ADC1_DONE_INT_ENA_Msk = 0x80000000
	// Bit ADC1_DONE_INT_ENA.
	APB_SARADC_INT_ENA_ADC1_DONE_INT_ENA = 0x80000000

	// INT_RAW: DIG ADC interrupt raw bits
	// Position of ADC2_THRES_INT_RAW field.
	APB_SARADC_INT_RAW_ADC2_THRES_INT_RAW_Pos = 0x1c
	// Bit mask of ADC2_THRES_INT_RAW field.
	APB_SARADC_INT_RAW_ADC2_THRES_INT_RAW_Msk = 0x10000000
	// Bit ADC2_THRES_INT_RAW.
	APB_SARADC_INT_RAW_ADC2_THRES_INT_RAW = 0x10000000
	// Position of ADC1_THRES_INT_RAW field.
	APB_SARADC_INT_RAW_ADC1_THRES_INT_RAW_Pos = 0x1d
	// Bit mask of ADC1_THRES_INT_RAW field.
	APB_SARADC_INT_RAW_ADC1_THRES_INT_RAW_Msk = 0x20000000
	// Bit ADC1_THRES_INT_RAW.
	APB_SARADC_INT_RAW_ADC1_THRES_INT_RAW = 0x20000000
	// Position of ADC2_DONE_INT_RAW field.
	APB_SARADC_INT_RAW_ADC2_DONE_INT_RAW_Pos = 0x1e
	// Bit mask of ADC2_DONE_INT_RAW field.
	APB_SARADC_INT_RAW_ADC2_DONE_INT_RAW_Msk = 0x40000000
	// Bit ADC2_DONE_INT_RAW.
	APB_SARADC_INT_RAW_ADC2_DONE_INT_RAW = 0x40000000
	// Position of ADC1_DONE_INT_RAW field.
	APB_SARADC_INT_RAW_ADC1_DONE_INT_RAW_Pos = 0x1f
	// Bit mask of ADC1_DONE_INT_RAW field.
	APB_SARADC_INT_RAW_ADC1_DONE_INT_RAW_Msk = 0x80000000
	// Bit ADC1_DONE_INT_RAW.
	APB_SARADC_INT_RAW_ADC1_DONE_INT_RAW = 0x80000000

	// INT_ST: DIG ADC interrupt status
	// Position of ADC2_THRES_INT_ST field.
	APB_SARADC_INT_ST_ADC2_THRES_INT_ST_Pos = 0x1c
	// Bit mask of ADC2_THRES_INT_ST field.
	APB_SARADC_INT_ST_ADC2_THRES_INT_ST_Msk = 0x10000000
	// Bit ADC2_THRES_INT_ST.
	APB_SARADC_INT_ST_ADC2_THRES_INT_ST = 0x10000000
	// Position of ADC1_THRES_INT_ST field.
	APB_SARADC_INT_ST_ADC1_THRES_INT_ST_Pos = 0x1d
	// Bit mask of ADC1_THRES_INT_ST field.
	APB_SARADC_INT_ST_ADC1_THRES_INT_ST_Msk = 0x20000000
	// Bit ADC1_THRES_INT_ST.
	APB_SARADC_INT_ST_ADC1_THRES_INT_ST = 0x20000000
	// Position of ADC2_DONE_INT_ST field.
	APB_SARADC_INT_ST_ADC2_DONE_INT_ST_Pos = 0x1e
	// Bit mask of ADC2_DONE_INT_ST field.
	APB_SARADC_INT_ST_ADC2_DONE_INT_ST_Msk = 0x40000000
	// Bit ADC2_DONE_INT_ST.
	APB_SARADC_INT_ST_ADC2_DONE_INT_ST = 0x40000000
	// Position of ADC1_DONE_INT_ST field.
	APB_SARADC_INT_ST_ADC1_DONE_INT_ST_Pos = 0x1f
	// Bit mask of ADC1_DONE_INT_ST field.
	APB_SARADC_INT_ST_ADC1_DONE_INT_ST_Msk = 0x80000000
	// Bit ADC1_DONE_INT_ST.
	APB_SARADC_INT_ST_ADC1_DONE_INT_ST = 0x80000000

	// INT_CLR: Clear DIG ADC interrupts
	// Position of ADC2_THRES_INT_CLR field.
	APB_SARADC_INT_CLR_ADC2_THRES_INT_CLR_Pos = 0x1c
	// Bit mask of ADC2_THRES_INT_CLR field.
	APB_SARADC_INT_CLR_ADC2_THRES_INT_CLR_Msk = 0x10000000
	// Bit ADC2_THRES_INT_CLR.
	APB_SARADC_INT_CLR_ADC2_THRES_INT_CLR = 0x10000000
	// Position of ADC1_THRES_INT_CLR field.
	APB_SARADC_INT_CLR_ADC1_THRES_INT_CLR_Pos = 0x1d
	// Bit mask of ADC1_THRES_INT_CLR field.
	APB_SARADC_INT_CLR_ADC1_THRES_INT_CLR_Msk = 0x20000000
	// Bit ADC1_THRES_INT_CLR.
	APB_SARADC_INT_CLR_ADC1_THRES_INT_CLR = 0x20000000
	// Position of ADC2_DONE_INT_CLR field.
	APB_SARADC_INT_CLR_ADC2_DONE_INT_CLR_Pos = 0x1e
	// Bit mask of ADC2_DONE_INT_CLR field.
	APB_SARADC_INT_CLR_ADC2_DONE_INT_CLR_Msk = 0x40000000
	// Bit ADC2_DONE_INT_CLR.
	APB_SARADC_INT_CLR_ADC2_DONE_INT_CLR = 0x40000000
	// Position of ADC1_DONE_INT_CLR field.
	APB_SARADC_INT_CLR_ADC1_DONE_INT_CLR_Pos = 0x1f
	// Bit mask of ADC1_DONE_INT_CLR field.
	APB_SARADC_INT_CLR_ADC1_DONE_INT_CLR_Msk = 0x80000000
	// Bit ADC1_DONE_INT_CLR.
	APB_SARADC_INT_CLR_ADC1_DONE_INT_CLR = 0x80000000

	// DMA_CONF: Configure digital ADC DMA path
	// Position of APB_ADC_EOF_NUM field.
	APB_SARADC_DMA_CONF_APB_ADC_EOF_NUM_Pos = 0x0
	// Bit mask of APB_ADC_EOF_NUM field.
	APB_SARADC_DMA_CONF_APB_ADC_EOF_NUM_Msk = 0xffff
	// Position of APB_ADC_RESET_FSM field.
	APB_SARADC_DMA_CONF_APB_ADC_RESET_FSM_Pos = 0x1e
	// Bit mask of APB_ADC_RESET_FSM field.
	APB_SARADC_DMA_CONF_APB_ADC_RESET_FSM_Msk = 0x40000000
	// Bit APB_ADC_RESET_FSM.
	APB_SARADC_DMA_CONF_APB_ADC_RESET_FSM = 0x40000000
	// Position of APB_ADC_TRANS field.
	APB_SARADC_DMA_CONF_APB_ADC_TRANS_Pos = 0x1f
	// Bit mask of APB_ADC_TRANS field.
	APB_SARADC_DMA_CONF_APB_ADC_TRANS_Msk = 0x80000000
	// Bit APB_ADC_TRANS.
	APB_SARADC_DMA_CONF_APB_ADC_TRANS = 0x80000000

	// CLKM_CONF: Configure DIG ADC clock
	// Position of CLKM_DIV_NUM field.
	APB_SARADC_CLKM_CONF_CLKM_DIV_NUM_Pos = 0x0
	// Bit mask of CLKM_DIV_NUM field.
	APB_SARADC_CLKM_CONF_CLKM_DIV_NUM_Msk = 0xff
	// Position of CLKM_DIV_B field.
	APB_SARADC_CLKM_CONF_CLKM_DIV_B_Pos = 0x8
	// Bit mask of CLKM_DIV_B field.
	APB_SARADC_CLKM_CONF_CLKM_DIV_B_Msk = 0x3f00
	// Position of CLKM_DIV_A field.
	APB_SARADC_CLKM_CONF_CLKM_DIV_A_Pos = 0xe
	// Bit mask of CLKM_DIV_A field.
	APB_SARADC_CLKM_CONF_CLKM_DIV_A_Msk = 0xfc000
	// Position of CLK_SEL field.
	APB_SARADC_CLKM_CONF_CLK_SEL_Pos = 0x15
	// Bit mask of CLK_SEL field.
	APB_SARADC_CLKM_CONF_CLK_SEL_Msk = 0x600000

	// APB_DAC_CTRL: Configure DAC settings
	// Position of DAC_TIMER_TARGET field.
	APB_SARADC_APB_DAC_CTRL_DAC_TIMER_TARGET_Pos = 0x0
	// Bit mask of DAC_TIMER_TARGET field.
	APB_SARADC_APB_DAC_CTRL_DAC_TIMER_TARGET_Msk = 0xfff
	// Position of DAC_TIMER_EN field.
	APB_SARADC_APB_DAC_CTRL_DAC_TIMER_EN_Pos = 0xc
	// Bit mask of DAC_TIMER_EN field.
	APB_SARADC_APB_DAC_CTRL_DAC_TIMER_EN_Msk = 0x1000
	// Bit DAC_TIMER_EN.
	APB_SARADC_APB_DAC_CTRL_DAC_TIMER_EN = 0x1000
	// Position of APB_DAC_ALTER_MODE field.
	APB_SARADC_APB_DAC_CTRL_APB_DAC_ALTER_MODE_Pos = 0xd
	// Bit mask of APB_DAC_ALTER_MODE field.
	APB_SARADC_APB_DAC_CTRL_APB_DAC_ALTER_MODE_Msk = 0x2000
	// Bit APB_DAC_ALTER_MODE.
	APB_SARADC_APB_DAC_CTRL_APB_DAC_ALTER_MODE = 0x2000
	// Position of APB_DAC_TRANS field.
	APB_SARADC_APB_DAC_CTRL_APB_DAC_TRANS_Pos = 0xe
	// Bit mask of APB_DAC_TRANS field.
	APB_SARADC_APB_DAC_CTRL_APB_DAC_TRANS_Msk = 0x4000
	// Bit APB_DAC_TRANS.
	APB_SARADC_APB_DAC_CTRL_APB_DAC_TRANS = 0x4000
	// Position of DAC_RESET_FIFO field.
	APB_SARADC_APB_DAC_CTRL_DAC_RESET_FIFO_Pos = 0xf
	// Bit mask of DAC_RESET_FIFO field.
	APB_SARADC_APB_DAC_CTRL_DAC_RESET_FIFO_Msk = 0x8000
	// Bit DAC_RESET_FIFO.
	APB_SARADC_APB_DAC_CTRL_DAC_RESET_FIFO = 0x8000
	// Position of APB_DAC_RST field.
	APB_SARADC_APB_DAC_CTRL_APB_DAC_RST_Pos = 0x10
	// Bit mask of APB_DAC_RST field.
	APB_SARADC_APB_DAC_CTRL_APB_DAC_RST_Msk = 0x10000
	// Bit APB_DAC_RST.
	APB_SARADC_APB_DAC_CTRL_APB_DAC_RST = 0x10000

	// APB_CTRL_DATE: Version control register
	// Position of APB_CTRL_DATE field.
	APB_SARADC_APB_CTRL_DATE_APB_CTRL_DATE_Pos = 0x0
	// Bit mask of APB_CTRL_DATE field.
	APB_SARADC_APB_CTRL_DATE_APB_CTRL_DATE_Msk = 0xffffffff
)

// Constants for DEDICATED_GPIO: Peripheral DEDICATED_GPIO
const (
	// OUT_DRT: Dedicated GPIO Directive Output register
	// Position of VLAUE field.
	DEDICATED_GPIO_OUT_DRT_VLAUE_Pos = 0x0
	// Bit mask of VLAUE field.
	DEDICATED_GPIO_OUT_DRT_VLAUE_Msk = 0xff

	// OUT_MSK: Dedicated GPIO Mask Output register
	// Position of OUT_VALUE field.
	DEDICATED_GPIO_OUT_MSK_OUT_VALUE_Pos = 0x0
	// Bit mask of OUT_VALUE field.
	DEDICATED_GPIO_OUT_MSK_OUT_VALUE_Msk = 0xff
	// Position of OUT_MSK field.
	DEDICATED_GPIO_OUT_MSK_OUT_MSK_Pos = 0x8
	// Bit mask of OUT_MSK field.
	DEDICATED_GPIO_OUT_MSK_OUT_MSK_Msk = 0xff00

	// OUT_IDV: Dedicated GPIO Individual Output register
	// Position of CH0 field.
	DEDICATED_GPIO_OUT_IDV_CH0_Pos = 0x0
	// Bit mask of CH0 field.
	DEDICATED_GPIO_OUT_IDV_CH0_Msk = 0x3
	// Position of CH1 field.
	DEDICATED_GPIO_OUT_IDV_CH1_Pos = 0x2
	// Bit mask of CH1 field.
	DEDICATED_GPIO_OUT_IDV_CH1_Msk = 0xc
	// Position of CH2 field.
	DEDICATED_GPIO_OUT_IDV_CH2_Pos = 0x4
	// Bit mask of CH2 field.
	DEDICATED_GPIO_OUT_IDV_CH2_Msk = 0x30
	// Position of CH3 field.
	DEDICATED_GPIO_OUT_IDV_CH3_Pos = 0x6
	// Bit mask of CH3 field.
	DEDICATED_GPIO_OUT_IDV_CH3_Msk = 0xc0
	// Position of CH4 field.
	DEDICATED_GPIO_OUT_IDV_CH4_Pos = 0x8
	// Bit mask of CH4 field.
	DEDICATED_GPIO_OUT_IDV_CH4_Msk = 0x300
	// Position of CH5 field.
	DEDICATED_GPIO_OUT_IDV_CH5_Pos = 0xa
	// Bit mask of CH5 field.
	DEDICATED_GPIO_OUT_IDV_CH5_Msk = 0xc00
	// Position of CH6 field.
	DEDICATED_GPIO_OUT_IDV_CH6_Pos = 0xc
	// Bit mask of CH6 field.
	DEDICATED_GPIO_OUT_IDV_CH6_Msk = 0x3000
	// Position of CH7 field.
	DEDICATED_GPIO_OUT_IDV_CH7_Pos = 0xe
	// Bit mask of CH7 field.
	DEDICATED_GPIO_OUT_IDV_CH7_Msk = 0xc000

	// OUT_SCAN: Dedicated GPIO Output Status register
	// Position of OUT_STATUS field.
	DEDICATED_GPIO_OUT_SCAN_OUT_STATUS_Pos = 0x0
	// Bit mask of OUT_STATUS field.
	DEDICATED_GPIO_OUT_SCAN_OUT_STATUS_Msk = 0xff

	// OUT_CPU: Dedicated GPIO Output Mode Select register
	// Position of SEL0 field.
	DEDICATED_GPIO_OUT_CPU_SEL0_Pos = 0x0
	// Bit mask of SEL0 field.
	DEDICATED_GPIO_OUT_CPU_SEL0_Msk = 0x1
	// Bit SEL0.
	DEDICATED_GPIO_OUT_CPU_SEL0 = 0x1
	// Position of SEL1 field.
	DEDICATED_GPIO_OUT_CPU_SEL1_Pos = 0x1
	// Bit mask of SEL1 field.
	DEDICATED_GPIO_OUT_CPU_SEL1_Msk = 0x2
	// Bit SEL1.
	DEDICATED_GPIO_OUT_CPU_SEL1 = 0x2
	// Position of SEL2 field.
	DEDICATED_GPIO_OUT_CPU_SEL2_Pos = 0x2
	// Bit mask of SEL2 field.
	DEDICATED_GPIO_OUT_CPU_SEL2_Msk = 0x4
	// Bit SEL2.
	DEDICATED_GPIO_OUT_CPU_SEL2 = 0x4
	// Position of SEL3 field.
	DEDICATED_GPIO_OUT_CPU_SEL3_Pos = 0x3
	// Bit mask of SEL3 field.
	DEDICATED_GPIO_OUT_CPU_SEL3_Msk = 0x8
	// Bit SEL3.
	DEDICATED_GPIO_OUT_CPU_SEL3 = 0x8
	// Position of SEL4 field.
	DEDICATED_GPIO_OUT_CPU_SEL4_Pos = 0x4
	// Bit mask of SEL4 field.
	DEDICATED_GPIO_OUT_CPU_SEL4_Msk = 0x10
	// Bit SEL4.
	DEDICATED_GPIO_OUT_CPU_SEL4 = 0x10
	// Position of SEL5 field.
	DEDICATED_GPIO_OUT_CPU_SEL5_Pos = 0x5
	// Bit mask of SEL5 field.
	DEDICATED_GPIO_OUT_CPU_SEL5_Msk = 0x20
	// Bit SEL5.
	DEDICATED_GPIO_OUT_CPU_SEL5 = 0x20
	// Position of SEL6 field.
	DEDICATED_GPIO_OUT_CPU_SEL6_Pos = 0x6
	// Bit mask of SEL6 field.
	DEDICATED_GPIO_OUT_CPU_SEL6_Msk = 0x40
	// Bit SEL6.
	DEDICATED_GPIO_OUT_CPU_SEL6 = 0x40
	// Position of SEL7 field.
	DEDICATED_GPIO_OUT_CPU_SEL7_Pos = 0x7
	// Bit mask of SEL7 field.
	DEDICATED_GPIO_OUT_CPU_SEL7_Msk = 0x80
	// Bit SEL7.
	DEDICATED_GPIO_OUT_CPU_SEL7 = 0x80

	// IN_DLY: Dedicated GPIO Input Delay Configuration register
	// Position of CH0 field.
	DEDICATED_GPIO_IN_DLY_CH0_Pos = 0x0
	// Bit mask of CH0 field.
	DEDICATED_GPIO_IN_DLY_CH0_Msk = 0x3
	// Position of CH1 field.
	DEDICATED_GPIO_IN_DLY_CH1_Pos = 0x2
	// Bit mask of CH1 field.
	DEDICATED_GPIO_IN_DLY_CH1_Msk = 0xc
	// Position of CH2 field.
	DEDICATED_GPIO_IN_DLY_CH2_Pos = 0x4
	// Bit mask of CH2 field.
	DEDICATED_GPIO_IN_DLY_CH2_Msk = 0x30
	// Position of CH3 field.
	DEDICATED_GPIO_IN_DLY_CH3_Pos = 0x6
	// Bit mask of CH3 field.
	DEDICATED_GPIO_IN_DLY_CH3_Msk = 0xc0
	// Position of CH4 field.
	DEDICATED_GPIO_IN_DLY_CH4_Pos = 0x8
	// Bit mask of CH4 field.
	DEDICATED_GPIO_IN_DLY_CH4_Msk = 0x300
	// Position of CH5 field.
	DEDICATED_GPIO_IN_DLY_CH5_Pos = 0xa
	// Bit mask of CH5 field.
	DEDICATED_GPIO_IN_DLY_CH5_Msk = 0xc00
	// Position of CH6 field.
	DEDICATED_GPIO_IN_DLY_CH6_Pos = 0xc
	// Bit mask of CH6 field.
	DEDICATED_GPIO_IN_DLY_CH6_Msk = 0x3000
	// Position of CH7 field.
	DEDICATED_GPIO_IN_DLY_CH7_Pos = 0xe
	// Bit mask of CH7 field.
	DEDICATED_GPIO_IN_DLY_CH7_Msk = 0xc000

	// IN_SCAN: Dedicated GPIO Input Status register
	// Position of IN_STATUS field.
	DEDICATED_GPIO_IN_SCAN_IN_STATUS_Pos = 0x0
	// Bit mask of IN_STATUS field.
	DEDICATED_GPIO_IN_SCAN_IN_STATUS_Msk = 0xff

	// INTR_RCGN: Dedicated GPIO Interrupts Generate Mode register
	// Position of INTR_MODE_CH0 field.
	DEDICATED_GPIO_INTR_RCGN_INTR_MODE_CH0_Pos = 0x0
	// Bit mask of INTR_MODE_CH0 field.
	DEDICATED_GPIO_INTR_RCGN_INTR_MODE_CH0_Msk = 0x7
	// Position of INTR_MODE_CH1 field.
	DEDICATED_GPIO_INTR_RCGN_INTR_MODE_CH1_Pos = 0x3
	// Bit mask of INTR_MODE_CH1 field.
	DEDICATED_GPIO_INTR_RCGN_INTR_MODE_CH1_Msk = 0x38
	// Position of INTR_MODE_CH2 field.
	DEDICATED_GPIO_INTR_RCGN_INTR_MODE_CH2_Pos = 0x6
	// Bit mask of INTR_MODE_CH2 field.
	DEDICATED_GPIO_INTR_RCGN_INTR_MODE_CH2_Msk = 0x1c0
	// Position of INTR_MODE_CH3 field.
	DEDICATED_GPIO_INTR_RCGN_INTR_MODE_CH3_Pos = 0x9
	// Bit mask of INTR_MODE_CH3 field.
	DEDICATED_GPIO_INTR_RCGN_INTR_MODE_CH3_Msk = 0xe00
	// Position of INTR_MODE_CH4 field.
	DEDICATED_GPIO_INTR_RCGN_INTR_MODE_CH4_Pos = 0xc
	// Bit mask of INTR_MODE_CH4 field.
	DEDICATED_GPIO_INTR_RCGN_INTR_MODE_CH4_Msk = 0x7000
	// Position of INTR_MODE_CH5 field.
	DEDICATED_GPIO_INTR_RCGN_INTR_MODE_CH5_Pos = 0xf
	// Bit mask of INTR_MODE_CH5 field.
	DEDICATED_GPIO_INTR_RCGN_INTR_MODE_CH5_Msk = 0x38000
	// Position of INTR_MODE_CH6 field.
	DEDICATED_GPIO_INTR_RCGN_INTR_MODE_CH6_Pos = 0x12
	// Bit mask of INTR_MODE_CH6 field.
	DEDICATED_GPIO_INTR_RCGN_INTR_MODE_CH6_Msk = 0x1c0000
	// Position of INTR_MODE_CH7 field.
	DEDICATED_GPIO_INTR_RCGN_INTR_MODE_CH7_Pos = 0x15
	// Bit mask of INTR_MODE_CH7 field.
	DEDICATED_GPIO_INTR_RCGN_INTR_MODE_CH7_Msk = 0xe00000

	// INTR_RAW: Raw interrupt status
	// Position of GPIO0 field.
	DEDICATED_GPIO_INTR_RAW_GPIO0_Pos = 0x0
	// Bit mask of GPIO0 field.
	DEDICATED_GPIO_INTR_RAW_GPIO0_Msk = 0x1
	// Bit GPIO0.
	DEDICATED_GPIO_INTR_RAW_GPIO0 = 0x1
	// Position of GPIO1 field.
	DEDICATED_GPIO_INTR_RAW_GPIO1_Pos = 0x1
	// Bit mask of GPIO1 field.
	DEDICATED_GPIO_INTR_RAW_GPIO1_Msk = 0x2
	// Bit GPIO1.
	DEDICATED_GPIO_INTR_RAW_GPIO1 = 0x2
	// Position of GPIO2 field.
	DEDICATED_GPIO_INTR_RAW_GPIO2_Pos = 0x2
	// Bit mask of GPIO2 field.
	DEDICATED_GPIO_INTR_RAW_GPIO2_Msk = 0x4
	// Bit GPIO2.
	DEDICATED_GPIO_INTR_RAW_GPIO2 = 0x4
	// Position of GPIO3 field.
	DEDICATED_GPIO_INTR_RAW_GPIO3_Pos = 0x3
	// Bit mask of GPIO3 field.
	DEDICATED_GPIO_INTR_RAW_GPIO3_Msk = 0x8
	// Bit GPIO3.
	DEDICATED_GPIO_INTR_RAW_GPIO3 = 0x8
	// Position of GPIO4 field.
	DEDICATED_GPIO_INTR_RAW_GPIO4_Pos = 0x4
	// Bit mask of GPIO4 field.
	DEDICATED_GPIO_INTR_RAW_GPIO4_Msk = 0x10
	// Bit GPIO4.
	DEDICATED_GPIO_INTR_RAW_GPIO4 = 0x10
	// Position of GPIO5 field.
	DEDICATED_GPIO_INTR_RAW_GPIO5_Pos = 0x5
	// Bit mask of GPIO5 field.
	DEDICATED_GPIO_INTR_RAW_GPIO5_Msk = 0x20
	// Bit GPIO5.
	DEDICATED_GPIO_INTR_RAW_GPIO5 = 0x20
	// Position of GPIO6 field.
	DEDICATED_GPIO_INTR_RAW_GPIO6_Pos = 0x6
	// Bit mask of GPIO6 field.
	DEDICATED_GPIO_INTR_RAW_GPIO6_Msk = 0x40
	// Bit GPIO6.
	DEDICATED_GPIO_INTR_RAW_GPIO6 = 0x40
	// Position of GPIO7 field.
	DEDICATED_GPIO_INTR_RAW_GPIO7_Pos = 0x7
	// Bit mask of GPIO7 field.
	DEDICATED_GPIO_INTR_RAW_GPIO7_Msk = 0x80
	// Bit GPIO7.
	DEDICATED_GPIO_INTR_RAW_GPIO7 = 0x80

	// INTR_RLS: Interrupt enable bits
	// Position of GPIO0_INT_ENA field.
	DEDICATED_GPIO_INTR_RLS_GPIO0_INT_ENA_Pos = 0x0
	// Bit mask of GPIO0_INT_ENA field.
	DEDICATED_GPIO_INTR_RLS_GPIO0_INT_ENA_Msk = 0x1
	// Bit GPIO0_INT_ENA.
	DEDICATED_GPIO_INTR_RLS_GPIO0_INT_ENA = 0x1
	// Position of GPIO1_INT_ENA field.
	DEDICATED_GPIO_INTR_RLS_GPIO1_INT_ENA_Pos = 0x1
	// Bit mask of GPIO1_INT_ENA field.
	DEDICATED_GPIO_INTR_RLS_GPIO1_INT_ENA_Msk = 0x2
	// Bit GPIO1_INT_ENA.
	DEDICATED_GPIO_INTR_RLS_GPIO1_INT_ENA = 0x2
	// Position of GPIO2_INT_ENA field.
	DEDICATED_GPIO_INTR_RLS_GPIO2_INT_ENA_Pos = 0x2
	// Bit mask of GPIO2_INT_ENA field.
	DEDICATED_GPIO_INTR_RLS_GPIO2_INT_ENA_Msk = 0x4
	// Bit GPIO2_INT_ENA.
	DEDICATED_GPIO_INTR_RLS_GPIO2_INT_ENA = 0x4
	// Position of GPIO3_INT_ENA field.
	DEDICATED_GPIO_INTR_RLS_GPIO3_INT_ENA_Pos = 0x3
	// Bit mask of GPIO3_INT_ENA field.
	DEDICATED_GPIO_INTR_RLS_GPIO3_INT_ENA_Msk = 0x8
	// Bit GPIO3_INT_ENA.
	DEDICATED_GPIO_INTR_RLS_GPIO3_INT_ENA = 0x8
	// Position of GPIO4_INT_ENA field.
	DEDICATED_GPIO_INTR_RLS_GPIO4_INT_ENA_Pos = 0x4
	// Bit mask of GPIO4_INT_ENA field.
	DEDICATED_GPIO_INTR_RLS_GPIO4_INT_ENA_Msk = 0x10
	// Bit GPIO4_INT_ENA.
	DEDICATED_GPIO_INTR_RLS_GPIO4_INT_ENA = 0x10
	// Position of GPIO5_INT_ENA field.
	DEDICATED_GPIO_INTR_RLS_GPIO5_INT_ENA_Pos = 0x5
	// Bit mask of GPIO5_INT_ENA field.
	DEDICATED_GPIO_INTR_RLS_GPIO5_INT_ENA_Msk = 0x20
	// Bit GPIO5_INT_ENA.
	DEDICATED_GPIO_INTR_RLS_GPIO5_INT_ENA = 0x20
	// Position of GPIO6_INT_ENA field.
	DEDICATED_GPIO_INTR_RLS_GPIO6_INT_ENA_Pos = 0x6
	// Bit mask of GPIO6_INT_ENA field.
	DEDICATED_GPIO_INTR_RLS_GPIO6_INT_ENA_Msk = 0x40
	// Bit GPIO6_INT_ENA.
	DEDICATED_GPIO_INTR_RLS_GPIO6_INT_ENA = 0x40
	// Position of GPIO7_INT_ENA field.
	DEDICATED_GPIO_INTR_RLS_GPIO7_INT_ENA_Pos = 0x7
	// Bit mask of GPIO7_INT_ENA field.
	DEDICATED_GPIO_INTR_RLS_GPIO7_INT_ENA_Msk = 0x80
	// Bit GPIO7_INT_ENA.
	DEDICATED_GPIO_INTR_RLS_GPIO7_INT_ENA = 0x80

	// INTR_ST: Masked interrupt status
	// Position of GPIO0_INT_ST field.
	DEDICATED_GPIO_INTR_ST_GPIO0_INT_ST_Pos = 0x0
	// Bit mask of GPIO0_INT_ST field.
	DEDICATED_GPIO_INTR_ST_GPIO0_INT_ST_Msk = 0x1
	// Bit GPIO0_INT_ST.
	DEDICATED_GPIO_INTR_ST_GPIO0_INT_ST = 0x1
	// Position of GPIO1_INT_ST field.
	DEDICATED_GPIO_INTR_ST_GPIO1_INT_ST_Pos = 0x1
	// Bit mask of GPIO1_INT_ST field.
	DEDICATED_GPIO_INTR_ST_GPIO1_INT_ST_Msk = 0x2
	// Bit GPIO1_INT_ST.
	DEDICATED_GPIO_INTR_ST_GPIO1_INT_ST = 0x2
	// Position of GPIO2_INT_ST field.
	DEDICATED_GPIO_INTR_ST_GPIO2_INT_ST_Pos = 0x2
	// Bit mask of GPIO2_INT_ST field.
	DEDICATED_GPIO_INTR_ST_GPIO2_INT_ST_Msk = 0x4
	// Bit GPIO2_INT_ST.
	DEDICATED_GPIO_INTR_ST_GPIO2_INT_ST = 0x4
	// Position of GPIO3_INT_ST field.
	DEDICATED_GPIO_INTR_ST_GPIO3_INT_ST_Pos = 0x3
	// Bit mask of GPIO3_INT_ST field.
	DEDICATED_GPIO_INTR_ST_GPIO3_INT_ST_Msk = 0x8
	// Bit GPIO3_INT_ST.
	DEDICATED_GPIO_INTR_ST_GPIO3_INT_ST = 0x8
	// Position of GPIO4_INT_ST field.
	DEDICATED_GPIO_INTR_ST_GPIO4_INT_ST_Pos = 0x4
	// Bit mask of GPIO4_INT_ST field.
	DEDICATED_GPIO_INTR_ST_GPIO4_INT_ST_Msk = 0x10
	// Bit GPIO4_INT_ST.
	DEDICATED_GPIO_INTR_ST_GPIO4_INT_ST = 0x10
	// Position of GPIO5_INT_ST field.
	DEDICATED_GPIO_INTR_ST_GPIO5_INT_ST_Pos = 0x5
	// Bit mask of GPIO5_INT_ST field.
	DEDICATED_GPIO_INTR_ST_GPIO5_INT_ST_Msk = 0x20
	// Bit GPIO5_INT_ST.
	DEDICATED_GPIO_INTR_ST_GPIO5_INT_ST = 0x20
	// Position of GPIO6_INT_ST field.
	DEDICATED_GPIO_INTR_ST_GPIO6_INT_ST_Pos = 0x6
	// Bit mask of GPIO6_INT_ST field.
	DEDICATED_GPIO_INTR_ST_GPIO6_INT_ST_Msk = 0x40
	// Bit GPIO6_INT_ST.
	DEDICATED_GPIO_INTR_ST_GPIO6_INT_ST = 0x40
	// Position of GPIO7_INT_ST field.
	DEDICATED_GPIO_INTR_ST_GPIO7_INT_ST_Pos = 0x7
	// Bit mask of GPIO7_INT_ST field.
	DEDICATED_GPIO_INTR_ST_GPIO7_INT_ST_Msk = 0x80
	// Bit GPIO7_INT_ST.
	DEDICATED_GPIO_INTR_ST_GPIO7_INT_ST = 0x80

	// INTR_CLR: Interrupt clear bits
	// Position of GPIO0_INT_CLR field.
	DEDICATED_GPIO_INTR_CLR_GPIO0_INT_CLR_Pos = 0x0
	// Bit mask of GPIO0_INT_CLR field.
	DEDICATED_GPIO_INTR_CLR_GPIO0_INT_CLR_Msk = 0x1
	// Bit GPIO0_INT_CLR.
	DEDICATED_GPIO_INTR_CLR_GPIO0_INT_CLR = 0x1
	// Position of GPIO1_INT_CLR field.
	DEDICATED_GPIO_INTR_CLR_GPIO1_INT_CLR_Pos = 0x1
	// Bit mask of GPIO1_INT_CLR field.
	DEDICATED_GPIO_INTR_CLR_GPIO1_INT_CLR_Msk = 0x2
	// Bit GPIO1_INT_CLR.
	DEDICATED_GPIO_INTR_CLR_GPIO1_INT_CLR = 0x2
	// Position of GPIO2_INT_CLR field.
	DEDICATED_GPIO_INTR_CLR_GPIO2_INT_CLR_Pos = 0x2
	// Bit mask of GPIO2_INT_CLR field.
	DEDICATED_GPIO_INTR_CLR_GPIO2_INT_CLR_Msk = 0x4
	// Bit GPIO2_INT_CLR.
	DEDICATED_GPIO_INTR_CLR_GPIO2_INT_CLR = 0x4
	// Position of GPIO3_INT_CLR field.
	DEDICATED_GPIO_INTR_CLR_GPIO3_INT_CLR_Pos = 0x3
	// Bit mask of GPIO3_INT_CLR field.
	DEDICATED_GPIO_INTR_CLR_GPIO3_INT_CLR_Msk = 0x8
	// Bit GPIO3_INT_CLR.
	DEDICATED_GPIO_INTR_CLR_GPIO3_INT_CLR = 0x8
	// Position of GPIO4_INT_CLR field.
	DEDICATED_GPIO_INTR_CLR_GPIO4_INT_CLR_Pos = 0x4
	// Bit mask of GPIO4_INT_CLR field.
	DEDICATED_GPIO_INTR_CLR_GPIO4_INT_CLR_Msk = 0x10
	// Bit GPIO4_INT_CLR.
	DEDICATED_GPIO_INTR_CLR_GPIO4_INT_CLR = 0x10
	// Position of GPIO5_INT_CLR field.
	DEDICATED_GPIO_INTR_CLR_GPIO5_INT_CLR_Pos = 0x5
	// Bit mask of GPIO5_INT_CLR field.
	DEDICATED_GPIO_INTR_CLR_GPIO5_INT_CLR_Msk = 0x20
	// Bit GPIO5_INT_CLR.
	DEDICATED_GPIO_INTR_CLR_GPIO5_INT_CLR = 0x20
	// Position of GPIO6_INT_CLR field.
	DEDICATED_GPIO_INTR_CLR_GPIO6_INT_CLR_Pos = 0x6
	// Bit mask of GPIO6_INT_CLR field.
	DEDICATED_GPIO_INTR_CLR_GPIO6_INT_CLR_Msk = 0x40
	// Bit GPIO6_INT_CLR.
	DEDICATED_GPIO_INTR_CLR_GPIO6_INT_CLR = 0x40
	// Position of GPIO7_INT_CLR field.
	DEDICATED_GPIO_INTR_CLR_GPIO7_INT_CLR_Pos = 0x7
	// Bit mask of GPIO7_INT_CLR field.
	DEDICATED_GPIO_INTR_CLR_GPIO7_INT_CLR_Msk = 0x80
	// Bit GPIO7_INT_CLR.
	DEDICATED_GPIO_INTR_CLR_GPIO7_INT_CLR = 0x80
)

// Constants for DS: Peripheral DS
const (
	// IV_0: IV block data
	// Position of IV_0 field.
	DS_IV_IV_0_Pos = 0x0
	// Bit mask of IV_0 field.
	DS_IV_IV_0_Msk = 0xffffffff

	// SET_START: Activates the DS peripheral
	// Position of SET_START field.
	DS_SET_START_SET_START_Pos = 0x0
	// Bit mask of SET_START field.
	DS_SET_START_SET_START_Msk = 0x1
	// Bit SET_START.
	DS_SET_START_SET_START = 0x1

	// SET_ME: Starts DS operation
	// Position of SET_ME field.
	DS_SET_ME_SET_ME_Pos = 0x0
	// Bit mask of SET_ME field.
	DS_SET_ME_SET_ME_Msk = 0x1
	// Bit SET_ME.
	DS_SET_ME_SET_ME = 0x1

	// SET_FINISH: Ends DS operation
	// Position of SET_FINISH field.
	DS_SET_FINISH_SET_FINISH_Pos = 0x0
	// Bit mask of SET_FINISH field.
	DS_SET_FINISH_SET_FINISH_Msk = 0x1
	// Bit SET_FINISH.
	DS_SET_FINISH_SET_FINISH = 0x1

	// QUERY_BUSY: Status of the DS
	// Position of QUERY_BUSY field.
	DS_QUERY_BUSY_QUERY_BUSY_Pos = 0x0
	// Bit mask of QUERY_BUSY field.
	DS_QUERY_BUSY_QUERY_BUSY_Msk = 0x1
	// Bit QUERY_BUSY.
	DS_QUERY_BUSY_QUERY_BUSY = 0x1

	// QUERY_KEY_WRONG: Checks the reason why DS_KEY is not ready.
	// Position of QUERY_KEY_WRONG field.
	DS_QUERY_KEY_WRONG_QUERY_KEY_WRONG_Pos = 0x0
	// Bit mask of QUERY_KEY_WRONG field.
	DS_QUERY_KEY_WRONG_QUERY_KEY_WRONG_Msk = 0xf

	// QUERY_CHECK: Queries DS check result
	// Position of MD_ERROR field.
	DS_QUERY_CHECK_MD_ERROR_Pos = 0x0
	// Bit mask of MD_ERROR field.
	DS_QUERY_CHECK_MD_ERROR_Msk = 0x1
	// Bit MD_ERROR.
	DS_QUERY_CHECK_MD_ERROR = 0x1
	// Position of PADDING_BAD field.
	DS_QUERY_CHECK_PADDING_BAD_Pos = 0x1
	// Bit mask of PADDING_BAD field.
	DS_QUERY_CHECK_PADDING_BAD_Msk = 0x2
	// Bit PADDING_BAD.
	DS_QUERY_CHECK_PADDING_BAD = 0x2

	// DATE: version register
	// Position of DATE field.
	DS_DATE_DATE_Pos = 0x0
	// Bit mask of DATE field.
	DS_DATE_DATE_Msk = 0x3fffffff
)

// Constants for EFUSE: Peripheral EFUSE
const (
	// PGM_DATA0: Register %s that stores data to be programmed.
	// Position of PGM_DATA_0 field.
	EFUSE_PGM_DATA_PGM_DATA_0_Pos = 0x0
	// Bit mask of PGM_DATA_0 field.
	EFUSE_PGM_DATA_PGM_DATA_0_Msk = 0xffffffff

	// PGM_CHECK_VALUE0: Register %s that stores the RS code to be programmed.
	// Position of PGM_RS_DATA_0 field.
	EFUSE_PGM_CHECK_VALUE_PGM_RS_DATA_0_Pos = 0x0
	// Bit mask of PGM_RS_DATA_0 field.
	EFUSE_PGM_CHECK_VALUE_PGM_RS_DATA_0_Msk = 0xffffffff

	// RD_WR_DIS: Register 0 of BLOCK0.
	// Position of WR_DIS field.
	EFUSE_RD_WR_DIS_WR_DIS_Pos = 0x0
	// Bit mask of WR_DIS field.
	EFUSE_RD_WR_DIS_WR_DIS_Msk = 0xffffffff

	// RD_REPEAT_DATA0: Register 1 of BLOCK0.
	// Position of RD_DIS field.
	EFUSE_RD_REPEAT_DATA0_RD_DIS_Pos = 0x0
	// Bit mask of RD_DIS field.
	EFUSE_RD_REPEAT_DATA0_RD_DIS_Msk = 0x7f
	// Position of DIS_RTC_RAM_BOOT field.
	EFUSE_RD_REPEAT_DATA0_DIS_RTC_RAM_BOOT_Pos = 0x7
	// Bit mask of DIS_RTC_RAM_BOOT field.
	EFUSE_RD_REPEAT_DATA0_DIS_RTC_RAM_BOOT_Msk = 0x80
	// Bit DIS_RTC_RAM_BOOT.
	EFUSE_RD_REPEAT_DATA0_DIS_RTC_RAM_BOOT = 0x80
	// Position of DIS_ICACHE field.
	EFUSE_RD_REPEAT_DATA0_DIS_ICACHE_Pos = 0x8
	// Bit mask of DIS_ICACHE field.
	EFUSE_RD_REPEAT_DATA0_DIS_ICACHE_Msk = 0x100
	// Bit DIS_ICACHE.
	EFUSE_RD_REPEAT_DATA0_DIS_ICACHE = 0x100
	// Position of DIS_DCACHE field.
	EFUSE_RD_REPEAT_DATA0_DIS_DCACHE_Pos = 0x9
	// Bit mask of DIS_DCACHE field.
	EFUSE_RD_REPEAT_DATA0_DIS_DCACHE_Msk = 0x200
	// Bit DIS_DCACHE.
	EFUSE_RD_REPEAT_DATA0_DIS_DCACHE = 0x200
	// Position of DIS_DOWNLOAD_ICACHE field.
	EFUSE_RD_REPEAT_DATA0_DIS_DOWNLOAD_ICACHE_Pos = 0xa
	// Bit mask of DIS_DOWNLOAD_ICACHE field.
	EFUSE_RD_REPEAT_DATA0_DIS_DOWNLOAD_ICACHE_Msk = 0x400
	// Bit DIS_DOWNLOAD_ICACHE.
	EFUSE_RD_REPEAT_DATA0_DIS_DOWNLOAD_ICACHE = 0x400
	// Position of DIS_DOWNLOAD_DCACHE field.
	EFUSE_RD_REPEAT_DATA0_DIS_DOWNLOAD_DCACHE_Pos = 0xb
	// Bit mask of DIS_DOWNLOAD_DCACHE field.
	EFUSE_RD_REPEAT_DATA0_DIS_DOWNLOAD_DCACHE_Msk = 0x800
	// Bit DIS_DOWNLOAD_DCACHE.
	EFUSE_RD_REPEAT_DATA0_DIS_DOWNLOAD_DCACHE = 0x800
	// Position of DIS_FORCE_DOWNLOAD field.
	EFUSE_RD_REPEAT_DATA0_DIS_FORCE_DOWNLOAD_Pos = 0xc
	// Bit mask of DIS_FORCE_DOWNLOAD field.
	EFUSE_RD_REPEAT_DATA0_DIS_FORCE_DOWNLOAD_Msk = 0x1000
	// Bit DIS_FORCE_DOWNLOAD.
	EFUSE_RD_REPEAT_DATA0_DIS_FORCE_DOWNLOAD = 0x1000
	// Position of DIS_USB field.
	EFUSE_RD_REPEAT_DATA0_DIS_USB_Pos = 0xd
	// Bit mask of DIS_USB field.
	EFUSE_RD_REPEAT_DATA0_DIS_USB_Msk = 0x2000
	// Bit DIS_USB.
	EFUSE_RD_REPEAT_DATA0_DIS_USB = 0x2000
	// Position of DIS_CAN field.
	EFUSE_RD_REPEAT_DATA0_DIS_CAN_Pos = 0xe
	// Bit mask of DIS_CAN field.
	EFUSE_RD_REPEAT_DATA0_DIS_CAN_Msk = 0x4000
	// Bit DIS_CAN.
	EFUSE_RD_REPEAT_DATA0_DIS_CAN = 0x4000
	// Position of DIS_BOOT_REMAP field.
	EFUSE_RD_REPEAT_DATA0_DIS_BOOT_REMAP_Pos = 0xf
	// Bit mask of DIS_BOOT_REMAP field.
	EFUSE_RD_REPEAT_DATA0_DIS_BOOT_REMAP_Msk = 0x8000
	// Bit DIS_BOOT_REMAP.
	EFUSE_RD_REPEAT_DATA0_DIS_BOOT_REMAP = 0x8000
	// Position of RPT4_RESERVED5 field.
	EFUSE_RD_REPEAT_DATA0_RPT4_RESERVED5_Pos = 0x10
	// Bit mask of RPT4_RESERVED5 field.
	EFUSE_RD_REPEAT_DATA0_RPT4_RESERVED5_Msk = 0x10000
	// Bit RPT4_RESERVED5.
	EFUSE_RD_REPEAT_DATA0_RPT4_RESERVED5 = 0x10000
	// Position of SOFT_DIS_JTAG field.
	EFUSE_RD_REPEAT_DATA0_SOFT_DIS_JTAG_Pos = 0x11
	// Bit mask of SOFT_DIS_JTAG field.
	EFUSE_RD_REPEAT_DATA0_SOFT_DIS_JTAG_Msk = 0x20000
	// Bit SOFT_DIS_JTAG.
	EFUSE_RD_REPEAT_DATA0_SOFT_DIS_JTAG = 0x20000
	// Position of HARD_DIS_JTAG field.
	EFUSE_RD_REPEAT_DATA0_HARD_DIS_JTAG_Pos = 0x12
	// Bit mask of HARD_DIS_JTAG field.
	EFUSE_RD_REPEAT_DATA0_HARD_DIS_JTAG_Msk = 0x40000
	// Bit HARD_DIS_JTAG.
	EFUSE_RD_REPEAT_DATA0_HARD_DIS_JTAG = 0x40000
	// Position of DIS_DOWNLOAD_MANUAL_ENCRYPT field.
	EFUSE_RD_REPEAT_DATA0_DIS_DOWNLOAD_MANUAL_ENCRYPT_Pos = 0x13
	// Bit mask of DIS_DOWNLOAD_MANUAL_ENCRYPT field.
	EFUSE_RD_REPEAT_DATA0_DIS_DOWNLOAD_MANUAL_ENCRYPT_Msk = 0x80000
	// Bit DIS_DOWNLOAD_MANUAL_ENCRYPT.
	EFUSE_RD_REPEAT_DATA0_DIS_DOWNLOAD_MANUAL_ENCRYPT = 0x80000
	// Position of USB_DREFH field.
	EFUSE_RD_REPEAT_DATA0_USB_DREFH_Pos = 0x14
	// Bit mask of USB_DREFH field.
	EFUSE_RD_REPEAT_DATA0_USB_DREFH_Msk = 0x300000
	// Position of USB_DREFL field.
	EFUSE_RD_REPEAT_DATA0_USB_DREFL_Pos = 0x16
	// Bit mask of USB_DREFL field.
	EFUSE_RD_REPEAT_DATA0_USB_DREFL_Msk = 0xc00000
	// Position of USB_EXCHG_PINS field.
	EFUSE_RD_REPEAT_DATA0_USB_EXCHG_PINS_Pos = 0x18
	// Bit mask of USB_EXCHG_PINS field.
	EFUSE_RD_REPEAT_DATA0_USB_EXCHG_PINS_Msk = 0x1000000
	// Bit USB_EXCHG_PINS.
	EFUSE_RD_REPEAT_DATA0_USB_EXCHG_PINS = 0x1000000
	// Position of EXT_PHY_ENABLE field.
	EFUSE_RD_REPEAT_DATA0_EXT_PHY_ENABLE_Pos = 0x19
	// Bit mask of EXT_PHY_ENABLE field.
	EFUSE_RD_REPEAT_DATA0_EXT_PHY_ENABLE_Msk = 0x2000000
	// Bit EXT_PHY_ENABLE.
	EFUSE_RD_REPEAT_DATA0_EXT_PHY_ENABLE = 0x2000000
	// Position of USB_FORCE_NOPERSIST field.
	EFUSE_RD_REPEAT_DATA0_USB_FORCE_NOPERSIST_Pos = 0x1a
	// Bit mask of USB_FORCE_NOPERSIST field.
	EFUSE_RD_REPEAT_DATA0_USB_FORCE_NOPERSIST_Msk = 0x4000000
	// Bit USB_FORCE_NOPERSIST.
	EFUSE_RD_REPEAT_DATA0_USB_FORCE_NOPERSIST = 0x4000000
	// Position of RPT4_RESERVED0 field.
	EFUSE_RD_REPEAT_DATA0_RPT4_RESERVED0_Pos = 0x1b
	// Bit mask of RPT4_RESERVED0 field.
	EFUSE_RD_REPEAT_DATA0_RPT4_RESERVED0_Msk = 0x18000000
	// Position of VDD_SPI_MODECURLIM field.
	EFUSE_RD_REPEAT_DATA0_VDD_SPI_MODECURLIM_Pos = 0x1d
	// Bit mask of VDD_SPI_MODECURLIM field.
	EFUSE_RD_REPEAT_DATA0_VDD_SPI_MODECURLIM_Msk = 0x20000000
	// Bit VDD_SPI_MODECURLIM.
	EFUSE_RD_REPEAT_DATA0_VDD_SPI_MODECURLIM = 0x20000000
	// Position of VDD_SPI_DREFH field.
	EFUSE_RD_REPEAT_DATA0_VDD_SPI_DREFH_Pos = 0x1e
	// Bit mask of VDD_SPI_DREFH field.
	EFUSE_RD_REPEAT_DATA0_VDD_SPI_DREFH_Msk = 0xc0000000

	// RD_REPEAT_DATA1: Register 2 of BLOCK0.
	// Position of VDD_SPI_DREFM field.
	EFUSE_RD_REPEAT_DATA1_VDD_SPI_DREFM_Pos = 0x0
	// Bit mask of VDD_SPI_DREFM field.
	EFUSE_RD_REPEAT_DATA1_VDD_SPI_DREFM_Msk = 0x3
	// Position of VDD_SPI_DREFL field.
	EFUSE_RD_REPEAT_DATA1_VDD_SPI_DREFL_Pos = 0x2
	// Bit mask of VDD_SPI_DREFL field.
	EFUSE_RD_REPEAT_DATA1_VDD_SPI_DREFL_Msk = 0xc
	// Position of VDD_SPI_XPD field.
	EFUSE_RD_REPEAT_DATA1_VDD_SPI_XPD_Pos = 0x4
	// Bit mask of VDD_SPI_XPD field.
	EFUSE_RD_REPEAT_DATA1_VDD_SPI_XPD_Msk = 0x10
	// Bit VDD_SPI_XPD.
	EFUSE_RD_REPEAT_DATA1_VDD_SPI_XPD = 0x10
	// Position of VDD_SPI_TIEH field.
	EFUSE_RD_REPEAT_DATA1_VDD_SPI_TIEH_Pos = 0x5
	// Bit mask of VDD_SPI_TIEH field.
	EFUSE_RD_REPEAT_DATA1_VDD_SPI_TIEH_Msk = 0x20
	// Bit VDD_SPI_TIEH.
	EFUSE_RD_REPEAT_DATA1_VDD_SPI_TIEH = 0x20
	// Position of VDD_SPI_FORCE field.
	EFUSE_RD_REPEAT_DATA1_VDD_SPI_FORCE_Pos = 0x6
	// Bit mask of VDD_SPI_FORCE field.
	EFUSE_RD_REPEAT_DATA1_VDD_SPI_FORCE_Msk = 0x40
	// Bit VDD_SPI_FORCE.
	EFUSE_RD_REPEAT_DATA1_VDD_SPI_FORCE = 0x40
	// Position of VDD_SPI_EN_INIT field.
	EFUSE_RD_REPEAT_DATA1_VDD_SPI_EN_INIT_Pos = 0x7
	// Bit mask of VDD_SPI_EN_INIT field.
	EFUSE_RD_REPEAT_DATA1_VDD_SPI_EN_INIT_Msk = 0x80
	// Bit VDD_SPI_EN_INIT.
	EFUSE_RD_REPEAT_DATA1_VDD_SPI_EN_INIT = 0x80
	// Position of VDD_SPI_ENCURLIM field.
	EFUSE_RD_REPEAT_DATA1_VDD_SPI_ENCURLIM_Pos = 0x8
	// Bit mask of VDD_SPI_ENCURLIM field.
	EFUSE_RD_REPEAT_DATA1_VDD_SPI_ENCURLIM_Msk = 0x100
	// Bit VDD_SPI_ENCURLIM.
	EFUSE_RD_REPEAT_DATA1_VDD_SPI_ENCURLIM = 0x100
	// Position of VDD_SPI_DCURLIM field.
	EFUSE_RD_REPEAT_DATA1_VDD_SPI_DCURLIM_Pos = 0x9
	// Bit mask of VDD_SPI_DCURLIM field.
	EFUSE_RD_REPEAT_DATA1_VDD_SPI_DCURLIM_Msk = 0xe00
	// Position of VDD_SPI_INIT field.
	EFUSE_RD_REPEAT_DATA1_VDD_SPI_INIT_Pos = 0xc
	// Bit mask of VDD_SPI_INIT field.
	EFUSE_RD_REPEAT_DATA1_VDD_SPI_INIT_Msk = 0x3000
	// Position of VDD_SPI_DCAP field.
	EFUSE_RD_REPEAT_DATA1_VDD_SPI_DCAP_Pos = 0xe
	// Bit mask of VDD_SPI_DCAP field.
	EFUSE_RD_REPEAT_DATA1_VDD_SPI_DCAP_Msk = 0xc000
	// Position of WDT_DELAY_SEL field.
	EFUSE_RD_REPEAT_DATA1_WDT_DELAY_SEL_Pos = 0x10
	// Bit mask of WDT_DELAY_SEL field.
	EFUSE_RD_REPEAT_DATA1_WDT_DELAY_SEL_Msk = 0x30000
	// Position of SPI_BOOT_CRYPT_CNT field.
	EFUSE_RD_REPEAT_DATA1_SPI_BOOT_CRYPT_CNT_Pos = 0x12
	// Bit mask of SPI_BOOT_CRYPT_CNT field.
	EFUSE_RD_REPEAT_DATA1_SPI_BOOT_CRYPT_CNT_Msk = 0x1c0000
	// Position of SECURE_BOOT_KEY_REVOKE0 field.
	EFUSE_RD_REPEAT_DATA1_SECURE_BOOT_KEY_REVOKE0_Pos = 0x15
	// Bit mask of SECURE_BOOT_KEY_REVOKE0 field.
	EFUSE_RD_REPEAT_DATA1_SECURE_BOOT_KEY_REVOKE0_Msk = 0x200000
	// Bit SECURE_BOOT_KEY_REVOKE0.
	EFUSE_RD_REPEAT_DATA1_SECURE_BOOT_KEY_REVOKE0 = 0x200000
	// Position of SECURE_BOOT_KEY_REVOKE1 field.
	EFUSE_RD_REPEAT_DATA1_SECURE_BOOT_KEY_REVOKE1_Pos = 0x16
	// Bit mask of SECURE_BOOT_KEY_REVOKE1 field.
	EFUSE_RD_REPEAT_DATA1_SECURE_BOOT_KEY_REVOKE1_Msk = 0x400000
	// Bit SECURE_BOOT_KEY_REVOKE1.
	EFUSE_RD_REPEAT_DATA1_SECURE_BOOT_KEY_REVOKE1 = 0x400000
	// Position of SECURE_BOOT_KEY_REVOKE2 field.
	EFUSE_RD_REPEAT_DATA1_SECURE_BOOT_KEY_REVOKE2_Pos = 0x17
	// Bit mask of SECURE_BOOT_KEY_REVOKE2 field.
	EFUSE_RD_REPEAT_DATA1_SECURE_BOOT_KEY_REVOKE2_Msk = 0x800000
	// Bit SECURE_BOOT_KEY_REVOKE2.
	EFUSE_RD_REPEAT_DATA1_SECURE_BOOT_KEY_REVOKE2 = 0x800000
	// Position of KEY_PURPOSE_0 field.
	EFUSE_RD_REPEAT_DATA1_KEY_PURPOSE_0_Pos = 0x18
	// Bit mask of KEY_PURPOSE_0 field.
	EFUSE_RD_REPEAT_DATA1_KEY_PURPOSE_0_Msk = 0xf000000
	// Position of KEY_PURPOSE_1 field.
	EFUSE_RD_REPEAT_DATA1_KEY_PURPOSE_1_Pos = 0x1c
	// Bit mask of KEY_PURPOSE_1 field.
	EFUSE_RD_REPEAT_DATA1_KEY_PURPOSE_1_Msk = 0xf0000000

	// RD_REPEAT_DATA2: Register 3 of BLOCK0.
	// Position of KEY_PURPOSE_2 field.
	EFUSE_RD_REPEAT_DATA2_KEY_PURPOSE_2_Pos = 0x0
	// Bit mask of KEY_PURPOSE_2 field.
	EFUSE_RD_REPEAT_DATA2_KEY_PURPOSE_2_Msk = 0xf
	// Position of KEY_PURPOSE_3 field.
	EFUSE_RD_REPEAT_DATA2_KEY_PURPOSE_3_Pos = 0x4
	// Bit mask of KEY_PURPOSE_3 field.
	EFUSE_RD_REPEAT_DATA2_KEY_PURPOSE_3_Msk = 0xf0
	// Position of KEY_PURPOSE_4 field.
	EFUSE_RD_REPEAT_DATA2_KEY_PURPOSE_4_Pos = 0x8
	// Bit mask of KEY_PURPOSE_4 field.
	EFUSE_RD_REPEAT_DATA2_KEY_PURPOSE_4_Msk = 0xf00
	// Position of KEY_PURPOSE_5 field.
	EFUSE_RD_REPEAT_DATA2_KEY_PURPOSE_5_Pos = 0xc
	// Bit mask of KEY_PURPOSE_5 field.
	EFUSE_RD_REPEAT_DATA2_KEY_PURPOSE_5_Msk = 0xf000
	// Position of KEY_PURPOSE_6 field.
	EFUSE_RD_REPEAT_DATA2_KEY_PURPOSE_6_Pos = 0x10
	// Bit mask of KEY_PURPOSE_6 field.
	EFUSE_RD_REPEAT_DATA2_KEY_PURPOSE_6_Msk = 0xf0000
	// Position of SECURE_BOOT_EN field.
	EFUSE_RD_REPEAT_DATA2_SECURE_BOOT_EN_Pos = 0x14
	// Bit mask of SECURE_BOOT_EN field.
	EFUSE_RD_REPEAT_DATA2_SECURE_BOOT_EN_Msk = 0x100000
	// Bit SECURE_BOOT_EN.
	EFUSE_RD_REPEAT_DATA2_SECURE_BOOT_EN = 0x100000
	// Position of SECURE_BOOT_AGGRESSIVE_REVOKE field.
	EFUSE_RD_REPEAT_DATA2_SECURE_BOOT_AGGRESSIVE_REVOKE_Pos = 0x15
	// Bit mask of SECURE_BOOT_AGGRESSIVE_REVOKE field.
	EFUSE_RD_REPEAT_DATA2_SECURE_BOOT_AGGRESSIVE_REVOKE_Msk = 0x200000
	// Bit SECURE_BOOT_AGGRESSIVE_REVOKE.
	EFUSE_RD_REPEAT_DATA2_SECURE_BOOT_AGGRESSIVE_REVOKE = 0x200000
	// Position of RPT4_RESERVED1 field.
	EFUSE_RD_REPEAT_DATA2_RPT4_RESERVED1_Pos = 0x16
	// Bit mask of RPT4_RESERVED1 field.
	EFUSE_RD_REPEAT_DATA2_RPT4_RESERVED1_Msk = 0xfc00000
	// Position of FLASH_TPUW field.
	EFUSE_RD_REPEAT_DATA2_FLASH_TPUW_Pos = 0x1c
	// Bit mask of FLASH_TPUW field.
	EFUSE_RD_REPEAT_DATA2_FLASH_TPUW_Msk = 0xf0000000

	// RD_REPEAT_DATA3: Register 4 of BLOCK0.
	// Position of DIS_DOWNLOAD_MODE field.
	EFUSE_RD_REPEAT_DATA3_DIS_DOWNLOAD_MODE_Pos = 0x0
	// Bit mask of DIS_DOWNLOAD_MODE field.
	EFUSE_RD_REPEAT_DATA3_DIS_DOWNLOAD_MODE_Msk = 0x1
	// Bit DIS_DOWNLOAD_MODE.
	EFUSE_RD_REPEAT_DATA3_DIS_DOWNLOAD_MODE = 0x1
	// Position of DIS_LEGACY_SPI_BOOT field.
	EFUSE_RD_REPEAT_DATA3_DIS_LEGACY_SPI_BOOT_Pos = 0x1
	// Bit mask of DIS_LEGACY_SPI_BOOT field.
	EFUSE_RD_REPEAT_DATA3_DIS_LEGACY_SPI_BOOT_Msk = 0x2
	// Bit DIS_LEGACY_SPI_BOOT.
	EFUSE_RD_REPEAT_DATA3_DIS_LEGACY_SPI_BOOT = 0x2
	// Position of UART_PRINT_CHANNEL field.
	EFUSE_RD_REPEAT_DATA3_UART_PRINT_CHANNEL_Pos = 0x2
	// Bit mask of UART_PRINT_CHANNEL field.
	EFUSE_RD_REPEAT_DATA3_UART_PRINT_CHANNEL_Msk = 0x4
	// Bit UART_PRINT_CHANNEL.
	EFUSE_RD_REPEAT_DATA3_UART_PRINT_CHANNEL = 0x4
	// Position of RPT4_RESERVED3 field.
	EFUSE_RD_REPEAT_DATA3_RPT4_RESERVED3_Pos = 0x3
	// Bit mask of RPT4_RESERVED3 field.
	EFUSE_RD_REPEAT_DATA3_RPT4_RESERVED3_Msk = 0x8
	// Bit RPT4_RESERVED3.
	EFUSE_RD_REPEAT_DATA3_RPT4_RESERVED3 = 0x8
	// Position of DIS_USB_DOWNLOAD_MODE field.
	EFUSE_RD_REPEAT_DATA3_DIS_USB_DOWNLOAD_MODE_Pos = 0x4
	// Bit mask of DIS_USB_DOWNLOAD_MODE field.
	EFUSE_RD_REPEAT_DATA3_DIS_USB_DOWNLOAD_MODE_Msk = 0x10
	// Bit DIS_USB_DOWNLOAD_MODE.
	EFUSE_RD_REPEAT_DATA3_DIS_USB_DOWNLOAD_MODE = 0x10
	// Position of ENABLE_SECURITY_DOWNLOAD field.
	EFUSE_RD_REPEAT_DATA3_ENABLE_SECURITY_DOWNLOAD_Pos = 0x5
	// Bit mask of ENABLE_SECURITY_DOWNLOAD field.
	EFUSE_RD_REPEAT_DATA3_ENABLE_SECURITY_DOWNLOAD_Msk = 0x20
	// Bit ENABLE_SECURITY_DOWNLOAD.
	EFUSE_RD_REPEAT_DATA3_ENABLE_SECURITY_DOWNLOAD = 0x20
	// Position of UART_PRINT_CONTROL field.
	EFUSE_RD_REPEAT_DATA3_UART_PRINT_CONTROL_Pos = 0x6
	// Bit mask of UART_PRINT_CONTROL field.
	EFUSE_RD_REPEAT_DATA3_UART_PRINT_CONTROL_Msk = 0xc0
	// Position of PIN_POWER_SELECTION field.
	EFUSE_RD_REPEAT_DATA3_PIN_POWER_SELECTION_Pos = 0x8
	// Bit mask of PIN_POWER_SELECTION field.
	EFUSE_RD_REPEAT_DATA3_PIN_POWER_SELECTION_Msk = 0x100
	// Bit PIN_POWER_SELECTION.
	EFUSE_RD_REPEAT_DATA3_PIN_POWER_SELECTION = 0x100
	// Position of FLASH_TYPE field.
	EFUSE_RD_REPEAT_DATA3_FLASH_TYPE_Pos = 0x9
	// Bit mask of FLASH_TYPE field.
	EFUSE_RD_REPEAT_DATA3_FLASH_TYPE_Msk = 0x200
	// Bit FLASH_TYPE.
	EFUSE_RD_REPEAT_DATA3_FLASH_TYPE = 0x200
	// Position of FORCE_SEND_RESUME field.
	EFUSE_RD_REPEAT_DATA3_FORCE_SEND_RESUME_Pos = 0xa
	// Bit mask of FORCE_SEND_RESUME field.
	EFUSE_RD_REPEAT_DATA3_FORCE_SEND_RESUME_Msk = 0x400
	// Bit FORCE_SEND_RESUME.
	EFUSE_RD_REPEAT_DATA3_FORCE_SEND_RESUME = 0x400
	// Position of SECURE_VERSION field.
	EFUSE_RD_REPEAT_DATA3_SECURE_VERSION_Pos = 0xb
	// Bit mask of SECURE_VERSION field.
	EFUSE_RD_REPEAT_DATA3_SECURE_VERSION_Msk = 0x7fff800
	// Position of RPT4_RESERVED2 field.
	EFUSE_RD_REPEAT_DATA3_RPT4_RESERVED2_Pos = 0x1b
	// Bit mask of RPT4_RESERVED2 field.
	EFUSE_RD_REPEAT_DATA3_RPT4_RESERVED2_Msk = 0xf8000000

	// RD_REPEAT_DATA4: Register 5 of BLOCK0.
	// Position of RPT4_RESERVED4 field.
	EFUSE_RD_REPEAT_DATA4_RPT4_RESERVED4_Pos = 0x0
	// Bit mask of RPT4_RESERVED4 field.
	EFUSE_RD_REPEAT_DATA4_RPT4_RESERVED4_Msk = 0xffffff

	// RD_MAC_SPI_SYS_0: Register 0 of BLOCK1.
	// Position of MAC_0 field.
	EFUSE_RD_MAC_SPI_SYS_0_MAC_0_Pos = 0x0
	// Bit mask of MAC_0 field.
	EFUSE_RD_MAC_SPI_SYS_0_MAC_0_Msk = 0xffffffff

	// RD_MAC_SPI_SYS_1: Register 1 of BLOCK1.
	// Position of MAC_1 field.
	EFUSE_RD_MAC_SPI_SYS_1_MAC_1_Pos = 0x0
	// Bit mask of MAC_1 field.
	EFUSE_RD_MAC_SPI_SYS_1_MAC_1_Msk = 0xffff
	// Position of SPI_PAD_CONF_0 field.
	EFUSE_RD_MAC_SPI_SYS_1_SPI_PAD_CONF_0_Pos = 0x10
	// Bit mask of SPI_PAD_CONF_0 field.
	EFUSE_RD_MAC_SPI_SYS_1_SPI_PAD_CONF_0_Msk = 0xffff0000

	// RD_MAC_SPI_SYS_2: Register 2 of BLOCK1.
	// Position of SPI_PAD_CONF_1 field.
	EFUSE_RD_MAC_SPI_SYS_2_SPI_PAD_CONF_1_Pos = 0x0
	// Bit mask of SPI_PAD_CONF_1 field.
	EFUSE_RD_MAC_SPI_SYS_2_SPI_PAD_CONF_1_Msk = 0xffffffff

	// RD_MAC_SPI_SYS_3: Register 3 of BLOCK1.
	// Position of SPI_PAD_CONF_2 field.
	EFUSE_RD_MAC_SPI_SYS_3_SPI_PAD_CONF_2_Pos = 0x0
	// Bit mask of SPI_PAD_CONF_2 field.
	EFUSE_RD_MAC_SPI_SYS_3_SPI_PAD_CONF_2_Msk = 0x3ffff
	// Position of SYS_DATA_PART0_0 field.
	EFUSE_RD_MAC_SPI_SYS_3_SYS_DATA_PART0_0_Pos = 0x12
	// Bit mask of SYS_DATA_PART0_0 field.
	EFUSE_RD_MAC_SPI_SYS_3_SYS_DATA_PART0_0_Msk = 0xfffc0000

	// RD_MAC_SPI_SYS_4: Register 4 of BLOCK1.
	// Position of SYS_DATA_PART0_1 field.
	EFUSE_RD_MAC_SPI_SYS_4_SYS_DATA_PART0_1_Pos = 0x0
	// Bit mask of SYS_DATA_PART0_1 field.
	EFUSE_RD_MAC_SPI_SYS_4_SYS_DATA_PART0_1_Msk = 0xffffffff

	// RD_MAC_SPI_SYS_5: Register 5 of BLOCK1.
	// Position of SYS_DATA_PART0_2 field.
	EFUSE_RD_MAC_SPI_SYS_5_SYS_DATA_PART0_2_Pos = 0x0
	// Bit mask of SYS_DATA_PART0_2 field.
	EFUSE_RD_MAC_SPI_SYS_5_SYS_DATA_PART0_2_Msk = 0xffffffff

	// RD_SYS_DATA_PART1_0: Register %s of BLOCK2 (system).
	// Position of SYS_DATA_PART1_0 field.
	EFUSE_RD_SYS_DATA_PART1_SYS_DATA_PART1_0_Pos = 0x0
	// Bit mask of SYS_DATA_PART1_0 field.
	EFUSE_RD_SYS_DATA_PART1_SYS_DATA_PART1_0_Msk = 0xffffffff

	// RD_USR_DATA0: Register %s of BLOCK3 (user).
	// Position of USR_DATA0 field.
	EFUSE_RD_USR_DATA_USR_DATA0_Pos = 0x0
	// Bit mask of USR_DATA0 field.
	EFUSE_RD_USR_DATA_USR_DATA0_Msk = 0xffffffff

	// RD_KEY0_DATA0: Register %s of BLOCK4 (KEY0).
	// Position of KEY0_DATA0 field.
	EFUSE_RD_KEY0_DATA_KEY0_DATA0_Pos = 0x0
	// Bit mask of KEY0_DATA0 field.
	EFUSE_RD_KEY0_DATA_KEY0_DATA0_Msk = 0xffffffff

	// RD_KEY1_DATA0: Register %s of BLOCK5 (KEY1).
	// Position of KEY1_DATA0 field.
	EFUSE_RD_KEY1_DATA_KEY1_DATA0_Pos = 0x0
	// Bit mask of KEY1_DATA0 field.
	EFUSE_RD_KEY1_DATA_KEY1_DATA0_Msk = 0xffffffff

	// RD_KEY2_DATA0: Register %s of BLOCK6 (KEY2).
	// Position of KEY2_DATA0 field.
	EFUSE_RD_KEY2_DATA_KEY2_DATA0_Pos = 0x0
	// Bit mask of KEY2_DATA0 field.
	EFUSE_RD_KEY2_DATA_KEY2_DATA0_Msk = 0xffffffff

	// RD_KEY3_DATA0: Register %s of BLOCK7 (KEY3).
	// Position of KEY3_DATA0 field.
	EFUSE_RD_KEY3_DATA_KEY3_DATA0_Pos = 0x0
	// Bit mask of KEY3_DATA0 field.
	EFUSE_RD_KEY3_DATA_KEY3_DATA0_Msk = 0xffffffff

	// RD_KEY4_DATA0: Register %s of BLOCK8 (KEY4).
	// Position of KEY4_DATA0 field.
	EFUSE_RD_KEY4_DATA_KEY4_DATA0_Pos = 0x0
	// Bit mask of KEY4_DATA0 field.
	EFUSE_RD_KEY4_DATA_KEY4_DATA0_Msk = 0xffffffff

	// RD_KEY5_DATA0: Register %s of BLOCK9 (KEY5).
	// Position of KEY5_DATA0 field.
	EFUSE_RD_KEY5_DATA_KEY5_DATA0_Pos = 0x0
	// Bit mask of KEY5_DATA0 field.
	EFUSE_RD_KEY5_DATA_KEY5_DATA0_Msk = 0xffffffff

	// RD_SYS_DATA_PART2_0: Register %s of BLOCK10 (system).
	// Position of SYS_DATA_PART2_0 field.
	EFUSE_RD_SYS_DATA_PART2_SYS_DATA_PART2_0_Pos = 0x0
	// Bit mask of SYS_DATA_PART2_0 field.
	EFUSE_RD_SYS_DATA_PART2_SYS_DATA_PART2_0_Msk = 0xffffffff

	// RD_REPEAT_ERR0: Programming error record register 0 of BLOCK0.
	// Position of RD_DIS_ERR field.
	EFUSE_RD_REPEAT_ERR0_RD_DIS_ERR_Pos = 0x0
	// Bit mask of RD_DIS_ERR field.
	EFUSE_RD_REPEAT_ERR0_RD_DIS_ERR_Msk = 0x7f
	// Position of DIS_RTC_RAM_BOOT_ERR field.
	EFUSE_RD_REPEAT_ERR0_DIS_RTC_RAM_BOOT_ERR_Pos = 0x7
	// Bit mask of DIS_RTC_RAM_BOOT_ERR field.
	EFUSE_RD_REPEAT_ERR0_DIS_RTC_RAM_BOOT_ERR_Msk = 0x80
	// Bit DIS_RTC_RAM_BOOT_ERR.
	EFUSE_RD_REPEAT_ERR0_DIS_RTC_RAM_BOOT_ERR = 0x80
	// Position of DIS_ICACHE_ERR field.
	EFUSE_RD_REPEAT_ERR0_DIS_ICACHE_ERR_Pos = 0x8
	// Bit mask of DIS_ICACHE_ERR field.
	EFUSE_RD_REPEAT_ERR0_DIS_ICACHE_ERR_Msk = 0x100
	// Bit DIS_ICACHE_ERR.
	EFUSE_RD_REPEAT_ERR0_DIS_ICACHE_ERR = 0x100
	// Position of DIS_DCACHE_ERR field.
	EFUSE_RD_REPEAT_ERR0_DIS_DCACHE_ERR_Pos = 0x9
	// Bit mask of DIS_DCACHE_ERR field.
	EFUSE_RD_REPEAT_ERR0_DIS_DCACHE_ERR_Msk = 0x200
	// Bit DIS_DCACHE_ERR.
	EFUSE_RD_REPEAT_ERR0_DIS_DCACHE_ERR = 0x200
	// Position of DIS_DOWNLOAD_ICACHE_ERR field.
	EFUSE_RD_REPEAT_ERR0_DIS_DOWNLOAD_ICACHE_ERR_Pos = 0xa
	// Bit mask of DIS_DOWNLOAD_ICACHE_ERR field.
	EFUSE_RD_REPEAT_ERR0_DIS_DOWNLOAD_ICACHE_ERR_Msk = 0x400
	// Bit DIS_DOWNLOAD_ICACHE_ERR.
	EFUSE_RD_REPEAT_ERR0_DIS_DOWNLOAD_ICACHE_ERR = 0x400
	// Position of DIS_DOWNLOAD_DCACHE_ERR field.
	EFUSE_RD_REPEAT_ERR0_DIS_DOWNLOAD_DCACHE_ERR_Pos = 0xb
	// Bit mask of DIS_DOWNLOAD_DCACHE_ERR field.
	EFUSE_RD_REPEAT_ERR0_DIS_DOWNLOAD_DCACHE_ERR_Msk = 0x800
	// Bit DIS_DOWNLOAD_DCACHE_ERR.
	EFUSE_RD_REPEAT_ERR0_DIS_DOWNLOAD_DCACHE_ERR = 0x800
	// Position of DIS_FORCE_DOWNLOAD_ERR field.
	EFUSE_RD_REPEAT_ERR0_DIS_FORCE_DOWNLOAD_ERR_Pos = 0xc
	// Bit mask of DIS_FORCE_DOWNLOAD_ERR field.
	EFUSE_RD_REPEAT_ERR0_DIS_FORCE_DOWNLOAD_ERR_Msk = 0x1000
	// Bit DIS_FORCE_DOWNLOAD_ERR.
	EFUSE_RD_REPEAT_ERR0_DIS_FORCE_DOWNLOAD_ERR = 0x1000
	// Position of DIS_USB_ERR field.
	EFUSE_RD_REPEAT_ERR0_DIS_USB_ERR_Pos = 0xd
	// Bit mask of DIS_USB_ERR field.
	EFUSE_RD_REPEAT_ERR0_DIS_USB_ERR_Msk = 0x2000
	// Bit DIS_USB_ERR.
	EFUSE_RD_REPEAT_ERR0_DIS_USB_ERR = 0x2000
	// Position of DIS_CAN_ERR field.
	EFUSE_RD_REPEAT_ERR0_DIS_CAN_ERR_Pos = 0xe
	// Bit mask of DIS_CAN_ERR field.
	EFUSE_RD_REPEAT_ERR0_DIS_CAN_ERR_Msk = 0x4000
	// Bit DIS_CAN_ERR.
	EFUSE_RD_REPEAT_ERR0_DIS_CAN_ERR = 0x4000
	// Position of DIS_BOOT_REMAP_ERR field.
	EFUSE_RD_REPEAT_ERR0_DIS_BOOT_REMAP_ERR_Pos = 0xf
	// Bit mask of DIS_BOOT_REMAP_ERR field.
	EFUSE_RD_REPEAT_ERR0_DIS_BOOT_REMAP_ERR_Msk = 0x8000
	// Bit DIS_BOOT_REMAP_ERR.
	EFUSE_RD_REPEAT_ERR0_DIS_BOOT_REMAP_ERR = 0x8000
	// Position of RPT4_RESERVED5_ERR field.
	EFUSE_RD_REPEAT_ERR0_RPT4_RESERVED5_ERR_Pos = 0x10
	// Bit mask of RPT4_RESERVED5_ERR field.
	EFUSE_RD_REPEAT_ERR0_RPT4_RESERVED5_ERR_Msk = 0x10000
	// Bit RPT4_RESERVED5_ERR.
	EFUSE_RD_REPEAT_ERR0_RPT4_RESERVED5_ERR = 0x10000
	// Position of SOFT_DIS_JTAG_ERR field.
	EFUSE_RD_REPEAT_ERR0_SOFT_DIS_JTAG_ERR_Pos = 0x11
	// Bit mask of SOFT_DIS_JTAG_ERR field.
	EFUSE_RD_REPEAT_ERR0_SOFT_DIS_JTAG_ERR_Msk = 0x20000
	// Bit SOFT_DIS_JTAG_ERR.
	EFUSE_RD_REPEAT_ERR0_SOFT_DIS_JTAG_ERR = 0x20000
	// Position of HARD_DIS_JTAG_ERR field.
	EFUSE_RD_REPEAT_ERR0_HARD_DIS_JTAG_ERR_Pos = 0x12
	// Bit mask of HARD_DIS_JTAG_ERR field.
	EFUSE_RD_REPEAT_ERR0_HARD_DIS_JTAG_ERR_Msk = 0x40000
	// Bit HARD_DIS_JTAG_ERR.
	EFUSE_RD_REPEAT_ERR0_HARD_DIS_JTAG_ERR = 0x40000
	// Position of DIS_DOWNLOAD_MANUAL_ENCRYPT_ERR field.
	EFUSE_RD_REPEAT_ERR0_DIS_DOWNLOAD_MANUAL_ENCRYPT_ERR_Pos = 0x13
	// Bit mask of DIS_DOWNLOAD_MANUAL_ENCRYPT_ERR field.
	EFUSE_RD_REPEAT_ERR0_DIS_DOWNLOAD_MANUAL_ENCRYPT_ERR_Msk = 0x80000
	// Bit DIS_DOWNLOAD_MANUAL_ENCRYPT_ERR.
	EFUSE_RD_REPEAT_ERR0_DIS_DOWNLOAD_MANUAL_ENCRYPT_ERR = 0x80000
	// Position of USB_DREFH_ERR field.
	EFUSE_RD_REPEAT_ERR0_USB_DREFH_ERR_Pos = 0x14
	// Bit mask of USB_DREFH_ERR field.
	EFUSE_RD_REPEAT_ERR0_USB_DREFH_ERR_Msk = 0x300000
	// Position of USB_DREFL_ERR field.
	EFUSE_RD_REPEAT_ERR0_USB_DREFL_ERR_Pos = 0x16
	// Bit mask of USB_DREFL_ERR field.
	EFUSE_RD_REPEAT_ERR0_USB_DREFL_ERR_Msk = 0xc00000
	// Position of USB_EXCHG_PINS_ERR field.
	EFUSE_RD_REPEAT_ERR0_USB_EXCHG_PINS_ERR_Pos = 0x18
	// Bit mask of USB_EXCHG_PINS_ERR field.
	EFUSE_RD_REPEAT_ERR0_USB_EXCHG_PINS_ERR_Msk = 0x1000000
	// Bit USB_EXCHG_PINS_ERR.
	EFUSE_RD_REPEAT_ERR0_USB_EXCHG_PINS_ERR = 0x1000000
	// Position of EXT_PHY_ENABLE_ERR field.
	EFUSE_RD_REPEAT_ERR0_EXT_PHY_ENABLE_ERR_Pos = 0x19
	// Bit mask of EXT_PHY_ENABLE_ERR field.
	EFUSE_RD_REPEAT_ERR0_EXT_PHY_ENABLE_ERR_Msk = 0x2000000
	// Bit EXT_PHY_ENABLE_ERR.
	EFUSE_RD_REPEAT_ERR0_EXT_PHY_ENABLE_ERR = 0x2000000
	// Position of USB_FORCE_NOPERSIST_ERR field.
	EFUSE_RD_REPEAT_ERR0_USB_FORCE_NOPERSIST_ERR_Pos = 0x1a
	// Bit mask of USB_FORCE_NOPERSIST_ERR field.
	EFUSE_RD_REPEAT_ERR0_USB_FORCE_NOPERSIST_ERR_Msk = 0x4000000
	// Bit USB_FORCE_NOPERSIST_ERR.
	EFUSE_RD_REPEAT_ERR0_USB_FORCE_NOPERSIST_ERR = 0x4000000
	// Position of RPT4_RESERVED0_ERR field.
	EFUSE_RD_REPEAT_ERR0_RPT4_RESERVED0_ERR_Pos = 0x1b
	// Bit mask of RPT4_RESERVED0_ERR field.
	EFUSE_RD_REPEAT_ERR0_RPT4_RESERVED0_ERR_Msk = 0x18000000
	// Position of VDD_SPI_MODECURLIM_ERR field.
	EFUSE_RD_REPEAT_ERR0_VDD_SPI_MODECURLIM_ERR_Pos = 0x1d
	// Bit mask of VDD_SPI_MODECURLIM_ERR field.
	EFUSE_RD_REPEAT_ERR0_VDD_SPI_MODECURLIM_ERR_Msk = 0x20000000
	// Bit VDD_SPI_MODECURLIM_ERR.
	EFUSE_RD_REPEAT_ERR0_VDD_SPI_MODECURLIM_ERR = 0x20000000
	// Position of VDD_SPI_DREFH_ERR field.
	EFUSE_RD_REPEAT_ERR0_VDD_SPI_DREFH_ERR_Pos = 0x1e
	// Bit mask of VDD_SPI_DREFH_ERR field.
	EFUSE_RD_REPEAT_ERR0_VDD_SPI_DREFH_ERR_Msk = 0xc0000000

	// RD_REPEAT_ERR1: Programming error record register 1 of BLOCK0.
	// Position of VDD_SPI_DREFM_ERR field.
	EFUSE_RD_REPEAT_ERR1_VDD_SPI_DREFM_ERR_Pos = 0x0
	// Bit mask of VDD_SPI_DREFM_ERR field.
	EFUSE_RD_REPEAT_ERR1_VDD_SPI_DREFM_ERR_Msk = 0x3
	// Position of VDD_SPI_DREFL_ERR field.
	EFUSE_RD_REPEAT_ERR1_VDD_SPI_DREFL_ERR_Pos = 0x2
	// Bit mask of VDD_SPI_DREFL_ERR field.
	EFUSE_RD_REPEAT_ERR1_VDD_SPI_DREFL_ERR_Msk = 0xc
	// Position of VDD_SPI_XPD_ERR field.
	EFUSE_RD_REPEAT_ERR1_VDD_SPI_XPD_ERR_Pos = 0x4
	// Bit mask of VDD_SPI_XPD_ERR field.
	EFUSE_RD_REPEAT_ERR1_VDD_SPI_XPD_ERR_Msk = 0x10
	// Bit VDD_SPI_XPD_ERR.
	EFUSE_RD_REPEAT_ERR1_VDD_SPI_XPD_ERR = 0x10
	// Position of VDD_SPI_TIEH_ERR field.
	EFUSE_RD_REPEAT_ERR1_VDD_SPI_TIEH_ERR_Pos = 0x5
	// Bit mask of VDD_SPI_TIEH_ERR field.
	EFUSE_RD_REPEAT_ERR1_VDD_SPI_TIEH_ERR_Msk = 0x20
	// Bit VDD_SPI_TIEH_ERR.
	EFUSE_RD_REPEAT_ERR1_VDD_SPI_TIEH_ERR = 0x20
	// Position of VDD_SPI_FORCE_ERR field.
	EFUSE_RD_REPEAT_ERR1_VDD_SPI_FORCE_ERR_Pos = 0x6
	// Bit mask of VDD_SPI_FORCE_ERR field.
	EFUSE_RD_REPEAT_ERR1_VDD_SPI_FORCE_ERR_Msk = 0x40
	// Bit VDD_SPI_FORCE_ERR.
	EFUSE_RD_REPEAT_ERR1_VDD_SPI_FORCE_ERR = 0x40
	// Position of VDD_SPI_EN_INIT_ERR field.
	EFUSE_RD_REPEAT_ERR1_VDD_SPI_EN_INIT_ERR_Pos = 0x7
	// Bit mask of VDD_SPI_EN_INIT_ERR field.
	EFUSE_RD_REPEAT_ERR1_VDD_SPI_EN_INIT_ERR_Msk = 0x80
	// Bit VDD_SPI_EN_INIT_ERR.
	EFUSE_RD_REPEAT_ERR1_VDD_SPI_EN_INIT_ERR = 0x80
	// Position of VDD_SPI_ENCURLIM_ERR field.
	EFUSE_RD_REPEAT_ERR1_VDD_SPI_ENCURLIM_ERR_Pos = 0x8
	// Bit mask of VDD_SPI_ENCURLIM_ERR field.
	EFUSE_RD_REPEAT_ERR1_VDD_SPI_ENCURLIM_ERR_Msk = 0x100
	// Bit VDD_SPI_ENCURLIM_ERR.
	EFUSE_RD_REPEAT_ERR1_VDD_SPI_ENCURLIM_ERR = 0x100
	// Position of VDD_SPI_DCURLIM_ERR field.
	EFUSE_RD_REPEAT_ERR1_VDD_SPI_DCURLIM_ERR_Pos = 0x9
	// Bit mask of VDD_SPI_DCURLIM_ERR field.
	EFUSE_RD_REPEAT_ERR1_VDD_SPI_DCURLIM_ERR_Msk = 0xe00
	// Position of VDD_SPI_INIT_ERR field.
	EFUSE_RD_REPEAT_ERR1_VDD_SPI_INIT_ERR_Pos = 0xc
	// Bit mask of VDD_SPI_INIT_ERR field.
	EFUSE_RD_REPEAT_ERR1_VDD_SPI_INIT_ERR_Msk = 0x3000
	// Position of VDD_SPI_DCAP_ERR field.
	EFUSE_RD_REPEAT_ERR1_VDD_SPI_DCAP_ERR_Pos = 0xe
	// Bit mask of VDD_SPI_DCAP_ERR field.
	EFUSE_RD_REPEAT_ERR1_VDD_SPI_DCAP_ERR_Msk = 0xc000
	// Position of WDT_DELAY_SEL_ERR field.
	EFUSE_RD_REPEAT_ERR1_WDT_DELAY_SEL_ERR_Pos = 0x10
	// Bit mask of WDT_DELAY_SEL_ERR field.
	EFUSE_RD_REPEAT_ERR1_WDT_DELAY_SEL_ERR_Msk = 0x30000
	// Position of SPI_BOOT_CRYPT_CNT_ERR field.
	EFUSE_RD_REPEAT_ERR1_SPI_BOOT_CRYPT_CNT_ERR_Pos = 0x12
	// Bit mask of SPI_BOOT_CRYPT_CNT_ERR field.
	EFUSE_RD_REPEAT_ERR1_SPI_BOOT_CRYPT_CNT_ERR_Msk = 0x1c0000
	// Position of SECURE_BOOT_KEY_REVOKE0_ERR field.
	EFUSE_RD_REPEAT_ERR1_SECURE_BOOT_KEY_REVOKE0_ERR_Pos = 0x15
	// Bit mask of SECURE_BOOT_KEY_REVOKE0_ERR field.
	EFUSE_RD_REPEAT_ERR1_SECURE_BOOT_KEY_REVOKE0_ERR_Msk = 0x200000
	// Bit SECURE_BOOT_KEY_REVOKE0_ERR.
	EFUSE_RD_REPEAT_ERR1_SECURE_BOOT_KEY_REVOKE0_ERR = 0x200000
	// Position of SECURE_BOOT_KEY_REVOKE1_ERR field.
	EFUSE_RD_REPEAT_ERR1_SECURE_BOOT_KEY_REVOKE1_ERR_Pos = 0x16
	// Bit mask of SECURE_BOOT_KEY_REVOKE1_ERR field.
	EFUSE_RD_REPEAT_ERR1_SECURE_BOOT_KEY_REVOKE1_ERR_Msk = 0x400000
	// Bit SECURE_BOOT_KEY_REVOKE1_ERR.
	EFUSE_RD_REPEAT_ERR1_SECURE_BOOT_KEY_REVOKE1_ERR = 0x400000
	// Position of SECURE_BOOT_KEY_REVOKE2_ERR field.
	EFUSE_RD_REPEAT_ERR1_SECURE_BOOT_KEY_REVOKE2_ERR_Pos = 0x17
	// Bit mask of SECURE_BOOT_KEY_REVOKE2_ERR field.
	EFUSE_RD_REPEAT_ERR1_SECURE_BOOT_KEY_REVOKE2_ERR_Msk = 0x800000
	// Bit SECURE_BOOT_KEY_REVOKE2_ERR.
	EFUSE_RD_REPEAT_ERR1_SECURE_BOOT_KEY_REVOKE2_ERR = 0x800000
	// Position of KEY_PURPOSE_0_ERR field.
	EFUSE_RD_REPEAT_ERR1_KEY_PURPOSE_0_ERR_Pos = 0x18
	// Bit mask of KEY_PURPOSE_0_ERR field.
	EFUSE_RD_REPEAT_ERR1_KEY_PURPOSE_0_ERR_Msk = 0xf000000
	// Position of KEY_PURPOSE_1_ERR field.
	EFUSE_RD_REPEAT_ERR1_KEY_PURPOSE_1_ERR_Pos = 0x1c
	// Bit mask of KEY_PURPOSE_1_ERR field.
	EFUSE_RD_REPEAT_ERR1_KEY_PURPOSE_1_ERR_Msk = 0xf0000000

	// RD_REPEAT_ERR2: Programming error record register 2 of BLOCK0.
	// Position of KEY_PURPOSE_2_ERR field.
	EFUSE_RD_REPEAT_ERR2_KEY_PURPOSE_2_ERR_Pos = 0x0
	// Bit mask of KEY_PURPOSE_2_ERR field.
	EFUSE_RD_REPEAT_ERR2_KEY_PURPOSE_2_ERR_Msk = 0xf
	// Position of KEY_PURPOSE_3_ERR field.
	EFUSE_RD_REPEAT_ERR2_KEY_PURPOSE_3_ERR_Pos = 0x4
	// Bit mask of KEY_PURPOSE_3_ERR field.
	EFUSE_RD_REPEAT_ERR2_KEY_PURPOSE_3_ERR_Msk = 0xf0
	// Position of KEY_PURPOSE_4_ERR field.
	EFUSE_RD_REPEAT_ERR2_KEY_PURPOSE_4_ERR_Pos = 0x8
	// Bit mask of KEY_PURPOSE_4_ERR field.
	EFUSE_RD_REPEAT_ERR2_KEY_PURPOSE_4_ERR_Msk = 0xf00
	// Position of KEY_PURPOSE_5_ERR field.
	EFUSE_RD_REPEAT_ERR2_KEY_PURPOSE_5_ERR_Pos = 0xc
	// Bit mask of KEY_PURPOSE_5_ERR field.
	EFUSE_RD_REPEAT_ERR2_KEY_PURPOSE_5_ERR_Msk = 0xf000
	// Position of KEY_PURPOSE_6_ERR field.
	EFUSE_RD_REPEAT_ERR2_KEY_PURPOSE_6_ERR_Pos = 0x10
	// Bit mask of KEY_PURPOSE_6_ERR field.
	EFUSE_RD_REPEAT_ERR2_KEY_PURPOSE_6_ERR_Msk = 0xf0000
	// Position of SECURE_BOOT_EN_ERR field.
	EFUSE_RD_REPEAT_ERR2_SECURE_BOOT_EN_ERR_Pos = 0x14
	// Bit mask of SECURE_BOOT_EN_ERR field.
	EFUSE_RD_REPEAT_ERR2_SECURE_BOOT_EN_ERR_Msk = 0x100000
	// Bit SECURE_BOOT_EN_ERR.
	EFUSE_RD_REPEAT_ERR2_SECURE_BOOT_EN_ERR = 0x100000
	// Position of SECURE_BOOT_AGGRESSIVE_REVOKE_ERR field.
	EFUSE_RD_REPEAT_ERR2_SECURE_BOOT_AGGRESSIVE_REVOKE_ERR_Pos = 0x15
	// Bit mask of SECURE_BOOT_AGGRESSIVE_REVOKE_ERR field.
	EFUSE_RD_REPEAT_ERR2_SECURE_BOOT_AGGRESSIVE_REVOKE_ERR_Msk = 0x200000
	// Bit SECURE_BOOT_AGGRESSIVE_REVOKE_ERR.
	EFUSE_RD_REPEAT_ERR2_SECURE_BOOT_AGGRESSIVE_REVOKE_ERR = 0x200000
	// Position of RPT4_RESERVED1_ERR field.
	EFUSE_RD_REPEAT_ERR2_RPT4_RESERVED1_ERR_Pos = 0x16
	// Bit mask of RPT4_RESERVED1_ERR field.
	EFUSE_RD_REPEAT_ERR2_RPT4_RESERVED1_ERR_Msk = 0xfc00000
	// Position of FLASH_TPUW_ERR field.
	EFUSE_RD_REPEAT_ERR2_FLASH_TPUW_ERR_Pos = 0x1c
	// Bit mask of FLASH_TPUW_ERR field.
	EFUSE_RD_REPEAT_ERR2_FLASH_TPUW_ERR_Msk = 0xf0000000

	// RD_REPEAT_ERR3: Programming error record register 3 of BLOCK0.
	// Position of DIS_DOWNLOAD_MODE_ERR field.
	EFUSE_RD_REPEAT_ERR3_DIS_DOWNLOAD_MODE_ERR_Pos = 0x0
	// Bit mask of DIS_DOWNLOAD_MODE_ERR field.
	EFUSE_RD_REPEAT_ERR3_DIS_DOWNLOAD_MODE_ERR_Msk = 0x1
	// Bit DIS_DOWNLOAD_MODE_ERR.
	EFUSE_RD_REPEAT_ERR3_DIS_DOWNLOAD_MODE_ERR = 0x1
	// Position of DIS_LEGACY_SPI_BOOT_ERR field.
	EFUSE_RD_REPEAT_ERR3_DIS_LEGACY_SPI_BOOT_ERR_Pos = 0x1
	// Bit mask of DIS_LEGACY_SPI_BOOT_ERR field.
	EFUSE_RD_REPEAT_ERR3_DIS_LEGACY_SPI_BOOT_ERR_Msk = 0x2
	// Bit DIS_LEGACY_SPI_BOOT_ERR.
	EFUSE_RD_REPEAT_ERR3_DIS_LEGACY_SPI_BOOT_ERR = 0x2
	// Position of UART_PRINT_CHANNEL_ERR field.
	EFUSE_RD_REPEAT_ERR3_UART_PRINT_CHANNEL_ERR_Pos = 0x2
	// Bit mask of UART_PRINT_CHANNEL_ERR field.
	EFUSE_RD_REPEAT_ERR3_UART_PRINT_CHANNEL_ERR_Msk = 0x4
	// Bit UART_PRINT_CHANNEL_ERR.
	EFUSE_RD_REPEAT_ERR3_UART_PRINT_CHANNEL_ERR = 0x4
	// Position of RPT4_RESERVED3_ERR field.
	EFUSE_RD_REPEAT_ERR3_RPT4_RESERVED3_ERR_Pos = 0x3
	// Bit mask of RPT4_RESERVED3_ERR field.
	EFUSE_RD_REPEAT_ERR3_RPT4_RESERVED3_ERR_Msk = 0x8
	// Bit RPT4_RESERVED3_ERR.
	EFUSE_RD_REPEAT_ERR3_RPT4_RESERVED3_ERR = 0x8
	// Position of DIS_USB_DOWNLOAD_MODE_ERR field.
	EFUSE_RD_REPEAT_ERR3_DIS_USB_DOWNLOAD_MODE_ERR_Pos = 0x4
	// Bit mask of DIS_USB_DOWNLOAD_MODE_ERR field.
	EFUSE_RD_REPEAT_ERR3_DIS_USB_DOWNLOAD_MODE_ERR_Msk = 0x10
	// Bit DIS_USB_DOWNLOAD_MODE_ERR.
	EFUSE_RD_REPEAT_ERR3_DIS_USB_DOWNLOAD_MODE_ERR = 0x10
	// Position of ENABLE_SECURITY_DOWNLOAD_ERR field.
	EFUSE_RD_REPEAT_ERR3_ENABLE_SECURITY_DOWNLOAD_ERR_Pos = 0x5
	// Bit mask of ENABLE_SECURITY_DOWNLOAD_ERR field.
	EFUSE_RD_REPEAT_ERR3_ENABLE_SECURITY_DOWNLOAD_ERR_Msk = 0x20
	// Bit ENABLE_SECURITY_DOWNLOAD_ERR.
	EFUSE_RD_REPEAT_ERR3_ENABLE_SECURITY_DOWNLOAD_ERR = 0x20
	// Position of UART_PRINT_CONTROL_ERR field.
	EFUSE_RD_REPEAT_ERR3_UART_PRINT_CONTROL_ERR_Pos = 0x6
	// Bit mask of UART_PRINT_CONTROL_ERR field.
	EFUSE_RD_REPEAT_ERR3_UART_PRINT_CONTROL_ERR_Msk = 0xc0
	// Position of PIN_POWER_SELECTION_ERR field.
	EFUSE_RD_REPEAT_ERR3_PIN_POWER_SELECTION_ERR_Pos = 0x8
	// Bit mask of PIN_POWER_SELECTION_ERR field.
	EFUSE_RD_REPEAT_ERR3_PIN_POWER_SELECTION_ERR_Msk = 0x100
	// Bit PIN_POWER_SELECTION_ERR.
	EFUSE_RD_REPEAT_ERR3_PIN_POWER_SELECTION_ERR = 0x100
	// Position of FLASH_TYPE_ERR field.
	EFUSE_RD_REPEAT_ERR3_FLASH_TYPE_ERR_Pos = 0x9
	// Bit mask of FLASH_TYPE_ERR field.
	EFUSE_RD_REPEAT_ERR3_FLASH_TYPE_ERR_Msk = 0x200
	// Bit FLASH_TYPE_ERR.
	EFUSE_RD_REPEAT_ERR3_FLASH_TYPE_ERR = 0x200
	// Position of FORCE_SEND_RESUME_ERR field.
	EFUSE_RD_REPEAT_ERR3_FORCE_SEND_RESUME_ERR_Pos = 0xa
	// Bit mask of FORCE_SEND_RESUME_ERR field.
	EFUSE_RD_REPEAT_ERR3_FORCE_SEND_RESUME_ERR_Msk = 0x400
	// Bit FORCE_SEND_RESUME_ERR.
	EFUSE_RD_REPEAT_ERR3_FORCE_SEND_RESUME_ERR = 0x400
	// Position of SECURE_VERSION_ERR field.
	EFUSE_RD_REPEAT_ERR3_SECURE_VERSION_ERR_Pos = 0xb
	// Bit mask of SECURE_VERSION_ERR field.
	EFUSE_RD_REPEAT_ERR3_SECURE_VERSION_ERR_Msk = 0x7fff800
	// Position of RPT4_RESERVED2_ERR field.
	EFUSE_RD_REPEAT_ERR3_RPT4_RESERVED2_ERR_Pos = 0x1b
	// Bit mask of RPT4_RESERVED2_ERR field.
	EFUSE_RD_REPEAT_ERR3_RPT4_RESERVED2_ERR_Msk = 0xf8000000

	// RD_REPEAT_ERR4: Programming error record register 4 of BLOCK0.
	// Position of RPT4_RESERVED4_ERR field.
	EFUSE_RD_REPEAT_ERR4_RPT4_RESERVED4_ERR_Pos = 0x0
	// Bit mask of RPT4_RESERVED4_ERR field.
	EFUSE_RD_REPEAT_ERR4_RPT4_RESERVED4_ERR_Msk = 0xffffff

	// RD_RS_ERR0: Programming error record register 0 of BLOCK1-10.
	// Position of MAC_SPI_8M_ERR_NUM field.
	EFUSE_RD_RS_ERR0_MAC_SPI_8M_ERR_NUM_Pos = 0x0
	// Bit mask of MAC_SPI_8M_ERR_NUM field.
	EFUSE_RD_RS_ERR0_MAC_SPI_8M_ERR_NUM_Msk = 0x7
	// Position of MAC_SPI_8M_FAIL field.
	EFUSE_RD_RS_ERR0_MAC_SPI_8M_FAIL_Pos = 0x3
	// Bit mask of MAC_SPI_8M_FAIL field.
	EFUSE_RD_RS_ERR0_MAC_SPI_8M_FAIL_Msk = 0x8
	// Bit MAC_SPI_8M_FAIL.
	EFUSE_RD_RS_ERR0_MAC_SPI_8M_FAIL = 0x8
	// Position of SYS_PART1_NUM field.
	EFUSE_RD_RS_ERR0_SYS_PART1_NUM_Pos = 0x4
	// Bit mask of SYS_PART1_NUM field.
	EFUSE_RD_RS_ERR0_SYS_PART1_NUM_Msk = 0x70
	// Position of SYS_PART1_FAIL field.
	EFUSE_RD_RS_ERR0_SYS_PART1_FAIL_Pos = 0x7
	// Bit mask of SYS_PART1_FAIL field.
	EFUSE_RD_RS_ERR0_SYS_PART1_FAIL_Msk = 0x80
	// Bit SYS_PART1_FAIL.
	EFUSE_RD_RS_ERR0_SYS_PART1_FAIL = 0x80
	// Position of USR_DATA_ERR_NUM field.
	EFUSE_RD_RS_ERR0_USR_DATA_ERR_NUM_Pos = 0x8
	// Bit mask of USR_DATA_ERR_NUM field.
	EFUSE_RD_RS_ERR0_USR_DATA_ERR_NUM_Msk = 0x700
	// Position of USR_DATA_FAIL field.
	EFUSE_RD_RS_ERR0_USR_DATA_FAIL_Pos = 0xb
	// Bit mask of USR_DATA_FAIL field.
	EFUSE_RD_RS_ERR0_USR_DATA_FAIL_Msk = 0x800
	// Bit USR_DATA_FAIL.
	EFUSE_RD_RS_ERR0_USR_DATA_FAIL = 0x800
	// Position of KEY0_ERR_NUM field.
	EFUSE_RD_RS_ERR0_KEY0_ERR_NUM_Pos = 0xc
	// Bit mask of KEY0_ERR_NUM field.
	EFUSE_RD_RS_ERR0_KEY0_ERR_NUM_Msk = 0x7000
	// Position of KEY0_FAIL field.
	EFUSE_RD_RS_ERR0_KEY0_FAIL_Pos = 0xf
	// Bit mask of KEY0_FAIL field.
	EFUSE_RD_RS_ERR0_KEY0_FAIL_Msk = 0x8000
	// Bit KEY0_FAIL.
	EFUSE_RD_RS_ERR0_KEY0_FAIL = 0x8000
	// Position of KEY1_ERR_NUM field.
	EFUSE_RD_RS_ERR0_KEY1_ERR_NUM_Pos = 0x10
	// Bit mask of KEY1_ERR_NUM field.
	EFUSE_RD_RS_ERR0_KEY1_ERR_NUM_Msk = 0x70000
	// Position of KEY1_FAIL field.
	EFUSE_RD_RS_ERR0_KEY1_FAIL_Pos = 0x13
	// Bit mask of KEY1_FAIL field.
	EFUSE_RD_RS_ERR0_KEY1_FAIL_Msk = 0x80000
	// Bit KEY1_FAIL.
	EFUSE_RD_RS_ERR0_KEY1_FAIL = 0x80000
	// Position of KEY2_ERR_NUM field.
	EFUSE_RD_RS_ERR0_KEY2_ERR_NUM_Pos = 0x14
	// Bit mask of KEY2_ERR_NUM field.
	EFUSE_RD_RS_ERR0_KEY2_ERR_NUM_Msk = 0x700000
	// Position of KEY2_FAIL field.
	EFUSE_RD_RS_ERR0_KEY2_FAIL_Pos = 0x17
	// Bit mask of KEY2_FAIL field.
	EFUSE_RD_RS_ERR0_KEY2_FAIL_Msk = 0x800000
	// Bit KEY2_FAIL.
	EFUSE_RD_RS_ERR0_KEY2_FAIL = 0x800000
	// Position of KEY3_ERR_NUM field.
	EFUSE_RD_RS_ERR0_KEY3_ERR_NUM_Pos = 0x18
	// Bit mask of KEY3_ERR_NUM field.
	EFUSE_RD_RS_ERR0_KEY3_ERR_NUM_Msk = 0x7000000
	// Position of KEY3_FAIL field.
	EFUSE_RD_RS_ERR0_KEY3_FAIL_Pos = 0x1b
	// Bit mask of KEY3_FAIL field.
	EFUSE_RD_RS_ERR0_KEY3_FAIL_Msk = 0x8000000
	// Bit KEY3_FAIL.
	EFUSE_RD_RS_ERR0_KEY3_FAIL = 0x8000000
	// Position of KEY4_ERR_NUM field.
	EFUSE_RD_RS_ERR0_KEY4_ERR_NUM_Pos = 0x1c
	// Bit mask of KEY4_ERR_NUM field.
	EFUSE_RD_RS_ERR0_KEY4_ERR_NUM_Msk = 0x70000000
	// Position of KEY4_FAIL field.
	EFUSE_RD_RS_ERR0_KEY4_FAIL_Pos = 0x1f
	// Bit mask of KEY4_FAIL field.
	EFUSE_RD_RS_ERR0_KEY4_FAIL_Msk = 0x80000000
	// Bit KEY4_FAIL.
	EFUSE_RD_RS_ERR0_KEY4_FAIL = 0x80000000

	// RD_RS_ERR1: Programming error record register 1 of BLOCK1-10.
	// Position of KEY5_ERR_NUM field.
	EFUSE_RD_RS_ERR1_KEY5_ERR_NUM_Pos = 0x0
	// Bit mask of KEY5_ERR_NUM field.
	EFUSE_RD_RS_ERR1_KEY5_ERR_NUM_Msk = 0x7
	// Position of KEY5_FAIL field.
	EFUSE_RD_RS_ERR1_KEY5_FAIL_Pos = 0x3
	// Bit mask of KEY5_FAIL field.
	EFUSE_RD_RS_ERR1_KEY5_FAIL_Msk = 0x8
	// Bit KEY5_FAIL.
	EFUSE_RD_RS_ERR1_KEY5_FAIL = 0x8
	// Position of SYS_PART2_ERR_NUM field.
	EFUSE_RD_RS_ERR1_SYS_PART2_ERR_NUM_Pos = 0x4
	// Bit mask of SYS_PART2_ERR_NUM field.
	EFUSE_RD_RS_ERR1_SYS_PART2_ERR_NUM_Msk = 0x70
	// Position of SYS_PART2_FAIL field.
	EFUSE_RD_RS_ERR1_SYS_PART2_FAIL_Pos = 0x7
	// Bit mask of SYS_PART2_FAIL field.
	EFUSE_RD_RS_ERR1_SYS_PART2_FAIL_Msk = 0x80
	// Bit SYS_PART2_FAIL.
	EFUSE_RD_RS_ERR1_SYS_PART2_FAIL = 0x80

	// CLK: eFuse clock configuration register.
	// Position of EFUSE_MEM_FORCE_PD field.
	EFUSE_CLK_EFUSE_MEM_FORCE_PD_Pos = 0x0
	// Bit mask of EFUSE_MEM_FORCE_PD field.
	EFUSE_CLK_EFUSE_MEM_FORCE_PD_Msk = 0x1
	// Bit EFUSE_MEM_FORCE_PD.
	EFUSE_CLK_EFUSE_MEM_FORCE_PD = 0x1
	// Position of MEM_CLK_FORCE_ON field.
	EFUSE_CLK_MEM_CLK_FORCE_ON_Pos = 0x1
	// Bit mask of MEM_CLK_FORCE_ON field.
	EFUSE_CLK_MEM_CLK_FORCE_ON_Msk = 0x2
	// Bit MEM_CLK_FORCE_ON.
	EFUSE_CLK_MEM_CLK_FORCE_ON = 0x2
	// Position of EFUSE_MEM_FORCE_PU field.
	EFUSE_CLK_EFUSE_MEM_FORCE_PU_Pos = 0x2
	// Bit mask of EFUSE_MEM_FORCE_PU field.
	EFUSE_CLK_EFUSE_MEM_FORCE_PU_Msk = 0x4
	// Bit EFUSE_MEM_FORCE_PU.
	EFUSE_CLK_EFUSE_MEM_FORCE_PU = 0x4
	// Position of EN field.
	EFUSE_CLK_EN_Pos = 0x10
	// Bit mask of EN field.
	EFUSE_CLK_EN_Msk = 0x10000
	// Bit EN.
	EFUSE_CLK_EN = 0x10000

	// CONF: eFuse operation mode configuration register.
	// Position of OP_CODE field.
	EFUSE_CONF_OP_CODE_Pos = 0x0
	// Bit mask of OP_CODE field.
	EFUSE_CONF_OP_CODE_Msk = 0xffff

	// STATUS: eFuse status register.
	// Position of STATE field.
	EFUSE_STATUS_STATE_Pos = 0x0
	// Bit mask of STATE field.
	EFUSE_STATUS_STATE_Msk = 0xf
	// Position of OTP_LOAD_SW field.
	EFUSE_STATUS_OTP_LOAD_SW_Pos = 0x4
	// Bit mask of OTP_LOAD_SW field.
	EFUSE_STATUS_OTP_LOAD_SW_Msk = 0x10
	// Bit OTP_LOAD_SW.
	EFUSE_STATUS_OTP_LOAD_SW = 0x10
	// Position of OTP_VDDQ_C_SYNC2 field.
	EFUSE_STATUS_OTP_VDDQ_C_SYNC2_Pos = 0x5
	// Bit mask of OTP_VDDQ_C_SYNC2 field.
	EFUSE_STATUS_OTP_VDDQ_C_SYNC2_Msk = 0x20
	// Bit OTP_VDDQ_C_SYNC2.
	EFUSE_STATUS_OTP_VDDQ_C_SYNC2 = 0x20
	// Position of OTP_STROBE_SW field.
	EFUSE_STATUS_OTP_STROBE_SW_Pos = 0x6
	// Bit mask of OTP_STROBE_SW field.
	EFUSE_STATUS_OTP_STROBE_SW_Msk = 0x40
	// Bit OTP_STROBE_SW.
	EFUSE_STATUS_OTP_STROBE_SW = 0x40
	// Position of OTP_CSB_SW field.
	EFUSE_STATUS_OTP_CSB_SW_Pos = 0x7
	// Bit mask of OTP_CSB_SW field.
	EFUSE_STATUS_OTP_CSB_SW_Msk = 0x80
	// Bit OTP_CSB_SW.
	EFUSE_STATUS_OTP_CSB_SW = 0x80
	// Position of OTP_PGENB_SW field.
	EFUSE_STATUS_OTP_PGENB_SW_Pos = 0x8
	// Bit mask of OTP_PGENB_SW field.
	EFUSE_STATUS_OTP_PGENB_SW_Msk = 0x100
	// Bit OTP_PGENB_SW.
	EFUSE_STATUS_OTP_PGENB_SW = 0x100
	// Position of OTP_VDDQ_IS_SW field.
	EFUSE_STATUS_OTP_VDDQ_IS_SW_Pos = 0x9
	// Bit mask of OTP_VDDQ_IS_SW field.
	EFUSE_STATUS_OTP_VDDQ_IS_SW_Msk = 0x200
	// Bit OTP_VDDQ_IS_SW.
	EFUSE_STATUS_OTP_VDDQ_IS_SW = 0x200
	// Position of REPEAT_ERR_CNT field.
	EFUSE_STATUS_REPEAT_ERR_CNT_Pos = 0xa
	// Bit mask of REPEAT_ERR_CNT field.
	EFUSE_STATUS_REPEAT_ERR_CNT_Msk = 0x3fc00

	// CMD: eFuse command register.
	// Position of READ_CMD field.
	EFUSE_CMD_READ_CMD_Pos = 0x0
	// Bit mask of READ_CMD field.
	EFUSE_CMD_READ_CMD_Msk = 0x1
	// Bit READ_CMD.
	EFUSE_CMD_READ_CMD = 0x1
	// Position of PGM_CMD field.
	EFUSE_CMD_PGM_CMD_Pos = 0x1
	// Bit mask of PGM_CMD field.
	EFUSE_CMD_PGM_CMD_Msk = 0x2
	// Bit PGM_CMD.
	EFUSE_CMD_PGM_CMD = 0x2
	// Position of BLK_NUM field.
	EFUSE_CMD_BLK_NUM_Pos = 0x2
	// Bit mask of BLK_NUM field.
	EFUSE_CMD_BLK_NUM_Msk = 0x3c

	// INT_RAW: eFuse raw interrupt register.
	// Position of READ_DONE_INT_RAW field.
	EFUSE_INT_RAW_READ_DONE_INT_RAW_Pos = 0x0
	// Bit mask of READ_DONE_INT_RAW field.
	EFUSE_INT_RAW_READ_DONE_INT_RAW_Msk = 0x1
	// Bit READ_DONE_INT_RAW.
	EFUSE_INT_RAW_READ_DONE_INT_RAW = 0x1
	// Position of PGM_DONE_INT_RAW field.
	EFUSE_INT_RAW_PGM_DONE_INT_RAW_Pos = 0x1
	// Bit mask of PGM_DONE_INT_RAW field.
	EFUSE_INT_RAW_PGM_DONE_INT_RAW_Msk = 0x2
	// Bit PGM_DONE_INT_RAW.
	EFUSE_INT_RAW_PGM_DONE_INT_RAW = 0x2

	// INT_ST: eFuse interrupt status register.
	// Position of READ_DONE_INT_ST field.
	EFUSE_INT_ST_READ_DONE_INT_ST_Pos = 0x0
	// Bit mask of READ_DONE_INT_ST field.
	EFUSE_INT_ST_READ_DONE_INT_ST_Msk = 0x1
	// Bit READ_DONE_INT_ST.
	EFUSE_INT_ST_READ_DONE_INT_ST = 0x1
	// Position of PGM_DONE_INT_ST field.
	EFUSE_INT_ST_PGM_DONE_INT_ST_Pos = 0x1
	// Bit mask of PGM_DONE_INT_ST field.
	EFUSE_INT_ST_PGM_DONE_INT_ST_Msk = 0x2
	// Bit PGM_DONE_INT_ST.
	EFUSE_INT_ST_PGM_DONE_INT_ST = 0x2

	// INT_ENA: eFuse interrupt enable register.
	// Position of READ_DONE_INT_ENA field.
	EFUSE_INT_ENA_READ_DONE_INT_ENA_Pos = 0x0
	// Bit mask of READ_DONE_INT_ENA field.
	EFUSE_INT_ENA_READ_DONE_INT_ENA_Msk = 0x1
	// Bit READ_DONE_INT_ENA.
	EFUSE_INT_ENA_READ_DONE_INT_ENA = 0x1
	// Position of PGM_DONE_INT_ENA field.
	EFUSE_INT_ENA_PGM_DONE_INT_ENA_Pos = 0x1
	// Bit mask of PGM_DONE_INT_ENA field.
	EFUSE_INT_ENA_PGM_DONE_INT_ENA_Msk = 0x2
	// Bit PGM_DONE_INT_ENA.
	EFUSE_INT_ENA_PGM_DONE_INT_ENA = 0x2

	// INT_CLR: eFuse interrupt clear register.
	// Position of READ_DONE_INT_CLR field.
	EFUSE_INT_CLR_READ_DONE_INT_CLR_Pos = 0x0
	// Bit mask of READ_DONE_INT_CLR field.
	EFUSE_INT_CLR_READ_DONE_INT_CLR_Msk = 0x1
	// Bit READ_DONE_INT_CLR.
	EFUSE_INT_CLR_READ_DONE_INT_CLR = 0x1
	// Position of PGM_DONE_INT_CLR field.
	EFUSE_INT_CLR_PGM_DONE_INT_CLR_Pos = 0x1
	// Bit mask of PGM_DONE_INT_CLR field.
	EFUSE_INT_CLR_PGM_DONE_INT_CLR_Msk = 0x2
	// Bit PGM_DONE_INT_CLR.
	EFUSE_INT_CLR_PGM_DONE_INT_CLR = 0x2

	// DAC_CONF: Controls the eFuse programming voltage.
	// Position of DAC_CLK_DIV field.
	EFUSE_DAC_CONF_DAC_CLK_DIV_Pos = 0x0
	// Bit mask of DAC_CLK_DIV field.
	EFUSE_DAC_CONF_DAC_CLK_DIV_Msk = 0xff
	// Position of DAC_CLK_PAD_SEL field.
	EFUSE_DAC_CONF_DAC_CLK_PAD_SEL_Pos = 0x8
	// Bit mask of DAC_CLK_PAD_SEL field.
	EFUSE_DAC_CONF_DAC_CLK_PAD_SEL_Msk = 0x100
	// Bit DAC_CLK_PAD_SEL.
	EFUSE_DAC_CONF_DAC_CLK_PAD_SEL = 0x100
	// Position of DAC_NUM field.
	EFUSE_DAC_CONF_DAC_NUM_Pos = 0x9
	// Bit mask of DAC_NUM field.
	EFUSE_DAC_CONF_DAC_NUM_Msk = 0x1fe00
	// Position of OE_CLR field.
	EFUSE_DAC_CONF_OE_CLR_Pos = 0x11
	// Bit mask of OE_CLR field.
	EFUSE_DAC_CONF_OE_CLR_Msk = 0x20000
	// Bit OE_CLR.
	EFUSE_DAC_CONF_OE_CLR = 0x20000

	// RD_TIM_CONF: Configures read timing parameters.
	// Position of THR_A field.
	EFUSE_RD_TIM_CONF_THR_A_Pos = 0x0
	// Bit mask of THR_A field.
	EFUSE_RD_TIM_CONF_THR_A_Msk = 0xff
	// Position of TRD field.
	EFUSE_RD_TIM_CONF_TRD_Pos = 0x8
	// Bit mask of TRD field.
	EFUSE_RD_TIM_CONF_TRD_Msk = 0xff00
	// Position of TSUR_A field.
	EFUSE_RD_TIM_CONF_TSUR_A_Pos = 0x10
	// Bit mask of TSUR_A field.
	EFUSE_RD_TIM_CONF_TSUR_A_Msk = 0xff0000
	// Position of READ_INIT_NUM field.
	EFUSE_RD_TIM_CONF_READ_INIT_NUM_Pos = 0x18
	// Bit mask of READ_INIT_NUM field.
	EFUSE_RD_TIM_CONF_READ_INIT_NUM_Msk = 0xff000000

	// WR_TIM_CONF0: Configuration register 0 of eFuse programming timing parameters.
	// Position of THP_A field.
	EFUSE_WR_TIM_CONF0_THP_A_Pos = 0x0
	// Bit mask of THP_A field.
	EFUSE_WR_TIM_CONF0_THP_A_Msk = 0xff
	// Position of TPGM_INACTIVE field.
	EFUSE_WR_TIM_CONF0_TPGM_INACTIVE_Pos = 0x8
	// Bit mask of TPGM_INACTIVE field.
	EFUSE_WR_TIM_CONF0_TPGM_INACTIVE_Msk = 0xff00
	// Position of TPGM field.
	EFUSE_WR_TIM_CONF0_TPGM_Pos = 0x10
	// Bit mask of TPGM field.
	EFUSE_WR_TIM_CONF0_TPGM_Msk = 0xffff0000

	// WR_TIM_CONF1: Configuration register 1 of eFuse programming timing parameters.
	// Position of TSUP_A field.
	EFUSE_WR_TIM_CONF1_TSUP_A_Pos = 0x0
	// Bit mask of TSUP_A field.
	EFUSE_WR_TIM_CONF1_TSUP_A_Msk = 0xff
	// Position of PWR_ON_NUM field.
	EFUSE_WR_TIM_CONF1_PWR_ON_NUM_Pos = 0x8
	// Bit mask of PWR_ON_NUM field.
	EFUSE_WR_TIM_CONF1_PWR_ON_NUM_Msk = 0xffff00

	// WR_TIM_CONF2: Configuration register 2 of eFuse programming timing parameters.
	// Position of PWR_OFF_NUM field.
	EFUSE_WR_TIM_CONF2_PWR_OFF_NUM_Pos = 0x0
	// Bit mask of PWR_OFF_NUM field.
	EFUSE_WR_TIM_CONF2_PWR_OFF_NUM_Msk = 0xffff

	// DATE: Version control register.
	// Position of DATE field.
	EFUSE_DATE_DATE_Pos = 0x0
	// Bit mask of DATE field.
	EFUSE_DATE_DATE_Msk = 0xffffffff
)

// Constants for GPIO: Peripheral GPIO
const (
	// BT_SELECT: GPIO bit select register
	// Position of BT_SEL field.
	GPIO_BT_SELECT_BT_SEL_Pos = 0x0
	// Bit mask of BT_SEL field.
	GPIO_BT_SELECT_BT_SEL_Msk = 0xffffffff

	// OUT: GPIO0 ~ 31 output register
	// Position of DATA_ORIG field.
	GPIO_OUT_DATA_ORIG_Pos = 0x0
	// Bit mask of DATA_ORIG field.
	GPIO_OUT_DATA_ORIG_Msk = 0xffffffff

	// OUT_W1TS: GPIO0 ~ 31 output bit set register
	// Position of OUT_W1TS field.
	GPIO_OUT_W1TS_OUT_W1TS_Pos = 0x0
	// Bit mask of OUT_W1TS field.
	GPIO_OUT_W1TS_OUT_W1TS_Msk = 0xffffffff

	// OUT_W1TC: GPIO0 ~ 31 output bit clear register
	// Position of OUT_W1TC field.
	GPIO_OUT_W1TC_OUT_W1TC_Pos = 0x0
	// Bit mask of OUT_W1TC field.
	GPIO_OUT_W1TC_OUT_W1TC_Msk = 0xffffffff

	// OUT1: GPIO32 ~ 53 output register
	// Position of DATA_ORIG field.
	GPIO_OUT1_DATA_ORIG_Pos = 0x0
	// Bit mask of DATA_ORIG field.
	GPIO_OUT1_DATA_ORIG_Msk = 0x3fffff

	// OUT1_W1TS: GPIO32 ~ 53 output bit set register
	// Position of OUT1_W1TS field.
	GPIO_OUT1_W1TS_OUT1_W1TS_Pos = 0x0
	// Bit mask of OUT1_W1TS field.
	GPIO_OUT1_W1TS_OUT1_W1TS_Msk = 0x3fffff

	// OUT1_W1TC: GPIO32 ~ 53 output bit clear register
	// Position of OUT1_W1TC field.
	GPIO_OUT1_W1TC_OUT1_W1TC_Pos = 0x0
	// Bit mask of OUT1_W1TC field.
	GPIO_OUT1_W1TC_OUT1_W1TC_Msk = 0x3fffff

	// SDIO_SELECT: GPIO SDIO selection register
	// Position of SDIO_SEL field.
	GPIO_SDIO_SELECT_SDIO_SEL_Pos = 0x0
	// Bit mask of SDIO_SEL field.
	GPIO_SDIO_SELECT_SDIO_SEL_Msk = 0xff

	// ENABLE: GPIO0 ~ 31 output enable register
	// Position of DATA field.
	GPIO_ENABLE_DATA_Pos = 0x0
	// Bit mask of DATA field.
	GPIO_ENABLE_DATA_Msk = 0xffffffff

	// ENABLE_W1TS: GPIO0 ~ 31 output enable bit set register
	// Position of ENABLE_W1TS field.
	GPIO_ENABLE_W1TS_ENABLE_W1TS_Pos = 0x0
	// Bit mask of ENABLE_W1TS field.
	GPIO_ENABLE_W1TS_ENABLE_W1TS_Msk = 0xffffffff

	// ENABLE_W1TC: GPIO0 ~ 31 output enable bit clear register
	// Position of ENABLE_W1TC field.
	GPIO_ENABLE_W1TC_ENABLE_W1TC_Pos = 0x0
	// Bit mask of ENABLE_W1TC field.
	GPIO_ENABLE_W1TC_ENABLE_W1TC_Msk = 0xffffffff

	// ENABLE1: GPIO32 ~ 53 output enable register
	// Position of DATA field.
	GPIO_ENABLE1_DATA_Pos = 0x0
	// Bit mask of DATA field.
	GPIO_ENABLE1_DATA_Msk = 0x3fffff

	// ENABLE1_W1TS: GPIO32 ~ 53 output enable bit set register
	// Position of ENABLE1_W1TS field.
	GPIO_ENABLE1_W1TS_ENABLE1_W1TS_Pos = 0x0
	// Bit mask of ENABLE1_W1TS field.
	GPIO_ENABLE1_W1TS_ENABLE1_W1TS_Msk = 0x3fffff

	// ENABLE1_W1TC: GPIO32 ~ 53 output enable bit clear register
	// Position of ENABLE1_W1TC field.
	GPIO_ENABLE1_W1TC_ENABLE1_W1TC_Pos = 0x0
	// Bit mask of ENABLE1_W1TC field.
	GPIO_ENABLE1_W1TC_ENABLE1_W1TC_Msk = 0x3fffff

	// STRAP: Bootstrap pin value register
	// Position of STRAPPING field.
	GPIO_STRAP_STRAPPING_Pos = 0x0
	// Bit mask of STRAPPING field.
	GPIO_STRAP_STRAPPING_Msk = 0xffff

	// IN: GPIO0 ~ 31 input register
	// Position of DATA_NEXT field.
	GPIO_IN_DATA_NEXT_Pos = 0x0
	// Bit mask of DATA_NEXT field.
	GPIO_IN_DATA_NEXT_Msk = 0xffffffff

	// IN1: GPIO32 ~ 53 input register
	// Position of IN_DATA1_NEXT field.
	GPIO_IN1_IN_DATA1_NEXT_Pos = 0x0
	// Bit mask of IN_DATA1_NEXT field.
	GPIO_IN1_IN_DATA1_NEXT_Msk = 0x3fffff

	// STATUS: GPIO0 ~ 31 interrupt status register
	// Position of INTERRUPT field.
	GPIO_STATUS_INTERRUPT_Pos = 0x0
	// Bit mask of INTERRUPT field.
	GPIO_STATUS_INTERRUPT_Msk = 0xffffffff

	// STATUS_W1TS: GPIO0 ~ 31 interrupt status bit set register
	// Position of STATUS_W1TS field.
	GPIO_STATUS_W1TS_STATUS_W1TS_Pos = 0x0
	// Bit mask of STATUS_W1TS field.
	GPIO_STATUS_W1TS_STATUS_W1TS_Msk = 0xffffffff

	// STATUS_W1TC: GPIO0 ~ 31 interrupt status bit clear register
	// Position of STATUS_W1TC field.
	GPIO_STATUS_W1TC_STATUS_W1TC_Pos = 0x0
	// Bit mask of STATUS_W1TC field.
	GPIO_STATUS_W1TC_STATUS_W1TC_Msk = 0xffffffff

	// STATUS1: GPIO32 ~ 53 interrupt status register
	// Position of INTERRUPT field.
	GPIO_STATUS1_INTERRUPT_Pos = 0x0
	// Bit mask of INTERRUPT field.
	GPIO_STATUS1_INTERRUPT_Msk = 0x3fffff

	// STATUS1_W1TS: GPIO32 ~ 53 interrupt status bit set register
	// Position of STATUS1_W1TS field.
	GPIO_STATUS1_W1TS_STATUS1_W1TS_Pos = 0x0
	// Bit mask of STATUS1_W1TS field.
	GPIO_STATUS1_W1TS_STATUS1_W1TS_Msk = 0x3fffff

	// STATUS1_W1TC: GPIO32 ~ 53 interrupt status bit clear register
	// Position of STATUS1_W1TC field.
	GPIO_STATUS1_W1TC_STATUS1_W1TC_Pos = 0x0
	// Bit mask of STATUS1_W1TC field.
	GPIO_STATUS1_W1TC_STATUS1_W1TC_Msk = 0x3fffff

	// PCPU_INT: GPIO0 ~ 31 PRO_CPU interrupt status register
	// Position of PROCPU_INT field.
	GPIO_PCPU_INT_PROCPU_INT_Pos = 0x0
	// Bit mask of PROCPU_INT field.
	GPIO_PCPU_INT_PROCPU_INT_Msk = 0xffffffff

	// PCPU_NMI_INT: GPIO0 ~ 31 PRO_CPU non-maskable interrupt status register
	// Position of PROCPU_NMI_INT field.
	GPIO_PCPU_NMI_INT_PROCPU_NMI_INT_Pos = 0x0
	// Bit mask of PROCPU_NMI_INT field.
	GPIO_PCPU_NMI_INT_PROCPU_NMI_INT_Msk = 0xffffffff

	// CPUSDIO_INT: GPIO0 ~ 31 CPU SDIO interrupt status register
	// Position of SDIO_INT field.
	GPIO_CPUSDIO_INT_SDIO_INT_Pos = 0x0
	// Bit mask of SDIO_INT field.
	GPIO_CPUSDIO_INT_SDIO_INT_Msk = 0xffffffff

	// PCPU_INT1: GPIO32 ~ 53 PRO_CPU interrupt status register
	// Position of PROCPU1_INT field.
	GPIO_PCPU_INT1_PROCPU1_INT_Pos = 0x0
	// Bit mask of PROCPU1_INT field.
	GPIO_PCPU_INT1_PROCPU1_INT_Msk = 0x3fffff

	// PCPU_NMI_INT1: GPIO32 ~ 53 PRO_CPU non-maskable interrupt status register
	// Position of PROCPU_NMI1_INT field.
	GPIO_PCPU_NMI_INT1_PROCPU_NMI1_INT_Pos = 0x0
	// Bit mask of PROCPU_NMI1_INT field.
	GPIO_PCPU_NMI_INT1_PROCPU_NMI1_INT_Msk = 0x3fffff

	// CPUSDIO_INT1: GPIO32 ~ 53 CPU SDIO interrupt status register
	// Position of SDIO1_INT field.
	GPIO_CPUSDIO_INT1_SDIO1_INT_Pos = 0x0
	// Bit mask of SDIO1_INT field.
	GPIO_CPUSDIO_INT1_SDIO1_INT_Msk = 0x3fffff

	// PIN0: Configuration for GPIO pin %s
	// Position of PIN0_SYNC2_BYPASS field.
	GPIO_PIN_PIN0_SYNC2_BYPASS_Pos = 0x0
	// Bit mask of PIN0_SYNC2_BYPASS field.
	GPIO_PIN_PIN0_SYNC2_BYPASS_Msk = 0x3
	// Position of PIN0_PAD_DRIVER field.
	GPIO_PIN_PIN0_PAD_DRIVER_Pos = 0x2
	// Bit mask of PIN0_PAD_DRIVER field.
	GPIO_PIN_PIN0_PAD_DRIVER_Msk = 0x4
	// Bit PIN0_PAD_DRIVER.
	GPIO_PIN_PIN0_PAD_DRIVER = 0x4
	// Position of PIN0_SYNC1_BYPASS field.
	GPIO_PIN_PIN0_SYNC1_BYPASS_Pos = 0x3
	// Bit mask of PIN0_SYNC1_BYPASS field.
	GPIO_PIN_PIN0_SYNC1_BYPASS_Msk = 0x18
	// Position of PIN0_INT_TYPE field.
	GPIO_PIN_PIN0_INT_TYPE_Pos = 0x7
	// Bit mask of PIN0_INT_TYPE field.
	GPIO_PIN_PIN0_INT_TYPE_Msk = 0x380
	// Position of PIN0_WAKEUP_ENABLE field.
	GPIO_PIN_PIN0_WAKEUP_ENABLE_Pos = 0xa
	// Bit mask of PIN0_WAKEUP_ENABLE field.
	GPIO_PIN_PIN0_WAKEUP_ENABLE_Msk = 0x400
	// Bit PIN0_WAKEUP_ENABLE.
	GPIO_PIN_PIN0_WAKEUP_ENABLE = 0x400
	// Position of PIN0_CONFIG field.
	GPIO_PIN_PIN0_CONFIG_Pos = 0xb
	// Bit mask of PIN0_CONFIG field.
	GPIO_PIN_PIN0_CONFIG_Msk = 0x1800
	// Position of PIN0_INT_ENA field.
	GPIO_PIN_PIN0_INT_ENA_Pos = 0xd
	// Bit mask of PIN0_INT_ENA field.
	GPIO_PIN_PIN0_INT_ENA_Msk = 0x3e000

	// STATUS_NEXT: GPIO0 ~ 31 interrupt source register
	// Position of STATUS_INTERRUPT_NEXT field.
	GPIO_STATUS_NEXT_STATUS_INTERRUPT_NEXT_Pos = 0x0
	// Bit mask of STATUS_INTERRUPT_NEXT field.
	GPIO_STATUS_NEXT_STATUS_INTERRUPT_NEXT_Msk = 0xffffffff

	// STATUS_NEXT1: GPIO32 ~ 53 interrupt source register
	// Position of STATUS1_INTERRUPT_NEXT field.
	GPIO_STATUS_NEXT1_STATUS1_INTERRUPT_NEXT_Pos = 0x0
	// Bit mask of STATUS1_INTERRUPT_NEXT field.
	GPIO_STATUS_NEXT1_STATUS1_INTERRUPT_NEXT_Msk = 0x3fffff

	// FUNC0_IN_SEL_CFG: Peripheral function %s input selection register
	// Position of FUNC0_IN_SEL field.
	GPIO_FUNC_IN_SEL_CFG_FUNC0_IN_SEL_Pos = 0x0
	// Bit mask of FUNC0_IN_SEL field.
	GPIO_FUNC_IN_SEL_CFG_FUNC0_IN_SEL_Msk = 0x3f
	// Position of FUNC0_IN_INV_SEL field.
	GPIO_FUNC_IN_SEL_CFG_FUNC0_IN_INV_SEL_Pos = 0x6
	// Bit mask of FUNC0_IN_INV_SEL field.
	GPIO_FUNC_IN_SEL_CFG_FUNC0_IN_INV_SEL_Msk = 0x40
	// Bit FUNC0_IN_INV_SEL.
	GPIO_FUNC_IN_SEL_CFG_FUNC0_IN_INV_SEL = 0x40
	// Position of SIG0_IN_SEL field.
	GPIO_FUNC_IN_SEL_CFG_SIG0_IN_SEL_Pos = 0x7
	// Bit mask of SIG0_IN_SEL field.
	GPIO_FUNC_IN_SEL_CFG_SIG0_IN_SEL_Msk = 0x80
	// Bit SIG0_IN_SEL.
	GPIO_FUNC_IN_SEL_CFG_SIG0_IN_SEL = 0x80

	// FUNC0_OUT_SEL_CFG: Peripheral output selection for GPIO %s
	// Position of FUNC0_OUT_SEL field.
	GPIO_FUNC_OUT_SEL_CFG_FUNC0_OUT_SEL_Pos = 0x0
	// Bit mask of FUNC0_OUT_SEL field.
	GPIO_FUNC_OUT_SEL_CFG_FUNC0_OUT_SEL_Msk = 0x1ff
	// Position of FUNC0_OUT_INV_SEL field.
	GPIO_FUNC_OUT_SEL_CFG_FUNC0_OUT_INV_SEL_Pos = 0x9
	// Bit mask of FUNC0_OUT_INV_SEL field.
	GPIO_FUNC_OUT_SEL_CFG_FUNC0_OUT_INV_SEL_Msk = 0x200
	// Bit FUNC0_OUT_INV_SEL.
	GPIO_FUNC_OUT_SEL_CFG_FUNC0_OUT_INV_SEL = 0x200
	// Position of FUNC0_OEN_SEL field.
	GPIO_FUNC_OUT_SEL_CFG_FUNC0_OEN_SEL_Pos = 0xa
	// Bit mask of FUNC0_OEN_SEL field.
	GPIO_FUNC_OUT_SEL_CFG_FUNC0_OEN_SEL_Msk = 0x400
	// Bit FUNC0_OEN_SEL.
	GPIO_FUNC_OUT_SEL_CFG_FUNC0_OEN_SEL = 0x400
	// Position of FUNC0_OEN_INV_SEL field.
	GPIO_FUNC_OUT_SEL_CFG_FUNC0_OEN_INV_SEL_Pos = 0xb
	// Bit mask of FUNC0_OEN_INV_SEL field.
	GPIO_FUNC_OUT_SEL_CFG_FUNC0_OEN_INV_SEL_Msk = 0x800
	// Bit FUNC0_OEN_INV_SEL.
	GPIO_FUNC_OUT_SEL_CFG_FUNC0_OEN_INV_SEL = 0x800

	// CLOCK_GATE: GPIO clock gating register
	// Position of CLK_EN field.
	GPIO_CLOCK_GATE_CLK_EN_Pos = 0x0
	// Bit mask of CLK_EN field.
	GPIO_CLOCK_GATE_CLK_EN_Msk = 0x1
	// Bit CLK_EN.
	GPIO_CLOCK_GATE_CLK_EN = 0x1

	// REG_DATE: Version control register
	// Position of DATE field.
	GPIO_REG_DATE_DATE_Pos = 0x0
	// Bit mask of DATE field.
	GPIO_REG_DATE_DATE_Msk = 0xfffffff
)

// Constants for GPIO_SD: Peripheral GPIO_SD
const (
	// SIGMADELTA0: Duty Cycle Configure Register of SDM%s
	// Position of SD0_IN field.
	GPIO_SD_SIGMADELTA_SD0_IN_Pos = 0x0
	// Bit mask of SD0_IN field.
	GPIO_SD_SIGMADELTA_SD0_IN_Msk = 0xff
	// Position of SD0_PRESCALE field.
	GPIO_SD_SIGMADELTA_SD0_PRESCALE_Pos = 0x8
	// Bit mask of SD0_PRESCALE field.
	GPIO_SD_SIGMADELTA_SD0_PRESCALE_Msk = 0xff00

	// SIGMADELTA_CG: Clock Gating Configure Register
	// Position of CLK_EN field.
	GPIO_SD_SIGMADELTA_CG_CLK_EN_Pos = 0x1f
	// Bit mask of CLK_EN field.
	GPIO_SD_SIGMADELTA_CG_CLK_EN_Msk = 0x80000000
	// Bit CLK_EN.
	GPIO_SD_SIGMADELTA_CG_CLK_EN = 0x80000000

	// SIGMADELTA_MISC: MISC Register
	// Position of FUNCTION_CLK_EN field.
	GPIO_SD_SIGMADELTA_MISC_FUNCTION_CLK_EN_Pos = 0x1e
	// Bit mask of FUNCTION_CLK_EN field.
	GPIO_SD_SIGMADELTA_MISC_FUNCTION_CLK_EN_Msk = 0x40000000
	// Bit FUNCTION_CLK_EN.
	GPIO_SD_SIGMADELTA_MISC_FUNCTION_CLK_EN = 0x40000000
	// Position of SPI_SWAP field.
	GPIO_SD_SIGMADELTA_MISC_SPI_SWAP_Pos = 0x1f
	// Bit mask of SPI_SWAP field.
	GPIO_SD_SIGMADELTA_MISC_SPI_SWAP_Msk = 0x80000000
	// Bit SPI_SWAP.
	GPIO_SD_SIGMADELTA_MISC_SPI_SWAP = 0x80000000

	// SIGMADELTA_VERSION: Version Control Register
	// Position of GPIO_SD_DATE field.
	GPIO_SD_SIGMADELTA_VERSION_GPIO_SD_DATE_Pos = 0x0
	// Bit mask of GPIO_SD_DATE field.
	GPIO_SD_SIGMADELTA_VERSION_GPIO_SD_DATE_Msk = 0xfffffff
)

// Constants for HMAC: Peripheral HMAC
const (
	// SET_START: HMAC start control register.
	// Position of SET_START field.
	HMAC_SET_START_SET_START_Pos = 0x0
	// Bit mask of SET_START field.
	HMAC_SET_START_SET_START_Msk = 0x1
	// Bit SET_START.
	HMAC_SET_START_SET_START = 0x1

	// SET_PARA_PURPOSE: HMAC parameter configuration register.
	// Position of PURPOSE_SET field.
	HMAC_SET_PARA_PURPOSE_PURPOSE_SET_Pos = 0x0
	// Bit mask of PURPOSE_SET field.
	HMAC_SET_PARA_PURPOSE_PURPOSE_SET_Msk = 0xf

	// SET_PARA_KEY: HMAC key configuration register.
	// Position of KEY_SET field.
	HMAC_SET_PARA_KEY_KEY_SET_Pos = 0x0
	// Bit mask of KEY_SET field.
	HMAC_SET_PARA_KEY_KEY_SET_Msk = 0x7

	// SET_PARA_FINISH: HMAC configuration completion register.
	// Position of SET_PARA_END field.
	HMAC_SET_PARA_FINISH_SET_PARA_END_Pos = 0x0
	// Bit mask of SET_PARA_END field.
	HMAC_SET_PARA_FINISH_SET_PARA_END_Msk = 0x1
	// Bit SET_PARA_END.
	HMAC_SET_PARA_FINISH_SET_PARA_END = 0x1

	// SET_MESSAGE_ONE: HMAC one message control register.
	// Position of SET_TEXT_ONE field.
	HMAC_SET_MESSAGE_ONE_SET_TEXT_ONE_Pos = 0x0
	// Bit mask of SET_TEXT_ONE field.
	HMAC_SET_MESSAGE_ONE_SET_TEXT_ONE_Msk = 0x1
	// Bit SET_TEXT_ONE.
	HMAC_SET_MESSAGE_ONE_SET_TEXT_ONE = 0x1

	// SET_MESSAGE_ING: HMAC message continue register.
	// Position of SET_TEXT_ING field.
	HMAC_SET_MESSAGE_ING_SET_TEXT_ING_Pos = 0x0
	// Bit mask of SET_TEXT_ING field.
	HMAC_SET_MESSAGE_ING_SET_TEXT_ING_Msk = 0x1
	// Bit SET_TEXT_ING.
	HMAC_SET_MESSAGE_ING_SET_TEXT_ING = 0x1

	// SET_MESSAGE_END: HMAC message end register.
	// Position of SET_TEXT_END field.
	HMAC_SET_MESSAGE_END_SET_TEXT_END_Pos = 0x0
	// Bit mask of SET_TEXT_END field.
	HMAC_SET_MESSAGE_END_SET_TEXT_END_Msk = 0x1
	// Bit SET_TEXT_END.
	HMAC_SET_MESSAGE_END_SET_TEXT_END = 0x1

	// SET_RESULT_FINISH: HMAC read result completion register.
	// Position of SET_RESULT_END field.
	HMAC_SET_RESULT_FINISH_SET_RESULT_END_Pos = 0x0
	// Bit mask of SET_RESULT_END field.
	HMAC_SET_RESULT_FINISH_SET_RESULT_END_Msk = 0x1
	// Bit SET_RESULT_END.
	HMAC_SET_RESULT_FINISH_SET_RESULT_END = 0x1

	// SET_INVALIDATE_JTAG: Invalidate JTAG result register.
	// Position of SET_INVALIDATE_JTAG field.
	HMAC_SET_INVALIDATE_JTAG_SET_INVALIDATE_JTAG_Pos = 0x0
	// Bit mask of SET_INVALIDATE_JTAG field.
	HMAC_SET_INVALIDATE_JTAG_SET_INVALIDATE_JTAG_Msk = 0x1
	// Bit SET_INVALIDATE_JTAG.
	HMAC_SET_INVALIDATE_JTAG_SET_INVALIDATE_JTAG = 0x1

	// SET_INVALIDATE_DS: Invalidate digital signature result register.
	// Position of SET_INVALIDATE_DS field.
	HMAC_SET_INVALIDATE_DS_SET_INVALIDATE_DS_Pos = 0x0
	// Bit mask of SET_INVALIDATE_DS field.
	HMAC_SET_INVALIDATE_DS_SET_INVALIDATE_DS_Msk = 0x1
	// Bit SET_INVALIDATE_DS.
	HMAC_SET_INVALIDATE_DS_SET_INVALIDATE_DS = 0x1

	// QUERY_ERROR: The matching result between key and purpose user configured.
	// Position of QUREY_CHECK field.
	HMAC_QUERY_ERROR_QUREY_CHECK_Pos = 0x0
	// Bit mask of QUREY_CHECK field.
	HMAC_QUERY_ERROR_QUREY_CHECK_Msk = 0x1
	// Bit QUREY_CHECK.
	HMAC_QUERY_ERROR_QUREY_CHECK = 0x1

	// QUERY_BUSY: The busy state of HMAC module.
	// Position of BUSY_STATE field.
	HMAC_QUERY_BUSY_BUSY_STATE_Pos = 0x0
	// Bit mask of BUSY_STATE field.
	HMAC_QUERY_BUSY_BUSY_STATE_Msk = 0x1
	// Bit BUSY_STATE.
	HMAC_QUERY_BUSY_BUSY_STATE = 0x1

	// WR_MESSAGE_0: Message register %s.
	// Position of WDATA field.
	HMAC_WR_MESSAGE_WDATA_Pos = 0x0
	// Bit mask of WDATA field.
	HMAC_WR_MESSAGE_WDATA_Msk = 0xffffffff

	// RD_RESULT_0: Hash result register %s.
	// Position of RDATA field.
	HMAC_RD_RESULT_RDATA_Pos = 0x0
	// Bit mask of RDATA field.
	HMAC_RD_RESULT_RDATA_Msk = 0xffffffff

	// SET_MESSAGE_PAD: Software padding register.
	// Position of SET_TEXT_PAD field.
	HMAC_SET_MESSAGE_PAD_SET_TEXT_PAD_Pos = 0x0
	// Bit mask of SET_TEXT_PAD field.
	HMAC_SET_MESSAGE_PAD_SET_TEXT_PAD_Msk = 0x1
	// Bit SET_TEXT_PAD.
	HMAC_SET_MESSAGE_PAD_SET_TEXT_PAD = 0x1

	// ONE_BLOCK: One block message register.
	// Position of SET_ONE_BLOCK field.
	HMAC_ONE_BLOCK_SET_ONE_BLOCK_Pos = 0x0
	// Bit mask of SET_ONE_BLOCK field.
	HMAC_ONE_BLOCK_SET_ONE_BLOCK_Msk = 0x1
	// Bit SET_ONE_BLOCK.
	HMAC_ONE_BLOCK_SET_ONE_BLOCK = 0x1

	// DATE: Version control register.
	// Position of DATE field.
	HMAC_DATE_DATE_Pos = 0x0
	// Bit mask of DATE field.
	HMAC_DATE_DATE_Msk = 0x3fffffff
)

// Constants for I2C0: Peripheral I2C
const (
	// SCL_LOW_PERIOD: Configures the low level width of the SCL clock
	// Position of SCL_LOW_PERIOD field.
	I2C0_SCL_LOW_PERIOD_SCL_LOW_PERIOD_Pos = 0x0
	// Bit mask of SCL_LOW_PERIOD field.
	I2C0_SCL_LOW_PERIOD_SCL_LOW_PERIOD_Msk = 0x3fff

	// CTR: Transmission setting
	// Position of SDA_FORCE_OUT field.
	I2C0_CTR_SDA_FORCE_OUT_Pos = 0x0
	// Bit mask of SDA_FORCE_OUT field.
	I2C0_CTR_SDA_FORCE_OUT_Msk = 0x1
	// Bit SDA_FORCE_OUT.
	I2C0_CTR_SDA_FORCE_OUT = 0x1
	// Position of SCL_FORCE_OUT field.
	I2C0_CTR_SCL_FORCE_OUT_Pos = 0x1
	// Bit mask of SCL_FORCE_OUT field.
	I2C0_CTR_SCL_FORCE_OUT_Msk = 0x2
	// Bit SCL_FORCE_OUT.
	I2C0_CTR_SCL_FORCE_OUT = 0x2
	// Position of SAMPLE_SCL_LEVEL field.
	I2C0_CTR_SAMPLE_SCL_LEVEL_Pos = 0x2
	// Bit mask of SAMPLE_SCL_LEVEL field.
	I2C0_CTR_SAMPLE_SCL_LEVEL_Msk = 0x4
	// Bit SAMPLE_SCL_LEVEL.
	I2C0_CTR_SAMPLE_SCL_LEVEL = 0x4
	// Position of RX_FULL_ACK_LEVEL field.
	I2C0_CTR_RX_FULL_ACK_LEVEL_Pos = 0x3
	// Bit mask of RX_FULL_ACK_LEVEL field.
	I2C0_CTR_RX_FULL_ACK_LEVEL_Msk = 0x8
	// Bit RX_FULL_ACK_LEVEL.
	I2C0_CTR_RX_FULL_ACK_LEVEL = 0x8
	// Position of MS_MODE field.
	I2C0_CTR_MS_MODE_Pos = 0x4
	// Bit mask of MS_MODE field.
	I2C0_CTR_MS_MODE_Msk = 0x10
	// Bit MS_MODE.
	I2C0_CTR_MS_MODE = 0x10
	// Position of TRANS_START field.
	I2C0_CTR_TRANS_START_Pos = 0x5
	// Bit mask of TRANS_START field.
	I2C0_CTR_TRANS_START_Msk = 0x20
	// Bit TRANS_START.
	I2C0_CTR_TRANS_START = 0x20
	// Position of TX_LSB_FIRST field.
	I2C0_CTR_TX_LSB_FIRST_Pos = 0x6
	// Bit mask of TX_LSB_FIRST field.
	I2C0_CTR_TX_LSB_FIRST_Msk = 0x40
	// Bit TX_LSB_FIRST.
	I2C0_CTR_TX_LSB_FIRST = 0x40
	// Position of RX_LSB_FIRST field.
	I2C0_CTR_RX_LSB_FIRST_Pos = 0x7
	// Bit mask of RX_LSB_FIRST field.
	I2C0_CTR_RX_LSB_FIRST_Msk = 0x80
	// Bit RX_LSB_FIRST.
	I2C0_CTR_RX_LSB_FIRST = 0x80
	// Position of CLK_EN field.
	I2C0_CTR_CLK_EN_Pos = 0x8
	// Bit mask of CLK_EN field.
	I2C0_CTR_CLK_EN_Msk = 0x100
	// Bit CLK_EN.
	I2C0_CTR_CLK_EN = 0x100
	// Position of ARBITRATION_EN field.
	I2C0_CTR_ARBITRATION_EN_Pos = 0x9
	// Bit mask of ARBITRATION_EN field.
	I2C0_CTR_ARBITRATION_EN_Msk = 0x200
	// Bit ARBITRATION_EN.
	I2C0_CTR_ARBITRATION_EN = 0x200
	// Position of FSM_RST field.
	I2C0_CTR_FSM_RST_Pos = 0xa
	// Bit mask of FSM_RST field.
	I2C0_CTR_FSM_RST_Msk = 0x400
	// Bit FSM_RST.
	I2C0_CTR_FSM_RST = 0x400
	// Position of REF_ALWAYS_ON field.
	I2C0_CTR_REF_ALWAYS_ON_Pos = 0xb
	// Bit mask of REF_ALWAYS_ON field.
	I2C0_CTR_REF_ALWAYS_ON_Msk = 0x800
	// Bit REF_ALWAYS_ON.
	I2C0_CTR_REF_ALWAYS_ON = 0x800

	// SR: Describe I2C work status
	// Position of RESP_REC field.
	I2C0_SR_RESP_REC_Pos = 0x0
	// Bit mask of RESP_REC field.
	I2C0_SR_RESP_REC_Msk = 0x1
	// Bit RESP_REC.
	I2C0_SR_RESP_REC = 0x1
	// Position of SLAVE_RW field.
	I2C0_SR_SLAVE_RW_Pos = 0x1
	// Bit mask of SLAVE_RW field.
	I2C0_SR_SLAVE_RW_Msk = 0x2
	// Bit SLAVE_RW.
	I2C0_SR_SLAVE_RW = 0x2
	// Position of TIME_OUT field.
	I2C0_SR_TIME_OUT_Pos = 0x2
	// Bit mask of TIME_OUT field.
	I2C0_SR_TIME_OUT_Msk = 0x4
	// Bit TIME_OUT.
	I2C0_SR_TIME_OUT = 0x4
	// Position of ARB_LOST field.
	I2C0_SR_ARB_LOST_Pos = 0x3
	// Bit mask of ARB_LOST field.
	I2C0_SR_ARB_LOST_Msk = 0x8
	// Bit ARB_LOST.
	I2C0_SR_ARB_LOST = 0x8
	// Position of BUS_BUSY field.
	I2C0_SR_BUS_BUSY_Pos = 0x4
	// Bit mask of BUS_BUSY field.
	I2C0_SR_BUS_BUSY_Msk = 0x10
	// Bit BUS_BUSY.
	I2C0_SR_BUS_BUSY = 0x10
	// Position of SLAVE_ADDRESSED field.
	I2C0_SR_SLAVE_ADDRESSED_Pos = 0x5
	// Bit mask of SLAVE_ADDRESSED field.
	I2C0_SR_SLAVE_ADDRESSED_Msk = 0x20
	// Bit SLAVE_ADDRESSED.
	I2C0_SR_SLAVE_ADDRESSED = 0x20
	// Position of BYTE_TRANS field.
	I2C0_SR_BYTE_TRANS_Pos = 0x6
	// Bit mask of BYTE_TRANS field.
	I2C0_SR_BYTE_TRANS_Msk = 0x40
	// Bit BYTE_TRANS.
	I2C0_SR_BYTE_TRANS = 0x40
	// Position of RXFIFO_CNT field.
	I2C0_SR_RXFIFO_CNT_Pos = 0x8
	// Bit mask of RXFIFO_CNT field.
	I2C0_SR_RXFIFO_CNT_Msk = 0x3f00
	// Position of STRETCH_CAUSE field.
	I2C0_SR_STRETCH_CAUSE_Pos = 0xe
	// Bit mask of STRETCH_CAUSE field.
	I2C0_SR_STRETCH_CAUSE_Msk = 0xc000
	// Position of TXFIFO_CNT field.
	I2C0_SR_TXFIFO_CNT_Pos = 0x12
	// Bit mask of TXFIFO_CNT field.
	I2C0_SR_TXFIFO_CNT_Msk = 0xfc0000
	// Position of SCL_MAIN_STATE_LAST field.
	I2C0_SR_SCL_MAIN_STATE_LAST_Pos = 0x18
	// Bit mask of SCL_MAIN_STATE_LAST field.
	I2C0_SR_SCL_MAIN_STATE_LAST_Msk = 0x7000000
	// Position of SCL_STATE_LAST field.
	I2C0_SR_SCL_STATE_LAST_Pos = 0x1c
	// Bit mask of SCL_STATE_LAST field.
	I2C0_SR_SCL_STATE_LAST_Msk = 0x70000000

	// TO: Setting time out control for receiving data
	// Position of TIME_OUT_VALUE field.
	I2C0_TO_TIME_OUT_VALUE_Pos = 0x0
	// Bit mask of TIME_OUT_VALUE field.
	I2C0_TO_TIME_OUT_VALUE_Msk = 0xffffff
	// Position of TIME_OUT_EN field.
	I2C0_TO_TIME_OUT_EN_Pos = 0x18
	// Bit mask of TIME_OUT_EN field.
	I2C0_TO_TIME_OUT_EN_Msk = 0x1000000
	// Bit TIME_OUT_EN.
	I2C0_TO_TIME_OUT_EN = 0x1000000

	// SLAVE_ADDR: Local slave address setting
	// Position of SLAVE_ADDR field.
	I2C0_SLAVE_ADDR_SLAVE_ADDR_Pos = 0x0
	// Bit mask of SLAVE_ADDR field.
	I2C0_SLAVE_ADDR_SLAVE_ADDR_Msk = 0x7fff
	// Position of ADDR_10BIT_EN field.
	I2C0_SLAVE_ADDR_ADDR_10BIT_EN_Pos = 0x1f
	// Bit mask of ADDR_10BIT_EN field.
	I2C0_SLAVE_ADDR_ADDR_10BIT_EN_Msk = 0x80000000
	// Bit ADDR_10BIT_EN.
	I2C0_SLAVE_ADDR_ADDR_10BIT_EN = 0x80000000

	// FIFO_ST: FIFO status register
	// Position of RXFIFO_START_ADDR field.
	I2C0_FIFO_ST_RXFIFO_START_ADDR_Pos = 0x0
	// Bit mask of RXFIFO_START_ADDR field.
	I2C0_FIFO_ST_RXFIFO_START_ADDR_Msk = 0x1f
	// Position of RXFIFO_END_ADDR field.
	I2C0_FIFO_ST_RXFIFO_END_ADDR_Pos = 0x5
	// Bit mask of RXFIFO_END_ADDR field.
	I2C0_FIFO_ST_RXFIFO_END_ADDR_Msk = 0x3e0
	// Position of TXFIFO_START_ADDR field.
	I2C0_FIFO_ST_TXFIFO_START_ADDR_Pos = 0xa
	// Bit mask of TXFIFO_START_ADDR field.
	I2C0_FIFO_ST_TXFIFO_START_ADDR_Msk = 0x7c00
	// Position of TXFIFO_END_ADDR field.
	I2C0_FIFO_ST_TXFIFO_END_ADDR_Pos = 0xf
	// Bit mask of TXFIFO_END_ADDR field.
	I2C0_FIFO_ST_TXFIFO_END_ADDR_Msk = 0xf8000
	// Position of RX_UPDATE field.
	I2C0_FIFO_ST_RX_UPDATE_Pos = 0x14
	// Bit mask of RX_UPDATE field.
	I2C0_FIFO_ST_RX_UPDATE_Msk = 0x100000
	// Bit RX_UPDATE.
	I2C0_FIFO_ST_RX_UPDATE = 0x100000
	// Position of TX_UPDATE field.
	I2C0_FIFO_ST_TX_UPDATE_Pos = 0x15
	// Bit mask of TX_UPDATE field.
	I2C0_FIFO_ST_TX_UPDATE_Msk = 0x200000
	// Bit TX_UPDATE.
	I2C0_FIFO_ST_TX_UPDATE = 0x200000
	// Position of SLAVE_RW_POINT field.
	I2C0_FIFO_ST_SLAVE_RW_POINT_Pos = 0x16
	// Bit mask of SLAVE_RW_POINT field.
	I2C0_FIFO_ST_SLAVE_RW_POINT_Msk = 0x3fc00000

	// FIFO_CONF: FIFO configuration register
	// Position of RXFIFO_WM_THRHD field.
	I2C0_FIFO_CONF_RXFIFO_WM_THRHD_Pos = 0x0
	// Bit mask of RXFIFO_WM_THRHD field.
	I2C0_FIFO_CONF_RXFIFO_WM_THRHD_Msk = 0x1f
	// Position of TXFIFO_WM_THRHD field.
	I2C0_FIFO_CONF_TXFIFO_WM_THRHD_Pos = 0x5
	// Bit mask of TXFIFO_WM_THRHD field.
	I2C0_FIFO_CONF_TXFIFO_WM_THRHD_Msk = 0x3e0
	// Position of NONFIFO_EN field.
	I2C0_FIFO_CONF_NONFIFO_EN_Pos = 0xa
	// Bit mask of NONFIFO_EN field.
	I2C0_FIFO_CONF_NONFIFO_EN_Msk = 0x400
	// Bit NONFIFO_EN.
	I2C0_FIFO_CONF_NONFIFO_EN = 0x400
	// Position of FIFO_ADDR_CFG_EN field.
	I2C0_FIFO_CONF_FIFO_ADDR_CFG_EN_Pos = 0xb
	// Bit mask of FIFO_ADDR_CFG_EN field.
	I2C0_FIFO_CONF_FIFO_ADDR_CFG_EN_Msk = 0x800
	// Bit FIFO_ADDR_CFG_EN.
	I2C0_FIFO_CONF_FIFO_ADDR_CFG_EN = 0x800
	// Position of RX_FIFO_RST field.
	I2C0_FIFO_CONF_RX_FIFO_RST_Pos = 0xc
	// Bit mask of RX_FIFO_RST field.
	I2C0_FIFO_CONF_RX_FIFO_RST_Msk = 0x1000
	// Bit RX_FIFO_RST.
	I2C0_FIFO_CONF_RX_FIFO_RST = 0x1000
	// Position of TX_FIFO_RST field.
	I2C0_FIFO_CONF_TX_FIFO_RST_Pos = 0xd
	// Bit mask of TX_FIFO_RST field.
	I2C0_FIFO_CONF_TX_FIFO_RST_Msk = 0x2000
	// Bit TX_FIFO_RST.
	I2C0_FIFO_CONF_TX_FIFO_RST = 0x2000
	// Position of NONFIFO_RX_THRES field.
	I2C0_FIFO_CONF_NONFIFO_RX_THRES_Pos = 0xe
	// Bit mask of NONFIFO_RX_THRES field.
	I2C0_FIFO_CONF_NONFIFO_RX_THRES_Msk = 0xfc000
	// Position of NONFIFO_TX_THRES field.
	I2C0_FIFO_CONF_NONFIFO_TX_THRES_Pos = 0x14
	// Bit mask of NONFIFO_TX_THRES field.
	I2C0_FIFO_CONF_NONFIFO_TX_THRES_Msk = 0x3f00000
	// Position of FIFO_PRT_EN field.
	I2C0_FIFO_CONF_FIFO_PRT_EN_Pos = 0x1a
	// Bit mask of FIFO_PRT_EN field.
	I2C0_FIFO_CONF_FIFO_PRT_EN_Msk = 0x4000000
	// Bit FIFO_PRT_EN.
	I2C0_FIFO_CONF_FIFO_PRT_EN = 0x4000000

	// DATA: RX FIFO read data
	// Position of FIFO_RDATA field.
	I2C0_DATA_FIFO_RDATA_Pos = 0x0
	// Bit mask of FIFO_RDATA field.
	I2C0_DATA_FIFO_RDATA_Msk = 0xff

	// INT_RAW: Raw interrupt status
	// Position of RXFIFO_WM_INT_RAW field.
	I2C0_INT_RAW_RXFIFO_WM_INT_RAW_Pos = 0x0
	// Bit mask of RXFIFO_WM_INT_RAW field.
	I2C0_INT_RAW_RXFIFO_WM_INT_RAW_Msk = 0x1
	// Bit RXFIFO_WM_INT_RAW.
	I2C0_INT_RAW_RXFIFO_WM_INT_RAW = 0x1
	// Position of TXFIFO_WM_INT_RAW field.
	I2C0_INT_RAW_TXFIFO_WM_INT_RAW_Pos = 0x1
	// Bit mask of TXFIFO_WM_INT_RAW field.
	I2C0_INT_RAW_TXFIFO_WM_INT_RAW_Msk = 0x2
	// Bit TXFIFO_WM_INT_RAW.
	I2C0_INT_RAW_TXFIFO_WM_INT_RAW = 0x2
	// Position of RXFIFO_OVF_INT_RAW field.
	I2C0_INT_RAW_RXFIFO_OVF_INT_RAW_Pos = 0x2
	// Bit mask of RXFIFO_OVF_INT_RAW field.
	I2C0_INT_RAW_RXFIFO_OVF_INT_RAW_Msk = 0x4
	// Bit RXFIFO_OVF_INT_RAW.
	I2C0_INT_RAW_RXFIFO_OVF_INT_RAW = 0x4
	// Position of END_DETECT_INT_RAW field.
	I2C0_INT_RAW_END_DETECT_INT_RAW_Pos = 0x3
	// Bit mask of END_DETECT_INT_RAW field.
	I2C0_INT_RAW_END_DETECT_INT_RAW_Msk = 0x8
	// Bit END_DETECT_INT_RAW.
	I2C0_INT_RAW_END_DETECT_INT_RAW = 0x8
	// Position of BYTE_TRANS_DONE_INT_RAW field.
	I2C0_INT_RAW_BYTE_TRANS_DONE_INT_RAW_Pos = 0x4
	// Bit mask of BYTE_TRANS_DONE_INT_RAW field.
	I2C0_INT_RAW_BYTE_TRANS_DONE_INT_RAW_Msk = 0x10
	// Bit BYTE_TRANS_DONE_INT_RAW.
	I2C0_INT_RAW_BYTE_TRANS_DONE_INT_RAW = 0x10
	// Position of ARBITRATION_LOST_INT_RAW field.
	I2C0_INT_RAW_ARBITRATION_LOST_INT_RAW_Pos = 0x5
	// Bit mask of ARBITRATION_LOST_INT_RAW field.
	I2C0_INT_RAW_ARBITRATION_LOST_INT_RAW_Msk = 0x20
	// Bit ARBITRATION_LOST_INT_RAW.
	I2C0_INT_RAW_ARBITRATION_LOST_INT_RAW = 0x20
	// Position of MST_TXFIFO_UDF_INT_RAW field.
	I2C0_INT_RAW_MST_TXFIFO_UDF_INT_RAW_Pos = 0x6
	// Bit mask of MST_TXFIFO_UDF_INT_RAW field.
	I2C0_INT_RAW_MST_TXFIFO_UDF_INT_RAW_Msk = 0x40
	// Bit MST_TXFIFO_UDF_INT_RAW.
	I2C0_INT_RAW_MST_TXFIFO_UDF_INT_RAW = 0x40
	// Position of TRANS_COMPLETE_INT_RAW field.
	I2C0_INT_RAW_TRANS_COMPLETE_INT_RAW_Pos = 0x7
	// Bit mask of TRANS_COMPLETE_INT_RAW field.
	I2C0_INT_RAW_TRANS_COMPLETE_INT_RAW_Msk = 0x80
	// Bit TRANS_COMPLETE_INT_RAW.
	I2C0_INT_RAW_TRANS_COMPLETE_INT_RAW = 0x80
	// Position of TIME_OUT_INT_RAW field.
	I2C0_INT_RAW_TIME_OUT_INT_RAW_Pos = 0x8
	// Bit mask of TIME_OUT_INT_RAW field.
	I2C0_INT_RAW_TIME_OUT_INT_RAW_Msk = 0x100
	// Bit TIME_OUT_INT_RAW.
	I2C0_INT_RAW_TIME_OUT_INT_RAW = 0x100
	// Position of TRANS_START_INT_RAW field.
	I2C0_INT_RAW_TRANS_START_INT_RAW_Pos = 0x9
	// Bit mask of TRANS_START_INT_RAW field.
	I2C0_INT_RAW_TRANS_START_INT_RAW_Msk = 0x200
	// Bit TRANS_START_INT_RAW.
	I2C0_INT_RAW_TRANS_START_INT_RAW = 0x200
	// Position of NACK_INT_RAW field.
	I2C0_INT_RAW_NACK_INT_RAW_Pos = 0xa
	// Bit mask of NACK_INT_RAW field.
	I2C0_INT_RAW_NACK_INT_RAW_Msk = 0x400
	// Bit NACK_INT_RAW.
	I2C0_INT_RAW_NACK_INT_RAW = 0x400
	// Position of TXFIFO_OVF_INT_RAW field.
	I2C0_INT_RAW_TXFIFO_OVF_INT_RAW_Pos = 0xb
	// Bit mask of TXFIFO_OVF_INT_RAW field.
	I2C0_INT_RAW_TXFIFO_OVF_INT_RAW_Msk = 0x800
	// Bit TXFIFO_OVF_INT_RAW.
	I2C0_INT_RAW_TXFIFO_OVF_INT_RAW = 0x800
	// Position of RXFIFO_UDF_INT_RAW field.
	I2C0_INT_RAW_RXFIFO_UDF_INT_RAW_Pos = 0xc
	// Bit mask of RXFIFO_UDF_INT_RAW field.
	I2C0_INT_RAW_RXFIFO_UDF_INT_RAW_Msk = 0x1000
	// Bit RXFIFO_UDF_INT_RAW.
	I2C0_INT_RAW_RXFIFO_UDF_INT_RAW = 0x1000
	// Position of SCL_ST_TO_INT_RAW field.
	I2C0_INT_RAW_SCL_ST_TO_INT_RAW_Pos = 0xd
	// Bit mask of SCL_ST_TO_INT_RAW field.
	I2C0_INT_RAW_SCL_ST_TO_INT_RAW_Msk = 0x2000
	// Bit SCL_ST_TO_INT_RAW.
	I2C0_INT_RAW_SCL_ST_TO_INT_RAW = 0x2000
	// Position of SCL_MAIN_ST_TO_INT_RAW field.
	I2C0_INT_RAW_SCL_MAIN_ST_TO_INT_RAW_Pos = 0xe
	// Bit mask of SCL_MAIN_ST_TO_INT_RAW field.
	I2C0_INT_RAW_SCL_MAIN_ST_TO_INT_RAW_Msk = 0x4000
	// Bit SCL_MAIN_ST_TO_INT_RAW.
	I2C0_INT_RAW_SCL_MAIN_ST_TO_INT_RAW = 0x4000
	// Position of DET_START_INT_RAW field.
	I2C0_INT_RAW_DET_START_INT_RAW_Pos = 0xf
	// Bit mask of DET_START_INT_RAW field.
	I2C0_INT_RAW_DET_START_INT_RAW_Msk = 0x8000
	// Bit DET_START_INT_RAW.
	I2C0_INT_RAW_DET_START_INT_RAW = 0x8000
	// Position of SLAVE_STRETCH_INT_RAW field.
	I2C0_INT_RAW_SLAVE_STRETCH_INT_RAW_Pos = 0x10
	// Bit mask of SLAVE_STRETCH_INT_RAW field.
	I2C0_INT_RAW_SLAVE_STRETCH_INT_RAW_Msk = 0x10000
	// Bit SLAVE_STRETCH_INT_RAW.
	I2C0_INT_RAW_SLAVE_STRETCH_INT_RAW = 0x10000

	// INT_CLR: Interrupt clear bits
	// Position of RXFIFO_WM_INT_CLR field.
	I2C0_INT_CLR_RXFIFO_WM_INT_CLR_Pos = 0x0
	// Bit mask of RXFIFO_WM_INT_CLR field.
	I2C0_INT_CLR_RXFIFO_WM_INT_CLR_Msk = 0x1
	// Bit RXFIFO_WM_INT_CLR.
	I2C0_INT_CLR_RXFIFO_WM_INT_CLR = 0x1
	// Position of TXFIFO_WM_INT_CLR field.
	I2C0_INT_CLR_TXFIFO_WM_INT_CLR_Pos = 0x1
	// Bit mask of TXFIFO_WM_INT_CLR field.
	I2C0_INT_CLR_TXFIFO_WM_INT_CLR_Msk = 0x2
	// Bit TXFIFO_WM_INT_CLR.
	I2C0_INT_CLR_TXFIFO_WM_INT_CLR = 0x2
	// Position of RXFIFO_OVF_INT_CLR field.
	I2C0_INT_CLR_RXFIFO_OVF_INT_CLR_Pos = 0x2
	// Bit mask of RXFIFO_OVF_INT_CLR field.
	I2C0_INT_CLR_RXFIFO_OVF_INT_CLR_Msk = 0x4
	// Bit RXFIFO_OVF_INT_CLR.
	I2C0_INT_CLR_RXFIFO_OVF_INT_CLR = 0x4
	// Position of END_DETECT_INT_CLR field.
	I2C0_INT_CLR_END_DETECT_INT_CLR_Pos = 0x3
	// Bit mask of END_DETECT_INT_CLR field.
	I2C0_INT_CLR_END_DETECT_INT_CLR_Msk = 0x8
	// Bit END_DETECT_INT_CLR.
	I2C0_INT_CLR_END_DETECT_INT_CLR = 0x8
	// Position of BYTE_TRANS_DONE_INT_CLR field.
	I2C0_INT_CLR_BYTE_TRANS_DONE_INT_CLR_Pos = 0x4
	// Bit mask of BYTE_TRANS_DONE_INT_CLR field.
	I2C0_INT_CLR_BYTE_TRANS_DONE_INT_CLR_Msk = 0x10
	// Bit BYTE_TRANS_DONE_INT_CLR.
	I2C0_INT_CLR_BYTE_TRANS_DONE_INT_CLR = 0x10
	// Position of ARBITRATION_LOST_INT_CLR field.
	I2C0_INT_CLR_ARBITRATION_LOST_INT_CLR_Pos = 0x5
	// Bit mask of ARBITRATION_LOST_INT_CLR field.
	I2C0_INT_CLR_ARBITRATION_LOST_INT_CLR_Msk = 0x20
	// Bit ARBITRATION_LOST_INT_CLR.
	I2C0_INT_CLR_ARBITRATION_LOST_INT_CLR = 0x20
	// Position of MST_TXFIFO_UDF_INT_CLR field.
	I2C0_INT_CLR_MST_TXFIFO_UDF_INT_CLR_Pos = 0x6
	// Bit mask of MST_TXFIFO_UDF_INT_CLR field.
	I2C0_INT_CLR_MST_TXFIFO_UDF_INT_CLR_Msk = 0x40
	// Bit MST_TXFIFO_UDF_INT_CLR.
	I2C0_INT_CLR_MST_TXFIFO_UDF_INT_CLR = 0x40
	// Position of TRANS_COMPLETE_INT_CLR field.
	I2C0_INT_CLR_TRANS_COMPLETE_INT_CLR_Pos = 0x7
	// Bit mask of TRANS_COMPLETE_INT_CLR field.
	I2C0_INT_CLR_TRANS_COMPLETE_INT_CLR_Msk = 0x80
	// Bit TRANS_COMPLETE_INT_CLR.
	I2C0_INT_CLR_TRANS_COMPLETE_INT_CLR = 0x80
	// Position of TIME_OUT_INT_CLR field.
	I2C0_INT_CLR_TIME_OUT_INT_CLR_Pos = 0x8
	// Bit mask of TIME_OUT_INT_CLR field.
	I2C0_INT_CLR_TIME_OUT_INT_CLR_Msk = 0x100
	// Bit TIME_OUT_INT_CLR.
	I2C0_INT_CLR_TIME_OUT_INT_CLR = 0x100
	// Position of TRANS_START_INT_CLR field.
	I2C0_INT_CLR_TRANS_START_INT_CLR_Pos = 0x9
	// Bit mask of TRANS_START_INT_CLR field.
	I2C0_INT_CLR_TRANS_START_INT_CLR_Msk = 0x200
	// Bit TRANS_START_INT_CLR.
	I2C0_INT_CLR_TRANS_START_INT_CLR = 0x200
	// Position of NACK_INT_CLR field.
	I2C0_INT_CLR_NACK_INT_CLR_Pos = 0xa
	// Bit mask of NACK_INT_CLR field.
	I2C0_INT_CLR_NACK_INT_CLR_Msk = 0x400
	// Bit NACK_INT_CLR.
	I2C0_INT_CLR_NACK_INT_CLR = 0x400
	// Position of TXFIFO_OVF_INT_CLR field.
	I2C0_INT_CLR_TXFIFO_OVF_INT_CLR_Pos = 0xb
	// Bit mask of TXFIFO_OVF_INT_CLR field.
	I2C0_INT_CLR_TXFIFO_OVF_INT_CLR_Msk = 0x800
	// Bit TXFIFO_OVF_INT_CLR.
	I2C0_INT_CLR_TXFIFO_OVF_INT_CLR = 0x800
	// Position of RXFIFO_UDF_INT_CLR field.
	I2C0_INT_CLR_RXFIFO_UDF_INT_CLR_Pos = 0xc
	// Bit mask of RXFIFO_UDF_INT_CLR field.
	I2C0_INT_CLR_RXFIFO_UDF_INT_CLR_Msk = 0x1000
	// Bit RXFIFO_UDF_INT_CLR.
	I2C0_INT_CLR_RXFIFO_UDF_INT_CLR = 0x1000
	// Position of SCL_ST_TO_INT_CLR field.
	I2C0_INT_CLR_SCL_ST_TO_INT_CLR_Pos = 0xd
	// Bit mask of SCL_ST_TO_INT_CLR field.
	I2C0_INT_CLR_SCL_ST_TO_INT_CLR_Msk = 0x2000
	// Bit SCL_ST_TO_INT_CLR.
	I2C0_INT_CLR_SCL_ST_TO_INT_CLR = 0x2000
	// Position of SCL_MAIN_ST_TO_INT_CLR field.
	I2C0_INT_CLR_SCL_MAIN_ST_TO_INT_CLR_Pos = 0xe
	// Bit mask of SCL_MAIN_ST_TO_INT_CLR field.
	I2C0_INT_CLR_SCL_MAIN_ST_TO_INT_CLR_Msk = 0x4000
	// Bit SCL_MAIN_ST_TO_INT_CLR.
	I2C0_INT_CLR_SCL_MAIN_ST_TO_INT_CLR = 0x4000
	// Position of DET_START_INT_CLR field.
	I2C0_INT_CLR_DET_START_INT_CLR_Pos = 0xf
	// Bit mask of DET_START_INT_CLR field.
	I2C0_INT_CLR_DET_START_INT_CLR_Msk = 0x8000
	// Bit DET_START_INT_CLR.
	I2C0_INT_CLR_DET_START_INT_CLR = 0x8000
	// Position of SLAVE_STRETCH_INT_CLR field.
	I2C0_INT_CLR_SLAVE_STRETCH_INT_CLR_Pos = 0x10
	// Bit mask of SLAVE_STRETCH_INT_CLR field.
	I2C0_INT_CLR_SLAVE_STRETCH_INT_CLR_Msk = 0x10000
	// Bit SLAVE_STRETCH_INT_CLR.
	I2C0_INT_CLR_SLAVE_STRETCH_INT_CLR = 0x10000

	// INT_ENA: Interrupt enable bits
	// Position of RXFIFO_WM_INT_ENA field.
	I2C0_INT_ENA_RXFIFO_WM_INT_ENA_Pos = 0x0
	// Bit mask of RXFIFO_WM_INT_ENA field.
	I2C0_INT_ENA_RXFIFO_WM_INT_ENA_Msk = 0x1
	// Bit RXFIFO_WM_INT_ENA.
	I2C0_INT_ENA_RXFIFO_WM_INT_ENA = 0x1
	// Position of TXFIFO_WM_INT_ENA field.
	I2C0_INT_ENA_TXFIFO_WM_INT_ENA_Pos = 0x1
	// Bit mask of TXFIFO_WM_INT_ENA field.
	I2C0_INT_ENA_TXFIFO_WM_INT_ENA_Msk = 0x2
	// Bit TXFIFO_WM_INT_ENA.
	I2C0_INT_ENA_TXFIFO_WM_INT_ENA = 0x2
	// Position of RXFIFO_OVF_INT_ENA field.
	I2C0_INT_ENA_RXFIFO_OVF_INT_ENA_Pos = 0x2
	// Bit mask of RXFIFO_OVF_INT_ENA field.
	I2C0_INT_ENA_RXFIFO_OVF_INT_ENA_Msk = 0x4
	// Bit RXFIFO_OVF_INT_ENA.
	I2C0_INT_ENA_RXFIFO_OVF_INT_ENA = 0x4
	// Position of END_DETECT_INT_ENA field.
	I2C0_INT_ENA_END_DETECT_INT_ENA_Pos = 0x3
	// Bit mask of END_DETECT_INT_ENA field.
	I2C0_INT_ENA_END_DETECT_INT_ENA_Msk = 0x8
	// Bit END_DETECT_INT_ENA.
	I2C0_INT_ENA_END_DETECT_INT_ENA = 0x8
	// Position of BYTE_TRANS_DONE_INT_ENA field.
	I2C0_INT_ENA_BYTE_TRANS_DONE_INT_ENA_Pos = 0x4
	// Bit mask of BYTE_TRANS_DONE_INT_ENA field.
	I2C0_INT_ENA_BYTE_TRANS_DONE_INT_ENA_Msk = 0x10
	// Bit BYTE_TRANS_DONE_INT_ENA.
	I2C0_INT_ENA_BYTE_TRANS_DONE_INT_ENA = 0x10
	// Position of ARBITRATION_LOST_INT_ENA field.
	I2C0_INT_ENA_ARBITRATION_LOST_INT_ENA_Pos = 0x5
	// Bit mask of ARBITRATION_LOST_INT_ENA field.
	I2C0_INT_ENA_ARBITRATION_LOST_INT_ENA_Msk = 0x20
	// Bit ARBITRATION_LOST_INT_ENA.
	I2C0_INT_ENA_ARBITRATION_LOST_INT_ENA = 0x20
	// Position of MST_TXFIFO_UDF_INT_ENA field.
	I2C0_INT_ENA_MST_TXFIFO_UDF_INT_ENA_Pos = 0x6
	// Bit mask of MST_TXFIFO_UDF_INT_ENA field.
	I2C0_INT_ENA_MST_TXFIFO_UDF_INT_ENA_Msk = 0x40
	// Bit MST_TXFIFO_UDF_INT_ENA.
	I2C0_INT_ENA_MST_TXFIFO_UDF_INT_ENA = 0x40
	// Position of TRANS_COMPLETE_INT_ENA field.
	I2C0_INT_ENA_TRANS_COMPLETE_INT_ENA_Pos = 0x7
	// Bit mask of TRANS_COMPLETE_INT_ENA field.
	I2C0_INT_ENA_TRANS_COMPLETE_INT_ENA_Msk = 0x80
	// Bit TRANS_COMPLETE_INT_ENA.
	I2C0_INT_ENA_TRANS_COMPLETE_INT_ENA = 0x80
	// Position of TIME_OUT_INT_ENA field.
	I2C0_INT_ENA_TIME_OUT_INT_ENA_Pos = 0x8
	// Bit mask of TIME_OUT_INT_ENA field.
	I2C0_INT_ENA_TIME_OUT_INT_ENA_Msk = 0x100
	// Bit TIME_OUT_INT_ENA.
	I2C0_INT_ENA_TIME_OUT_INT_ENA = 0x100
	// Position of TRANS_START_INT_ENA field.
	I2C0_INT_ENA_TRANS_START_INT_ENA_Pos = 0x9
	// Bit mask of TRANS_START_INT_ENA field.
	I2C0_INT_ENA_TRANS_START_INT_ENA_Msk = 0x200
	// Bit TRANS_START_INT_ENA.
	I2C0_INT_ENA_TRANS_START_INT_ENA = 0x200
	// Position of NACK_INT_ENA field.
	I2C0_INT_ENA_NACK_INT_ENA_Pos = 0xa
	// Bit mask of NACK_INT_ENA field.
	I2C0_INT_ENA_NACK_INT_ENA_Msk = 0x400
	// Bit NACK_INT_ENA.
	I2C0_INT_ENA_NACK_INT_ENA = 0x400
	// Position of TXFIFO_OVF_INT_ENA field.
	I2C0_INT_ENA_TXFIFO_OVF_INT_ENA_Pos = 0xb
	// Bit mask of TXFIFO_OVF_INT_ENA field.
	I2C0_INT_ENA_TXFIFO_OVF_INT_ENA_Msk = 0x800
	// Bit TXFIFO_OVF_INT_ENA.
	I2C0_INT_ENA_TXFIFO_OVF_INT_ENA = 0x800
	// Position of RXFIFO_UDF_INT_ENA field.
	I2C0_INT_ENA_RXFIFO_UDF_INT_ENA_Pos = 0xc
	// Bit mask of RXFIFO_UDF_INT_ENA field.
	I2C0_INT_ENA_RXFIFO_UDF_INT_ENA_Msk = 0x1000
	// Bit RXFIFO_UDF_INT_ENA.
	I2C0_INT_ENA_RXFIFO_UDF_INT_ENA = 0x1000
	// Position of SCL_ST_TO_INT_ENA field.
	I2C0_INT_ENA_SCL_ST_TO_INT_ENA_Pos = 0xd
	// Bit mask of SCL_ST_TO_INT_ENA field.
	I2C0_INT_ENA_SCL_ST_TO_INT_ENA_Msk = 0x2000
	// Bit SCL_ST_TO_INT_ENA.
	I2C0_INT_ENA_SCL_ST_TO_INT_ENA = 0x2000
	// Position of SCL_MAIN_ST_TO_INT_ENA field.
	I2C0_INT_ENA_SCL_MAIN_ST_TO_INT_ENA_Pos = 0xe
	// Bit mask of SCL_MAIN_ST_TO_INT_ENA field.
	I2C0_INT_ENA_SCL_MAIN_ST_TO_INT_ENA_Msk = 0x4000
	// Bit SCL_MAIN_ST_TO_INT_ENA.
	I2C0_INT_ENA_SCL_MAIN_ST_TO_INT_ENA = 0x4000
	// Position of DET_START_INT_ENA field.
	I2C0_INT_ENA_DET_START_INT_ENA_Pos = 0xf
	// Bit mask of DET_START_INT_ENA field.
	I2C0_INT_ENA_DET_START_INT_ENA_Msk = 0x8000
	// Bit DET_START_INT_ENA.
	I2C0_INT_ENA_DET_START_INT_ENA = 0x8000
	// Position of SLAVE_STRETCH_INT_ENA field.
	I2C0_INT_ENA_SLAVE_STRETCH_INT_ENA_Pos = 0x10
	// Bit mask of SLAVE_STRETCH_INT_ENA field.
	I2C0_INT_ENA_SLAVE_STRETCH_INT_ENA_Msk = 0x10000
	// Bit SLAVE_STRETCH_INT_ENA.
	I2C0_INT_ENA_SLAVE_STRETCH_INT_ENA = 0x10000

	// INT_STATUS: Status of captured I2C communication events
	// Position of RXFIFO_WM_INT_ST field.
	I2C0_INT_STATUS_RXFIFO_WM_INT_ST_Pos = 0x0
	// Bit mask of RXFIFO_WM_INT_ST field.
	I2C0_INT_STATUS_RXFIFO_WM_INT_ST_Msk = 0x1
	// Bit RXFIFO_WM_INT_ST.
	I2C0_INT_STATUS_RXFIFO_WM_INT_ST = 0x1
	// Position of TXFIFO_WM_INT_ST field.
	I2C0_INT_STATUS_TXFIFO_WM_INT_ST_Pos = 0x1
	// Bit mask of TXFIFO_WM_INT_ST field.
	I2C0_INT_STATUS_TXFIFO_WM_INT_ST_Msk = 0x2
	// Bit TXFIFO_WM_INT_ST.
	I2C0_INT_STATUS_TXFIFO_WM_INT_ST = 0x2
	// Position of RXFIFO_OVF_INT_ST field.
	I2C0_INT_STATUS_RXFIFO_OVF_INT_ST_Pos = 0x2
	// Bit mask of RXFIFO_OVF_INT_ST field.
	I2C0_INT_STATUS_RXFIFO_OVF_INT_ST_Msk = 0x4
	// Bit RXFIFO_OVF_INT_ST.
	I2C0_INT_STATUS_RXFIFO_OVF_INT_ST = 0x4
	// Position of END_DETECT_INT_ST field.
	I2C0_INT_STATUS_END_DETECT_INT_ST_Pos = 0x3
	// Bit mask of END_DETECT_INT_ST field.
	I2C0_INT_STATUS_END_DETECT_INT_ST_Msk = 0x8
	// Bit END_DETECT_INT_ST.
	I2C0_INT_STATUS_END_DETECT_INT_ST = 0x8
	// Position of BYTE_TRANS_DONE_INT_ST field.
	I2C0_INT_STATUS_BYTE_TRANS_DONE_INT_ST_Pos = 0x4
	// Bit mask of BYTE_TRANS_DONE_INT_ST field.
	I2C0_INT_STATUS_BYTE_TRANS_DONE_INT_ST_Msk = 0x10
	// Bit BYTE_TRANS_DONE_INT_ST.
	I2C0_INT_STATUS_BYTE_TRANS_DONE_INT_ST = 0x10
	// Position of ARBITRATION_LOST_INT_ST field.
	I2C0_INT_STATUS_ARBITRATION_LOST_INT_ST_Pos = 0x5
	// Bit mask of ARBITRATION_LOST_INT_ST field.
	I2C0_INT_STATUS_ARBITRATION_LOST_INT_ST_Msk = 0x20
	// Bit ARBITRATION_LOST_INT_ST.
	I2C0_INT_STATUS_ARBITRATION_LOST_INT_ST = 0x20
	// Position of MST_TXFIFO_UDF_INT_ST field.
	I2C0_INT_STATUS_MST_TXFIFO_UDF_INT_ST_Pos = 0x6
	// Bit mask of MST_TXFIFO_UDF_INT_ST field.
	I2C0_INT_STATUS_MST_TXFIFO_UDF_INT_ST_Msk = 0x40
	// Bit MST_TXFIFO_UDF_INT_ST.
	I2C0_INT_STATUS_MST_TXFIFO_UDF_INT_ST = 0x40
	// Position of TRANS_COMPLETE_INT_ST field.
	I2C0_INT_STATUS_TRANS_COMPLETE_INT_ST_Pos = 0x7
	// Bit mask of TRANS_COMPLETE_INT_ST field.
	I2C0_INT_STATUS_TRANS_COMPLETE_INT_ST_Msk = 0x80
	// Bit TRANS_COMPLETE_INT_ST.
	I2C0_INT_STATUS_TRANS_COMPLETE_INT_ST = 0x80
	// Position of TIME_OUT_INT_ST field.
	I2C0_INT_STATUS_TIME_OUT_INT_ST_Pos = 0x8
	// Bit mask of TIME_OUT_INT_ST field.
	I2C0_INT_STATUS_TIME_OUT_INT_ST_Msk = 0x100
	// Bit TIME_OUT_INT_ST.
	I2C0_INT_STATUS_TIME_OUT_INT_ST = 0x100
	// Position of TRANS_START_INT_ST field.
	I2C0_INT_STATUS_TRANS_START_INT_ST_Pos = 0x9
	// Bit mask of TRANS_START_INT_ST field.
	I2C0_INT_STATUS_TRANS_START_INT_ST_Msk = 0x200
	// Bit TRANS_START_INT_ST.
	I2C0_INT_STATUS_TRANS_START_INT_ST = 0x200
	// Position of NACK_INT_ST field.
	I2C0_INT_STATUS_NACK_INT_ST_Pos = 0xa
	// Bit mask of NACK_INT_ST field.
	I2C0_INT_STATUS_NACK_INT_ST_Msk = 0x400
	// Bit NACK_INT_ST.
	I2C0_INT_STATUS_NACK_INT_ST = 0x400
	// Position of TXFIFO_OVF_INT_ST field.
	I2C0_INT_STATUS_TXFIFO_OVF_INT_ST_Pos = 0xb
	// Bit mask of TXFIFO_OVF_INT_ST field.
	I2C0_INT_STATUS_TXFIFO_OVF_INT_ST_Msk = 0x800
	// Bit TXFIFO_OVF_INT_ST.
	I2C0_INT_STATUS_TXFIFO_OVF_INT_ST = 0x800
	// Position of RXFIFO_UDF_INT_ST field.
	I2C0_INT_STATUS_RXFIFO_UDF_INT_ST_Pos = 0xc
	// Bit mask of RXFIFO_UDF_INT_ST field.
	I2C0_INT_STATUS_RXFIFO_UDF_INT_ST_Msk = 0x1000
	// Bit RXFIFO_UDF_INT_ST.
	I2C0_INT_STATUS_RXFIFO_UDF_INT_ST = 0x1000
	// Position of SCL_ST_TO_INT_ST field.
	I2C0_INT_STATUS_SCL_ST_TO_INT_ST_Pos = 0xd
	// Bit mask of SCL_ST_TO_INT_ST field.
	I2C0_INT_STATUS_SCL_ST_TO_INT_ST_Msk = 0x2000
	// Bit SCL_ST_TO_INT_ST.
	I2C0_INT_STATUS_SCL_ST_TO_INT_ST = 0x2000
	// Position of SCL_MAIN_ST_TO_INT_ST field.
	I2C0_INT_STATUS_SCL_MAIN_ST_TO_INT_ST_Pos = 0xe
	// Bit mask of SCL_MAIN_ST_TO_INT_ST field.
	I2C0_INT_STATUS_SCL_MAIN_ST_TO_INT_ST_Msk = 0x4000
	// Bit SCL_MAIN_ST_TO_INT_ST.
	I2C0_INT_STATUS_SCL_MAIN_ST_TO_INT_ST = 0x4000
	// Position of DET_START_INT_ST field.
	I2C0_INT_STATUS_DET_START_INT_ST_Pos = 0xf
	// Bit mask of DET_START_INT_ST field.
	I2C0_INT_STATUS_DET_START_INT_ST_Msk = 0x8000
	// Bit DET_START_INT_ST.
	I2C0_INT_STATUS_DET_START_INT_ST = 0x8000
	// Position of SLAVE_STRETCH_INT_ST field.
	I2C0_INT_STATUS_SLAVE_STRETCH_INT_ST_Pos = 0x10
	// Bit mask of SLAVE_STRETCH_INT_ST field.
	I2C0_INT_STATUS_SLAVE_STRETCH_INT_ST_Msk = 0x10000
	// Bit SLAVE_STRETCH_INT_ST.
	I2C0_INT_STATUS_SLAVE_STRETCH_INT_ST = 0x10000

	// SDA_HOLD: Configures the hold time after a negative SCL edge
	// Position of TIME field.
	I2C0_SDA_HOLD_TIME_Pos = 0x0
	// Bit mask of TIME field.
	I2C0_SDA_HOLD_TIME_Msk = 0x3ff

	// SDA_SAMPLE: Configures the sample time after a positive SCL edge
	// Position of TIME field.
	I2C0_SDA_SAMPLE_TIME_Pos = 0x0
	// Bit mask of TIME field.
	I2C0_SDA_SAMPLE_TIME_Msk = 0x3ff

	// SCL_HIGH_PERIOD: Configures the high level width of the SCL clock
	// Position of SCL_HIGH_PERIOD field.
	I2C0_SCL_HIGH_PERIOD_SCL_HIGH_PERIOD_Pos = 0x0
	// Bit mask of SCL_HIGH_PERIOD field.
	I2C0_SCL_HIGH_PERIOD_SCL_HIGH_PERIOD_Msk = 0x3fff
	// Position of SCL_WAIT_HIGH_PERIOD field.
	I2C0_SCL_HIGH_PERIOD_SCL_WAIT_HIGH_PERIOD_Pos = 0xe
	// Bit mask of SCL_WAIT_HIGH_PERIOD field.
	I2C0_SCL_HIGH_PERIOD_SCL_WAIT_HIGH_PERIOD_Msk = 0xfffc000

	// SCL_START_HOLD: Configures the interval between pulling SDA low and pulling SCL low when the master generates a START condition
	// Position of TIME field.
	I2C0_SCL_START_HOLD_TIME_Pos = 0x0
	// Bit mask of TIME field.
	I2C0_SCL_START_HOLD_TIME_Msk = 0x3ff

	// SCL_RSTART_SETUP: Configures the interval between the positive; ;;;;;;;; >>>>>>>>>>edge of SCL and the negative edge of SDA
	// Position of TIME field.
	I2C0_SCL_RSTART_SETUP_TIME_Pos = 0x0
	// Bit mask of TIME field.
	I2C0_SCL_RSTART_SETUP_TIME_Msk = 0x3ff

	// SCL_STOP_HOLD: Configures the delay after the SCL clock; ;;;;;;;; >>>>>>>>>>edge for a stop condition
	// Position of TIME field.
	I2C0_SCL_STOP_HOLD_TIME_Pos = 0x0
	// Bit mask of TIME field.
	I2C0_SCL_STOP_HOLD_TIME_Msk = 0x3fff

	// SCL_STOP_SETUP: Configures the delay between the SDA and; ;;;;;;;; >>>>>>>>>>SCL positive edge for a stop condition
	// Position of TIME field.
	I2C0_SCL_STOP_SETUP_TIME_Pos = 0x0
	// Bit mask of TIME field.
	I2C0_SCL_STOP_SETUP_TIME_Msk = 0x3ff

	// SCL_FILTER_CFG: SCL filter configuration register
	// Position of SCL_FILTER_THRES field.
	I2C0_SCL_FILTER_CFG_SCL_FILTER_THRES_Pos = 0x0
	// Bit mask of SCL_FILTER_THRES field.
	I2C0_SCL_FILTER_CFG_SCL_FILTER_THRES_Msk = 0xf
	// Position of SCL_FILTER_EN field.
	I2C0_SCL_FILTER_CFG_SCL_FILTER_EN_Pos = 0x4
	// Bit mask of SCL_FILTER_EN field.
	I2C0_SCL_FILTER_CFG_SCL_FILTER_EN_Msk = 0x10
	// Bit SCL_FILTER_EN.
	I2C0_SCL_FILTER_CFG_SCL_FILTER_EN = 0x10

	// SDA_FILTER_CFG: SDA filter configuration register
	// Position of SDA_FILTER_THRES field.
	I2C0_SDA_FILTER_CFG_SDA_FILTER_THRES_Pos = 0x0
	// Bit mask of SDA_FILTER_THRES field.
	I2C0_SDA_FILTER_CFG_SDA_FILTER_THRES_Msk = 0xf
	// Position of SDA_FILTER_EN field.
	I2C0_SDA_FILTER_CFG_SDA_FILTER_EN_Pos = 0x4
	// Bit mask of SDA_FILTER_EN field.
	I2C0_SDA_FILTER_CFG_SDA_FILTER_EN_Msk = 0x10
	// Bit SDA_FILTER_EN.
	I2C0_SDA_FILTER_CFG_SDA_FILTER_EN = 0x10

	// COMD0: I2C command register 0
	// Position of COMMAND0 field.
	I2C0_COMD0_COMMAND0_Pos = 0x0
	// Bit mask of COMMAND0 field.
	I2C0_COMD0_COMMAND0_Msk = 0x3fff
	// Position of COMMAND0_DONE field.
	I2C0_COMD0_COMMAND0_DONE_Pos = 0x1f
	// Bit mask of COMMAND0_DONE field.
	I2C0_COMD0_COMMAND0_DONE_Msk = 0x80000000
	// Bit COMMAND0_DONE.
	I2C0_COMD0_COMMAND0_DONE = 0x80000000

	// COMD1: I2C command register 1
	// Position of COMMAND1 field.
	I2C0_COMD1_COMMAND1_Pos = 0x0
	// Bit mask of COMMAND1 field.
	I2C0_COMD1_COMMAND1_Msk = 0x3fff
	// Position of COMMAND1_DONE field.
	I2C0_COMD1_COMMAND1_DONE_Pos = 0x1f
	// Bit mask of COMMAND1_DONE field.
	I2C0_COMD1_COMMAND1_DONE_Msk = 0x80000000
	// Bit COMMAND1_DONE.
	I2C0_COMD1_COMMAND1_DONE = 0x80000000

	// COMD2: I2C command register 2
	// Position of COMMAND2 field.
	I2C0_COMD2_COMMAND2_Pos = 0x0
	// Bit mask of COMMAND2 field.
	I2C0_COMD2_COMMAND2_Msk = 0x3fff
	// Position of COMMAND2_DONE field.
	I2C0_COMD2_COMMAND2_DONE_Pos = 0x1f
	// Bit mask of COMMAND2_DONE field.
	I2C0_COMD2_COMMAND2_DONE_Msk = 0x80000000
	// Bit COMMAND2_DONE.
	I2C0_COMD2_COMMAND2_DONE = 0x80000000

	// COMD3: I2C command register 3
	// Position of COMMAND3 field.
	I2C0_COMD3_COMMAND3_Pos = 0x0
	// Bit mask of COMMAND3 field.
	I2C0_COMD3_COMMAND3_Msk = 0x3fff
	// Position of COMMAND3_DONE field.
	I2C0_COMD3_COMMAND3_DONE_Pos = 0x1f
	// Bit mask of COMMAND3_DONE field.
	I2C0_COMD3_COMMAND3_DONE_Msk = 0x80000000
	// Bit COMMAND3_DONE.
	I2C0_COMD3_COMMAND3_DONE = 0x80000000

	// COMD4: I2C command register 4
	// Position of COMMAND4 field.
	I2C0_COMD4_COMMAND4_Pos = 0x0
	// Bit mask of COMMAND4 field.
	I2C0_COMD4_COMMAND4_Msk = 0x3fff
	// Position of COMMAND4_DONE field.
	I2C0_COMD4_COMMAND4_DONE_Pos = 0x1f
	// Bit mask of COMMAND4_DONE field.
	I2C0_COMD4_COMMAND4_DONE_Msk = 0x80000000
	// Bit COMMAND4_DONE.
	I2C0_COMD4_COMMAND4_DONE = 0x80000000

	// COMD5: I2C command register 5
	// Position of COMMAND5 field.
	I2C0_COMD5_COMMAND5_Pos = 0x0
	// Bit mask of COMMAND5 field.
	I2C0_COMD5_COMMAND5_Msk = 0x3fff
	// Position of COMMAND5_DONE field.
	I2C0_COMD5_COMMAND5_DONE_Pos = 0x1f
	// Bit mask of COMMAND5_DONE field.
	I2C0_COMD5_COMMAND5_DONE_Msk = 0x80000000
	// Bit COMMAND5_DONE.
	I2C0_COMD5_COMMAND5_DONE = 0x80000000

	// COMD6: I2C command register 6
	// Position of COMMAND6 field.
	I2C0_COMD6_COMMAND6_Pos = 0x0
	// Bit mask of COMMAND6 field.
	I2C0_COMD6_COMMAND6_Msk = 0x3fff
	// Position of COMMAND6_DONE field.
	I2C0_COMD6_COMMAND6_DONE_Pos = 0x1f
	// Bit mask of COMMAND6_DONE field.
	I2C0_COMD6_COMMAND6_DONE_Msk = 0x80000000
	// Bit COMMAND6_DONE.
	I2C0_COMD6_COMMAND6_DONE = 0x80000000

	// COMD7: I2C command register 7
	// Position of COMMAND7 field.
	I2C0_COMD7_COMMAND7_Pos = 0x0
	// Bit mask of COMMAND7 field.
	I2C0_COMD7_COMMAND7_Msk = 0x3fff
	// Position of COMMAND7_DONE field.
	I2C0_COMD7_COMMAND7_DONE_Pos = 0x1f
	// Bit mask of COMMAND7_DONE field.
	I2C0_COMD7_COMMAND7_DONE_Msk = 0x80000000
	// Bit COMMAND7_DONE.
	I2C0_COMD7_COMMAND7_DONE = 0x80000000

	// COMD8: I2C command register 8
	// Position of COMMAND8 field.
	I2C0_COMD8_COMMAND8_Pos = 0x0
	// Bit mask of COMMAND8 field.
	I2C0_COMD8_COMMAND8_Msk = 0x3fff
	// Position of COMMAND8_DONE field.
	I2C0_COMD8_COMMAND8_DONE_Pos = 0x1f
	// Bit mask of COMMAND8_DONE field.
	I2C0_COMD8_COMMAND8_DONE_Msk = 0x80000000
	// Bit COMMAND8_DONE.
	I2C0_COMD8_COMMAND8_DONE = 0x80000000

	// COMD9: I2C command register 9
	// Position of COMMAND9 field.
	I2C0_COMD9_COMMAND9_Pos = 0x0
	// Bit mask of COMMAND9 field.
	I2C0_COMD9_COMMAND9_Msk = 0x3fff
	// Position of COMMAND9_DONE field.
	I2C0_COMD9_COMMAND9_DONE_Pos = 0x1f
	// Bit mask of COMMAND9_DONE field.
	I2C0_COMD9_COMMAND9_DONE_Msk = 0x80000000
	// Bit COMMAND9_DONE.
	I2C0_COMD9_COMMAND9_DONE = 0x80000000

	// COMD10: I2C command register 10
	// Position of COMMAND10 field.
	I2C0_COMD10_COMMAND10_Pos = 0x0
	// Bit mask of COMMAND10 field.
	I2C0_COMD10_COMMAND10_Msk = 0x3fff
	// Position of COMMAND10_DONE field.
	I2C0_COMD10_COMMAND10_DONE_Pos = 0x1f
	// Bit mask of COMMAND10_DONE field.
	I2C0_COMD10_COMMAND10_DONE_Msk = 0x80000000
	// Bit COMMAND10_DONE.
	I2C0_COMD10_COMMAND10_DONE = 0x80000000

	// COMD11: I2C command register 11
	// Position of COMMAND11 field.
	I2C0_COMD11_COMMAND11_Pos = 0x0
	// Bit mask of COMMAND11 field.
	I2C0_COMD11_COMMAND11_Msk = 0x3fff
	// Position of COMMAND11_DONE field.
	I2C0_COMD11_COMMAND11_DONE_Pos = 0x1f
	// Bit mask of COMMAND11_DONE field.
	I2C0_COMD11_COMMAND11_DONE_Msk = 0x80000000
	// Bit COMMAND11_DONE.
	I2C0_COMD11_COMMAND11_DONE = 0x80000000

	// COMD12: I2C command register 12
	// Position of COMMAND12 field.
	I2C0_COMD12_COMMAND12_Pos = 0x0
	// Bit mask of COMMAND12 field.
	I2C0_COMD12_COMMAND12_Msk = 0x3fff
	// Position of COMMAND12_DONE field.
	I2C0_COMD12_COMMAND12_DONE_Pos = 0x1f
	// Bit mask of COMMAND12_DONE field.
	I2C0_COMD12_COMMAND12_DONE_Msk = 0x80000000
	// Bit COMMAND12_DONE.
	I2C0_COMD12_COMMAND12_DONE = 0x80000000

	// COMD13: I2C command register 13
	// Position of COMMAND13 field.
	I2C0_COMD13_COMMAND13_Pos = 0x0
	// Bit mask of COMMAND13 field.
	I2C0_COMD13_COMMAND13_Msk = 0x3fff
	// Position of COMMAND13_DONE field.
	I2C0_COMD13_COMMAND13_DONE_Pos = 0x1f
	// Bit mask of COMMAND13_DONE field.
	I2C0_COMD13_COMMAND13_DONE_Msk = 0x80000000
	// Bit COMMAND13_DONE.
	I2C0_COMD13_COMMAND13_DONE = 0x80000000

	// COMD14: I2C command register 14
	// Position of COMMAND14 field.
	I2C0_COMD14_COMMAND14_Pos = 0x0
	// Bit mask of COMMAND14 field.
	I2C0_COMD14_COMMAND14_Msk = 0x3fff
	// Position of COMMAND14_DONE field.
	I2C0_COMD14_COMMAND14_DONE_Pos = 0x1f
	// Bit mask of COMMAND14_DONE field.
	I2C0_COMD14_COMMAND14_DONE_Msk = 0x80000000
	// Bit COMMAND14_DONE.
	I2C0_COMD14_COMMAND14_DONE = 0x80000000

	// COMD15: I2C command register 15
	// Position of COMMAND15 field.
	I2C0_COMD15_COMMAND15_Pos = 0x0
	// Bit mask of COMMAND15 field.
	I2C0_COMD15_COMMAND15_Msk = 0x3fff
	// Position of COMMAND15_DONE field.
	I2C0_COMD15_COMMAND15_DONE_Pos = 0x1f
	// Bit mask of COMMAND15_DONE field.
	I2C0_COMD15_COMMAND15_DONE_Msk = 0x80000000
	// Bit COMMAND15_DONE.
	I2C0_COMD15_COMMAND15_DONE = 0x80000000

	// SCL_ST_TIME_OUT: SCL status time out register
	// Position of SCL_ST_TO field.
	I2C0_SCL_ST_TIME_OUT_SCL_ST_TO_Pos = 0x0
	// Bit mask of SCL_ST_TO field.
	I2C0_SCL_ST_TIME_OUT_SCL_ST_TO_Msk = 0xffffff

	// SCL_MAIN_ST_TIME_OUT: SCL main status time out register
	// Position of SCL_MAIN_ST_TO field.
	I2C0_SCL_MAIN_ST_TIME_OUT_SCL_MAIN_ST_TO_Pos = 0x0
	// Bit mask of SCL_MAIN_ST_TO field.
	I2C0_SCL_MAIN_ST_TIME_OUT_SCL_MAIN_ST_TO_Msk = 0xffffff

	// SCL_SP_CONF: Power configuration register
	// Position of SCL_RST_SLV_EN field.
	I2C0_SCL_SP_CONF_SCL_RST_SLV_EN_Pos = 0x0
	// Bit mask of SCL_RST_SLV_EN field.
	I2C0_SCL_SP_CONF_SCL_RST_SLV_EN_Msk = 0x1
	// Bit SCL_RST_SLV_EN.
	I2C0_SCL_SP_CONF_SCL_RST_SLV_EN = 0x1
	// Position of SCL_RST_SLV_NUM field.
	I2C0_SCL_SP_CONF_SCL_RST_SLV_NUM_Pos = 0x1
	// Bit mask of SCL_RST_SLV_NUM field.
	I2C0_SCL_SP_CONF_SCL_RST_SLV_NUM_Msk = 0x3e
	// Position of SCL_PD_EN field.
	I2C0_SCL_SP_CONF_SCL_PD_EN_Pos = 0x6
	// Bit mask of SCL_PD_EN field.
	I2C0_SCL_SP_CONF_SCL_PD_EN_Msk = 0x40
	// Bit SCL_PD_EN.
	I2C0_SCL_SP_CONF_SCL_PD_EN = 0x40
	// Position of SDA_PD_EN field.
	I2C0_SCL_SP_CONF_SDA_PD_EN_Pos = 0x7
	// Bit mask of SDA_PD_EN field.
	I2C0_SCL_SP_CONF_SDA_PD_EN_Msk = 0x80
	// Bit SDA_PD_EN.
	I2C0_SCL_SP_CONF_SDA_PD_EN = 0x80

	// SCL_STRETCH_CONF: Set SCL stretch of I2C slave
	// Position of STRETCH_PROTECT_NUM field.
	I2C0_SCL_STRETCH_CONF_STRETCH_PROTECT_NUM_Pos = 0x0
	// Bit mask of STRETCH_PROTECT_NUM field.
	I2C0_SCL_STRETCH_CONF_STRETCH_PROTECT_NUM_Msk = 0x3ff
	// Position of SLAVE_SCL_STRETCH_EN field.
	I2C0_SCL_STRETCH_CONF_SLAVE_SCL_STRETCH_EN_Pos = 0xa
	// Bit mask of SLAVE_SCL_STRETCH_EN field.
	I2C0_SCL_STRETCH_CONF_SLAVE_SCL_STRETCH_EN_Msk = 0x400
	// Bit SLAVE_SCL_STRETCH_EN.
	I2C0_SCL_STRETCH_CONF_SLAVE_SCL_STRETCH_EN = 0x400
	// Position of SLAVE_SCL_STRETCH_CLR field.
	I2C0_SCL_STRETCH_CONF_SLAVE_SCL_STRETCH_CLR_Pos = 0xb
	// Bit mask of SLAVE_SCL_STRETCH_CLR field.
	I2C0_SCL_STRETCH_CONF_SLAVE_SCL_STRETCH_CLR_Msk = 0x800
	// Bit SLAVE_SCL_STRETCH_CLR.
	I2C0_SCL_STRETCH_CONF_SLAVE_SCL_STRETCH_CLR = 0x800

	// DATE: Version control register
	// Position of DATE field.
	I2C0_DATE_DATE_Pos = 0x0
	// Bit mask of DATE field.
	I2C0_DATE_DATE_Msk = 0xffffffff
)

// Constants for I2S: Peripheral I2S
const (
	// CONF: I2S Configure register
	// Position of TX_RESET field.
	I2S_CONF_TX_RESET_Pos = 0x0
	// Bit mask of TX_RESET field.
	I2S_CONF_TX_RESET_Msk = 0x1
	// Bit TX_RESET.
	I2S_CONF_TX_RESET = 0x1
	// Position of RX_RESET field.
	I2S_CONF_RX_RESET_Pos = 0x1
	// Bit mask of RX_RESET field.
	I2S_CONF_RX_RESET_Msk = 0x2
	// Bit RX_RESET.
	I2S_CONF_RX_RESET = 0x2
	// Position of TX_FIFO_RESET field.
	I2S_CONF_TX_FIFO_RESET_Pos = 0x2
	// Bit mask of TX_FIFO_RESET field.
	I2S_CONF_TX_FIFO_RESET_Msk = 0x4
	// Bit TX_FIFO_RESET.
	I2S_CONF_TX_FIFO_RESET = 0x4
	// Position of RX_FIFO_RESET field.
	I2S_CONF_RX_FIFO_RESET_Pos = 0x3
	// Bit mask of RX_FIFO_RESET field.
	I2S_CONF_RX_FIFO_RESET_Msk = 0x8
	// Bit RX_FIFO_RESET.
	I2S_CONF_RX_FIFO_RESET = 0x8
	// Position of TX_START field.
	I2S_CONF_TX_START_Pos = 0x4
	// Bit mask of TX_START field.
	I2S_CONF_TX_START_Msk = 0x10
	// Bit TX_START.
	I2S_CONF_TX_START = 0x10
	// Position of RX_START field.
	I2S_CONF_RX_START_Pos = 0x5
	// Bit mask of RX_START field.
	I2S_CONF_RX_START_Msk = 0x20
	// Bit RX_START.
	I2S_CONF_RX_START = 0x20
	// Position of TX_SLAVE_MOD field.
	I2S_CONF_TX_SLAVE_MOD_Pos = 0x6
	// Bit mask of TX_SLAVE_MOD field.
	I2S_CONF_TX_SLAVE_MOD_Msk = 0x40
	// Bit TX_SLAVE_MOD.
	I2S_CONF_TX_SLAVE_MOD = 0x40
	// Position of RX_SLAVE_MOD field.
	I2S_CONF_RX_SLAVE_MOD_Pos = 0x7
	// Bit mask of RX_SLAVE_MOD field.
	I2S_CONF_RX_SLAVE_MOD_Msk = 0x80
	// Bit RX_SLAVE_MOD.
	I2S_CONF_RX_SLAVE_MOD = 0x80
	// Position of TX_RIGHT_FIRST field.
	I2S_CONF_TX_RIGHT_FIRST_Pos = 0x8
	// Bit mask of TX_RIGHT_FIRST field.
	I2S_CONF_TX_RIGHT_FIRST_Msk = 0x100
	// Bit TX_RIGHT_FIRST.
	I2S_CONF_TX_RIGHT_FIRST = 0x100
	// Position of RX_RIGHT_FIRST field.
	I2S_CONF_RX_RIGHT_FIRST_Pos = 0x9
	// Bit mask of RX_RIGHT_FIRST field.
	I2S_CONF_RX_RIGHT_FIRST_Msk = 0x200
	// Bit RX_RIGHT_FIRST.
	I2S_CONF_RX_RIGHT_FIRST = 0x200
	// Position of TX_MSB_SHIFT field.
	I2S_CONF_TX_MSB_SHIFT_Pos = 0xa
	// Bit mask of TX_MSB_SHIFT field.
	I2S_CONF_TX_MSB_SHIFT_Msk = 0x400
	// Bit TX_MSB_SHIFT.
	I2S_CONF_TX_MSB_SHIFT = 0x400
	// Position of RX_MSB_SHIFT field.
	I2S_CONF_RX_MSB_SHIFT_Pos = 0xb
	// Bit mask of RX_MSB_SHIFT field.
	I2S_CONF_RX_MSB_SHIFT_Msk = 0x800
	// Bit RX_MSB_SHIFT.
	I2S_CONF_RX_MSB_SHIFT = 0x800
	// Position of TX_SHORT_SYNC field.
	I2S_CONF_TX_SHORT_SYNC_Pos = 0xc
	// Bit mask of TX_SHORT_SYNC field.
	I2S_CONF_TX_SHORT_SYNC_Msk = 0x1000
	// Bit TX_SHORT_SYNC.
	I2S_CONF_TX_SHORT_SYNC = 0x1000
	// Position of RX_SHORT_SYNC field.
	I2S_CONF_RX_SHORT_SYNC_Pos = 0xd
	// Bit mask of RX_SHORT_SYNC field.
	I2S_CONF_RX_SHORT_SYNC_Msk = 0x2000
	// Bit RX_SHORT_SYNC.
	I2S_CONF_RX_SHORT_SYNC = 0x2000
	// Position of TX_MONO field.
	I2S_CONF_TX_MONO_Pos = 0xe
	// Bit mask of TX_MONO field.
	I2S_CONF_TX_MONO_Msk = 0x4000
	// Bit TX_MONO.
	I2S_CONF_TX_MONO = 0x4000
	// Position of RX_MONO field.
	I2S_CONF_RX_MONO_Pos = 0xf
	// Bit mask of RX_MONO field.
	I2S_CONF_RX_MONO_Msk = 0x8000
	// Bit RX_MONO.
	I2S_CONF_RX_MONO = 0x8000
	// Position of TX_MSB_RIGHT field.
	I2S_CONF_TX_MSB_RIGHT_Pos = 0x10
	// Bit mask of TX_MSB_RIGHT field.
	I2S_CONF_TX_MSB_RIGHT_Msk = 0x10000
	// Bit TX_MSB_RIGHT.
	I2S_CONF_TX_MSB_RIGHT = 0x10000
	// Position of RX_MSB_RIGHT field.
	I2S_CONF_RX_MSB_RIGHT_Pos = 0x11
	// Bit mask of RX_MSB_RIGHT field.
	I2S_CONF_RX_MSB_RIGHT_Msk = 0x20000
	// Bit RX_MSB_RIGHT.
	I2S_CONF_RX_MSB_RIGHT = 0x20000
	// Position of TX_LSB_FIRST_DMA field.
	I2S_CONF_TX_LSB_FIRST_DMA_Pos = 0x12
	// Bit mask of TX_LSB_FIRST_DMA field.
	I2S_CONF_TX_LSB_FIRST_DMA_Msk = 0x40000
	// Bit TX_LSB_FIRST_DMA.
	I2S_CONF_TX_LSB_FIRST_DMA = 0x40000
	// Position of RX_LSB_FIRST_DMA field.
	I2S_CONF_RX_LSB_FIRST_DMA_Pos = 0x13
	// Bit mask of RX_LSB_FIRST_DMA field.
	I2S_CONF_RX_LSB_FIRST_DMA_Msk = 0x80000
	// Bit RX_LSB_FIRST_DMA.
	I2S_CONF_RX_LSB_FIRST_DMA = 0x80000
	// Position of SIG_LOOPBACK field.
	I2S_CONF_SIG_LOOPBACK_Pos = 0x14
	// Bit mask of SIG_LOOPBACK field.
	I2S_CONF_SIG_LOOPBACK_Msk = 0x100000
	// Bit SIG_LOOPBACK.
	I2S_CONF_SIG_LOOPBACK = 0x100000
	// Position of TX_FIFO_RESET_ST field.
	I2S_CONF_TX_FIFO_RESET_ST_Pos = 0x15
	// Bit mask of TX_FIFO_RESET_ST field.
	I2S_CONF_TX_FIFO_RESET_ST_Msk = 0x200000
	// Bit TX_FIFO_RESET_ST.
	I2S_CONF_TX_FIFO_RESET_ST = 0x200000
	// Position of RX_FIFO_RESET_ST field.
	I2S_CONF_RX_FIFO_RESET_ST_Pos = 0x16
	// Bit mask of RX_FIFO_RESET_ST field.
	I2S_CONF_RX_FIFO_RESET_ST_Msk = 0x400000
	// Bit RX_FIFO_RESET_ST.
	I2S_CONF_RX_FIFO_RESET_ST = 0x400000
	// Position of TX_RESET_ST field.
	I2S_CONF_TX_RESET_ST_Pos = 0x17
	// Bit mask of TX_RESET_ST field.
	I2S_CONF_TX_RESET_ST_Msk = 0x800000
	// Bit TX_RESET_ST.
	I2S_CONF_TX_RESET_ST = 0x800000
	// Position of TX_DMA_EQUAL field.
	I2S_CONF_TX_DMA_EQUAL_Pos = 0x18
	// Bit mask of TX_DMA_EQUAL field.
	I2S_CONF_TX_DMA_EQUAL_Msk = 0x1000000
	// Bit TX_DMA_EQUAL.
	I2S_CONF_TX_DMA_EQUAL = 0x1000000
	// Position of RX_DMA_EQUAL field.
	I2S_CONF_RX_DMA_EQUAL_Pos = 0x19
	// Bit mask of RX_DMA_EQUAL field.
	I2S_CONF_RX_DMA_EQUAL_Msk = 0x2000000
	// Bit RX_DMA_EQUAL.
	I2S_CONF_RX_DMA_EQUAL = 0x2000000
	// Position of PRE_REQ_EN field.
	I2S_CONF_PRE_REQ_EN_Pos = 0x1a
	// Bit mask of PRE_REQ_EN field.
	I2S_CONF_PRE_REQ_EN_Msk = 0x4000000
	// Bit PRE_REQ_EN.
	I2S_CONF_PRE_REQ_EN = 0x4000000
	// Position of TX_BIG_ENDIAN field.
	I2S_CONF_TX_BIG_ENDIAN_Pos = 0x1b
	// Bit mask of TX_BIG_ENDIAN field.
	I2S_CONF_TX_BIG_ENDIAN_Msk = 0x8000000
	// Bit TX_BIG_ENDIAN.
	I2S_CONF_TX_BIG_ENDIAN = 0x8000000
	// Position of RX_BIG_ENDIAN field.
	I2S_CONF_RX_BIG_ENDIAN_Pos = 0x1c
	// Bit mask of RX_BIG_ENDIAN field.
	I2S_CONF_RX_BIG_ENDIAN_Msk = 0x10000000
	// Bit RX_BIG_ENDIAN.
	I2S_CONF_RX_BIG_ENDIAN = 0x10000000
	// Position of RX_RESET_ST field.
	I2S_CONF_RX_RESET_ST_Pos = 0x1d
	// Bit mask of RX_RESET_ST field.
	I2S_CONF_RX_RESET_ST_Msk = 0x20000000
	// Bit RX_RESET_ST.
	I2S_CONF_RX_RESET_ST = 0x20000000

	// INT_RAW: Raw interrupt status
	// Position of RX_TAKE_DATA_INT_RAW field.
	I2S_INT_RAW_RX_TAKE_DATA_INT_RAW_Pos = 0x0
	// Bit mask of RX_TAKE_DATA_INT_RAW field.
	I2S_INT_RAW_RX_TAKE_DATA_INT_RAW_Msk = 0x1
	// Bit RX_TAKE_DATA_INT_RAW.
	I2S_INT_RAW_RX_TAKE_DATA_INT_RAW = 0x1
	// Position of TX_PUT_DATA_INT_RAW field.
	I2S_INT_RAW_TX_PUT_DATA_INT_RAW_Pos = 0x1
	// Bit mask of TX_PUT_DATA_INT_RAW field.
	I2S_INT_RAW_TX_PUT_DATA_INT_RAW_Msk = 0x2
	// Bit TX_PUT_DATA_INT_RAW.
	I2S_INT_RAW_TX_PUT_DATA_INT_RAW = 0x2
	// Position of RX_WFULL_INT_RAW field.
	I2S_INT_RAW_RX_WFULL_INT_RAW_Pos = 0x2
	// Bit mask of RX_WFULL_INT_RAW field.
	I2S_INT_RAW_RX_WFULL_INT_RAW_Msk = 0x4
	// Bit RX_WFULL_INT_RAW.
	I2S_INT_RAW_RX_WFULL_INT_RAW = 0x4
	// Position of RX_REMPTY_INT_RAW field.
	I2S_INT_RAW_RX_REMPTY_INT_RAW_Pos = 0x3
	// Bit mask of RX_REMPTY_INT_RAW field.
	I2S_INT_RAW_RX_REMPTY_INT_RAW_Msk = 0x8
	// Bit RX_REMPTY_INT_RAW.
	I2S_INT_RAW_RX_REMPTY_INT_RAW = 0x8
	// Position of TX_WFULL_INT_RAW field.
	I2S_INT_RAW_TX_WFULL_INT_RAW_Pos = 0x4
	// Bit mask of TX_WFULL_INT_RAW field.
	I2S_INT_RAW_TX_WFULL_INT_RAW_Msk = 0x10
	// Bit TX_WFULL_INT_RAW.
	I2S_INT_RAW_TX_WFULL_INT_RAW = 0x10
	// Position of TX_REMPTY_INT_RAW field.
	I2S_INT_RAW_TX_REMPTY_INT_RAW_Pos = 0x5
	// Bit mask of TX_REMPTY_INT_RAW field.
	I2S_INT_RAW_TX_REMPTY_INT_RAW_Msk = 0x20
	// Bit TX_REMPTY_INT_RAW.
	I2S_INT_RAW_TX_REMPTY_INT_RAW = 0x20
	// Position of RX_HUNG_INT_RAW field.
	I2S_INT_RAW_RX_HUNG_INT_RAW_Pos = 0x6
	// Bit mask of RX_HUNG_INT_RAW field.
	I2S_INT_RAW_RX_HUNG_INT_RAW_Msk = 0x40
	// Bit RX_HUNG_INT_RAW.
	I2S_INT_RAW_RX_HUNG_INT_RAW = 0x40
	// Position of TX_HUNG_INT_RAW field.
	I2S_INT_RAW_TX_HUNG_INT_RAW_Pos = 0x7
	// Bit mask of TX_HUNG_INT_RAW field.
	I2S_INT_RAW_TX_HUNG_INT_RAW_Msk = 0x80
	// Bit TX_HUNG_INT_RAW.
	I2S_INT_RAW_TX_HUNG_INT_RAW = 0x80
	// Position of IN_DONE_INT_RAW field.
	I2S_INT_RAW_IN_DONE_INT_RAW_Pos = 0x8
	// Bit mask of IN_DONE_INT_RAW field.
	I2S_INT_RAW_IN_DONE_INT_RAW_Msk = 0x100
	// Bit IN_DONE_INT_RAW.
	I2S_INT_RAW_IN_DONE_INT_RAW = 0x100
	// Position of IN_SUC_EOF_INT_RAW field.
	I2S_INT_RAW_IN_SUC_EOF_INT_RAW_Pos = 0x9
	// Bit mask of IN_SUC_EOF_INT_RAW field.
	I2S_INT_RAW_IN_SUC_EOF_INT_RAW_Msk = 0x200
	// Bit IN_SUC_EOF_INT_RAW.
	I2S_INT_RAW_IN_SUC_EOF_INT_RAW = 0x200
	// Position of IN_ERR_EOF_INT_RAW field.
	I2S_INT_RAW_IN_ERR_EOF_INT_RAW_Pos = 0xa
	// Bit mask of IN_ERR_EOF_INT_RAW field.
	I2S_INT_RAW_IN_ERR_EOF_INT_RAW_Msk = 0x400
	// Bit IN_ERR_EOF_INT_RAW.
	I2S_INT_RAW_IN_ERR_EOF_INT_RAW = 0x400
	// Position of OUT_DONE_INT_RAW field.
	I2S_INT_RAW_OUT_DONE_INT_RAW_Pos = 0xb
	// Bit mask of OUT_DONE_INT_RAW field.
	I2S_INT_RAW_OUT_DONE_INT_RAW_Msk = 0x800
	// Bit OUT_DONE_INT_RAW.
	I2S_INT_RAW_OUT_DONE_INT_RAW = 0x800
	// Position of OUT_EOF_INT_RAW field.
	I2S_INT_RAW_OUT_EOF_INT_RAW_Pos = 0xc
	// Bit mask of OUT_EOF_INT_RAW field.
	I2S_INT_RAW_OUT_EOF_INT_RAW_Msk = 0x1000
	// Bit OUT_EOF_INT_RAW.
	I2S_INT_RAW_OUT_EOF_INT_RAW = 0x1000
	// Position of IN_DSCR_ERR_INT_RAW field.
	I2S_INT_RAW_IN_DSCR_ERR_INT_RAW_Pos = 0xd
	// Bit mask of IN_DSCR_ERR_INT_RAW field.
	I2S_INT_RAW_IN_DSCR_ERR_INT_RAW_Msk = 0x2000
	// Bit IN_DSCR_ERR_INT_RAW.
	I2S_INT_RAW_IN_DSCR_ERR_INT_RAW = 0x2000
	// Position of OUT_DSCR_ERR_INT_RAW field.
	I2S_INT_RAW_OUT_DSCR_ERR_INT_RAW_Pos = 0xe
	// Bit mask of OUT_DSCR_ERR_INT_RAW field.
	I2S_INT_RAW_OUT_DSCR_ERR_INT_RAW_Msk = 0x4000
	// Bit OUT_DSCR_ERR_INT_RAW.
	I2S_INT_RAW_OUT_DSCR_ERR_INT_RAW = 0x4000
	// Position of IN_DSCR_EMPTY_INT_RAW field.
	I2S_INT_RAW_IN_DSCR_EMPTY_INT_RAW_Pos = 0xf
	// Bit mask of IN_DSCR_EMPTY_INT_RAW field.
	I2S_INT_RAW_IN_DSCR_EMPTY_INT_RAW_Msk = 0x8000
	// Bit IN_DSCR_EMPTY_INT_RAW.
	I2S_INT_RAW_IN_DSCR_EMPTY_INT_RAW = 0x8000
	// Position of OUT_TOTAL_EOF_INT_RAW field.
	I2S_INT_RAW_OUT_TOTAL_EOF_INT_RAW_Pos = 0x10
	// Bit mask of OUT_TOTAL_EOF_INT_RAW field.
	I2S_INT_RAW_OUT_TOTAL_EOF_INT_RAW_Msk = 0x10000
	// Bit OUT_TOTAL_EOF_INT_RAW.
	I2S_INT_RAW_OUT_TOTAL_EOF_INT_RAW = 0x10000
	// Position of V_SYNC_INT_RAW field.
	I2S_INT_RAW_V_SYNC_INT_RAW_Pos = 0x11
	// Bit mask of V_SYNC_INT_RAW field.
	I2S_INT_RAW_V_SYNC_INT_RAW_Msk = 0x20000
	// Bit V_SYNC_INT_RAW.
	I2S_INT_RAW_V_SYNC_INT_RAW = 0x20000

	// INT_ST: Masked interrupt status
	// Position of RX_TAKE_DATA_INT_ST field.
	I2S_INT_ST_RX_TAKE_DATA_INT_ST_Pos = 0x0
	// Bit mask of RX_TAKE_DATA_INT_ST field.
	I2S_INT_ST_RX_TAKE_DATA_INT_ST_Msk = 0x1
	// Bit RX_TAKE_DATA_INT_ST.
	I2S_INT_ST_RX_TAKE_DATA_INT_ST = 0x1
	// Position of TX_PUT_DATA_INT_ST field.
	I2S_INT_ST_TX_PUT_DATA_INT_ST_Pos = 0x1
	// Bit mask of TX_PUT_DATA_INT_ST field.
	I2S_INT_ST_TX_PUT_DATA_INT_ST_Msk = 0x2
	// Bit TX_PUT_DATA_INT_ST.
	I2S_INT_ST_TX_PUT_DATA_INT_ST = 0x2
	// Position of RX_WFULL_INT_ST field.
	I2S_INT_ST_RX_WFULL_INT_ST_Pos = 0x2
	// Bit mask of RX_WFULL_INT_ST field.
	I2S_INT_ST_RX_WFULL_INT_ST_Msk = 0x4
	// Bit RX_WFULL_INT_ST.
	I2S_INT_ST_RX_WFULL_INT_ST = 0x4
	// Position of RX_REMPTY_INT_ST field.
	I2S_INT_ST_RX_REMPTY_INT_ST_Pos = 0x3
	// Bit mask of RX_REMPTY_INT_ST field.
	I2S_INT_ST_RX_REMPTY_INT_ST_Msk = 0x8
	// Bit RX_REMPTY_INT_ST.
	I2S_INT_ST_RX_REMPTY_INT_ST = 0x8
	// Position of TX_WFULL_INT_ST field.
	I2S_INT_ST_TX_WFULL_INT_ST_Pos = 0x4
	// Bit mask of TX_WFULL_INT_ST field.
	I2S_INT_ST_TX_WFULL_INT_ST_Msk = 0x10
	// Bit TX_WFULL_INT_ST.
	I2S_INT_ST_TX_WFULL_INT_ST = 0x10
	// Position of TX_REMPTY_INT_ST field.
	I2S_INT_ST_TX_REMPTY_INT_ST_Pos = 0x5
	// Bit mask of TX_REMPTY_INT_ST field.
	I2S_INT_ST_TX_REMPTY_INT_ST_Msk = 0x20
	// Bit TX_REMPTY_INT_ST.
	I2S_INT_ST_TX_REMPTY_INT_ST = 0x20
	// Position of RX_HUNG_INT_ST field.
	I2S_INT_ST_RX_HUNG_INT_ST_Pos = 0x6
	// Bit mask of RX_HUNG_INT_ST field.
	I2S_INT_ST_RX_HUNG_INT_ST_Msk = 0x40
	// Bit RX_HUNG_INT_ST.
	I2S_INT_ST_RX_HUNG_INT_ST = 0x40
	// Position of TX_HUNG_INT_ST field.
	I2S_INT_ST_TX_HUNG_INT_ST_Pos = 0x7
	// Bit mask of TX_HUNG_INT_ST field.
	I2S_INT_ST_TX_HUNG_INT_ST_Msk = 0x80
	// Bit TX_HUNG_INT_ST.
	I2S_INT_ST_TX_HUNG_INT_ST = 0x80
	// Position of IN_DONE_INT_ST field.
	I2S_INT_ST_IN_DONE_INT_ST_Pos = 0x8
	// Bit mask of IN_DONE_INT_ST field.
	I2S_INT_ST_IN_DONE_INT_ST_Msk = 0x100
	// Bit IN_DONE_INT_ST.
	I2S_INT_ST_IN_DONE_INT_ST = 0x100
	// Position of IN_SUC_EOF_INT_ST field.
	I2S_INT_ST_IN_SUC_EOF_INT_ST_Pos = 0x9
	// Bit mask of IN_SUC_EOF_INT_ST field.
	I2S_INT_ST_IN_SUC_EOF_INT_ST_Msk = 0x200
	// Bit IN_SUC_EOF_INT_ST.
	I2S_INT_ST_IN_SUC_EOF_INT_ST = 0x200
	// Position of IN_ERR_EOF_INT_ST field.
	I2S_INT_ST_IN_ERR_EOF_INT_ST_Pos = 0xa
	// Bit mask of IN_ERR_EOF_INT_ST field.
	I2S_INT_ST_IN_ERR_EOF_INT_ST_Msk = 0x400
	// Bit IN_ERR_EOF_INT_ST.
	I2S_INT_ST_IN_ERR_EOF_INT_ST = 0x400
	// Position of OUT_DONE_INT_ST field.
	I2S_INT_ST_OUT_DONE_INT_ST_Pos = 0xb
	// Bit mask of OUT_DONE_INT_ST field.
	I2S_INT_ST_OUT_DONE_INT_ST_Msk = 0x800
	// Bit OUT_DONE_INT_ST.
	I2S_INT_ST_OUT_DONE_INT_ST = 0x800
	// Position of OUT_EOF_INT_ST field.
	I2S_INT_ST_OUT_EOF_INT_ST_Pos = 0xc
	// Bit mask of OUT_EOF_INT_ST field.
	I2S_INT_ST_OUT_EOF_INT_ST_Msk = 0x1000
	// Bit OUT_EOF_INT_ST.
	I2S_INT_ST_OUT_EOF_INT_ST = 0x1000
	// Position of IN_DSCR_ERR_INT_ST field.
	I2S_INT_ST_IN_DSCR_ERR_INT_ST_Pos = 0xd
	// Bit mask of IN_DSCR_ERR_INT_ST field.
	I2S_INT_ST_IN_DSCR_ERR_INT_ST_Msk = 0x2000
	// Bit IN_DSCR_ERR_INT_ST.
	I2S_INT_ST_IN_DSCR_ERR_INT_ST = 0x2000
	// Position of OUT_DSCR_ERR_INT_ST field.
	I2S_INT_ST_OUT_DSCR_ERR_INT_ST_Pos = 0xe
	// Bit mask of OUT_DSCR_ERR_INT_ST field.
	I2S_INT_ST_OUT_DSCR_ERR_INT_ST_Msk = 0x4000
	// Bit OUT_DSCR_ERR_INT_ST.
	I2S_INT_ST_OUT_DSCR_ERR_INT_ST = 0x4000
	// Position of IN_DSCR_EMPTY_INT_ST field.
	I2S_INT_ST_IN_DSCR_EMPTY_INT_ST_Pos = 0xf
	// Bit mask of IN_DSCR_EMPTY_INT_ST field.
	I2S_INT_ST_IN_DSCR_EMPTY_INT_ST_Msk = 0x8000
	// Bit IN_DSCR_EMPTY_INT_ST.
	I2S_INT_ST_IN_DSCR_EMPTY_INT_ST = 0x8000
	// Position of OUT_TOTAL_EOF_INT_ST field.
	I2S_INT_ST_OUT_TOTAL_EOF_INT_ST_Pos = 0x10
	// Bit mask of OUT_TOTAL_EOF_INT_ST field.
	I2S_INT_ST_OUT_TOTAL_EOF_INT_ST_Msk = 0x10000
	// Bit OUT_TOTAL_EOF_INT_ST.
	I2S_INT_ST_OUT_TOTAL_EOF_INT_ST = 0x10000
	// Position of V_SYNC_INT_ST field.
	I2S_INT_ST_V_SYNC_INT_ST_Pos = 0x11
	// Bit mask of V_SYNC_INT_ST field.
	I2S_INT_ST_V_SYNC_INT_ST_Msk = 0x20000
	// Bit V_SYNC_INT_ST.
	I2S_INT_ST_V_SYNC_INT_ST = 0x20000

	// INT_ENA: Interrupt enable bits
	// Position of RX_TAKE_DATA_INT_ENA field.
	I2S_INT_ENA_RX_TAKE_DATA_INT_ENA_Pos = 0x0
	// Bit mask of RX_TAKE_DATA_INT_ENA field.
	I2S_INT_ENA_RX_TAKE_DATA_INT_ENA_Msk = 0x1
	// Bit RX_TAKE_DATA_INT_ENA.
	I2S_INT_ENA_RX_TAKE_DATA_INT_ENA = 0x1
	// Position of TX_PUT_DATA_INT_ENA field.
	I2S_INT_ENA_TX_PUT_DATA_INT_ENA_Pos = 0x1
	// Bit mask of TX_PUT_DATA_INT_ENA field.
	I2S_INT_ENA_TX_PUT_DATA_INT_ENA_Msk = 0x2
	// Bit TX_PUT_DATA_INT_ENA.
	I2S_INT_ENA_TX_PUT_DATA_INT_ENA = 0x2
	// Position of RX_WFULL_INT_ENA field.
	I2S_INT_ENA_RX_WFULL_INT_ENA_Pos = 0x2
	// Bit mask of RX_WFULL_INT_ENA field.
	I2S_INT_ENA_RX_WFULL_INT_ENA_Msk = 0x4
	// Bit RX_WFULL_INT_ENA.
	I2S_INT_ENA_RX_WFULL_INT_ENA = 0x4
	// Position of RX_REMPTY_INT_ENA field.
	I2S_INT_ENA_RX_REMPTY_INT_ENA_Pos = 0x3
	// Bit mask of RX_REMPTY_INT_ENA field.
	I2S_INT_ENA_RX_REMPTY_INT_ENA_Msk = 0x8
	// Bit RX_REMPTY_INT_ENA.
	I2S_INT_ENA_RX_REMPTY_INT_ENA = 0x8
	// Position of TX_WFULL_INT_ENA field.
	I2S_INT_ENA_TX_WFULL_INT_ENA_Pos = 0x4
	// Bit mask of TX_WFULL_INT_ENA field.
	I2S_INT_ENA_TX_WFULL_INT_ENA_Msk = 0x10
	// Bit TX_WFULL_INT_ENA.
	I2S_INT_ENA_TX_WFULL_INT_ENA = 0x10
	// Position of TX_REMPTY_INT_ENA field.
	I2S_INT_ENA_TX_REMPTY_INT_ENA_Pos = 0x5
	// Bit mask of TX_REMPTY_INT_ENA field.
	I2S_INT_ENA_TX_REMPTY_INT_ENA_Msk = 0x20
	// Bit TX_REMPTY_INT_ENA.
	I2S_INT_ENA_TX_REMPTY_INT_ENA = 0x20
	// Position of RX_HUNG_INT_ENA field.
	I2S_INT_ENA_RX_HUNG_INT_ENA_Pos = 0x6
	// Bit mask of RX_HUNG_INT_ENA field.
	I2S_INT_ENA_RX_HUNG_INT_ENA_Msk = 0x40
	// Bit RX_HUNG_INT_ENA.
	I2S_INT_ENA_RX_HUNG_INT_ENA = 0x40
	// Position of TX_HUNG_INT_ENA field.
	I2S_INT_ENA_TX_HUNG_INT_ENA_Pos = 0x7
	// Bit mask of TX_HUNG_INT_ENA field.
	I2S_INT_ENA_TX_HUNG_INT_ENA_Msk = 0x80
	// Bit TX_HUNG_INT_ENA.
	I2S_INT_ENA_TX_HUNG_INT_ENA = 0x80
	// Position of IN_DONE_INT_ENA field.
	I2S_INT_ENA_IN_DONE_INT_ENA_Pos = 0x8
	// Bit mask of IN_DONE_INT_ENA field.
	I2S_INT_ENA_IN_DONE_INT_ENA_Msk = 0x100
	// Bit IN_DONE_INT_ENA.
	I2S_INT_ENA_IN_DONE_INT_ENA = 0x100
	// Position of IN_SUC_EOF_INT_ENA field.
	I2S_INT_ENA_IN_SUC_EOF_INT_ENA_Pos = 0x9
	// Bit mask of IN_SUC_EOF_INT_ENA field.
	I2S_INT_ENA_IN_SUC_EOF_INT_ENA_Msk = 0x200
	// Bit IN_SUC_EOF_INT_ENA.
	I2S_INT_ENA_IN_SUC_EOF_INT_ENA = 0x200
	// Position of IN_ERR_EOF_INT_ENA field.
	I2S_INT_ENA_IN_ERR_EOF_INT_ENA_Pos = 0xa
	// Bit mask of IN_ERR_EOF_INT_ENA field.
	I2S_INT_ENA_IN_ERR_EOF_INT_ENA_Msk = 0x400
	// Bit IN_ERR_EOF_INT_ENA.
	I2S_INT_ENA_IN_ERR_EOF_INT_ENA = 0x400
	// Position of OUT_DONE_INT_ENA field.
	I2S_INT_ENA_OUT_DONE_INT_ENA_Pos = 0xb
	// Bit mask of OUT_DONE_INT_ENA field.
	I2S_INT_ENA_OUT_DONE_INT_ENA_Msk = 0x800
	// Bit OUT_DONE_INT_ENA.
	I2S_INT_ENA_OUT_DONE_INT_ENA = 0x800
	// Position of OUT_EOF_INT_ENA field.
	I2S_INT_ENA_OUT_EOF_INT_ENA_Pos = 0xc
	// Bit mask of OUT_EOF_INT_ENA field.
	I2S_INT_ENA_OUT_EOF_INT_ENA_Msk = 0x1000
	// Bit OUT_EOF_INT_ENA.
	I2S_INT_ENA_OUT_EOF_INT_ENA = 0x1000
	// Position of IN_DSCR_ERR_INT_ENA field.
	I2S_INT_ENA_IN_DSCR_ERR_INT_ENA_Pos = 0xd
	// Bit mask of IN_DSCR_ERR_INT_ENA field.
	I2S_INT_ENA_IN_DSCR_ERR_INT_ENA_Msk = 0x2000
	// Bit IN_DSCR_ERR_INT_ENA.
	I2S_INT_ENA_IN_DSCR_ERR_INT_ENA = 0x2000
	// Position of OUT_DSCR_ERR_INT_ENA field.
	I2S_INT_ENA_OUT_DSCR_ERR_INT_ENA_Pos = 0xe
	// Bit mask of OUT_DSCR_ERR_INT_ENA field.
	I2S_INT_ENA_OUT_DSCR_ERR_INT_ENA_Msk = 0x4000
	// Bit OUT_DSCR_ERR_INT_ENA.
	I2S_INT_ENA_OUT_DSCR_ERR_INT_ENA = 0x4000
	// Position of IN_DSCR_EMPTY_INT_ENA field.
	I2S_INT_ENA_IN_DSCR_EMPTY_INT_ENA_Pos = 0xf
	// Bit mask of IN_DSCR_EMPTY_INT_ENA field.
	I2S_INT_ENA_IN_DSCR_EMPTY_INT_ENA_Msk = 0x8000
	// Bit IN_DSCR_EMPTY_INT_ENA.
	I2S_INT_ENA_IN_DSCR_EMPTY_INT_ENA = 0x8000
	// Position of OUT_TOTAL_EOF_INT_ENA field.
	I2S_INT_ENA_OUT_TOTAL_EOF_INT_ENA_Pos = 0x10
	// Bit mask of OUT_TOTAL_EOF_INT_ENA field.
	I2S_INT_ENA_OUT_TOTAL_EOF_INT_ENA_Msk = 0x10000
	// Bit OUT_TOTAL_EOF_INT_ENA.
	I2S_INT_ENA_OUT_TOTAL_EOF_INT_ENA = 0x10000
	// Position of V_SYNC_INT_ENA field.
	I2S_INT_ENA_V_SYNC_INT_ENA_Pos = 0x11
	// Bit mask of V_SYNC_INT_ENA field.
	I2S_INT_ENA_V_SYNC_INT_ENA_Msk = 0x20000
	// Bit V_SYNC_INT_ENA.
	I2S_INT_ENA_V_SYNC_INT_ENA = 0x20000

	// INT_CLR: Interrupt clear bits
	// Position of TAKE_DATA_INT_CLR field.
	I2S_INT_CLR_TAKE_DATA_INT_CLR_Pos = 0x0
	// Bit mask of TAKE_DATA_INT_CLR field.
	I2S_INT_CLR_TAKE_DATA_INT_CLR_Msk = 0x1
	// Bit TAKE_DATA_INT_CLR.
	I2S_INT_CLR_TAKE_DATA_INT_CLR = 0x1
	// Position of PUT_DATA_INT_CLR field.
	I2S_INT_CLR_PUT_DATA_INT_CLR_Pos = 0x1
	// Bit mask of PUT_DATA_INT_CLR field.
	I2S_INT_CLR_PUT_DATA_INT_CLR_Msk = 0x2
	// Bit PUT_DATA_INT_CLR.
	I2S_INT_CLR_PUT_DATA_INT_CLR = 0x2
	// Position of RX_WFULL_INT_CLR field.
	I2S_INT_CLR_RX_WFULL_INT_CLR_Pos = 0x2
	// Bit mask of RX_WFULL_INT_CLR field.
	I2S_INT_CLR_RX_WFULL_INT_CLR_Msk = 0x4
	// Bit RX_WFULL_INT_CLR.
	I2S_INT_CLR_RX_WFULL_INT_CLR = 0x4
	// Position of RX_REMPTY_INT_CLR field.
	I2S_INT_CLR_RX_REMPTY_INT_CLR_Pos = 0x3
	// Bit mask of RX_REMPTY_INT_CLR field.
	I2S_INT_CLR_RX_REMPTY_INT_CLR_Msk = 0x8
	// Bit RX_REMPTY_INT_CLR.
	I2S_INT_CLR_RX_REMPTY_INT_CLR = 0x8
	// Position of TX_WFULL_INT_CLR field.
	I2S_INT_CLR_TX_WFULL_INT_CLR_Pos = 0x4
	// Bit mask of TX_WFULL_INT_CLR field.
	I2S_INT_CLR_TX_WFULL_INT_CLR_Msk = 0x10
	// Bit TX_WFULL_INT_CLR.
	I2S_INT_CLR_TX_WFULL_INT_CLR = 0x10
	// Position of TX_REMPTY_INT_CLR field.
	I2S_INT_CLR_TX_REMPTY_INT_CLR_Pos = 0x5
	// Bit mask of TX_REMPTY_INT_CLR field.
	I2S_INT_CLR_TX_REMPTY_INT_CLR_Msk = 0x20
	// Bit TX_REMPTY_INT_CLR.
	I2S_INT_CLR_TX_REMPTY_INT_CLR = 0x20
	// Position of RX_HUNG_INT_CLR field.
	I2S_INT_CLR_RX_HUNG_INT_CLR_Pos = 0x6
	// Bit mask of RX_HUNG_INT_CLR field.
	I2S_INT_CLR_RX_HUNG_INT_CLR_Msk = 0x40
	// Bit RX_HUNG_INT_CLR.
	I2S_INT_CLR_RX_HUNG_INT_CLR = 0x40
	// Position of TX_HUNG_INT_CLR field.
	I2S_INT_CLR_TX_HUNG_INT_CLR_Pos = 0x7
	// Bit mask of TX_HUNG_INT_CLR field.
	I2S_INT_CLR_TX_HUNG_INT_CLR_Msk = 0x80
	// Bit TX_HUNG_INT_CLR.
	I2S_INT_CLR_TX_HUNG_INT_CLR = 0x80
	// Position of IN_DONE_INT_CLR field.
	I2S_INT_CLR_IN_DONE_INT_CLR_Pos = 0x8
	// Bit mask of IN_DONE_INT_CLR field.
	I2S_INT_CLR_IN_DONE_INT_CLR_Msk = 0x100
	// Bit IN_DONE_INT_CLR.
	I2S_INT_CLR_IN_DONE_INT_CLR = 0x100
	// Position of IN_SUC_EOF_INT_CLR field.
	I2S_INT_CLR_IN_SUC_EOF_INT_CLR_Pos = 0x9
	// Bit mask of IN_SUC_EOF_INT_CLR field.
	I2S_INT_CLR_IN_SUC_EOF_INT_CLR_Msk = 0x200
	// Bit IN_SUC_EOF_INT_CLR.
	I2S_INT_CLR_IN_SUC_EOF_INT_CLR = 0x200
	// Position of IN_ERR_EOF_INT_CLR field.
	I2S_INT_CLR_IN_ERR_EOF_INT_CLR_Pos = 0xa
	// Bit mask of IN_ERR_EOF_INT_CLR field.
	I2S_INT_CLR_IN_ERR_EOF_INT_CLR_Msk = 0x400
	// Bit IN_ERR_EOF_INT_CLR.
	I2S_INT_CLR_IN_ERR_EOF_INT_CLR = 0x400
	// Position of OUT_DONE_INT_CLR field.
	I2S_INT_CLR_OUT_DONE_INT_CLR_Pos = 0xb
	// Bit mask of OUT_DONE_INT_CLR field.
	I2S_INT_CLR_OUT_DONE_INT_CLR_Msk = 0x800
	// Bit OUT_DONE_INT_CLR.
	I2S_INT_CLR_OUT_DONE_INT_CLR = 0x800
	// Position of OUT_EOF_INT_CLR field.
	I2S_INT_CLR_OUT_EOF_INT_CLR_Pos = 0xc
	// Bit mask of OUT_EOF_INT_CLR field.
	I2S_INT_CLR_OUT_EOF_INT_CLR_Msk = 0x1000
	// Bit OUT_EOF_INT_CLR.
	I2S_INT_CLR_OUT_EOF_INT_CLR = 0x1000
	// Position of IN_DSCR_ERR_INT_CLR field.
	I2S_INT_CLR_IN_DSCR_ERR_INT_CLR_Pos = 0xd
	// Bit mask of IN_DSCR_ERR_INT_CLR field.
	I2S_INT_CLR_IN_DSCR_ERR_INT_CLR_Msk = 0x2000
	// Bit IN_DSCR_ERR_INT_CLR.
	I2S_INT_CLR_IN_DSCR_ERR_INT_CLR = 0x2000
	// Position of OUT_DSCR_ERR_INT_CLR field.
	I2S_INT_CLR_OUT_DSCR_ERR_INT_CLR_Pos = 0xe
	// Bit mask of OUT_DSCR_ERR_INT_CLR field.
	I2S_INT_CLR_OUT_DSCR_ERR_INT_CLR_Msk = 0x4000
	// Bit OUT_DSCR_ERR_INT_CLR.
	I2S_INT_CLR_OUT_DSCR_ERR_INT_CLR = 0x4000
	// Position of IN_DSCR_EMPTY_INT_CLR field.
	I2S_INT_CLR_IN_DSCR_EMPTY_INT_CLR_Pos = 0xf
	// Bit mask of IN_DSCR_EMPTY_INT_CLR field.
	I2S_INT_CLR_IN_DSCR_EMPTY_INT_CLR_Msk = 0x8000
	// Bit IN_DSCR_EMPTY_INT_CLR.
	I2S_INT_CLR_IN_DSCR_EMPTY_INT_CLR = 0x8000
	// Position of OUT_TOTAL_EOF_INT_CLR field.
	I2S_INT_CLR_OUT_TOTAL_EOF_INT_CLR_Pos = 0x10
	// Bit mask of OUT_TOTAL_EOF_INT_CLR field.
	I2S_INT_CLR_OUT_TOTAL_EOF_INT_CLR_Msk = 0x10000
	// Bit OUT_TOTAL_EOF_INT_CLR.
	I2S_INT_CLR_OUT_TOTAL_EOF_INT_CLR = 0x10000
	// Position of V_SYNC_INT_CLR field.
	I2S_INT_CLR_V_SYNC_INT_CLR_Pos = 0x11
	// Bit mask of V_SYNC_INT_CLR field.
	I2S_INT_CLR_V_SYNC_INT_CLR_Msk = 0x20000
	// Bit V_SYNC_INT_CLR.
	I2S_INT_CLR_V_SYNC_INT_CLR = 0x20000

	// TIMING: I2S timing register
	// Position of TX_BCK_IN_DELAY field.
	I2S_TIMING_TX_BCK_IN_DELAY_Pos = 0x0
	// Bit mask of TX_BCK_IN_DELAY field.
	I2S_TIMING_TX_BCK_IN_DELAY_Msk = 0x3
	// Position of TX_WS_IN_DELAY field.
	I2S_TIMING_TX_WS_IN_DELAY_Pos = 0x2
	// Bit mask of TX_WS_IN_DELAY field.
	I2S_TIMING_TX_WS_IN_DELAY_Msk = 0xc
	// Position of RX_BCK_IN_DELAY field.
	I2S_TIMING_RX_BCK_IN_DELAY_Pos = 0x4
	// Bit mask of RX_BCK_IN_DELAY field.
	I2S_TIMING_RX_BCK_IN_DELAY_Msk = 0x30
	// Position of RX_WS_IN_DELAY field.
	I2S_TIMING_RX_WS_IN_DELAY_Pos = 0x6
	// Bit mask of RX_WS_IN_DELAY field.
	I2S_TIMING_RX_WS_IN_DELAY_Msk = 0xc0
	// Position of RX_SD_IN_DELAY field.
	I2S_TIMING_RX_SD_IN_DELAY_Pos = 0x8
	// Bit mask of RX_SD_IN_DELAY field.
	I2S_TIMING_RX_SD_IN_DELAY_Msk = 0x300
	// Position of TX_BCK_OUT_DELAY field.
	I2S_TIMING_TX_BCK_OUT_DELAY_Pos = 0xa
	// Bit mask of TX_BCK_OUT_DELAY field.
	I2S_TIMING_TX_BCK_OUT_DELAY_Msk = 0xc00
	// Position of TX_WS_OUT_DELAY field.
	I2S_TIMING_TX_WS_OUT_DELAY_Pos = 0xc
	// Bit mask of TX_WS_OUT_DELAY field.
	I2S_TIMING_TX_WS_OUT_DELAY_Msk = 0x3000
	// Position of TX_SD_OUT_DELAY field.
	I2S_TIMING_TX_SD_OUT_DELAY_Pos = 0xe
	// Bit mask of TX_SD_OUT_DELAY field.
	I2S_TIMING_TX_SD_OUT_DELAY_Msk = 0xc000
	// Position of RX_WS_OUT_DELAY field.
	I2S_TIMING_RX_WS_OUT_DELAY_Pos = 0x10
	// Bit mask of RX_WS_OUT_DELAY field.
	I2S_TIMING_RX_WS_OUT_DELAY_Msk = 0x30000
	// Position of RX_BCK_OUT_DELAY field.
	I2S_TIMING_RX_BCK_OUT_DELAY_Pos = 0x12
	// Bit mask of RX_BCK_OUT_DELAY field.
	I2S_TIMING_RX_BCK_OUT_DELAY_Msk = 0xc0000
	// Position of TX_DSYNC_SW field.
	I2S_TIMING_TX_DSYNC_SW_Pos = 0x14
	// Bit mask of TX_DSYNC_SW field.
	I2S_TIMING_TX_DSYNC_SW_Msk = 0x100000
	// Bit TX_DSYNC_SW.
	I2S_TIMING_TX_DSYNC_SW = 0x100000
	// Position of RX_DSYNC_SW field.
	I2S_TIMING_RX_DSYNC_SW_Pos = 0x15
	// Bit mask of RX_DSYNC_SW field.
	I2S_TIMING_RX_DSYNC_SW_Msk = 0x200000
	// Bit RX_DSYNC_SW.
	I2S_TIMING_RX_DSYNC_SW = 0x200000
	// Position of DATA_ENABLE_DELAY field.
	I2S_TIMING_DATA_ENABLE_DELAY_Pos = 0x16
	// Bit mask of DATA_ENABLE_DELAY field.
	I2S_TIMING_DATA_ENABLE_DELAY_Msk = 0xc00000
	// Position of TX_BCK_IN_INV field.
	I2S_TIMING_TX_BCK_IN_INV_Pos = 0x18
	// Bit mask of TX_BCK_IN_INV field.
	I2S_TIMING_TX_BCK_IN_INV_Msk = 0x1000000
	// Bit TX_BCK_IN_INV.
	I2S_TIMING_TX_BCK_IN_INV = 0x1000000

	// FIFO_CONF: I2S FIFO configure register
	// Position of RX_DATA_NUM field.
	I2S_FIFO_CONF_RX_DATA_NUM_Pos = 0x0
	// Bit mask of RX_DATA_NUM field.
	I2S_FIFO_CONF_RX_DATA_NUM_Msk = 0x3f
	// Position of TX_DATA_NUM field.
	I2S_FIFO_CONF_TX_DATA_NUM_Pos = 0x6
	// Bit mask of TX_DATA_NUM field.
	I2S_FIFO_CONF_TX_DATA_NUM_Msk = 0xfc0
	// Position of DSCR_EN field.
	I2S_FIFO_CONF_DSCR_EN_Pos = 0xc
	// Bit mask of DSCR_EN field.
	I2S_FIFO_CONF_DSCR_EN_Msk = 0x1000
	// Bit DSCR_EN.
	I2S_FIFO_CONF_DSCR_EN = 0x1000
	// Position of TX_FIFO_MOD field.
	I2S_FIFO_CONF_TX_FIFO_MOD_Pos = 0xd
	// Bit mask of TX_FIFO_MOD field.
	I2S_FIFO_CONF_TX_FIFO_MOD_Msk = 0xe000
	// Position of RX_FIFO_MOD field.
	I2S_FIFO_CONF_RX_FIFO_MOD_Pos = 0x10
	// Bit mask of RX_FIFO_MOD field.
	I2S_FIFO_CONF_RX_FIFO_MOD_Msk = 0x70000
	// Position of TX_FIFO_MOD_FORCE_EN field.
	I2S_FIFO_CONF_TX_FIFO_MOD_FORCE_EN_Pos = 0x13
	// Bit mask of TX_FIFO_MOD_FORCE_EN field.
	I2S_FIFO_CONF_TX_FIFO_MOD_FORCE_EN_Msk = 0x80000
	// Bit TX_FIFO_MOD_FORCE_EN.
	I2S_FIFO_CONF_TX_FIFO_MOD_FORCE_EN = 0x80000
	// Position of RX_FIFO_MOD_FORCE_EN field.
	I2S_FIFO_CONF_RX_FIFO_MOD_FORCE_EN_Pos = 0x14
	// Bit mask of RX_FIFO_MOD_FORCE_EN field.
	I2S_FIFO_CONF_RX_FIFO_MOD_FORCE_EN_Msk = 0x100000
	// Bit RX_FIFO_MOD_FORCE_EN.
	I2S_FIFO_CONF_RX_FIFO_MOD_FORCE_EN = 0x100000
	// Position of RX_FIFO_SYNC field.
	I2S_FIFO_CONF_RX_FIFO_SYNC_Pos = 0x15
	// Bit mask of RX_FIFO_SYNC field.
	I2S_FIFO_CONF_RX_FIFO_SYNC_Msk = 0x200000
	// Bit RX_FIFO_SYNC.
	I2S_FIFO_CONF_RX_FIFO_SYNC = 0x200000
	// Position of RX_24MSB_EN field.
	I2S_FIFO_CONF_RX_24MSB_EN_Pos = 0x16
	// Bit mask of RX_24MSB_EN field.
	I2S_FIFO_CONF_RX_24MSB_EN_Msk = 0x400000
	// Bit RX_24MSB_EN.
	I2S_FIFO_CONF_RX_24MSB_EN = 0x400000
	// Position of TX_24MSB_EN field.
	I2S_FIFO_CONF_TX_24MSB_EN_Pos = 0x17
	// Bit mask of TX_24MSB_EN field.
	I2S_FIFO_CONF_TX_24MSB_EN_Msk = 0x800000
	// Bit TX_24MSB_EN.
	I2S_FIFO_CONF_TX_24MSB_EN = 0x800000

	// RXEOF_NUM: I2S DMA RX EOF data length
	// Position of RX_EOF_NUM field.
	I2S_RXEOF_NUM_RX_EOF_NUM_Pos = 0x0
	// Bit mask of RX_EOF_NUM field.
	I2S_RXEOF_NUM_RX_EOF_NUM_Msk = 0xffffffff

	// CONF_SIGLE_DATA: Constant single channel data
	// Position of SIGLE_DATA field.
	I2S_CONF_SIGLE_DATA_SIGLE_DATA_Pos = 0x0
	// Bit mask of SIGLE_DATA field.
	I2S_CONF_SIGLE_DATA_SIGLE_DATA_Msk = 0xffffffff

	// CONF_CHAN: I2S channel configure register
	// Position of TX_CHAN_MOD field.
	I2S_CONF_CHAN_TX_CHAN_MOD_Pos = 0x0
	// Bit mask of TX_CHAN_MOD field.
	I2S_CONF_CHAN_TX_CHAN_MOD_Msk = 0x7
	// Position of RX_CHAN_MOD field.
	I2S_CONF_CHAN_RX_CHAN_MOD_Pos = 0x3
	// Bit mask of RX_CHAN_MOD field.
	I2S_CONF_CHAN_RX_CHAN_MOD_Msk = 0x18

	// OUT_LINK: I2S DMA TX configure register
	// Position of OUTLINK_ADDR field.
	I2S_OUT_LINK_OUTLINK_ADDR_Pos = 0x0
	// Bit mask of OUTLINK_ADDR field.
	I2S_OUT_LINK_OUTLINK_ADDR_Msk = 0xfffff
	// Position of OUTLINK_STOP field.
	I2S_OUT_LINK_OUTLINK_STOP_Pos = 0x1c
	// Bit mask of OUTLINK_STOP field.
	I2S_OUT_LINK_OUTLINK_STOP_Msk = 0x10000000
	// Bit OUTLINK_STOP.
	I2S_OUT_LINK_OUTLINK_STOP = 0x10000000
	// Position of OUTLINK_START field.
	I2S_OUT_LINK_OUTLINK_START_Pos = 0x1d
	// Bit mask of OUTLINK_START field.
	I2S_OUT_LINK_OUTLINK_START_Msk = 0x20000000
	// Bit OUTLINK_START.
	I2S_OUT_LINK_OUTLINK_START = 0x20000000
	// Position of OUTLINK_RESTART field.
	I2S_OUT_LINK_OUTLINK_RESTART_Pos = 0x1e
	// Bit mask of OUTLINK_RESTART field.
	I2S_OUT_LINK_OUTLINK_RESTART_Msk = 0x40000000
	// Bit OUTLINK_RESTART.
	I2S_OUT_LINK_OUTLINK_RESTART = 0x40000000
	// Position of OUTLINK_PARK field.
	I2S_OUT_LINK_OUTLINK_PARK_Pos = 0x1f
	// Bit mask of OUTLINK_PARK field.
	I2S_OUT_LINK_OUTLINK_PARK_Msk = 0x80000000
	// Bit OUTLINK_PARK.
	I2S_OUT_LINK_OUTLINK_PARK = 0x80000000

	// IN_LINK: I2S DMA RX configure register
	// Position of INLINK_ADDR field.
	I2S_IN_LINK_INLINK_ADDR_Pos = 0x0
	// Bit mask of INLINK_ADDR field.
	I2S_IN_LINK_INLINK_ADDR_Msk = 0xfffff
	// Position of INLINK_STOP field.
	I2S_IN_LINK_INLINK_STOP_Pos = 0x1c
	// Bit mask of INLINK_STOP field.
	I2S_IN_LINK_INLINK_STOP_Msk = 0x10000000
	// Bit INLINK_STOP.
	I2S_IN_LINK_INLINK_STOP = 0x10000000
	// Position of INLINK_START field.
	I2S_IN_LINK_INLINK_START_Pos = 0x1d
	// Bit mask of INLINK_START field.
	I2S_IN_LINK_INLINK_START_Msk = 0x20000000
	// Bit INLINK_START.
	I2S_IN_LINK_INLINK_START = 0x20000000
	// Position of INLINK_RESTART field.
	I2S_IN_LINK_INLINK_RESTART_Pos = 0x1e
	// Bit mask of INLINK_RESTART field.
	I2S_IN_LINK_INLINK_RESTART_Msk = 0x40000000
	// Bit INLINK_RESTART.
	I2S_IN_LINK_INLINK_RESTART = 0x40000000
	// Position of INLINK_PARK field.
	I2S_IN_LINK_INLINK_PARK_Pos = 0x1f
	// Bit mask of INLINK_PARK field.
	I2S_IN_LINK_INLINK_PARK_Msk = 0x80000000
	// Bit INLINK_PARK.
	I2S_IN_LINK_INLINK_PARK = 0x80000000

	// OUT_EOF_DES_ADDR: The address of outlink descriptor that produces EOF
	// Position of OUT_EOF_DES_ADDR field.
	I2S_OUT_EOF_DES_ADDR_OUT_EOF_DES_ADDR_Pos = 0x0
	// Bit mask of OUT_EOF_DES_ADDR field.
	I2S_OUT_EOF_DES_ADDR_OUT_EOF_DES_ADDR_Msk = 0xffffffff

	// IN_EOF_DES_ADDR: The address of inlink descriptor that produces EOF
	// Position of IN_SUC_EOF_DES_ADDR field.
	I2S_IN_EOF_DES_ADDR_IN_SUC_EOF_DES_ADDR_Pos = 0x0
	// Bit mask of IN_SUC_EOF_DES_ADDR field.
	I2S_IN_EOF_DES_ADDR_IN_SUC_EOF_DES_ADDR_Msk = 0xffffffff

	// OUT_EOF_BFR_DES_ADDR: The address of buffer relative to the outlink descriptor that produces EOF
	// Position of OUT_EOF_BFR_DES_ADDR field.
	I2S_OUT_EOF_BFR_DES_ADDR_OUT_EOF_BFR_DES_ADDR_Pos = 0x0
	// Bit mask of OUT_EOF_BFR_DES_ADDR field.
	I2S_OUT_EOF_BFR_DES_ADDR_OUT_EOF_BFR_DES_ADDR_Msk = 0xffffffff

	// INLINK_DSCR: The address of current inlink descriptor
	// Position of INLINK_DSCR field.
	I2S_INLINK_DSCR_INLINK_DSCR_Pos = 0x0
	// Bit mask of INLINK_DSCR field.
	I2S_INLINK_DSCR_INLINK_DSCR_Msk = 0xffffffff

	// INLINK_DSCR_BF0: The address of next inlink descriptor
	// Position of INLINK_DSCR_BF0 field.
	I2S_INLINK_DSCR_BF0_INLINK_DSCR_BF0_Pos = 0x0
	// Bit mask of INLINK_DSCR_BF0 field.
	I2S_INLINK_DSCR_BF0_INLINK_DSCR_BF0_Msk = 0xffffffff

	// INLINK_DSCR_BF1: The address of next inlink data buffer
	// Position of INLINK_DSCR_BF1 field.
	I2S_INLINK_DSCR_BF1_INLINK_DSCR_BF1_Pos = 0x0
	// Bit mask of INLINK_DSCR_BF1 field.
	I2S_INLINK_DSCR_BF1_INLINK_DSCR_BF1_Msk = 0xffffffff

	// OUTLINK_DSCR: The address of current outlink descriptor
	// Position of OUTLINK_DSCR field.
	I2S_OUTLINK_DSCR_OUTLINK_DSCR_Pos = 0x0
	// Bit mask of OUTLINK_DSCR field.
	I2S_OUTLINK_DSCR_OUTLINK_DSCR_Msk = 0xffffffff

	// OUTLINK_DSCR_BF0: The address of next outlink descriptor
	// Position of OUTLINK_DSCR_BF0 field.
	I2S_OUTLINK_DSCR_BF0_OUTLINK_DSCR_BF0_Pos = 0x0
	// Bit mask of OUTLINK_DSCR_BF0 field.
	I2S_OUTLINK_DSCR_BF0_OUTLINK_DSCR_BF0_Msk = 0xffffffff

	// OUTLINK_DSCR_BF1: The address of next outlink data buffer
	// Position of OUTLINK_DSCR_BF1 field.
	I2S_OUTLINK_DSCR_BF1_OUTLINK_DSCR_BF1_Pos = 0x0
	// Bit mask of OUTLINK_DSCR_BF1 field.
	I2S_OUTLINK_DSCR_BF1_OUTLINK_DSCR_BF1_Msk = 0xffffffff

	// LC_CONF: I2S DMA configuration register
	// Position of IN_RST field.
	I2S_LC_CONF_IN_RST_Pos = 0x0
	// Bit mask of IN_RST field.
	I2S_LC_CONF_IN_RST_Msk = 0x1
	// Bit IN_RST.
	I2S_LC_CONF_IN_RST = 0x1
	// Position of OUT_RST field.
	I2S_LC_CONF_OUT_RST_Pos = 0x1
	// Bit mask of OUT_RST field.
	I2S_LC_CONF_OUT_RST_Msk = 0x2
	// Bit OUT_RST.
	I2S_LC_CONF_OUT_RST = 0x2
	// Position of AHBM_FIFO_RST field.
	I2S_LC_CONF_AHBM_FIFO_RST_Pos = 0x2
	// Bit mask of AHBM_FIFO_RST field.
	I2S_LC_CONF_AHBM_FIFO_RST_Msk = 0x4
	// Bit AHBM_FIFO_RST.
	I2S_LC_CONF_AHBM_FIFO_RST = 0x4
	// Position of AHBM_RST field.
	I2S_LC_CONF_AHBM_RST_Pos = 0x3
	// Bit mask of AHBM_RST field.
	I2S_LC_CONF_AHBM_RST_Msk = 0x8
	// Bit AHBM_RST.
	I2S_LC_CONF_AHBM_RST = 0x8
	// Position of OUT_LOOP_TEST field.
	I2S_LC_CONF_OUT_LOOP_TEST_Pos = 0x4
	// Bit mask of OUT_LOOP_TEST field.
	I2S_LC_CONF_OUT_LOOP_TEST_Msk = 0x10
	// Bit OUT_LOOP_TEST.
	I2S_LC_CONF_OUT_LOOP_TEST = 0x10
	// Position of IN_LOOP_TEST field.
	I2S_LC_CONF_IN_LOOP_TEST_Pos = 0x5
	// Bit mask of IN_LOOP_TEST field.
	I2S_LC_CONF_IN_LOOP_TEST_Msk = 0x20
	// Bit IN_LOOP_TEST.
	I2S_LC_CONF_IN_LOOP_TEST = 0x20
	// Position of OUT_AUTO_WRBACK field.
	I2S_LC_CONF_OUT_AUTO_WRBACK_Pos = 0x6
	// Bit mask of OUT_AUTO_WRBACK field.
	I2S_LC_CONF_OUT_AUTO_WRBACK_Msk = 0x40
	// Bit OUT_AUTO_WRBACK.
	I2S_LC_CONF_OUT_AUTO_WRBACK = 0x40
	// Position of OUT_NO_RESTART_CLR field.
	I2S_LC_CONF_OUT_NO_RESTART_CLR_Pos = 0x7
	// Bit mask of OUT_NO_RESTART_CLR field.
	I2S_LC_CONF_OUT_NO_RESTART_CLR_Msk = 0x80
	// Bit OUT_NO_RESTART_CLR.
	I2S_LC_CONF_OUT_NO_RESTART_CLR = 0x80
	// Position of OUT_EOF_MODE field.
	I2S_LC_CONF_OUT_EOF_MODE_Pos = 0x8
	// Bit mask of OUT_EOF_MODE field.
	I2S_LC_CONF_OUT_EOF_MODE_Msk = 0x100
	// Bit OUT_EOF_MODE.
	I2S_LC_CONF_OUT_EOF_MODE = 0x100
	// Position of OUTDSCR_BURST_EN field.
	I2S_LC_CONF_OUTDSCR_BURST_EN_Pos = 0x9
	// Bit mask of OUTDSCR_BURST_EN field.
	I2S_LC_CONF_OUTDSCR_BURST_EN_Msk = 0x200
	// Bit OUTDSCR_BURST_EN.
	I2S_LC_CONF_OUTDSCR_BURST_EN = 0x200
	// Position of INDSCR_BURST_EN field.
	I2S_LC_CONF_INDSCR_BURST_EN_Pos = 0xa
	// Bit mask of INDSCR_BURST_EN field.
	I2S_LC_CONF_INDSCR_BURST_EN_Msk = 0x400
	// Bit INDSCR_BURST_EN.
	I2S_LC_CONF_INDSCR_BURST_EN = 0x400
	// Position of OUT_DATA_BURST_EN field.
	I2S_LC_CONF_OUT_DATA_BURST_EN_Pos = 0xb
	// Bit mask of OUT_DATA_BURST_EN field.
	I2S_LC_CONF_OUT_DATA_BURST_EN_Msk = 0x800
	// Bit OUT_DATA_BURST_EN.
	I2S_LC_CONF_OUT_DATA_BURST_EN = 0x800
	// Position of CHECK_OWNER field.
	I2S_LC_CONF_CHECK_OWNER_Pos = 0xc
	// Bit mask of CHECK_OWNER field.
	I2S_LC_CONF_CHECK_OWNER_Msk = 0x1000
	// Bit CHECK_OWNER.
	I2S_LC_CONF_CHECK_OWNER = 0x1000
	// Position of MEM_TRANS_EN field.
	I2S_LC_CONF_MEM_TRANS_EN_Pos = 0xd
	// Bit mask of MEM_TRANS_EN field.
	I2S_LC_CONF_MEM_TRANS_EN_Msk = 0x2000
	// Bit MEM_TRANS_EN.
	I2S_LC_CONF_MEM_TRANS_EN = 0x2000
	// Position of EXT_MEM_BK_SIZE field.
	I2S_LC_CONF_EXT_MEM_BK_SIZE_Pos = 0xe
	// Bit mask of EXT_MEM_BK_SIZE field.
	I2S_LC_CONF_EXT_MEM_BK_SIZE_Msk = 0xc000

	// OUTFIFO_PUSH: APB out FIFO mode register
	// Position of OUTFIFO_WDATA field.
	I2S_OUTFIFO_PUSH_OUTFIFO_WDATA_Pos = 0x0
	// Bit mask of OUTFIFO_WDATA field.
	I2S_OUTFIFO_PUSH_OUTFIFO_WDATA_Msk = 0x1ff
	// Position of OUTFIFO_PUSH field.
	I2S_OUTFIFO_PUSH_OUTFIFO_PUSH_Pos = 0x10
	// Bit mask of OUTFIFO_PUSH field.
	I2S_OUTFIFO_PUSH_OUTFIFO_PUSH_Msk = 0x10000
	// Bit OUTFIFO_PUSH.
	I2S_OUTFIFO_PUSH_OUTFIFO_PUSH = 0x10000

	// INFIFO_POP: APB in FIFO mode register
	// Position of INFIFO_RDATA field.
	I2S_INFIFO_POP_INFIFO_RDATA_Pos = 0x0
	// Bit mask of INFIFO_RDATA field.
	I2S_INFIFO_POP_INFIFO_RDATA_Msk = 0xfff
	// Position of INFIFO_POP field.
	I2S_INFIFO_POP_INFIFO_POP_Pos = 0x10
	// Bit mask of INFIFO_POP field.
	I2S_INFIFO_POP_INFIFO_POP_Msk = 0x10000
	// Bit INFIFO_POP.
	I2S_INFIFO_POP_INFIFO_POP = 0x10000

	// LC_STATE0: I2S DMA TX status
	// Position of OUTLINK_DSCR_ADDR field.
	I2S_LC_STATE0_OUTLINK_DSCR_ADDR_Pos = 0x0
	// Bit mask of OUTLINK_DSCR_ADDR field.
	I2S_LC_STATE0_OUTLINK_DSCR_ADDR_Msk = 0x3ffff
	// Position of OUT_DSCR_STATE field.
	I2S_LC_STATE0_OUT_DSCR_STATE_Pos = 0x12
	// Bit mask of OUT_DSCR_STATE field.
	I2S_LC_STATE0_OUT_DSCR_STATE_Msk = 0xc0000
	// Position of OUT_STATE field.
	I2S_LC_STATE0_OUT_STATE_Pos = 0x14
	// Bit mask of OUT_STATE field.
	I2S_LC_STATE0_OUT_STATE_Msk = 0x700000
	// Position of OUTFIFO_CNT field.
	I2S_LC_STATE0_OUTFIFO_CNT_Pos = 0x17
	// Bit mask of OUTFIFO_CNT field.
	I2S_LC_STATE0_OUTFIFO_CNT_Msk = 0x3f800000
	// Position of OUT_FULL field.
	I2S_LC_STATE0_OUT_FULL_Pos = 0x1e
	// Bit mask of OUT_FULL field.
	I2S_LC_STATE0_OUT_FULL_Msk = 0x40000000
	// Bit OUT_FULL.
	I2S_LC_STATE0_OUT_FULL = 0x40000000
	// Position of OUT_EMPTY field.
	I2S_LC_STATE0_OUT_EMPTY_Pos = 0x1f
	// Bit mask of OUT_EMPTY field.
	I2S_LC_STATE0_OUT_EMPTY_Msk = 0x80000000
	// Bit OUT_EMPTY.
	I2S_LC_STATE0_OUT_EMPTY = 0x80000000

	// LC_STATE1: I2S DMA RX status
	// Position of INLINK_DSCR_ADDR field.
	I2S_LC_STATE1_INLINK_DSCR_ADDR_Pos = 0x0
	// Bit mask of INLINK_DSCR_ADDR field.
	I2S_LC_STATE1_INLINK_DSCR_ADDR_Msk = 0x3ffff
	// Position of IN_DSCR_STATE field.
	I2S_LC_STATE1_IN_DSCR_STATE_Pos = 0x12
	// Bit mask of IN_DSCR_STATE field.
	I2S_LC_STATE1_IN_DSCR_STATE_Msk = 0xc0000
	// Position of IN_STATE field.
	I2S_LC_STATE1_IN_STATE_Pos = 0x14
	// Bit mask of IN_STATE field.
	I2S_LC_STATE1_IN_STATE_Msk = 0x700000
	// Position of INFIFO_CNT_DEBUG field.
	I2S_LC_STATE1_INFIFO_CNT_DEBUG_Pos = 0x17
	// Bit mask of INFIFO_CNT_DEBUG field.
	I2S_LC_STATE1_INFIFO_CNT_DEBUG_Msk = 0x3f800000
	// Position of IN_FULL field.
	I2S_LC_STATE1_IN_FULL_Pos = 0x1e
	// Bit mask of IN_FULL field.
	I2S_LC_STATE1_IN_FULL_Msk = 0x40000000
	// Bit IN_FULL.
	I2S_LC_STATE1_IN_FULL = 0x40000000
	// Position of IN_EMPTY field.
	I2S_LC_STATE1_IN_EMPTY_Pos = 0x1f
	// Bit mask of IN_EMPTY field.
	I2S_LC_STATE1_IN_EMPTY_Msk = 0x80000000
	// Bit IN_EMPTY.
	I2S_LC_STATE1_IN_EMPTY = 0x80000000

	// LC_HUNG_CONF: I2S Hung configure register
	// Position of LC_FIFO_TIMEOUT field.
	I2S_LC_HUNG_CONF_LC_FIFO_TIMEOUT_Pos = 0x0
	// Bit mask of LC_FIFO_TIMEOUT field.
	I2S_LC_HUNG_CONF_LC_FIFO_TIMEOUT_Msk = 0xff
	// Position of LC_FIFO_TIMEOUT_SHIFT field.
	I2S_LC_HUNG_CONF_LC_FIFO_TIMEOUT_SHIFT_Pos = 0x8
	// Bit mask of LC_FIFO_TIMEOUT_SHIFT field.
	I2S_LC_HUNG_CONF_LC_FIFO_TIMEOUT_SHIFT_Msk = 0x700
	// Position of LC_FIFO_TIMEOUT_ENA field.
	I2S_LC_HUNG_CONF_LC_FIFO_TIMEOUT_ENA_Pos = 0xb
	// Bit mask of LC_FIFO_TIMEOUT_ENA field.
	I2S_LC_HUNG_CONF_LC_FIFO_TIMEOUT_ENA_Msk = 0x800
	// Bit LC_FIFO_TIMEOUT_ENA.
	I2S_LC_HUNG_CONF_LC_FIFO_TIMEOUT_ENA = 0x800

	// CONF1: I2S configure1 register
	// Position of TX_PCM_CONF field.
	I2S_CONF1_TX_PCM_CONF_Pos = 0x0
	// Bit mask of TX_PCM_CONF field.
	I2S_CONF1_TX_PCM_CONF_Msk = 0x7
	// Position of TX_PCM_BYPASS field.
	I2S_CONF1_TX_PCM_BYPASS_Pos = 0x3
	// Bit mask of TX_PCM_BYPASS field.
	I2S_CONF1_TX_PCM_BYPASS_Msk = 0x8
	// Bit TX_PCM_BYPASS.
	I2S_CONF1_TX_PCM_BYPASS = 0x8
	// Position of RX_PCM_CONF field.
	I2S_CONF1_RX_PCM_CONF_Pos = 0x4
	// Bit mask of RX_PCM_CONF field.
	I2S_CONF1_RX_PCM_CONF_Msk = 0x70
	// Position of RX_PCM_BYPASS field.
	I2S_CONF1_RX_PCM_BYPASS_Pos = 0x7
	// Bit mask of RX_PCM_BYPASS field.
	I2S_CONF1_RX_PCM_BYPASS_Msk = 0x80
	// Bit RX_PCM_BYPASS.
	I2S_CONF1_RX_PCM_BYPASS = 0x80
	// Position of TX_STOP_EN field.
	I2S_CONF1_TX_STOP_EN_Pos = 0x8
	// Bit mask of TX_STOP_EN field.
	I2S_CONF1_TX_STOP_EN_Msk = 0x100
	// Bit TX_STOP_EN.
	I2S_CONF1_TX_STOP_EN = 0x100
	// Position of TX_ZEROS_RM_EN field.
	I2S_CONF1_TX_ZEROS_RM_EN_Pos = 0x9
	// Bit mask of TX_ZEROS_RM_EN field.
	I2S_CONF1_TX_ZEROS_RM_EN_Msk = 0x200
	// Bit TX_ZEROS_RM_EN.
	I2S_CONF1_TX_ZEROS_RM_EN = 0x200

	// PD_CONF: I2S power down configure register
	// Position of FIFO_FORCE_PD field.
	I2S_PD_CONF_FIFO_FORCE_PD_Pos = 0x0
	// Bit mask of FIFO_FORCE_PD field.
	I2S_PD_CONF_FIFO_FORCE_PD_Msk = 0x1
	// Bit FIFO_FORCE_PD.
	I2S_PD_CONF_FIFO_FORCE_PD = 0x1
	// Position of FIFO_FORCE_PU field.
	I2S_PD_CONF_FIFO_FORCE_PU_Pos = 0x1
	// Bit mask of FIFO_FORCE_PU field.
	I2S_PD_CONF_FIFO_FORCE_PU_Msk = 0x2
	// Bit FIFO_FORCE_PU.
	I2S_PD_CONF_FIFO_FORCE_PU = 0x2
	// Position of PLC_MEM_FORCE_PD field.
	I2S_PD_CONF_PLC_MEM_FORCE_PD_Pos = 0x2
	// Bit mask of PLC_MEM_FORCE_PD field.
	I2S_PD_CONF_PLC_MEM_FORCE_PD_Msk = 0x4
	// Bit PLC_MEM_FORCE_PD.
	I2S_PD_CONF_PLC_MEM_FORCE_PD = 0x4
	// Position of PLC_MEM_FORCE_PU field.
	I2S_PD_CONF_PLC_MEM_FORCE_PU_Pos = 0x3
	// Bit mask of PLC_MEM_FORCE_PU field.
	I2S_PD_CONF_PLC_MEM_FORCE_PU_Msk = 0x8
	// Bit PLC_MEM_FORCE_PU.
	I2S_PD_CONF_PLC_MEM_FORCE_PU = 0x8
	// Position of DMA_RAM_FORCE_PD field.
	I2S_PD_CONF_DMA_RAM_FORCE_PD_Pos = 0x4
	// Bit mask of DMA_RAM_FORCE_PD field.
	I2S_PD_CONF_DMA_RAM_FORCE_PD_Msk = 0x10
	// Bit DMA_RAM_FORCE_PD.
	I2S_PD_CONF_DMA_RAM_FORCE_PD = 0x10
	// Position of DMA_RAM_FORCE_PU field.
	I2S_PD_CONF_DMA_RAM_FORCE_PU_Pos = 0x5
	// Bit mask of DMA_RAM_FORCE_PU field.
	I2S_PD_CONF_DMA_RAM_FORCE_PU_Msk = 0x20
	// Bit DMA_RAM_FORCE_PU.
	I2S_PD_CONF_DMA_RAM_FORCE_PU = 0x20
	// Position of DMA_RAM_CLK_FO field.
	I2S_PD_CONF_DMA_RAM_CLK_FO_Pos = 0x6
	// Bit mask of DMA_RAM_CLK_FO field.
	I2S_PD_CONF_DMA_RAM_CLK_FO_Msk = 0x40
	// Bit DMA_RAM_CLK_FO.
	I2S_PD_CONF_DMA_RAM_CLK_FO = 0x40

	// CONF2: I2S configure2 register
	// Position of CAMERA_EN field.
	I2S_CONF2_CAMERA_EN_Pos = 0x0
	// Bit mask of CAMERA_EN field.
	I2S_CONF2_CAMERA_EN_Msk = 0x1
	// Bit CAMERA_EN.
	I2S_CONF2_CAMERA_EN = 0x1
	// Position of LCD_TX_WRX2_EN field.
	I2S_CONF2_LCD_TX_WRX2_EN_Pos = 0x1
	// Bit mask of LCD_TX_WRX2_EN field.
	I2S_CONF2_LCD_TX_WRX2_EN_Msk = 0x2
	// Bit LCD_TX_WRX2_EN.
	I2S_CONF2_LCD_TX_WRX2_EN = 0x2
	// Position of LCD_TX_SDX2_EN field.
	I2S_CONF2_LCD_TX_SDX2_EN_Pos = 0x2
	// Bit mask of LCD_TX_SDX2_EN field.
	I2S_CONF2_LCD_TX_SDX2_EN_Msk = 0x4
	// Bit LCD_TX_SDX2_EN.
	I2S_CONF2_LCD_TX_SDX2_EN = 0x4
	// Position of DATA_ENABLE_TEST_EN field.
	I2S_CONF2_DATA_ENABLE_TEST_EN_Pos = 0x3
	// Bit mask of DATA_ENABLE_TEST_EN field.
	I2S_CONF2_DATA_ENABLE_TEST_EN_Msk = 0x8
	// Bit DATA_ENABLE_TEST_EN.
	I2S_CONF2_DATA_ENABLE_TEST_EN = 0x8
	// Position of DATA_ENABLE field.
	I2S_CONF2_DATA_ENABLE_Pos = 0x4
	// Bit mask of DATA_ENABLE field.
	I2S_CONF2_DATA_ENABLE_Msk = 0x10
	// Bit DATA_ENABLE.
	I2S_CONF2_DATA_ENABLE = 0x10
	// Position of LCD_EN field.
	I2S_CONF2_LCD_EN_Pos = 0x5
	// Bit mask of LCD_EN field.
	I2S_CONF2_LCD_EN_Msk = 0x20
	// Bit LCD_EN.
	I2S_CONF2_LCD_EN = 0x20
	// Position of EXT_ADC_START_EN field.
	I2S_CONF2_EXT_ADC_START_EN_Pos = 0x6
	// Bit mask of EXT_ADC_START_EN field.
	I2S_CONF2_EXT_ADC_START_EN_Msk = 0x40
	// Bit EXT_ADC_START_EN.
	I2S_CONF2_EXT_ADC_START_EN = 0x40
	// Position of INTER_VALID_EN field.
	I2S_CONF2_INTER_VALID_EN_Pos = 0x7
	// Bit mask of INTER_VALID_EN field.
	I2S_CONF2_INTER_VALID_EN_Msk = 0x80
	// Bit INTER_VALID_EN.
	I2S_CONF2_INTER_VALID_EN = 0x80
	// Position of CAM_SYNC_FIFO_RESET field.
	I2S_CONF2_CAM_SYNC_FIFO_RESET_Pos = 0x8
	// Bit mask of CAM_SYNC_FIFO_RESET field.
	I2S_CONF2_CAM_SYNC_FIFO_RESET_Msk = 0x100
	// Bit CAM_SYNC_FIFO_RESET.
	I2S_CONF2_CAM_SYNC_FIFO_RESET = 0x100
	// Position of CAM_CLK_LOOPBACK field.
	I2S_CONF2_CAM_CLK_LOOPBACK_Pos = 0x9
	// Bit mask of CAM_CLK_LOOPBACK field.
	I2S_CONF2_CAM_CLK_LOOPBACK_Msk = 0x200
	// Bit CAM_CLK_LOOPBACK.
	I2S_CONF2_CAM_CLK_LOOPBACK = 0x200
	// Position of VSYNC_FILTER_EN field.
	I2S_CONF2_VSYNC_FILTER_EN_Pos = 0xa
	// Bit mask of VSYNC_FILTER_EN field.
	I2S_CONF2_VSYNC_FILTER_EN_Msk = 0x400
	// Bit VSYNC_FILTER_EN.
	I2S_CONF2_VSYNC_FILTER_EN = 0x400
	// Position of VSYNC_FILTER_THRES field.
	I2S_CONF2_VSYNC_FILTER_THRES_Pos = 0xb
	// Bit mask of VSYNC_FILTER_THRES field.
	I2S_CONF2_VSYNC_FILTER_THRES_Msk = 0x3800

	// CLKM_CONF: I2S module clock configure register
	// Position of CLKM_DIV_NUM field.
	I2S_CLKM_CONF_CLKM_DIV_NUM_Pos = 0x0
	// Bit mask of CLKM_DIV_NUM field.
	I2S_CLKM_CONF_CLKM_DIV_NUM_Msk = 0xff
	// Position of CLKM_DIV_B field.
	I2S_CLKM_CONF_CLKM_DIV_B_Pos = 0x8
	// Bit mask of CLKM_DIV_B field.
	I2S_CLKM_CONF_CLKM_DIV_B_Msk = 0x3f00
	// Position of CLKM_DIV_A field.
	I2S_CLKM_CONF_CLKM_DIV_A_Pos = 0xe
	// Bit mask of CLKM_DIV_A field.
	I2S_CLKM_CONF_CLKM_DIV_A_Msk = 0xfc000
	// Position of CLK_EN field.
	I2S_CLKM_CONF_CLK_EN_Pos = 0x14
	// Bit mask of CLK_EN field.
	I2S_CLKM_CONF_CLK_EN_Msk = 0x100000
	// Bit CLK_EN.
	I2S_CLKM_CONF_CLK_EN = 0x100000
	// Position of CLK_SEL field.
	I2S_CLKM_CONF_CLK_SEL_Pos = 0x15
	// Bit mask of CLK_SEL field.
	I2S_CLKM_CONF_CLK_SEL_Msk = 0x600000

	// SAMPLE_RATE_CONF: I2S sample rate register
	// Position of TX_BCK_DIV_NUM field.
	I2S_SAMPLE_RATE_CONF_TX_BCK_DIV_NUM_Pos = 0x0
	// Bit mask of TX_BCK_DIV_NUM field.
	I2S_SAMPLE_RATE_CONF_TX_BCK_DIV_NUM_Msk = 0x3f
	// Position of RX_BCK_DIV_NUM field.
	I2S_SAMPLE_RATE_CONF_RX_BCK_DIV_NUM_Pos = 0x6
	// Bit mask of RX_BCK_DIV_NUM field.
	I2S_SAMPLE_RATE_CONF_RX_BCK_DIV_NUM_Msk = 0xfc0
	// Position of TX_BITS_MOD field.
	I2S_SAMPLE_RATE_CONF_TX_BITS_MOD_Pos = 0xc
	// Bit mask of TX_BITS_MOD field.
	I2S_SAMPLE_RATE_CONF_TX_BITS_MOD_Msk = 0x3f000
	// Position of RX_BITS_MOD field.
	I2S_SAMPLE_RATE_CONF_RX_BITS_MOD_Pos = 0x12
	// Bit mask of RX_BITS_MOD field.
	I2S_SAMPLE_RATE_CONF_RX_BITS_MOD_Msk = 0xfc0000

	// STATE: I2S TX status register
	// Position of TX_IDLE field.
	I2S_STATE_TX_IDLE_Pos = 0x0
	// Bit mask of TX_IDLE field.
	I2S_STATE_TX_IDLE_Msk = 0x1
	// Bit TX_IDLE.
	I2S_STATE_TX_IDLE = 0x1

	// DATE: Version control register
	// Position of DATE field.
	I2S_DATE_DATE_Pos = 0x0
	// Bit mask of DATE field.
	I2S_DATE_DATE_Msk = 0xffffffff
)

// Constants for INTERRUPT: Peripheral INTERRUPT
const (
	// PRO_MAC_INTR_MAP: MAC_INTR interrupt configuration register
	// Position of PRO_MAC_INTR_MAP field.
	INTERRUPT_PRO_MAC_INTR_MAP_PRO_MAC_INTR_MAP_Pos = 0x0
	// Bit mask of PRO_MAC_INTR_MAP field.
	INTERRUPT_PRO_MAC_INTR_MAP_PRO_MAC_INTR_MAP_Msk = 0x1f

	// PRO_MAC_NMI_MAP: MAC_NMI interrupt configuration register
	// Position of PRO_MAC_NMI_MAP field.
	INTERRUPT_PRO_MAC_NMI_MAP_PRO_MAC_NMI_MAP_Pos = 0x0
	// Bit mask of PRO_MAC_NMI_MAP field.
	INTERRUPT_PRO_MAC_NMI_MAP_PRO_MAC_NMI_MAP_Msk = 0x1f

	// PRO_PWR_INTR_MAP: PWR_INTR interrupt configuration register
	// Position of PRO_PWR_INTR_MAP field.
	INTERRUPT_PRO_PWR_INTR_MAP_PRO_PWR_INTR_MAP_Pos = 0x0
	// Bit mask of PRO_PWR_INTR_MAP field.
	INTERRUPT_PRO_PWR_INTR_MAP_PRO_PWR_INTR_MAP_Msk = 0x1f

	// PRO_BB_INT_MAP: BB_INT interrupt configuration register
	// Position of PRO_BB_INT_MAP field.
	INTERRUPT_PRO_BB_INT_MAP_PRO_BB_INT_MAP_Pos = 0x0
	// Bit mask of PRO_BB_INT_MAP field.
	INTERRUPT_PRO_BB_INT_MAP_PRO_BB_INT_MAP_Msk = 0x1f

	// PRO_BT_MAC_INT_MAP: BT_MAC_INT interrupt configuration register
	// Position of PRO_BT_MAC_INT_MAP field.
	INTERRUPT_PRO_BT_MAC_INT_MAP_PRO_BT_MAC_INT_MAP_Pos = 0x0
	// Bit mask of PRO_BT_MAC_INT_MAP field.
	INTERRUPT_PRO_BT_MAC_INT_MAP_PRO_BT_MAC_INT_MAP_Msk = 0x1f

	// PRO_BT_BB_INT_MAP: BT_BB_INT interrupt configuration register
	// Position of PRO_BT_BB_INT_MAP field.
	INTERRUPT_PRO_BT_BB_INT_MAP_PRO_BT_BB_INT_MAP_Pos = 0x0
	// Bit mask of PRO_BT_BB_INT_MAP field.
	INTERRUPT_PRO_BT_BB_INT_MAP_PRO_BT_BB_INT_MAP_Msk = 0x1f

	// PRO_BT_BB_NMI_MAP: BT_BB_NMI interrupt configuration register
	// Position of PRO_BT_BB_NMI_MAP field.
	INTERRUPT_PRO_BT_BB_NMI_MAP_PRO_BT_BB_NMI_MAP_Pos = 0x0
	// Bit mask of PRO_BT_BB_NMI_MAP field.
	INTERRUPT_PRO_BT_BB_NMI_MAP_PRO_BT_BB_NMI_MAP_Msk = 0x1f

	// PRO_RWBT_IRQ_MAP: RWBT_IRQ interrupt configuration register
	// Position of PRO_RWBT_IRQ_MAP field.
	INTERRUPT_PRO_RWBT_IRQ_MAP_PRO_RWBT_IRQ_MAP_Pos = 0x0
	// Bit mask of PRO_RWBT_IRQ_MAP field.
	INTERRUPT_PRO_RWBT_IRQ_MAP_PRO_RWBT_IRQ_MAP_Msk = 0x1f

	// PRO_RWBLE_IRQ_MAP: RWBLE_IRQ interrupt configuration register
	// Position of PRO_RWBLE_IRQ_MAP field.
	INTERRUPT_PRO_RWBLE_IRQ_MAP_PRO_RWBLE_IRQ_MAP_Pos = 0x0
	// Bit mask of PRO_RWBLE_IRQ_MAP field.
	INTERRUPT_PRO_RWBLE_IRQ_MAP_PRO_RWBLE_IRQ_MAP_Msk = 0x1f

	// PRO_RWBT_NMI_MAP: RWBT_NMI interrupt configuration register
	// Position of PRO_RWBT_NMI_MAP field.
	INTERRUPT_PRO_RWBT_NMI_MAP_PRO_RWBT_NMI_MAP_Pos = 0x0
	// Bit mask of PRO_RWBT_NMI_MAP field.
	INTERRUPT_PRO_RWBT_NMI_MAP_PRO_RWBT_NMI_MAP_Msk = 0x1f

	// PRO_RWBLE_NMI_MAP: RWBLE_NMI interrupt configuration register
	// Position of PRO_RWBLE_NMI_MAP field.
	INTERRUPT_PRO_RWBLE_NMI_MAP_PRO_RWBLE_NMI_MAP_Pos = 0x0
	// Bit mask of PRO_RWBLE_NMI_MAP field.
	INTERRUPT_PRO_RWBLE_NMI_MAP_PRO_RWBLE_NMI_MAP_Msk = 0x1f

	// PRO_SLC0_INTR_MAP: SLC0_INTR interrupt configuration register
	// Position of PRO_SLC0_INTR_MAP field.
	INTERRUPT_PRO_SLC0_INTR_MAP_PRO_SLC0_INTR_MAP_Pos = 0x0
	// Bit mask of PRO_SLC0_INTR_MAP field.
	INTERRUPT_PRO_SLC0_INTR_MAP_PRO_SLC0_INTR_MAP_Msk = 0x1f

	// PRO_SLC1_INTR_MAP: SLC1_INTR interrupt configuration register
	// Position of PRO_SLC1_INTR_MAP field.
	INTERRUPT_PRO_SLC1_INTR_MAP_PRO_SLC1_INTR_MAP_Pos = 0x0
	// Bit mask of PRO_SLC1_INTR_MAP field.
	INTERRUPT_PRO_SLC1_INTR_MAP_PRO_SLC1_INTR_MAP_Msk = 0x1f

	// PRO_UHCI0_INTR_MAP: UHCI0_INTR interrupt configuration register
	// Position of PRO_UHCI0_INTR_MAP field.
	INTERRUPT_PRO_UHCI0_INTR_MAP_PRO_UHCI0_INTR_MAP_Pos = 0x0
	// Bit mask of PRO_UHCI0_INTR_MAP field.
	INTERRUPT_PRO_UHCI0_INTR_MAP_PRO_UHCI0_INTR_MAP_Msk = 0x1f

	// PRO_UHCI1_INTR_MAP: UHCI1_INTR interrupt configuration register
	// Position of PRO_UHCI1_INTR_MAP field.
	INTERRUPT_PRO_UHCI1_INTR_MAP_PRO_UHCI1_INTR_MAP_Pos = 0x0
	// Bit mask of PRO_UHCI1_INTR_MAP field.
	INTERRUPT_PRO_UHCI1_INTR_MAP_PRO_UHCI1_INTR_MAP_Msk = 0x1f

	// PRO_TG_T0_LEVEL_INT_MAP: TG_T0_LEVEL_INT interrupt configuration register
	// Position of PRO_TG_T0_LEVEL_INT_MAP field.
	INTERRUPT_PRO_TG_T0_LEVEL_INT_MAP_PRO_TG_T0_LEVEL_INT_MAP_Pos = 0x0
	// Bit mask of PRO_TG_T0_LEVEL_INT_MAP field.
	INTERRUPT_PRO_TG_T0_LEVEL_INT_MAP_PRO_TG_T0_LEVEL_INT_MAP_Msk = 0x1f

	// PRO_TG_T1_LEVEL_INT_MAP: TG_T1_LEVEL_INT interrupt configuration register
	// Position of PRO_TG_T1_LEVEL_INT_MAP field.
	INTERRUPT_PRO_TG_T1_LEVEL_INT_MAP_PRO_TG_T1_LEVEL_INT_MAP_Pos = 0x0
	// Bit mask of PRO_TG_T1_LEVEL_INT_MAP field.
	INTERRUPT_PRO_TG_T1_LEVEL_INT_MAP_PRO_TG_T1_LEVEL_INT_MAP_Msk = 0x1f

	// PRO_TG_WDT_LEVEL_INT_MAP: TG_WDT_LEVEL_INT interrupt configuration register
	// Position of PRO_TG_WDT_LEVEL_INT_MAP field.
	INTERRUPT_PRO_TG_WDT_LEVEL_INT_MAP_PRO_TG_WDT_LEVEL_INT_MAP_Pos = 0x0
	// Bit mask of PRO_TG_WDT_LEVEL_INT_MAP field.
	INTERRUPT_PRO_TG_WDT_LEVEL_INT_MAP_PRO_TG_WDT_LEVEL_INT_MAP_Msk = 0x1f

	// PRO_TG_LACT_LEVEL_INT_MAP: TG_LACT_LEVEL_INT interrupt configuration register
	// Position of PRO_TG_LACT_LEVEL_INT_MAP field.
	INTERRUPT_PRO_TG_LACT_LEVEL_INT_MAP_PRO_TG_LACT_LEVEL_INT_MAP_Pos = 0x0
	// Bit mask of PRO_TG_LACT_LEVEL_INT_MAP field.
	INTERRUPT_PRO_TG_LACT_LEVEL_INT_MAP_PRO_TG_LACT_LEVEL_INT_MAP_Msk = 0x1f

	// PRO_TG1_T0_LEVEL_INT_MAP: TG1_T0_LEVEL_INT interrupt configuration register
	// Position of PRO_TG1_T0_LEVEL_INT_MAP field.
	INTERRUPT_PRO_TG1_T0_LEVEL_INT_MAP_PRO_TG1_T0_LEVEL_INT_MAP_Pos = 0x0
	// Bit mask of PRO_TG1_T0_LEVEL_INT_MAP field.
	INTERRUPT_PRO_TG1_T0_LEVEL_INT_MAP_PRO_TG1_T0_LEVEL_INT_MAP_Msk = 0x1f

	// PRO_TG1_T1_LEVEL_INT_MAP: TG1_T1_LEVEL_INT interrupt configuration register
	// Position of PRO_TG1_T1_LEVEL_INT_MAP field.
	INTERRUPT_PRO_TG1_T1_LEVEL_INT_MAP_PRO_TG1_T1_LEVEL_INT_MAP_Pos = 0x0
	// Bit mask of PRO_TG1_T1_LEVEL_INT_MAP field.
	INTERRUPT_PRO_TG1_T1_LEVEL_INT_MAP_PRO_TG1_T1_LEVEL_INT_MAP_Msk = 0x1f

	// PRO_TG1_WDT_LEVEL_INT_MAP: TG1_WDT_LEVEL_INT interrupt configuration register
	// Position of PRO_TG1_WDT_LEVEL_INT_MAP field.
	INTERRUPT_PRO_TG1_WDT_LEVEL_INT_MAP_PRO_TG1_WDT_LEVEL_INT_MAP_Pos = 0x0
	// Bit mask of PRO_TG1_WDT_LEVEL_INT_MAP field.
	INTERRUPT_PRO_TG1_WDT_LEVEL_INT_MAP_PRO_TG1_WDT_LEVEL_INT_MAP_Msk = 0x1f

	// PRO_TG1_LACT_LEVEL_INT_MAP: TG1_LACT_LEVEL_INT interrupt configuration register
	// Position of PRO_TG1_LACT_LEVEL_INT_MAP field.
	INTERRUPT_PRO_TG1_LACT_LEVEL_INT_MAP_PRO_TG1_LACT_LEVEL_INT_MAP_Pos = 0x0
	// Bit mask of PRO_TG1_LACT_LEVEL_INT_MAP field.
	INTERRUPT_PRO_TG1_LACT_LEVEL_INT_MAP_PRO_TG1_LACT_LEVEL_INT_MAP_Msk = 0x1f

	// PRO_GPIO_INTERRUPT_PRO_MAP: GPIO_INTERRUPT_PRO interrupt configuration register
	// Position of PRO_GPIO_INTERRUPT_PRO_MAP field.
	INTERRUPT_PRO_GPIO_INTERRUPT_PRO_MAP_PRO_GPIO_INTERRUPT_PRO_MAP_Pos = 0x0
	// Bit mask of PRO_GPIO_INTERRUPT_PRO_MAP field.
	INTERRUPT_PRO_GPIO_INTERRUPT_PRO_MAP_PRO_GPIO_INTERRUPT_PRO_MAP_Msk = 0x1f

	// PRO_GPIO_INTERRUPT_PRO_NMI_MAP: GPIO_INTERRUPT_PRO_NMI interrupt configuration register
	// Position of PRO_GPIO_INTERRUPT_PRO_NMI_MAP field.
	INTERRUPT_PRO_GPIO_INTERRUPT_PRO_NMI_MAP_PRO_GPIO_INTERRUPT_PRO_NMI_MAP_Pos = 0x0
	// Bit mask of PRO_GPIO_INTERRUPT_PRO_NMI_MAP field.
	INTERRUPT_PRO_GPIO_INTERRUPT_PRO_NMI_MAP_PRO_GPIO_INTERRUPT_PRO_NMI_MAP_Msk = 0x1f

	// PRO_GPIO_INTERRUPT_APP_MAP: GPIO_INTERRUPT_APP interrupt configuration register
	// Position of PRO_GPIO_INTERRUPT_APP_MAP field.
	INTERRUPT_PRO_GPIO_INTERRUPT_APP_MAP_PRO_GPIO_INTERRUPT_APP_MAP_Pos = 0x0
	// Bit mask of PRO_GPIO_INTERRUPT_APP_MAP field.
	INTERRUPT_PRO_GPIO_INTERRUPT_APP_MAP_PRO_GPIO_INTERRUPT_APP_MAP_Msk = 0x1f

	// PRO_GPIO_INTERRUPT_APP_NMI_MAP: GPIO_INTERRUPT_APP_NMI interrupt configuration register
	// Position of PRO_GPIO_INTERRUPT_APP_NMI_MAP field.
	INTERRUPT_PRO_GPIO_INTERRUPT_APP_NMI_MAP_PRO_GPIO_INTERRUPT_APP_NMI_MAP_Pos = 0x0
	// Bit mask of PRO_GPIO_INTERRUPT_APP_NMI_MAP field.
	INTERRUPT_PRO_GPIO_INTERRUPT_APP_NMI_MAP_PRO_GPIO_INTERRUPT_APP_NMI_MAP_Msk = 0x1f

	// PRO_DEDICATED_GPIO_IN_INTR_MAP: DEDICATED_GPIO_IN_INTR interrupt configuration register
	// Position of PRO_DEDICATED_GPIO_IN_INTR_MAP field.
	INTERRUPT_PRO_DEDICATED_GPIO_IN_INTR_MAP_PRO_DEDICATED_GPIO_IN_INTR_MAP_Pos = 0x0
	// Bit mask of PRO_DEDICATED_GPIO_IN_INTR_MAP field.
	INTERRUPT_PRO_DEDICATED_GPIO_IN_INTR_MAP_PRO_DEDICATED_GPIO_IN_INTR_MAP_Msk = 0x1f

	// PRO_CPU_INTR_FROM_CPU_0_MAP: CPU_INTR_FROM_CPU_0 interrupt configuration register
	// Position of PRO_CPU_INTR_FROM_CPU_0_MAP field.
	INTERRUPT_PRO_CPU_INTR_FROM_CPU_0_MAP_PRO_CPU_INTR_FROM_CPU_0_MAP_Pos = 0x0
	// Bit mask of PRO_CPU_INTR_FROM_CPU_0_MAP field.
	INTERRUPT_PRO_CPU_INTR_FROM_CPU_0_MAP_PRO_CPU_INTR_FROM_CPU_0_MAP_Msk = 0x1f

	// PRO_CPU_INTR_FROM_CPU_1_MAP: CPU_INTR_FROM_CPU_1 interrupt configuration register
	// Position of PRO_CPU_INTR_FROM_CPU_1_MAP field.
	INTERRUPT_PRO_CPU_INTR_FROM_CPU_1_MAP_PRO_CPU_INTR_FROM_CPU_1_MAP_Pos = 0x0
	// Bit mask of PRO_CPU_INTR_FROM_CPU_1_MAP field.
	INTERRUPT_PRO_CPU_INTR_FROM_CPU_1_MAP_PRO_CPU_INTR_FROM_CPU_1_MAP_Msk = 0x1f

	// PRO_CPU_INTR_FROM_CPU_2_MAP: CPU_INTR_FROM_CPU_2 interrupt configuration register
	// Position of PRO_CPU_INTR_FROM_CPU_2_MAP field.
	INTERRUPT_PRO_CPU_INTR_FROM_CPU_2_MAP_PRO_CPU_INTR_FROM_CPU_2_MAP_Pos = 0x0
	// Bit mask of PRO_CPU_INTR_FROM_CPU_2_MAP field.
	INTERRUPT_PRO_CPU_INTR_FROM_CPU_2_MAP_PRO_CPU_INTR_FROM_CPU_2_MAP_Msk = 0x1f

	// PRO_CPU_INTR_FROM_CPU_3_MAP: CPU_INTR_FROM_CPU_3 interrupt configuration register
	// Position of PRO_CPU_INTR_FROM_CPU_3_MAP field.
	INTERRUPT_PRO_CPU_INTR_FROM_CPU_3_MAP_PRO_CPU_INTR_FROM_CPU_3_MAP_Pos = 0x0
	// Bit mask of PRO_CPU_INTR_FROM_CPU_3_MAP field.
	INTERRUPT_PRO_CPU_INTR_FROM_CPU_3_MAP_PRO_CPU_INTR_FROM_CPU_3_MAP_Msk = 0x1f

	// PRO_SPI_INTR_1_MAP: SPI_INTR_1 interrupt configuration register
	// Position of PRO_SPI_INTR_1_MAP field.
	INTERRUPT_PRO_SPI_INTR_1_MAP_PRO_SPI_INTR_1_MAP_Pos = 0x0
	// Bit mask of PRO_SPI_INTR_1_MAP field.
	INTERRUPT_PRO_SPI_INTR_1_MAP_PRO_SPI_INTR_1_MAP_Msk = 0x1f

	// PRO_SPI_INTR_2_MAP: SPI_INTR_2 interrupt configuration register
	// Position of PRO_SPI_INTR_2_MAP field.
	INTERRUPT_PRO_SPI_INTR_2_MAP_PRO_SPI_INTR_2_MAP_Pos = 0x0
	// Bit mask of PRO_SPI_INTR_2_MAP field.
	INTERRUPT_PRO_SPI_INTR_2_MAP_PRO_SPI_INTR_2_MAP_Msk = 0x1f

	// PRO_SPI_INTR_3_MAP: SPI_INTR_3 interrupt configuration register
	// Position of PRO_SPI_INTR_3_MAP field.
	INTERRUPT_PRO_SPI_INTR_3_MAP_PRO_SPI_INTR_3_MAP_Pos = 0x0
	// Bit mask of PRO_SPI_INTR_3_MAP field.
	INTERRUPT_PRO_SPI_INTR_3_MAP_PRO_SPI_INTR_3_MAP_Msk = 0x1f

	// PRO_I2S0_INT_MAP: I2S0_INT interrupt configuration register
	// Position of PRO_I2S0_INT_MAP field.
	INTERRUPT_PRO_I2S0_INT_MAP_PRO_I2S0_INT_MAP_Pos = 0x0
	// Bit mask of PRO_I2S0_INT_MAP field.
	INTERRUPT_PRO_I2S0_INT_MAP_PRO_I2S0_INT_MAP_Msk = 0x1f

	// PRO_I2S1_INT_MAP: I2S1_INT interrupt configuration register
	// Position of PRO_I2S1_INT_MAP field.
	INTERRUPT_PRO_I2S1_INT_MAP_PRO_I2S1_INT_MAP_Pos = 0x0
	// Bit mask of PRO_I2S1_INT_MAP field.
	INTERRUPT_PRO_I2S1_INT_MAP_PRO_I2S1_INT_MAP_Msk = 0x1f

	// PRO_UART_INTR_MAP: UART_INT interrupt configuration register
	// Position of PRO_UART_INTR_MAP field.
	INTERRUPT_PRO_UART_INTR_MAP_PRO_UART_INTR_MAP_Pos = 0x0
	// Bit mask of PRO_UART_INTR_MAP field.
	INTERRUPT_PRO_UART_INTR_MAP_PRO_UART_INTR_MAP_Msk = 0x1f

	// PRO_UART1_INTR_MAP: UART1_INT interrupt configuration register
	// Position of PRO_UART1_INTR_MAP field.
	INTERRUPT_PRO_UART1_INTR_MAP_PRO_UART1_INTR_MAP_Pos = 0x0
	// Bit mask of PRO_UART1_INTR_MAP field.
	INTERRUPT_PRO_UART1_INTR_MAP_PRO_UART1_INTR_MAP_Msk = 0x1f

	// PRO_UART2_INTR_MAP: UART2_INT interrupt configuration register
	// Position of PRO_UART2_INTR_MAP field.
	INTERRUPT_PRO_UART2_INTR_MAP_PRO_UART2_INTR_MAP_Pos = 0x0
	// Bit mask of PRO_UART2_INTR_MAP field.
	INTERRUPT_PRO_UART2_INTR_MAP_PRO_UART2_INTR_MAP_Msk = 0x1f

	// PRO_SDIO_HOST_INTERRUPT_MAP: SDIO_HOST_INTERRUPT configuration register
	// Position of PRO_SDIO_HOST_INTERRUPT_MAP field.
	INTERRUPT_PRO_SDIO_HOST_INTERRUPT_MAP_PRO_SDIO_HOST_INTERRUPT_MAP_Pos = 0x0
	// Bit mask of PRO_SDIO_HOST_INTERRUPT_MAP field.
	INTERRUPT_PRO_SDIO_HOST_INTERRUPT_MAP_PRO_SDIO_HOST_INTERRUPT_MAP_Msk = 0x1f

	// PRO_PWM0_INTR_MAP: PWM0_INTR interrupt configuration register
	// Position of PRO_PWM0_INTR_MAP field.
	INTERRUPT_PRO_PWM0_INTR_MAP_PRO_PWM0_INTR_MAP_Pos = 0x0
	// Bit mask of PRO_PWM0_INTR_MAP field.
	INTERRUPT_PRO_PWM0_INTR_MAP_PRO_PWM0_INTR_MAP_Msk = 0x1f

	// PRO_PWM1_INTR_MAP: PWM1_INTR interrupt configuration register
	// Position of PRO_PWM1_INTR_MAP field.
	INTERRUPT_PRO_PWM1_INTR_MAP_PRO_PWM1_INTR_MAP_Pos = 0x0
	// Bit mask of PRO_PWM1_INTR_MAP field.
	INTERRUPT_PRO_PWM1_INTR_MAP_PRO_PWM1_INTR_MAP_Msk = 0x1f

	// PRO_PWM2_INTR_MAP: PWM2_INTR interrupt configuration register
	// Position of PRO_PWM2_INTR_MAP field.
	INTERRUPT_PRO_PWM2_INTR_MAP_PRO_PWM2_INTR_MAP_Pos = 0x0
	// Bit mask of PRO_PWM2_INTR_MAP field.
	INTERRUPT_PRO_PWM2_INTR_MAP_PRO_PWM2_INTR_MAP_Msk = 0x1f

	// PRO_PWM3_INTR_MAP: PWM3_INTR interrupt configuration register
	// Position of PRO_PWM3_INTR_MAP field.
	INTERRUPT_PRO_PWM3_INTR_MAP_PRO_PWM3_INTR_MAP_Pos = 0x0
	// Bit mask of PRO_PWM3_INTR_MAP field.
	INTERRUPT_PRO_PWM3_INTR_MAP_PRO_PWM3_INTR_MAP_Msk = 0x1f

	// PRO_LEDC_INT_MAP: LEDC_INTR interrupt configuration register
	// Position of PRO_LEDC_INT_MAP field.
	INTERRUPT_PRO_LEDC_INT_MAP_PRO_LEDC_INT_MAP_Pos = 0x0
	// Bit mask of PRO_LEDC_INT_MAP field.
	INTERRUPT_PRO_LEDC_INT_MAP_PRO_LEDC_INT_MAP_Msk = 0x1f

	// PRO_EFUSE_INT_MAP: EFUSE_INT interrupt configuration register
	// Position of PRO_EFUSE_INT_MAP field.
	INTERRUPT_PRO_EFUSE_INT_MAP_PRO_EFUSE_INT_MAP_Pos = 0x0
	// Bit mask of PRO_EFUSE_INT_MAP field.
	INTERRUPT_PRO_EFUSE_INT_MAP_PRO_EFUSE_INT_MAP_Msk = 0x1f

	// PRO_CAN_INT_MAP: CAN_INT interrupt configuration register
	// Position of PRO_CAN_INT_MAP field.
	INTERRUPT_PRO_CAN_INT_MAP_PRO_CAN_INT_MAP_Pos = 0x0
	// Bit mask of PRO_CAN_INT_MAP field.
	INTERRUPT_PRO_CAN_INT_MAP_PRO_CAN_INT_MAP_Msk = 0x1f

	// PRO_USB_INTR_MAP: USB_INT interrupt configuration register
	// Position of PRO_USB_INTR_MAP field.
	INTERRUPT_PRO_USB_INTR_MAP_PRO_USB_INTR_MAP_Pos = 0x0
	// Bit mask of PRO_USB_INTR_MAP field.
	INTERRUPT_PRO_USB_INTR_MAP_PRO_USB_INTR_MAP_Msk = 0x1f

	// PRO_RTC_CORE_INTR_MAP: RTC_CORE_INTR interrupt configuration register
	// Position of PRO_RTC_CORE_INTR_MAP field.
	INTERRUPT_PRO_RTC_CORE_INTR_MAP_PRO_RTC_CORE_INTR_MAP_Pos = 0x0
	// Bit mask of PRO_RTC_CORE_INTR_MAP field.
	INTERRUPT_PRO_RTC_CORE_INTR_MAP_PRO_RTC_CORE_INTR_MAP_Msk = 0x1f

	// PRO_RMT_INTR_MAP: RMT_INTR interrupt configuration register
	// Position of PRO_RMT_INTR_MAP field.
	INTERRUPT_PRO_RMT_INTR_MAP_PRO_RMT_INTR_MAP_Pos = 0x0
	// Bit mask of PRO_RMT_INTR_MAP field.
	INTERRUPT_PRO_RMT_INTR_MAP_PRO_RMT_INTR_MAP_Msk = 0x1f

	// PRO_PCNT_INTR_MAP: PCNT_INTR interrupt configuration register
	// Position of PRO_PCNT_INTR_MAP field.
	INTERRUPT_PRO_PCNT_INTR_MAP_PRO_PCNT_INTR_MAP_Pos = 0x0
	// Bit mask of PRO_PCNT_INTR_MAP field.
	INTERRUPT_PRO_PCNT_INTR_MAP_PRO_PCNT_INTR_MAP_Msk = 0x1f

	// PRO_I2C_EXT0_INTR_MAP: I2C_EXT0_INTR interrupt configuration register
	// Position of PRO_I2C_EXT0_INTR_MAP field.
	INTERRUPT_PRO_I2C_EXT0_INTR_MAP_PRO_I2C_EXT0_INTR_MAP_Pos = 0x0
	// Bit mask of PRO_I2C_EXT0_INTR_MAP field.
	INTERRUPT_PRO_I2C_EXT0_INTR_MAP_PRO_I2C_EXT0_INTR_MAP_Msk = 0x1f

	// PRO_I2C_EXT1_INTR_MAP: I2C_EXT1_INTR interrupt configuration register
	// Position of PRO_I2C_EXT1_INTR_MAP field.
	INTERRUPT_PRO_I2C_EXT1_INTR_MAP_PRO_I2C_EXT1_INTR_MAP_Pos = 0x0
	// Bit mask of PRO_I2C_EXT1_INTR_MAP field.
	INTERRUPT_PRO_I2C_EXT1_INTR_MAP_PRO_I2C_EXT1_INTR_MAP_Msk = 0x1f

	// PRO_RSA_INTR_MAP: RSA_INTR interrupt configuration register
	// Position of PRO_RSA_INTR_MAP field.
	INTERRUPT_PRO_RSA_INTR_MAP_PRO_RSA_INTR_MAP_Pos = 0x0
	// Bit mask of PRO_RSA_INTR_MAP field.
	INTERRUPT_PRO_RSA_INTR_MAP_PRO_RSA_INTR_MAP_Msk = 0x1f

	// PRO_SHA_INTR_MAP: SHA_INTR interrupt configuration register
	// Position of PRO_SHA_INTR_MAP field.
	INTERRUPT_PRO_SHA_INTR_MAP_PRO_SHA_INTR_MAP_Pos = 0x0
	// Bit mask of PRO_SHA_INTR_MAP field.
	INTERRUPT_PRO_SHA_INTR_MAP_PRO_SHA_INTR_MAP_Msk = 0x1f

	// PRO_AES_INTR_MAP: AES_INTR interrupt configuration register
	// Position of PRO_AES_INTR_MAP field.
	INTERRUPT_PRO_AES_INTR_MAP_PRO_AES_INTR_MAP_Pos = 0x0
	// Bit mask of PRO_AES_INTR_MAP field.
	INTERRUPT_PRO_AES_INTR_MAP_PRO_AES_INTR_MAP_Msk = 0x1f

	// PRO_SPI2_DMA_INT_MAP: SPI2_DMA_INT interrupt configuration register
	// Position of PRO_SPI2_DMA_INT_MAP field.
	INTERRUPT_PRO_SPI2_DMA_INT_MAP_PRO_SPI2_DMA_INT_MAP_Pos = 0x0
	// Bit mask of PRO_SPI2_DMA_INT_MAP field.
	INTERRUPT_PRO_SPI2_DMA_INT_MAP_PRO_SPI2_DMA_INT_MAP_Msk = 0x1f

	// PRO_SPI3_DMA_INT_MAP: SPI3_DMA_INT interrupt configuration register
	// Position of PRO_SPI3_DMA_INT_MAP field.
	INTERRUPT_PRO_SPI3_DMA_INT_MAP_PRO_SPI3_DMA_INT_MAP_Pos = 0x0
	// Bit mask of PRO_SPI3_DMA_INT_MAP field.
	INTERRUPT_PRO_SPI3_DMA_INT_MAP_PRO_SPI3_DMA_INT_MAP_Msk = 0x1f

	// PRO_WDG_INT_MAP: WDG_INT interrupt configuration register
	// Position of PRO_WDG_INT_MAP field.
	INTERRUPT_PRO_WDG_INT_MAP_PRO_WDG_INT_MAP_Pos = 0x0
	// Bit mask of PRO_WDG_INT_MAP field.
	INTERRUPT_PRO_WDG_INT_MAP_PRO_WDG_INT_MAP_Msk = 0x1f

	// PRO_TIMER_INT1_MAP: TIMER_INT1 interrupt configuration register
	// Position of PRO_TIMER_INT1_MAP field.
	INTERRUPT_PRO_TIMER_INT1_MAP_PRO_TIMER_INT1_MAP_Pos = 0x0
	// Bit mask of PRO_TIMER_INT1_MAP field.
	INTERRUPT_PRO_TIMER_INT1_MAP_PRO_TIMER_INT1_MAP_Msk = 0x1f

	// PRO_TIMER_INT2_MAP: TIMER_INT2 interrupt configuration register
	// Position of PRO_TIMER_INT2_MAP field.
	INTERRUPT_PRO_TIMER_INT2_MAP_PRO_TIMER_INT2_MAP_Pos = 0x0
	// Bit mask of PRO_TIMER_INT2_MAP field.
	INTERRUPT_PRO_TIMER_INT2_MAP_PRO_TIMER_INT2_MAP_Msk = 0x1f

	// PRO_TG_T0_EDGE_INT_MAP: TG_T0_EDGE_INT interrupt configuration register
	// Position of PRO_TG_T0_EDGE_INT_MAP field.
	INTERRUPT_PRO_TG_T0_EDGE_INT_MAP_PRO_TG_T0_EDGE_INT_MAP_Pos = 0x0
	// Bit mask of PRO_TG_T0_EDGE_INT_MAP field.
	INTERRUPT_PRO_TG_T0_EDGE_INT_MAP_PRO_TG_T0_EDGE_INT_MAP_Msk = 0x1f

	// PRO_TG_T1_EDGE_INT_MAP: TG_T1_EDGE_INT interrupt configuration register
	// Position of PRO_TG_T1_EDGE_INT_MAP field.
	INTERRUPT_PRO_TG_T1_EDGE_INT_MAP_PRO_TG_T1_EDGE_INT_MAP_Pos = 0x0
	// Bit mask of PRO_TG_T1_EDGE_INT_MAP field.
	INTERRUPT_PRO_TG_T1_EDGE_INT_MAP_PRO_TG_T1_EDGE_INT_MAP_Msk = 0x1f

	// PRO_TG_WDT_EDGE_INT_MAP: TG_WDT_EDGE_INT interrupt configuration register
	// Position of PRO_TG_WDT_EDGE_INT_MAP field.
	INTERRUPT_PRO_TG_WDT_EDGE_INT_MAP_PRO_TG_WDT_EDGE_INT_MAP_Pos = 0x0
	// Bit mask of PRO_TG_WDT_EDGE_INT_MAP field.
	INTERRUPT_PRO_TG_WDT_EDGE_INT_MAP_PRO_TG_WDT_EDGE_INT_MAP_Msk = 0x1f

	// PRO_TG_LACT_EDGE_INT_MAP: TG_LACT_EDGE_INT interrupt configuration register
	// Position of PRO_TG_LACT_EDGE_INT_MAP field.
	INTERRUPT_PRO_TG_LACT_EDGE_INT_MAP_PRO_TG_LACT_EDGE_INT_MAP_Pos = 0x0
	// Bit mask of PRO_TG_LACT_EDGE_INT_MAP field.
	INTERRUPT_PRO_TG_LACT_EDGE_INT_MAP_PRO_TG_LACT_EDGE_INT_MAP_Msk = 0x1f

	// PRO_TG1_T0_EDGE_INT_MAP: TG1_T0_EDGE_INT interrupt configuration register
	// Position of PRO_TG1_T0_EDGE_INT_MAP field.
	INTERRUPT_PRO_TG1_T0_EDGE_INT_MAP_PRO_TG1_T0_EDGE_INT_MAP_Pos = 0x0
	// Bit mask of PRO_TG1_T0_EDGE_INT_MAP field.
	INTERRUPT_PRO_TG1_T0_EDGE_INT_MAP_PRO_TG1_T0_EDGE_INT_MAP_Msk = 0x1f

	// PRO_TG1_T1_EDGE_INT_MAP: TG1_T1_EDGE_INT interrupt configuration register
	// Position of PRO_TG1_T1_EDGE_INT_MAP field.
	INTERRUPT_PRO_TG1_T1_EDGE_INT_MAP_PRO_TG1_T1_EDGE_INT_MAP_Pos = 0x0
	// Bit mask of PRO_TG1_T1_EDGE_INT_MAP field.
	INTERRUPT_PRO_TG1_T1_EDGE_INT_MAP_PRO_TG1_T1_EDGE_INT_MAP_Msk = 0x1f

	// PRO_TG1_WDT_EDGE_INT_MAP: TG1_WDT_EDGE_INT interrupt configuration register
	// Position of PRO_TG1_WDT_EDGE_INT_MAP field.
	INTERRUPT_PRO_TG1_WDT_EDGE_INT_MAP_PRO_TG1_WDT_EDGE_INT_MAP_Pos = 0x0
	// Bit mask of PRO_TG1_WDT_EDGE_INT_MAP field.
	INTERRUPT_PRO_TG1_WDT_EDGE_INT_MAP_PRO_TG1_WDT_EDGE_INT_MAP_Msk = 0x1f

	// PRO_TG1_LACT_EDGE_INT_MAP: TG1_LACT_EDGE_INT interrupt configuration register
	// Position of PRO_TG1_LACT_EDGE_INT_MAP field.
	INTERRUPT_PRO_TG1_LACT_EDGE_INT_MAP_PRO_TG1_LACT_EDGE_INT_MAP_Pos = 0x0
	// Bit mask of PRO_TG1_LACT_EDGE_INT_MAP field.
	INTERRUPT_PRO_TG1_LACT_EDGE_INT_MAP_PRO_TG1_LACT_EDGE_INT_MAP_Msk = 0x1f

	// PRO_CACHE_IA_INT_MAP: CACHE_IA_INT interrupt configuration register
	// Position of PRO_CACHE_IA_INT_MAP field.
	INTERRUPT_PRO_CACHE_IA_INT_MAP_PRO_CACHE_IA_INT_MAP_Pos = 0x0
	// Bit mask of PRO_CACHE_IA_INT_MAP field.
	INTERRUPT_PRO_CACHE_IA_INT_MAP_PRO_CACHE_IA_INT_MAP_Msk = 0x1f

	// PRO_SYSTIMER_TARGET0_INT_MAP: SYSTIMER_TARGET0_INT interrupt configuration register
	// Position of PRO_SYSTIMER_TARGET0_INT_MAP field.
	INTERRUPT_PRO_SYSTIMER_TARGET0_INT_MAP_PRO_SYSTIMER_TARGET0_INT_MAP_Pos = 0x0
	// Bit mask of PRO_SYSTIMER_TARGET0_INT_MAP field.
	INTERRUPT_PRO_SYSTIMER_TARGET0_INT_MAP_PRO_SYSTIMER_TARGET0_INT_MAP_Msk = 0x1f

	// PRO_SYSTIMER_TARGET1_INT_MAP: SYSTIMER_TARGET1_INT interrupt configuration register
	// Position of PRO_SYSTIMER_TARGET1_INT_MAP field.
	INTERRUPT_PRO_SYSTIMER_TARGET1_INT_MAP_PRO_SYSTIMER_TARGET1_INT_MAP_Pos = 0x0
	// Bit mask of PRO_SYSTIMER_TARGET1_INT_MAP field.
	INTERRUPT_PRO_SYSTIMER_TARGET1_INT_MAP_PRO_SYSTIMER_TARGET1_INT_MAP_Msk = 0x1f

	// PRO_SYSTIMER_TARGET2_INT_MAP: SYSTIMER_TARGET2_INT interrupt configuration register
	// Position of PRO_SYSTIMER_TARGET2_INT_MAP field.
	INTERRUPT_PRO_SYSTIMER_TARGET2_INT_MAP_PRO_SYSTIMER_TARGET2_INT_MAP_Pos = 0x0
	// Bit mask of PRO_SYSTIMER_TARGET2_INT_MAP field.
	INTERRUPT_PRO_SYSTIMER_TARGET2_INT_MAP_PRO_SYSTIMER_TARGET2_INT_MAP_Msk = 0x1f

	// PRO_ASSIST_DEBUG_INTR_MAP: ASSIST_DEBUG_INTR interrupt configuration register
	// Position of PRO_ASSIST_DEBUG_INTR_MAP field.
	INTERRUPT_PRO_ASSIST_DEBUG_INTR_MAP_PRO_ASSIST_DEBUG_INTR_MAP_Pos = 0x0
	// Bit mask of PRO_ASSIST_DEBUG_INTR_MAP field.
	INTERRUPT_PRO_ASSIST_DEBUG_INTR_MAP_PRO_ASSIST_DEBUG_INTR_MAP_Msk = 0x1f

	// PRO_PMS_PRO_IRAM0_ILG_INTR_MAP: PMS_PRO_IRAM0_ILG interrupt configuration register
	// Position of PRO_PMS_PRO_IRAM0_ILG_INTR_MAP field.
	INTERRUPT_PRO_PMS_PRO_IRAM0_ILG_INTR_MAP_PRO_PMS_PRO_IRAM0_ILG_INTR_MAP_Pos = 0x0
	// Bit mask of PRO_PMS_PRO_IRAM0_ILG_INTR_MAP field.
	INTERRUPT_PRO_PMS_PRO_IRAM0_ILG_INTR_MAP_PRO_PMS_PRO_IRAM0_ILG_INTR_MAP_Msk = 0x1f

	// PRO_PMS_PRO_DRAM0_ILG_INTR_MAP: PMS_PRO_DRAM0_ILG interrupt configuration register
	// Position of PRO_PMS_PRO_DRAM0_ILG_INTR_MAP field.
	INTERRUPT_PRO_PMS_PRO_DRAM0_ILG_INTR_MAP_PRO_PMS_PRO_DRAM0_ILG_INTR_MAP_Pos = 0x0
	// Bit mask of PRO_PMS_PRO_DRAM0_ILG_INTR_MAP field.
	INTERRUPT_PRO_PMS_PRO_DRAM0_ILG_INTR_MAP_PRO_PMS_PRO_DRAM0_ILG_INTR_MAP_Msk = 0x1f

	// PRO_PMS_PRO_DPORT_ILG_INTR_MAP: PMS_PRO_DPORT_ILG interrupt configuration register
	// Position of PRO_PMS_PRO_DPORT_ILG_INTR_MAP field.
	INTERRUPT_PRO_PMS_PRO_DPORT_ILG_INTR_MAP_PRO_PMS_PRO_DPORT_ILG_INTR_MAP_Pos = 0x0
	// Bit mask of PRO_PMS_PRO_DPORT_ILG_INTR_MAP field.
	INTERRUPT_PRO_PMS_PRO_DPORT_ILG_INTR_MAP_PRO_PMS_PRO_DPORT_ILG_INTR_MAP_Msk = 0x1f

	// PRO_PMS_PRO_AHB_ILG_INTR_MAP: PMS_PRO_AHB_ILG interrupt configuration register
	// Position of PRO_PMS_PRO_AHB_ILG_INTR_MAP field.
	INTERRUPT_PRO_PMS_PRO_AHB_ILG_INTR_MAP_PRO_PMS_PRO_AHB_ILG_INTR_MAP_Pos = 0x0
	// Bit mask of PRO_PMS_PRO_AHB_ILG_INTR_MAP field.
	INTERRUPT_PRO_PMS_PRO_AHB_ILG_INTR_MAP_PRO_PMS_PRO_AHB_ILG_INTR_MAP_Msk = 0x1f

	// PRO_PMS_PRO_CACHE_ILG_INTR_MAP: PMS_PRO_CACHE_ILG interrupt configuration register
	// Position of PRO_PMS_PRO_CACHE_ILG_INTR_MAP field.
	INTERRUPT_PRO_PMS_PRO_CACHE_ILG_INTR_MAP_PRO_PMS_PRO_CACHE_ILG_INTR_MAP_Pos = 0x0
	// Bit mask of PRO_PMS_PRO_CACHE_ILG_INTR_MAP field.
	INTERRUPT_PRO_PMS_PRO_CACHE_ILG_INTR_MAP_PRO_PMS_PRO_CACHE_ILG_INTR_MAP_Msk = 0x1f

	// PRO_PMS_DMA_APB_I_ILG_INTR_MAP: PMS_DMA_APB_I_ILG interrupt configuration register
	// Position of PRO_PMS_DMA_APB_I_ILG_INTR_MAP field.
	INTERRUPT_PRO_PMS_DMA_APB_I_ILG_INTR_MAP_PRO_PMS_DMA_APB_I_ILG_INTR_MAP_Pos = 0x0
	// Bit mask of PRO_PMS_DMA_APB_I_ILG_INTR_MAP field.
	INTERRUPT_PRO_PMS_DMA_APB_I_ILG_INTR_MAP_PRO_PMS_DMA_APB_I_ILG_INTR_MAP_Msk = 0x1f

	// PRO_PMS_DMA_RX_I_ILG_INTR_MAP: PMS_DMA_RX_I_ILG interrupt configuration register
	// Position of PRO_PMS_DMA_RX_I_ILG_INTR_MAP field.
	INTERRUPT_PRO_PMS_DMA_RX_I_ILG_INTR_MAP_PRO_PMS_DMA_RX_I_ILG_INTR_MAP_Pos = 0x0
	// Bit mask of PRO_PMS_DMA_RX_I_ILG_INTR_MAP field.
	INTERRUPT_PRO_PMS_DMA_RX_I_ILG_INTR_MAP_PRO_PMS_DMA_RX_I_ILG_INTR_MAP_Msk = 0x1f

	// PRO_PMS_DMA_TX_I_ILG_INTR_MAP: PMS_DMA_TX_I_ILG interrupt configuration register
	// Position of PRO_PMS_DMA_TX_I_ILG_INTR_MAP field.
	INTERRUPT_PRO_PMS_DMA_TX_I_ILG_INTR_MAP_PRO_PMS_DMA_TX_I_ILG_INTR_MAP_Pos = 0x0
	// Bit mask of PRO_PMS_DMA_TX_I_ILG_INTR_MAP field.
	INTERRUPT_PRO_PMS_DMA_TX_I_ILG_INTR_MAP_PRO_PMS_DMA_TX_I_ILG_INTR_MAP_Msk = 0x1f

	// PRO_SPI_MEM_REJECT_INTR_MAP: SPI_MEM_REJECT_INTR interrupt configuration register
	// Position of PRO_SPI_MEM_REJECT_INTR_MAP field.
	INTERRUPT_PRO_SPI_MEM_REJECT_INTR_MAP_PRO_SPI_MEM_REJECT_INTR_MAP_Pos = 0x0
	// Bit mask of PRO_SPI_MEM_REJECT_INTR_MAP field.
	INTERRUPT_PRO_SPI_MEM_REJECT_INTR_MAP_PRO_SPI_MEM_REJECT_INTR_MAP_Msk = 0x1f

	// PRO_DMA_COPY_INTR_MAP: DMA_COPY_INTR interrupt configuration register
	// Position of PRO_DMA_COPY_INTR_MAP field.
	INTERRUPT_PRO_DMA_COPY_INTR_MAP_PRO_DMA_COPY_INTR_MAP_Pos = 0x0
	// Bit mask of PRO_DMA_COPY_INTR_MAP field.
	INTERRUPT_PRO_DMA_COPY_INTR_MAP_PRO_DMA_COPY_INTR_MAP_Msk = 0x1f

	// PRO_SPI4_DMA_INT_MAP: SPI4_DMA_INT interrupt configuration register
	// Position of PRO_SPI4_DMA_INT_MAP field.
	INTERRUPT_PRO_SPI4_DMA_INT_MAP_PRO_SPI4_DMA_INT_MAP_Pos = 0x0
	// Bit mask of PRO_SPI4_DMA_INT_MAP field.
	INTERRUPT_PRO_SPI4_DMA_INT_MAP_PRO_SPI4_DMA_INT_MAP_Msk = 0x1f

	// PRO_SPI_INTR_4_MAP: SPI_INTR_4 interrupt configuration register
	// Position of PRO_SPI_INTR_4_MAP field.
	INTERRUPT_PRO_SPI_INTR_4_MAP_PRO_SPI_INTR_4_MAP_Pos = 0x0
	// Bit mask of PRO_SPI_INTR_4_MAP field.
	INTERRUPT_PRO_SPI_INTR_4_MAP_PRO_SPI_INTR_4_MAP_Msk = 0x1f

	// PRO_DCACHE_PRELOAD_INT_MAP: DCACHE_PRELOAD_INT interrupt configuration register
	// Position of PRO_DCACHE_PRELOAD_INT_MAP field.
	INTERRUPT_PRO_DCACHE_PRELOAD_INT_MAP_PRO_DCACHE_PRELOAD_INT_MAP_Pos = 0x0
	// Bit mask of PRO_DCACHE_PRELOAD_INT_MAP field.
	INTERRUPT_PRO_DCACHE_PRELOAD_INT_MAP_PRO_DCACHE_PRELOAD_INT_MAP_Msk = 0x1f

	// PRO_ICACHE_PRELOAD_INT_MAP: ICACHE_PRELOAD_INT interrupt configuration register
	// Position of PRO_ICACHE_PRELOAD_INT_MAP field.
	INTERRUPT_PRO_ICACHE_PRELOAD_INT_MAP_PRO_ICACHE_PRELOAD_INT_MAP_Pos = 0x0
	// Bit mask of PRO_ICACHE_PRELOAD_INT_MAP field.
	INTERRUPT_PRO_ICACHE_PRELOAD_INT_MAP_PRO_ICACHE_PRELOAD_INT_MAP_Msk = 0x1f

	// PRO_APB_ADC_INT_MAP: APB_ADC_INT interrupt configuration register
	// Position of PRO_APB_ADC_INT_MAP field.
	INTERRUPT_PRO_APB_ADC_INT_MAP_PRO_APB_ADC_INT_MAP_Pos = 0x0
	// Bit mask of PRO_APB_ADC_INT_MAP field.
	INTERRUPT_PRO_APB_ADC_INT_MAP_PRO_APB_ADC_INT_MAP_Msk = 0x1f

	// PRO_CRYPTO_DMA_INT_MAP: CRYPTO_DMA_INT interrupt configuration register
	// Position of PRO_CRYPTO_DMA_INT_MAP field.
	INTERRUPT_PRO_CRYPTO_DMA_INT_MAP_PRO_CRYPTO_DMA_INT_MAP_Pos = 0x0
	// Bit mask of PRO_CRYPTO_DMA_INT_MAP field.
	INTERRUPT_PRO_CRYPTO_DMA_INT_MAP_PRO_CRYPTO_DMA_INT_MAP_Msk = 0x1f

	// PRO_CPU_PERI_ERROR_INT_MAP: CPU_PERI_ERROR_INT interrupt configuration register
	// Position of PRO_CPU_PERI_ERROR_INT_MAP field.
	INTERRUPT_PRO_CPU_PERI_ERROR_INT_MAP_PRO_CPU_PERI_ERROR_INT_MAP_Pos = 0x0
	// Bit mask of PRO_CPU_PERI_ERROR_INT_MAP field.
	INTERRUPT_PRO_CPU_PERI_ERROR_INT_MAP_PRO_CPU_PERI_ERROR_INT_MAP_Msk = 0x1f

	// PRO_APB_PERI_ERROR_INT_MAP: APB_PERI_ERROR_INT interrupt configuration register
	// Position of PRO_APB_PERI_ERROR_INT_MAP field.
	INTERRUPT_PRO_APB_PERI_ERROR_INT_MAP_PRO_APB_PERI_ERROR_INT_MAP_Pos = 0x0
	// Bit mask of PRO_APB_PERI_ERROR_INT_MAP field.
	INTERRUPT_PRO_APB_PERI_ERROR_INT_MAP_PRO_APB_PERI_ERROR_INT_MAP_Msk = 0x1f

	// PRO_DCACHE_SYNC_INT_MAP: DCACHE_SYNC_INT interrupt configuration register
	// Position of PRO_DCACHE_SYNC_INT_MAP field.
	INTERRUPT_PRO_DCACHE_SYNC_INT_MAP_PRO_DCACHE_SYNC_INT_MAP_Pos = 0x0
	// Bit mask of PRO_DCACHE_SYNC_INT_MAP field.
	INTERRUPT_PRO_DCACHE_SYNC_INT_MAP_PRO_DCACHE_SYNC_INT_MAP_Msk = 0x1f

	// PRO_ICACHE_SYNC_INT_MAP: ICACHE_SYNC_INT interrupt configuration register
	// Position of PRO_ICACHE_SYNC_INT_MAP field.
	INTERRUPT_PRO_ICACHE_SYNC_INT_MAP_PRO_ICACHE_SYNC_INT_MAP_Pos = 0x0
	// Bit mask of PRO_ICACHE_SYNC_INT_MAP field.
	INTERRUPT_PRO_ICACHE_SYNC_INT_MAP_PRO_ICACHE_SYNC_INT_MAP_Msk = 0x1f

	// PRO_INTR_STATUS_REG_0: Interrupt status register 0
	// Position of PRO_INTR_STATUS_0 field.
	INTERRUPT_PRO_INTR_STATUS_REG_0_PRO_INTR_STATUS_0_Pos = 0x0
	// Bit mask of PRO_INTR_STATUS_0 field.
	INTERRUPT_PRO_INTR_STATUS_REG_0_PRO_INTR_STATUS_0_Msk = 0xffffffff

	// PRO_INTR_STATUS_REG_1: Interrupt status register 1
	// Position of PRO_INTR_STATUS_1 field.
	INTERRUPT_PRO_INTR_STATUS_REG_1_PRO_INTR_STATUS_1_Pos = 0x0
	// Bit mask of PRO_INTR_STATUS_1 field.
	INTERRUPT_PRO_INTR_STATUS_REG_1_PRO_INTR_STATUS_1_Msk = 0xffffffff

	// PRO_INTR_STATUS_REG_2: Interrupt status register 2
	// Position of PRO_INTR_STATUS_2 field.
	INTERRUPT_PRO_INTR_STATUS_REG_2_PRO_INTR_STATUS_2_Pos = 0x0
	// Bit mask of PRO_INTR_STATUS_2 field.
	INTERRUPT_PRO_INTR_STATUS_REG_2_PRO_INTR_STATUS_2_Msk = 0xffffffff

	// CLOCK_GATE: NMI interrupt signals mask register
	// Position of CLK_EN field.
	INTERRUPT_CLOCK_GATE_CLK_EN_Pos = 0x0
	// Bit mask of CLK_EN field.
	INTERRUPT_CLOCK_GATE_CLK_EN_Msk = 0x1
	// Bit CLK_EN.
	INTERRUPT_CLOCK_GATE_CLK_EN = 0x1
	// Position of PRO_NMI_MASK_HW field.
	INTERRUPT_CLOCK_GATE_PRO_NMI_MASK_HW_Pos = 0x1
	// Bit mask of PRO_NMI_MASK_HW field.
	INTERRUPT_CLOCK_GATE_PRO_NMI_MASK_HW_Msk = 0x2
	// Bit PRO_NMI_MASK_HW.
	INTERRUPT_CLOCK_GATE_PRO_NMI_MASK_HW = 0x2

	// REG_DATE: Version control register
	// Position of INTERRUPT_REG_DATE field.
	INTERRUPT_REG_DATE_INTERRUPT_REG_DATE_Pos = 0x0
	// Bit mask of INTERRUPT_REG_DATE field.
	INTERRUPT_REG_DATE_INTERRUPT_REG_DATE_Msk = 0xfffffff
)

// Constants for IO_MUX: Peripheral IO_MUX
const (
	// PIN_CTRL: Clock output configuration register
	// Position of PIN_CLK_OUT1 field.
	IO_MUX_PIN_CTRL_PIN_CLK_OUT1_Pos = 0x0
	// Bit mask of PIN_CLK_OUT1 field.
	IO_MUX_PIN_CTRL_PIN_CLK_OUT1_Msk = 0xf
	// Position of PIN_CLK_OUT2 field.
	IO_MUX_PIN_CTRL_PIN_CLK_OUT2_Pos = 0x4
	// Bit mask of PIN_CLK_OUT2 field.
	IO_MUX_PIN_CTRL_PIN_CLK_OUT2_Msk = 0xf0
	// Position of PIN_CLK_OUT3 field.
	IO_MUX_PIN_CTRL_PIN_CLK_OUT3_Pos = 0x8
	// Bit mask of PIN_CLK_OUT3 field.
	IO_MUX_PIN_CTRL_PIN_CLK_OUT3_Msk = 0xf00
	// Position of SWITCH_PRT_NUM field.
	IO_MUX_PIN_CTRL_SWITCH_PRT_NUM_Pos = 0xc
	// Bit mask of SWITCH_PRT_NUM field.
	IO_MUX_PIN_CTRL_SWITCH_PRT_NUM_Msk = 0x7000
	// Position of PAD_POWER_CTRL field.
	IO_MUX_PIN_CTRL_PAD_POWER_CTRL_Pos = 0xf
	// Bit mask of PAD_POWER_CTRL field.
	IO_MUX_PIN_CTRL_PAD_POWER_CTRL_Msk = 0x8000
	// Bit PAD_POWER_CTRL.
	IO_MUX_PIN_CTRL_PAD_POWER_CTRL = 0x8000

	// GPIO0: Configuration register for pad GPIO0
	// Position of MCU_OE field.
	IO_MUX_GPIO0_MCU_OE_Pos = 0x0
	// Bit mask of MCU_OE field.
	IO_MUX_GPIO0_MCU_OE_Msk = 0x1
	// Bit MCU_OE.
	IO_MUX_GPIO0_MCU_OE = 0x1
	// Position of SLP_SEL field.
	IO_MUX_GPIO0_SLP_SEL_Pos = 0x1
	// Bit mask of SLP_SEL field.
	IO_MUX_GPIO0_SLP_SEL_Msk = 0x2
	// Bit SLP_SEL.
	IO_MUX_GPIO0_SLP_SEL = 0x2
	// Position of MCU_WPD field.
	IO_MUX_GPIO0_MCU_WPD_Pos = 0x2
	// Bit mask of MCU_WPD field.
	IO_MUX_GPIO0_MCU_WPD_Msk = 0x4
	// Bit MCU_WPD.
	IO_MUX_GPIO0_MCU_WPD = 0x4
	// Position of MCU_WPU field.
	IO_MUX_GPIO0_MCU_WPU_Pos = 0x3
	// Bit mask of MCU_WPU field.
	IO_MUX_GPIO0_MCU_WPU_Msk = 0x8
	// Bit MCU_WPU.
	IO_MUX_GPIO0_MCU_WPU = 0x8
	// Position of MCU_IE field.
	IO_MUX_GPIO0_MCU_IE_Pos = 0x4
	// Bit mask of MCU_IE field.
	IO_MUX_GPIO0_MCU_IE_Msk = 0x10
	// Bit MCU_IE.
	IO_MUX_GPIO0_MCU_IE = 0x10
	// Position of FUN_WPD field.
	IO_MUX_GPIO0_FUN_WPD_Pos = 0x7
	// Bit mask of FUN_WPD field.
	IO_MUX_GPIO0_FUN_WPD_Msk = 0x80
	// Bit FUN_WPD.
	IO_MUX_GPIO0_FUN_WPD = 0x80
	// Position of FUN_WPU field.
	IO_MUX_GPIO0_FUN_WPU_Pos = 0x8
	// Bit mask of FUN_WPU field.
	IO_MUX_GPIO0_FUN_WPU_Msk = 0x100
	// Bit FUN_WPU.
	IO_MUX_GPIO0_FUN_WPU = 0x100
	// Position of FUN_IE field.
	IO_MUX_GPIO0_FUN_IE_Pos = 0x9
	// Bit mask of FUN_IE field.
	IO_MUX_GPIO0_FUN_IE_Msk = 0x200
	// Bit FUN_IE.
	IO_MUX_GPIO0_FUN_IE = 0x200
	// Position of FUN_DRV field.
	IO_MUX_GPIO0_FUN_DRV_Pos = 0xa
	// Bit mask of FUN_DRV field.
	IO_MUX_GPIO0_FUN_DRV_Msk = 0xc00
	// Position of MCU_SEL field.
	IO_MUX_GPIO0_MCU_SEL_Pos = 0xc
	// Bit mask of MCU_SEL field.
	IO_MUX_GPIO0_MCU_SEL_Msk = 0x7000
	// Position of FILTER_EN field.
	IO_MUX_GPIO0_FILTER_EN_Pos = 0xf
	// Bit mask of FILTER_EN field.
	IO_MUX_GPIO0_FILTER_EN_Msk = 0x8000
	// Bit FILTER_EN.
	IO_MUX_GPIO0_FILTER_EN = 0x8000

	// GPIO1: Configuration register for pad GPIO1
	// Position of MCU_OE field.
	IO_MUX_GPIO1_MCU_OE_Pos = 0x0
	// Bit mask of MCU_OE field.
	IO_MUX_GPIO1_MCU_OE_Msk = 0x1
	// Bit MCU_OE.
	IO_MUX_GPIO1_MCU_OE = 0x1
	// Position of SLP_SEL field.
	IO_MUX_GPIO1_SLP_SEL_Pos = 0x1
	// Bit mask of SLP_SEL field.
	IO_MUX_GPIO1_SLP_SEL_Msk = 0x2
	// Bit SLP_SEL.
	IO_MUX_GPIO1_SLP_SEL = 0x2
	// Position of MCU_WPD field.
	IO_MUX_GPIO1_MCU_WPD_Pos = 0x2
	// Bit mask of MCU_WPD field.
	IO_MUX_GPIO1_MCU_WPD_Msk = 0x4
	// Bit MCU_WPD.
	IO_MUX_GPIO1_MCU_WPD = 0x4
	// Position of MCU_WPU field.
	IO_MUX_GPIO1_MCU_WPU_Pos = 0x3
	// Bit mask of MCU_WPU field.
	IO_MUX_GPIO1_MCU_WPU_Msk = 0x8
	// Bit MCU_WPU.
	IO_MUX_GPIO1_MCU_WPU = 0x8
	// Position of MCU_IE field.
	IO_MUX_GPIO1_MCU_IE_Pos = 0x4
	// Bit mask of MCU_IE field.
	IO_MUX_GPIO1_MCU_IE_Msk = 0x10
	// Bit MCU_IE.
	IO_MUX_GPIO1_MCU_IE = 0x10
	// Position of FUN_WPD field.
	IO_MUX_GPIO1_FUN_WPD_Pos = 0x7
	// Bit mask of FUN_WPD field.
	IO_MUX_GPIO1_FUN_WPD_Msk = 0x80
	// Bit FUN_WPD.
	IO_MUX_GPIO1_FUN_WPD = 0x80
	// Position of FUN_WPU field.
	IO_MUX_GPIO1_FUN_WPU_Pos = 0x8
	// Bit mask of FUN_WPU field.
	IO_MUX_GPIO1_FUN_WPU_Msk = 0x100
	// Bit FUN_WPU.
	IO_MUX_GPIO1_FUN_WPU = 0x100
	// Position of FUN_IE field.
	IO_MUX_GPIO1_FUN_IE_Pos = 0x9
	// Bit mask of FUN_IE field.
	IO_MUX_GPIO1_FUN_IE_Msk = 0x200
	// Bit FUN_IE.
	IO_MUX_GPIO1_FUN_IE = 0x200
	// Position of FUN_DRV field.
	IO_MUX_GPIO1_FUN_DRV_Pos = 0xa
	// Bit mask of FUN_DRV field.
	IO_MUX_GPIO1_FUN_DRV_Msk = 0xc00
	// Position of MCU_SEL field.
	IO_MUX_GPIO1_MCU_SEL_Pos = 0xc
	// Bit mask of MCU_SEL field.
	IO_MUX_GPIO1_MCU_SEL_Msk = 0x7000
	// Position of FILTER_EN field.
	IO_MUX_GPIO1_FILTER_EN_Pos = 0xf
	// Bit mask of FILTER_EN field.
	IO_MUX_GPIO1_FILTER_EN_Msk = 0x8000
	// Bit FILTER_EN.
	IO_MUX_GPIO1_FILTER_EN = 0x8000

	// GPIO2: Configuration register for pad GPIO2
	// Position of MCU_OE field.
	IO_MUX_GPIO2_MCU_OE_Pos = 0x0
	// Bit mask of MCU_OE field.
	IO_MUX_GPIO2_MCU_OE_Msk = 0x1
	// Bit MCU_OE.
	IO_MUX_GPIO2_MCU_OE = 0x1
	// Position of SLP_SEL field.
	IO_MUX_GPIO2_SLP_SEL_Pos = 0x1
	// Bit mask of SLP_SEL field.
	IO_MUX_GPIO2_SLP_SEL_Msk = 0x2
	// Bit SLP_SEL.
	IO_MUX_GPIO2_SLP_SEL = 0x2
	// Position of MCU_WPD field.
	IO_MUX_GPIO2_MCU_WPD_Pos = 0x2
	// Bit mask of MCU_WPD field.
	IO_MUX_GPIO2_MCU_WPD_Msk = 0x4
	// Bit MCU_WPD.
	IO_MUX_GPIO2_MCU_WPD = 0x4
	// Position of MCU_WPU field.
	IO_MUX_GPIO2_MCU_WPU_Pos = 0x3
	// Bit mask of MCU_WPU field.
	IO_MUX_GPIO2_MCU_WPU_Msk = 0x8
	// Bit MCU_WPU.
	IO_MUX_GPIO2_MCU_WPU = 0x8
	// Position of MCU_IE field.
	IO_MUX_GPIO2_MCU_IE_Pos = 0x4
	// Bit mask of MCU_IE field.
	IO_MUX_GPIO2_MCU_IE_Msk = 0x10
	// Bit MCU_IE.
	IO_MUX_GPIO2_MCU_IE = 0x10
	// Position of FUN_WPD field.
	IO_MUX_GPIO2_FUN_WPD_Pos = 0x7
	// Bit mask of FUN_WPD field.
	IO_MUX_GPIO2_FUN_WPD_Msk = 0x80
	// Bit FUN_WPD.
	IO_MUX_GPIO2_FUN_WPD = 0x80
	// Position of FUN_WPU field.
	IO_MUX_GPIO2_FUN_WPU_Pos = 0x8
	// Bit mask of FUN_WPU field.
	IO_MUX_GPIO2_FUN_WPU_Msk = 0x100
	// Bit FUN_WPU.
	IO_MUX_GPIO2_FUN_WPU = 0x100
	// Position of FUN_IE field.
	IO_MUX_GPIO2_FUN_IE_Pos = 0x9
	// Bit mask of FUN_IE field.
	IO_MUX_GPIO2_FUN_IE_Msk = 0x200
	// Bit FUN_IE.
	IO_MUX_GPIO2_FUN_IE = 0x200
	// Position of FUN_DRV field.
	IO_MUX_GPIO2_FUN_DRV_Pos = 0xa
	// Bit mask of FUN_DRV field.
	IO_MUX_GPIO2_FUN_DRV_Msk = 0xc00
	// Position of MCU_SEL field.
	IO_MUX_GPIO2_MCU_SEL_Pos = 0xc
	// Bit mask of MCU_SEL field.
	IO_MUX_GPIO2_MCU_SEL_Msk = 0x7000
	// Position of FILTER_EN field.
	IO_MUX_GPIO2_FILTER_EN_Pos = 0xf
	// Bit mask of FILTER_EN field.
	IO_MUX_GPIO2_FILTER_EN_Msk = 0x8000
	// Bit FILTER_EN.
	IO_MUX_GPIO2_FILTER_EN = 0x8000

	// GPIO3: Configuration register for pad GPIO3
	// Position of MCU_OE field.
	IO_MUX_GPIO3_MCU_OE_Pos = 0x0
	// Bit mask of MCU_OE field.
	IO_MUX_GPIO3_MCU_OE_Msk = 0x1
	// Bit MCU_OE.
	IO_MUX_GPIO3_MCU_OE = 0x1
	// Position of SLP_SEL field.
	IO_MUX_GPIO3_SLP_SEL_Pos = 0x1
	// Bit mask of SLP_SEL field.
	IO_MUX_GPIO3_SLP_SEL_Msk = 0x2
	// Bit SLP_SEL.
	IO_MUX_GPIO3_SLP_SEL = 0x2
	// Position of MCU_WPD field.
	IO_MUX_GPIO3_MCU_WPD_Pos = 0x2
	// Bit mask of MCU_WPD field.
	IO_MUX_GPIO3_MCU_WPD_Msk = 0x4
	// Bit MCU_WPD.
	IO_MUX_GPIO3_MCU_WPD = 0x4
	// Position of MCU_WPU field.
	IO_MUX_GPIO3_MCU_WPU_Pos = 0x3
	// Bit mask of MCU_WPU field.
	IO_MUX_GPIO3_MCU_WPU_Msk = 0x8
	// Bit MCU_WPU.
	IO_MUX_GPIO3_MCU_WPU = 0x8
	// Position of MCU_IE field.
	IO_MUX_GPIO3_MCU_IE_Pos = 0x4
	// Bit mask of MCU_IE field.
	IO_MUX_GPIO3_MCU_IE_Msk = 0x10
	// Bit MCU_IE.
	IO_MUX_GPIO3_MCU_IE = 0x10
	// Position of FUN_WPD field.
	IO_MUX_GPIO3_FUN_WPD_Pos = 0x7
	// Bit mask of FUN_WPD field.
	IO_MUX_GPIO3_FUN_WPD_Msk = 0x80
	// Bit FUN_WPD.
	IO_MUX_GPIO3_FUN_WPD = 0x80
	// Position of FUN_WPU field.
	IO_MUX_GPIO3_FUN_WPU_Pos = 0x8
	// Bit mask of FUN_WPU field.
	IO_MUX_GPIO3_FUN_WPU_Msk = 0x100
	// Bit FUN_WPU.
	IO_MUX_GPIO3_FUN_WPU = 0x100
	// Position of FUN_IE field.
	IO_MUX_GPIO3_FUN_IE_Pos = 0x9
	// Bit mask of FUN_IE field.
	IO_MUX_GPIO3_FUN_IE_Msk = 0x200
	// Bit FUN_IE.
	IO_MUX_GPIO3_FUN_IE = 0x200
	// Position of FUN_DRV field.
	IO_MUX_GPIO3_FUN_DRV_Pos = 0xa
	// Bit mask of FUN_DRV field.
	IO_MUX_GPIO3_FUN_DRV_Msk = 0xc00
	// Position of MCU_SEL field.
	IO_MUX_GPIO3_MCU_SEL_Pos = 0xc
	// Bit mask of MCU_SEL field.
	IO_MUX_GPIO3_MCU_SEL_Msk = 0x7000
	// Position of FILTER_EN field.
	IO_MUX_GPIO3_FILTER_EN_Pos = 0xf
	// Bit mask of FILTER_EN field.
	IO_MUX_GPIO3_FILTER_EN_Msk = 0x8000
	// Bit FILTER_EN.
	IO_MUX_GPIO3_FILTER_EN = 0x8000

	// GPIO4: Configuration register for pad GPIO4
	// Position of MCU_OE field.
	IO_MUX_GPIO4_MCU_OE_Pos = 0x0
	// Bit mask of MCU_OE field.
	IO_MUX_GPIO4_MCU_OE_Msk = 0x1
	// Bit MCU_OE.
	IO_MUX_GPIO4_MCU_OE = 0x1
	// Position of SLP_SEL field.
	IO_MUX_GPIO4_SLP_SEL_Pos = 0x1
	// Bit mask of SLP_SEL field.
	IO_MUX_GPIO4_SLP_SEL_Msk = 0x2
	// Bit SLP_SEL.
	IO_MUX_GPIO4_SLP_SEL = 0x2
	// Position of MCU_WPD field.
	IO_MUX_GPIO4_MCU_WPD_Pos = 0x2
	// Bit mask of MCU_WPD field.
	IO_MUX_GPIO4_MCU_WPD_Msk = 0x4
	// Bit MCU_WPD.
	IO_MUX_GPIO4_MCU_WPD = 0x4
	// Position of MCU_WPU field.
	IO_MUX_GPIO4_MCU_WPU_Pos = 0x3
	// Bit mask of MCU_WPU field.
	IO_MUX_GPIO4_MCU_WPU_Msk = 0x8
	// Bit MCU_WPU.
	IO_MUX_GPIO4_MCU_WPU = 0x8
	// Position of MCU_IE field.
	IO_MUX_GPIO4_MCU_IE_Pos = 0x4
	// Bit mask of MCU_IE field.
	IO_MUX_GPIO4_MCU_IE_Msk = 0x10
	// Bit MCU_IE.
	IO_MUX_GPIO4_MCU_IE = 0x10
	// Position of FUN_WPD field.
	IO_MUX_GPIO4_FUN_WPD_Pos = 0x7
	// Bit mask of FUN_WPD field.
	IO_MUX_GPIO4_FUN_WPD_Msk = 0x80
	// Bit FUN_WPD.
	IO_MUX_GPIO4_FUN_WPD = 0x80
	// Position of FUN_WPU field.
	IO_MUX_GPIO4_FUN_WPU_Pos = 0x8
	// Bit mask of FUN_WPU field.
	IO_MUX_GPIO4_FUN_WPU_Msk = 0x100
	// Bit FUN_WPU.
	IO_MUX_GPIO4_FUN_WPU = 0x100
	// Position of FUN_IE field.
	IO_MUX_GPIO4_FUN_IE_Pos = 0x9
	// Bit mask of FUN_IE field.
	IO_MUX_GPIO4_FUN_IE_Msk = 0x200
	// Bit FUN_IE.
	IO_MUX_GPIO4_FUN_IE = 0x200
	// Position of FUN_DRV field.
	IO_MUX_GPIO4_FUN_DRV_Pos = 0xa
	// Bit mask of FUN_DRV field.
	IO_MUX_GPIO4_FUN_DRV_Msk = 0xc00
	// Position of MCU_SEL field.
	IO_MUX_GPIO4_MCU_SEL_Pos = 0xc
	// Bit mask of MCU_SEL field.
	IO_MUX_GPIO4_MCU_SEL_Msk = 0x7000
	// Position of FILTER_EN field.
	IO_MUX_GPIO4_FILTER_EN_Pos = 0xf
	// Bit mask of FILTER_EN field.
	IO_MUX_GPIO4_FILTER_EN_Msk = 0x8000
	// Bit FILTER_EN.
	IO_MUX_GPIO4_FILTER_EN = 0x8000

	// GPIO5: Configuration register for pad GPIO5
	// Position of MCU_OE field.
	IO_MUX_GPIO5_MCU_OE_Pos = 0x0
	// Bit mask of MCU_OE field.
	IO_MUX_GPIO5_MCU_OE_Msk = 0x1
	// Bit MCU_OE.
	IO_MUX_GPIO5_MCU_OE = 0x1
	// Position of SLP_SEL field.
	IO_MUX_GPIO5_SLP_SEL_Pos = 0x1
	// Bit mask of SLP_SEL field.
	IO_MUX_GPIO5_SLP_SEL_Msk = 0x2
	// Bit SLP_SEL.
	IO_MUX_GPIO5_SLP_SEL = 0x2
	// Position of MCU_WPD field.
	IO_MUX_GPIO5_MCU_WPD_Pos = 0x2
	// Bit mask of MCU_WPD field.
	IO_MUX_GPIO5_MCU_WPD_Msk = 0x4
	// Bit MCU_WPD.
	IO_MUX_GPIO5_MCU_WPD = 0x4
	// Position of MCU_WPU field.
	IO_MUX_GPIO5_MCU_WPU_Pos = 0x3
	// Bit mask of MCU_WPU field.
	IO_MUX_GPIO5_MCU_WPU_Msk = 0x8
	// Bit MCU_WPU.
	IO_MUX_GPIO5_MCU_WPU = 0x8
	// Position of MCU_IE field.
	IO_MUX_GPIO5_MCU_IE_Pos = 0x4
	// Bit mask of MCU_IE field.
	IO_MUX_GPIO5_MCU_IE_Msk = 0x10
	// Bit MCU_IE.
	IO_MUX_GPIO5_MCU_IE = 0x10
	// Position of FUN_WPD field.
	IO_MUX_GPIO5_FUN_WPD_Pos = 0x7
	// Bit mask of FUN_WPD field.
	IO_MUX_GPIO5_FUN_WPD_Msk = 0x80
	// Bit FUN_WPD.
	IO_MUX_GPIO5_FUN_WPD = 0x80
	// Position of FUN_WPU field.
	IO_MUX_GPIO5_FUN_WPU_Pos = 0x8
	// Bit mask of FUN_WPU field.
	IO_MUX_GPIO5_FUN_WPU_Msk = 0x100
	// Bit FUN_WPU.
	IO_MUX_GPIO5_FUN_WPU = 0x100
	// Position of FUN_IE field.
	IO_MUX_GPIO5_FUN_IE_Pos = 0x9
	// Bit mask of FUN_IE field.
	IO_MUX_GPIO5_FUN_IE_Msk = 0x200
	// Bit FUN_IE.
	IO_MUX_GPIO5_FUN_IE = 0x200
	// Position of FUN_DRV field.
	IO_MUX_GPIO5_FUN_DRV_Pos = 0xa
	// Bit mask of FUN_DRV field.
	IO_MUX_GPIO5_FUN_DRV_Msk = 0xc00
	// Position of MCU_SEL field.
	IO_MUX_GPIO5_MCU_SEL_Pos = 0xc
	// Bit mask of MCU_SEL field.
	IO_MUX_GPIO5_MCU_SEL_Msk = 0x7000
	// Position of FILTER_EN field.
	IO_MUX_GPIO5_FILTER_EN_Pos = 0xf
	// Bit mask of FILTER_EN field.
	IO_MUX_GPIO5_FILTER_EN_Msk = 0x8000
	// Bit FILTER_EN.
	IO_MUX_GPIO5_FILTER_EN = 0x8000

	// GPIO6: Configuration register for pad GPIO6
	// Position of MCU_OE field.
	IO_MUX_GPIO6_MCU_OE_Pos = 0x0
	// Bit mask of MCU_OE field.
	IO_MUX_GPIO6_MCU_OE_Msk = 0x1
	// Bit MCU_OE.
	IO_MUX_GPIO6_MCU_OE = 0x1
	// Position of SLP_SEL field.
	IO_MUX_GPIO6_SLP_SEL_Pos = 0x1
	// Bit mask of SLP_SEL field.
	IO_MUX_GPIO6_SLP_SEL_Msk = 0x2
	// Bit SLP_SEL.
	IO_MUX_GPIO6_SLP_SEL = 0x2
	// Position of MCU_WPD field.
	IO_MUX_GPIO6_MCU_WPD_Pos = 0x2
	// Bit mask of MCU_WPD field.
	IO_MUX_GPIO6_MCU_WPD_Msk = 0x4
	// Bit MCU_WPD.
	IO_MUX_GPIO6_MCU_WPD = 0x4
	// Position of MCU_WPU field.
	IO_MUX_GPIO6_MCU_WPU_Pos = 0x3
	// Bit mask of MCU_WPU field.
	IO_MUX_GPIO6_MCU_WPU_Msk = 0x8
	// Bit MCU_WPU.
	IO_MUX_GPIO6_MCU_WPU = 0x8
	// Position of MCU_IE field.
	IO_MUX_GPIO6_MCU_IE_Pos = 0x4
	// Bit mask of MCU_IE field.
	IO_MUX_GPIO6_MCU_IE_Msk = 0x10
	// Bit MCU_IE.
	IO_MUX_GPIO6_MCU_IE = 0x10
	// Position of FUN_WPD field.
	IO_MUX_GPIO6_FUN_WPD_Pos = 0x7
	// Bit mask of FUN_WPD field.
	IO_MUX_GPIO6_FUN_WPD_Msk = 0x80
	// Bit FUN_WPD.
	IO_MUX_GPIO6_FUN_WPD = 0x80
	// Position of FUN_WPU field.
	IO_MUX_GPIO6_FUN_WPU_Pos = 0x8
	// Bit mask of FUN_WPU field.
	IO_MUX_GPIO6_FUN_WPU_Msk = 0x100
	// Bit FUN_WPU.
	IO_MUX_GPIO6_FUN_WPU = 0x100
	// Position of FUN_IE field.
	IO_MUX_GPIO6_FUN_IE_Pos = 0x9
	// Bit mask of FUN_IE field.
	IO_MUX_GPIO6_FUN_IE_Msk = 0x200
	// Bit FUN_IE.
	IO_MUX_GPIO6_FUN_IE = 0x200
	// Position of FUN_DRV field.
	IO_MUX_GPIO6_FUN_DRV_Pos = 0xa
	// Bit mask of FUN_DRV field.
	IO_MUX_GPIO6_FUN_DRV_Msk = 0xc00
	// Position of MCU_SEL field.
	IO_MUX_GPIO6_MCU_SEL_Pos = 0xc
	// Bit mask of MCU_SEL field.
	IO_MUX_GPIO6_MCU_SEL_Msk = 0x7000
	// Position of FILTER_EN field.
	IO_MUX_GPIO6_FILTER_EN_Pos = 0xf
	// Bit mask of FILTER_EN field.
	IO_MUX_GPIO6_FILTER_EN_Msk = 0x8000
	// Bit FILTER_EN.
	IO_MUX_GPIO6_FILTER_EN = 0x8000

	// GPIO7: Configuration register for pad GPIO7
	// Position of MCU_OE field.
	IO_MUX_GPIO7_MCU_OE_Pos = 0x0
	// Bit mask of MCU_OE field.
	IO_MUX_GPIO7_MCU_OE_Msk = 0x1
	// Bit MCU_OE.
	IO_MUX_GPIO7_MCU_OE = 0x1
	// Position of SLP_SEL field.
	IO_MUX_GPIO7_SLP_SEL_Pos = 0x1
	// Bit mask of SLP_SEL field.
	IO_MUX_GPIO7_SLP_SEL_Msk = 0x2
	// Bit SLP_SEL.
	IO_MUX_GPIO7_SLP_SEL = 0x2
	// Position of MCU_WPD field.
	IO_MUX_GPIO7_MCU_WPD_Pos = 0x2
	// Bit mask of MCU_WPD field.
	IO_MUX_GPIO7_MCU_WPD_Msk = 0x4
	// Bit MCU_WPD.
	IO_MUX_GPIO7_MCU_WPD = 0x4
	// Position of MCU_WPU field.
	IO_MUX_GPIO7_MCU_WPU_Pos = 0x3
	// Bit mask of MCU_WPU field.
	IO_MUX_GPIO7_MCU_WPU_Msk = 0x8
	// Bit MCU_WPU.
	IO_MUX_GPIO7_MCU_WPU = 0x8
	// Position of MCU_IE field.
	IO_MUX_GPIO7_MCU_IE_Pos = 0x4
	// Bit mask of MCU_IE field.
	IO_MUX_GPIO7_MCU_IE_Msk = 0x10
	// Bit MCU_IE.
	IO_MUX_GPIO7_MCU_IE = 0x10
	// Position of FUN_WPD field.
	IO_MUX_GPIO7_FUN_WPD_Pos = 0x7
	// Bit mask of FUN_WPD field.
	IO_MUX_GPIO7_FUN_WPD_Msk = 0x80
	// Bit FUN_WPD.
	IO_MUX_GPIO7_FUN_WPD = 0x80
	// Position of FUN_WPU field.
	IO_MUX_GPIO7_FUN_WPU_Pos = 0x8
	// Bit mask of FUN_WPU field.
	IO_MUX_GPIO7_FUN_WPU_Msk = 0x100
	// Bit FUN_WPU.
	IO_MUX_GPIO7_FUN_WPU = 0x100
	// Position of FUN_IE field.
	IO_MUX_GPIO7_FUN_IE_Pos = 0x9
	// Bit mask of FUN_IE field.
	IO_MUX_GPIO7_FUN_IE_Msk = 0x200
	// Bit FUN_IE.
	IO_MUX_GPIO7_FUN_IE = 0x200
	// Position of FUN_DRV field.
	IO_MUX_GPIO7_FUN_DRV_Pos = 0xa
	// Bit mask of FUN_DRV field.
	IO_MUX_GPIO7_FUN_DRV_Msk = 0xc00
	// Position of MCU_SEL field.
	IO_MUX_GPIO7_MCU_SEL_Pos = 0xc
	// Bit mask of MCU_SEL field.
	IO_MUX_GPIO7_MCU_SEL_Msk = 0x7000
	// Position of FILTER_EN field.
	IO_MUX_GPIO7_FILTER_EN_Pos = 0xf
	// Bit mask of FILTER_EN field.
	IO_MUX_GPIO7_FILTER_EN_Msk = 0x8000
	// Bit FILTER_EN.
	IO_MUX_GPIO7_FILTER_EN = 0x8000

	// GPIO8: Configuration register for pad GPIO8
	// Position of MCU_OE field.
	IO_MUX_GPIO8_MCU_OE_Pos = 0x0
	// Bit mask of MCU_OE field.
	IO_MUX_GPIO8_MCU_OE_Msk = 0x1
	// Bit MCU_OE.
	IO_MUX_GPIO8_MCU_OE = 0x1
	// Position of SLP_SEL field.
	IO_MUX_GPIO8_SLP_SEL_Pos = 0x1
	// Bit mask of SLP_SEL field.
	IO_MUX_GPIO8_SLP_SEL_Msk = 0x2
	// Bit SLP_SEL.
	IO_MUX_GPIO8_SLP_SEL = 0x2
	// Position of MCU_WPD field.
	IO_MUX_GPIO8_MCU_WPD_Pos = 0x2
	// Bit mask of MCU_WPD field.
	IO_MUX_GPIO8_MCU_WPD_Msk = 0x4
	// Bit MCU_WPD.
	IO_MUX_GPIO8_MCU_WPD = 0x4
	// Position of MCU_WPU field.
	IO_MUX_GPIO8_MCU_WPU_Pos = 0x3
	// Bit mask of MCU_WPU field.
	IO_MUX_GPIO8_MCU_WPU_Msk = 0x8
	// Bit MCU_WPU.
	IO_MUX_GPIO8_MCU_WPU = 0x8
	// Position of MCU_IE field.
	IO_MUX_GPIO8_MCU_IE_Pos = 0x4
	// Bit mask of MCU_IE field.
	IO_MUX_GPIO8_MCU_IE_Msk = 0x10
	// Bit MCU_IE.
	IO_MUX_GPIO8_MCU_IE = 0x10
	// Position of FUN_WPD field.
	IO_MUX_GPIO8_FUN_WPD_Pos = 0x7
	// Bit mask of FUN_WPD field.
	IO_MUX_GPIO8_FUN_WPD_Msk = 0x80
	// Bit FUN_WPD.
	IO_MUX_GPIO8_FUN_WPD = 0x80
	// Position of FUN_WPU field.
	IO_MUX_GPIO8_FUN_WPU_Pos = 0x8
	// Bit mask of FUN_WPU field.
	IO_MUX_GPIO8_FUN_WPU_Msk = 0x100
	// Bit FUN_WPU.
	IO_MUX_GPIO8_FUN_WPU = 0x100
	// Position of FUN_IE field.
	IO_MUX_GPIO8_FUN_IE_Pos = 0x9
	// Bit mask of FUN_IE field.
	IO_MUX_GPIO8_FUN_IE_Msk = 0x200
	// Bit FUN_IE.
	IO_MUX_GPIO8_FUN_IE = 0x200
	// Position of FUN_DRV field.
	IO_MUX_GPIO8_FUN_DRV_Pos = 0xa
	// Bit mask of FUN_DRV field.
	IO_MUX_GPIO8_FUN_DRV_Msk = 0xc00
	// Position of MCU_SEL field.
	IO_MUX_GPIO8_MCU_SEL_Pos = 0xc
	// Bit mask of MCU_SEL field.
	IO_MUX_GPIO8_MCU_SEL_Msk = 0x7000
	// Position of FILTER_EN field.
	IO_MUX_GPIO8_FILTER_EN_Pos = 0xf
	// Bit mask of FILTER_EN field.
	IO_MUX_GPIO8_FILTER_EN_Msk = 0x8000
	// Bit FILTER_EN.
	IO_MUX_GPIO8_FILTER_EN = 0x8000

	// GPIO9: Configuration register for pad GPIO9
	// Position of MCU_OE field.
	IO_MUX_GPIO9_MCU_OE_Pos = 0x0
	// Bit mask of MCU_OE field.
	IO_MUX_GPIO9_MCU_OE_Msk = 0x1
	// Bit MCU_OE.
	IO_MUX_GPIO9_MCU_OE = 0x1
	// Position of SLP_SEL field.
	IO_MUX_GPIO9_SLP_SEL_Pos = 0x1
	// Bit mask of SLP_SEL field.
	IO_MUX_GPIO9_SLP_SEL_Msk = 0x2
	// Bit SLP_SEL.
	IO_MUX_GPIO9_SLP_SEL = 0x2
	// Position of MCU_WPD field.
	IO_MUX_GPIO9_MCU_WPD_Pos = 0x2
	// Bit mask of MCU_WPD field.
	IO_MUX_GPIO9_MCU_WPD_Msk = 0x4
	// Bit MCU_WPD.
	IO_MUX_GPIO9_MCU_WPD = 0x4
	// Position of MCU_WPU field.
	IO_MUX_GPIO9_MCU_WPU_Pos = 0x3
	// Bit mask of MCU_WPU field.
	IO_MUX_GPIO9_MCU_WPU_Msk = 0x8
	// Bit MCU_WPU.
	IO_MUX_GPIO9_MCU_WPU = 0x8
	// Position of MCU_IE field.
	IO_MUX_GPIO9_MCU_IE_Pos = 0x4
	// Bit mask of MCU_IE field.
	IO_MUX_GPIO9_MCU_IE_Msk = 0x10
	// Bit MCU_IE.
	IO_MUX_GPIO9_MCU_IE = 0x10
	// Position of FUN_WPD field.
	IO_MUX_GPIO9_FUN_WPD_Pos = 0x7
	// Bit mask of FUN_WPD field.
	IO_MUX_GPIO9_FUN_WPD_Msk = 0x80
	// Bit FUN_WPD.
	IO_MUX_GPIO9_FUN_WPD = 0x80
	// Position of FUN_WPU field.
	IO_MUX_GPIO9_FUN_WPU_Pos = 0x8
	// Bit mask of FUN_WPU field.
	IO_MUX_GPIO9_FUN_WPU_Msk = 0x100
	// Bit FUN_WPU.
	IO_MUX_GPIO9_FUN_WPU = 0x100
	// Position of FUN_IE field.
	IO_MUX_GPIO9_FUN_IE_Pos = 0x9
	// Bit mask of FUN_IE field.
	IO_MUX_GPIO9_FUN_IE_Msk = 0x200
	// Bit FUN_IE.
	IO_MUX_GPIO9_FUN_IE = 0x200
	// Position of FUN_DRV field.
	IO_MUX_GPIO9_FUN_DRV_Pos = 0xa
	// Bit mask of FUN_DRV field.
	IO_MUX_GPIO9_FUN_DRV_Msk = 0xc00
	// Position of MCU_SEL field.
	IO_MUX_GPIO9_MCU_SEL_Pos = 0xc
	// Bit mask of MCU_SEL field.
	IO_MUX_GPIO9_MCU_SEL_Msk = 0x7000
	// Position of FILTER_EN field.
	IO_MUX_GPIO9_FILTER_EN_Pos = 0xf
	// Bit mask of FILTER_EN field.
	IO_MUX_GPIO9_FILTER_EN_Msk = 0x8000
	// Bit FILTER_EN.
	IO_MUX_GPIO9_FILTER_EN = 0x8000

	// GPIO10: Configuration register for pad GPIO10
	// Position of MCU_OE field.
	IO_MUX_GPIO10_MCU_OE_Pos = 0x0
	// Bit mask of MCU_OE field.
	IO_MUX_GPIO10_MCU_OE_Msk = 0x1
	// Bit MCU_OE.
	IO_MUX_GPIO10_MCU_OE = 0x1
	// Position of SLP_SEL field.
	IO_MUX_GPIO10_SLP_SEL_Pos = 0x1
	// Bit mask of SLP_SEL field.
	IO_MUX_GPIO10_SLP_SEL_Msk = 0x2
	// Bit SLP_SEL.
	IO_MUX_GPIO10_SLP_SEL = 0x2
	// Position of MCU_WPD field.
	IO_MUX_GPIO10_MCU_WPD_Pos = 0x2
	// Bit mask of MCU_WPD field.
	IO_MUX_GPIO10_MCU_WPD_Msk = 0x4
	// Bit MCU_WPD.
	IO_MUX_GPIO10_MCU_WPD = 0x4
	// Position of MCU_WPU field.
	IO_MUX_GPIO10_MCU_WPU_Pos = 0x3
	// Bit mask of MCU_WPU field.
	IO_MUX_GPIO10_MCU_WPU_Msk = 0x8
	// Bit MCU_WPU.
	IO_MUX_GPIO10_MCU_WPU = 0x8
	// Position of MCU_IE field.
	IO_MUX_GPIO10_MCU_IE_Pos = 0x4
	// Bit mask of MCU_IE field.
	IO_MUX_GPIO10_MCU_IE_Msk = 0x10
	// Bit MCU_IE.
	IO_MUX_GPIO10_MCU_IE = 0x10
	// Position of FUN_WPD field.
	IO_MUX_GPIO10_FUN_WPD_Pos = 0x7
	// Bit mask of FUN_WPD field.
	IO_MUX_GPIO10_FUN_WPD_Msk = 0x80
	// Bit FUN_WPD.
	IO_MUX_GPIO10_FUN_WPD = 0x80
	// Position of FUN_WPU field.
	IO_MUX_GPIO10_FUN_WPU_Pos = 0x8
	// Bit mask of FUN_WPU field.
	IO_MUX_GPIO10_FUN_WPU_Msk = 0x100
	// Bit FUN_WPU.
	IO_MUX_GPIO10_FUN_WPU = 0x100
	// Position of FUN_IE field.
	IO_MUX_GPIO10_FUN_IE_Pos = 0x9
	// Bit mask of FUN_IE field.
	IO_MUX_GPIO10_FUN_IE_Msk = 0x200
	// Bit FUN_IE.
	IO_MUX_GPIO10_FUN_IE = 0x200
	// Position of FUN_DRV field.
	IO_MUX_GPIO10_FUN_DRV_Pos = 0xa
	// Bit mask of FUN_DRV field.
	IO_MUX_GPIO10_FUN_DRV_Msk = 0xc00
	// Position of MCU_SEL field.
	IO_MUX_GPIO10_MCU_SEL_Pos = 0xc
	// Bit mask of MCU_SEL field.
	IO_MUX_GPIO10_MCU_SEL_Msk = 0x7000
	// Position of FILTER_EN field.
	IO_MUX_GPIO10_FILTER_EN_Pos = 0xf
	// Bit mask of FILTER_EN field.
	IO_MUX_GPIO10_FILTER_EN_Msk = 0x8000
	// Bit FILTER_EN.
	IO_MUX_GPIO10_FILTER_EN = 0x8000

	// GPIO11: Configuration register for pad GPIO11
	// Position of MCU_OE field.
	IO_MUX_GPIO11_MCU_OE_Pos = 0x0
	// Bit mask of MCU_OE field.
	IO_MUX_GPIO11_MCU_OE_Msk = 0x1
	// Bit MCU_OE.
	IO_MUX_GPIO11_MCU_OE = 0x1
	// Position of SLP_SEL field.
	IO_MUX_GPIO11_SLP_SEL_Pos = 0x1
	// Bit mask of SLP_SEL field.
	IO_MUX_GPIO11_SLP_SEL_Msk = 0x2
	// Bit SLP_SEL.
	IO_MUX_GPIO11_SLP_SEL = 0x2
	// Position of MCU_WPD field.
	IO_MUX_GPIO11_MCU_WPD_Pos = 0x2
	// Bit mask of MCU_WPD field.
	IO_MUX_GPIO11_MCU_WPD_Msk = 0x4
	// Bit MCU_WPD.
	IO_MUX_GPIO11_MCU_WPD = 0x4
	// Position of MCU_WPU field.
	IO_MUX_GPIO11_MCU_WPU_Pos = 0x3
	// Bit mask of MCU_WPU field.
	IO_MUX_GPIO11_MCU_WPU_Msk = 0x8
	// Bit MCU_WPU.
	IO_MUX_GPIO11_MCU_WPU = 0x8
	// Position of MCU_IE field.
	IO_MUX_GPIO11_MCU_IE_Pos = 0x4
	// Bit mask of MCU_IE field.
	IO_MUX_GPIO11_MCU_IE_Msk = 0x10
	// Bit MCU_IE.
	IO_MUX_GPIO11_MCU_IE = 0x10
	// Position of FUN_WPD field.
	IO_MUX_GPIO11_FUN_WPD_Pos = 0x7
	// Bit mask of FUN_WPD field.
	IO_MUX_GPIO11_FUN_WPD_Msk = 0x80
	// Bit FUN_WPD.
	IO_MUX_GPIO11_FUN_WPD = 0x80
	// Position of FUN_WPU field.
	IO_MUX_GPIO11_FUN_WPU_Pos = 0x8
	// Bit mask of FUN_WPU field.
	IO_MUX_GPIO11_FUN_WPU_Msk = 0x100
	// Bit FUN_WPU.
	IO_MUX_GPIO11_FUN_WPU = 0x100
	// Position of FUN_IE field.
	IO_MUX_GPIO11_FUN_IE_Pos = 0x9
	// Bit mask of FUN_IE field.
	IO_MUX_GPIO11_FUN_IE_Msk = 0x200
	// Bit FUN_IE.
	IO_MUX_GPIO11_FUN_IE = 0x200
	// Position of FUN_DRV field.
	IO_MUX_GPIO11_FUN_DRV_Pos = 0xa
	// Bit mask of FUN_DRV field.
	IO_MUX_GPIO11_FUN_DRV_Msk = 0xc00
	// Position of MCU_SEL field.
	IO_MUX_GPIO11_MCU_SEL_Pos = 0xc
	// Bit mask of MCU_SEL field.
	IO_MUX_GPIO11_MCU_SEL_Msk = 0x7000
	// Position of FILTER_EN field.
	IO_MUX_GPIO11_FILTER_EN_Pos = 0xf
	// Bit mask of FILTER_EN field.
	IO_MUX_GPIO11_FILTER_EN_Msk = 0x8000
	// Bit FILTER_EN.
	IO_MUX_GPIO11_FILTER_EN = 0x8000

	// GPIO12: Configuration register for pad GPIO12
	// Position of MCU_OE field.
	IO_MUX_GPIO12_MCU_OE_Pos = 0x0
	// Bit mask of MCU_OE field.
	IO_MUX_GPIO12_MCU_OE_Msk = 0x1
	// Bit MCU_OE.
	IO_MUX_GPIO12_MCU_OE = 0x1
	// Position of SLP_SEL field.
	IO_MUX_GPIO12_SLP_SEL_Pos = 0x1
	// Bit mask of SLP_SEL field.
	IO_MUX_GPIO12_SLP_SEL_Msk = 0x2
	// Bit SLP_SEL.
	IO_MUX_GPIO12_SLP_SEL = 0x2
	// Position of MCU_WPD field.
	IO_MUX_GPIO12_MCU_WPD_Pos = 0x2
	// Bit mask of MCU_WPD field.
	IO_MUX_GPIO12_MCU_WPD_Msk = 0x4
	// Bit MCU_WPD.
	IO_MUX_GPIO12_MCU_WPD = 0x4
	// Position of MCU_WPU field.
	IO_MUX_GPIO12_MCU_WPU_Pos = 0x3
	// Bit mask of MCU_WPU field.
	IO_MUX_GPIO12_MCU_WPU_Msk = 0x8
	// Bit MCU_WPU.
	IO_MUX_GPIO12_MCU_WPU = 0x8
	// Position of MCU_IE field.
	IO_MUX_GPIO12_MCU_IE_Pos = 0x4
	// Bit mask of MCU_IE field.
	IO_MUX_GPIO12_MCU_IE_Msk = 0x10
	// Bit MCU_IE.
	IO_MUX_GPIO12_MCU_IE = 0x10
	// Position of FUN_WPD field.
	IO_MUX_GPIO12_FUN_WPD_Pos = 0x7
	// Bit mask of FUN_WPD field.
	IO_MUX_GPIO12_FUN_WPD_Msk = 0x80
	// Bit FUN_WPD.
	IO_MUX_GPIO12_FUN_WPD = 0x80
	// Position of FUN_WPU field.
	IO_MUX_GPIO12_FUN_WPU_Pos = 0x8
	// Bit mask of FUN_WPU field.
	IO_MUX_GPIO12_FUN_WPU_Msk = 0x100
	// Bit FUN_WPU.
	IO_MUX_GPIO12_FUN_WPU = 0x100
	// Position of FUN_IE field.
	IO_MUX_GPIO12_FUN_IE_Pos = 0x9
	// Bit mask of FUN_IE field.
	IO_MUX_GPIO12_FUN_IE_Msk = 0x200
	// Bit FUN_IE.
	IO_MUX_GPIO12_FUN_IE = 0x200
	// Position of FUN_DRV field.
	IO_MUX_GPIO12_FUN_DRV_Pos = 0xa
	// Bit mask of FUN_DRV field.
	IO_MUX_GPIO12_FUN_DRV_Msk = 0xc00
	// Position of MCU_SEL field.
	IO_MUX_GPIO12_MCU_SEL_Pos = 0xc
	// Bit mask of MCU_SEL field.
	IO_MUX_GPIO12_MCU_SEL_Msk = 0x7000
	// Position of FILTER_EN field.
	IO_MUX_GPIO12_FILTER_EN_Pos = 0xf
	// Bit mask of FILTER_EN field.
	IO_MUX_GPIO12_FILTER_EN_Msk = 0x8000
	// Bit FILTER_EN.
	IO_MUX_GPIO12_FILTER_EN = 0x8000

	// GPIO13: Configuration register for pad GPIO13
	// Position of MCU_OE field.
	IO_MUX_GPIO13_MCU_OE_Pos = 0x0
	// Bit mask of MCU_OE field.
	IO_MUX_GPIO13_MCU_OE_Msk = 0x1
	// Bit MCU_OE.
	IO_MUX_GPIO13_MCU_OE = 0x1
	// Position of SLP_SEL field.
	IO_MUX_GPIO13_SLP_SEL_Pos = 0x1
	// Bit mask of SLP_SEL field.
	IO_MUX_GPIO13_SLP_SEL_Msk = 0x2
	// Bit SLP_SEL.
	IO_MUX_GPIO13_SLP_SEL = 0x2
	// Position of MCU_WPD field.
	IO_MUX_GPIO13_MCU_WPD_Pos = 0x2
	// Bit mask of MCU_WPD field.
	IO_MUX_GPIO13_MCU_WPD_Msk = 0x4
	// Bit MCU_WPD.
	IO_MUX_GPIO13_MCU_WPD = 0x4
	// Position of MCU_WPU field.
	IO_MUX_GPIO13_MCU_WPU_Pos = 0x3
	// Bit mask of MCU_WPU field.
	IO_MUX_GPIO13_MCU_WPU_Msk = 0x8
	// Bit MCU_WPU.
	IO_MUX_GPIO13_MCU_WPU = 0x8
	// Position of MCU_IE field.
	IO_MUX_GPIO13_MCU_IE_Pos = 0x4
	// Bit mask of MCU_IE field.
	IO_MUX_GPIO13_MCU_IE_Msk = 0x10
	// Bit MCU_IE.
	IO_MUX_GPIO13_MCU_IE = 0x10
	// Position of FUN_WPD field.
	IO_MUX_GPIO13_FUN_WPD_Pos = 0x7
	// Bit mask of FUN_WPD field.
	IO_MUX_GPIO13_FUN_WPD_Msk = 0x80
	// Bit FUN_WPD.
	IO_MUX_GPIO13_FUN_WPD = 0x80
	// Position of FUN_WPU field.
	IO_MUX_GPIO13_FUN_WPU_Pos = 0x8
	// Bit mask of FUN_WPU field.
	IO_MUX_GPIO13_FUN_WPU_Msk = 0x100
	// Bit FUN_WPU.
	IO_MUX_GPIO13_FUN_WPU = 0x100
	// Position of FUN_IE field.
	IO_MUX_GPIO13_FUN_IE_Pos = 0x9
	// Bit mask of FUN_IE field.
	IO_MUX_GPIO13_FUN_IE_Msk = 0x200
	// Bit FUN_IE.
	IO_MUX_GPIO13_FUN_IE = 0x200
	// Position of FUN_DRV field.
	IO_MUX_GPIO13_FUN_DRV_Pos = 0xa
	// Bit mask of FUN_DRV field.
	IO_MUX_GPIO13_FUN_DRV_Msk = 0xc00
	// Position of MCU_SEL field.
	IO_MUX_GPIO13_MCU_SEL_Pos = 0xc
	// Bit mask of MCU_SEL field.
	IO_MUX_GPIO13_MCU_SEL_Msk = 0x7000
	// Position of FILTER_EN field.
	IO_MUX_GPIO13_FILTER_EN_Pos = 0xf
	// Bit mask of FILTER_EN field.
	IO_MUX_GPIO13_FILTER_EN_Msk = 0x8000
	// Bit FILTER_EN.
	IO_MUX_GPIO13_FILTER_EN = 0x8000

	// GPIO14: Configuration register for pad GPIO14
	// Position of MCU_OE field.
	IO_MUX_GPIO14_MCU_OE_Pos = 0x0
	// Bit mask of MCU_OE field.
	IO_MUX_GPIO14_MCU_OE_Msk = 0x1
	// Bit MCU_OE.
	IO_MUX_GPIO14_MCU_OE = 0x1
	// Position of SLP_SEL field.
	IO_MUX_GPIO14_SLP_SEL_Pos = 0x1
	// Bit mask of SLP_SEL field.
	IO_MUX_GPIO14_SLP_SEL_Msk = 0x2
	// Bit SLP_SEL.
	IO_MUX_GPIO14_SLP_SEL = 0x2
	// Position of MCU_WPD field.
	IO_MUX_GPIO14_MCU_WPD_Pos = 0x2
	// Bit mask of MCU_WPD field.
	IO_MUX_GPIO14_MCU_WPD_Msk = 0x4
	// Bit MCU_WPD.
	IO_MUX_GPIO14_MCU_WPD = 0x4
	// Position of MCU_WPU field.
	IO_MUX_GPIO14_MCU_WPU_Pos = 0x3
	// Bit mask of MCU_WPU field.
	IO_MUX_GPIO14_MCU_WPU_Msk = 0x8
	// Bit MCU_WPU.
	IO_MUX_GPIO14_MCU_WPU = 0x8
	// Position of MCU_IE field.
	IO_MUX_GPIO14_MCU_IE_Pos = 0x4
	// Bit mask of MCU_IE field.
	IO_MUX_GPIO14_MCU_IE_Msk = 0x10
	// Bit MCU_IE.
	IO_MUX_GPIO14_MCU_IE = 0x10
	// Position of FUN_WPD field.
	IO_MUX_GPIO14_FUN_WPD_Pos = 0x7
	// Bit mask of FUN_WPD field.
	IO_MUX_GPIO14_FUN_WPD_Msk = 0x80
	// Bit FUN_WPD.
	IO_MUX_GPIO14_FUN_WPD = 0x80
	// Position of FUN_WPU field.
	IO_MUX_GPIO14_FUN_WPU_Pos = 0x8
	// Bit mask of FUN_WPU field.
	IO_MUX_GPIO14_FUN_WPU_Msk = 0x100
	// Bit FUN_WPU.
	IO_MUX_GPIO14_FUN_WPU = 0x100
	// Position of FUN_IE field.
	IO_MUX_GPIO14_FUN_IE_Pos = 0x9
	// Bit mask of FUN_IE field.
	IO_MUX_GPIO14_FUN_IE_Msk = 0x200
	// Bit FUN_IE.
	IO_MUX_GPIO14_FUN_IE = 0x200
	// Position of FUN_DRV field.
	IO_MUX_GPIO14_FUN_DRV_Pos = 0xa
	// Bit mask of FUN_DRV field.
	IO_MUX_GPIO14_FUN_DRV_Msk = 0xc00
	// Position of MCU_SEL field.
	IO_MUX_GPIO14_MCU_SEL_Pos = 0xc
	// Bit mask of MCU_SEL field.
	IO_MUX_GPIO14_MCU_SEL_Msk = 0x7000
	// Position of FILTER_EN field.
	IO_MUX_GPIO14_FILTER_EN_Pos = 0xf
	// Bit mask of FILTER_EN field.
	IO_MUX_GPIO14_FILTER_EN_Msk = 0x8000
	// Bit FILTER_EN.
	IO_MUX_GPIO14_FILTER_EN = 0x8000

	// XTAL_32K_P: Configuration register for pad XTAL_32K_P
	// Position of MCU_OE field.
	IO_MUX_XTAL_32K_P_MCU_OE_Pos = 0x0
	// Bit mask of MCU_OE field.
	IO_MUX_XTAL_32K_P_MCU_OE_Msk = 0x1
	// Bit MCU_OE.
	IO_MUX_XTAL_32K_P_MCU_OE = 0x1
	// Position of SLP_SEL field.
	IO_MUX_XTAL_32K_P_SLP_SEL_Pos = 0x1
	// Bit mask of SLP_SEL field.
	IO_MUX_XTAL_32K_P_SLP_SEL_Msk = 0x2
	// Bit SLP_SEL.
	IO_MUX_XTAL_32K_P_SLP_SEL = 0x2
	// Position of MCU_WPD field.
	IO_MUX_XTAL_32K_P_MCU_WPD_Pos = 0x2
	// Bit mask of MCU_WPD field.
	IO_MUX_XTAL_32K_P_MCU_WPD_Msk = 0x4
	// Bit MCU_WPD.
	IO_MUX_XTAL_32K_P_MCU_WPD = 0x4
	// Position of MCU_WPU field.
	IO_MUX_XTAL_32K_P_MCU_WPU_Pos = 0x3
	// Bit mask of MCU_WPU field.
	IO_MUX_XTAL_32K_P_MCU_WPU_Msk = 0x8
	// Bit MCU_WPU.
	IO_MUX_XTAL_32K_P_MCU_WPU = 0x8
	// Position of MCU_IE field.
	IO_MUX_XTAL_32K_P_MCU_IE_Pos = 0x4
	// Bit mask of MCU_IE field.
	IO_MUX_XTAL_32K_P_MCU_IE_Msk = 0x10
	// Bit MCU_IE.
	IO_MUX_XTAL_32K_P_MCU_IE = 0x10
	// Position of FUN_WPD field.
	IO_MUX_XTAL_32K_P_FUN_WPD_Pos = 0x7
	// Bit mask of FUN_WPD field.
	IO_MUX_XTAL_32K_P_FUN_WPD_Msk = 0x80
	// Bit FUN_WPD.
	IO_MUX_XTAL_32K_P_FUN_WPD = 0x80
	// Position of FUN_WPU field.
	IO_MUX_XTAL_32K_P_FUN_WPU_Pos = 0x8
	// Bit mask of FUN_WPU field.
	IO_MUX_XTAL_32K_P_FUN_WPU_Msk = 0x100
	// Bit FUN_WPU.
	IO_MUX_XTAL_32K_P_FUN_WPU = 0x100
	// Position of FUN_IE field.
	IO_MUX_XTAL_32K_P_FUN_IE_Pos = 0x9
	// Bit mask of FUN_IE field.
	IO_MUX_XTAL_32K_P_FUN_IE_Msk = 0x200
	// Bit FUN_IE.
	IO_MUX_XTAL_32K_P_FUN_IE = 0x200
	// Position of FUN_DRV field.
	IO_MUX_XTAL_32K_P_FUN_DRV_Pos = 0xa
	// Bit mask of FUN_DRV field.
	IO_MUX_XTAL_32K_P_FUN_DRV_Msk = 0xc00
	// Position of MCU_SEL field.
	IO_MUX_XTAL_32K_P_MCU_SEL_Pos = 0xc
	// Bit mask of MCU_SEL field.
	IO_MUX_XTAL_32K_P_MCU_SEL_Msk = 0x7000
	// Position of FILTER_EN field.
	IO_MUX_XTAL_32K_P_FILTER_EN_Pos = 0xf
	// Bit mask of FILTER_EN field.
	IO_MUX_XTAL_32K_P_FILTER_EN_Msk = 0x8000
	// Bit FILTER_EN.
	IO_MUX_XTAL_32K_P_FILTER_EN = 0x8000

	// XTAL_32K_N: Configuration register for pad XTAL_32K_N
	// Position of MCU_OE field.
	IO_MUX_XTAL_32K_N_MCU_OE_Pos = 0x0
	// Bit mask of MCU_OE field.
	IO_MUX_XTAL_32K_N_MCU_OE_Msk = 0x1
	// Bit MCU_OE.
	IO_MUX_XTAL_32K_N_MCU_OE = 0x1
	// Position of SLP_SEL field.
	IO_MUX_XTAL_32K_N_SLP_SEL_Pos = 0x1
	// Bit mask of SLP_SEL field.
	IO_MUX_XTAL_32K_N_SLP_SEL_Msk = 0x2
	// Bit SLP_SEL.
	IO_MUX_XTAL_32K_N_SLP_SEL = 0x2
	// Position of MCU_WPD field.
	IO_MUX_XTAL_32K_N_MCU_WPD_Pos = 0x2
	// Bit mask of MCU_WPD field.
	IO_MUX_XTAL_32K_N_MCU_WPD_Msk = 0x4
	// Bit MCU_WPD.
	IO_MUX_XTAL_32K_N_MCU_WPD = 0x4
	// Position of MCU_WPU field.
	IO_MUX_XTAL_32K_N_MCU_WPU_Pos = 0x3
	// Bit mask of MCU_WPU field.
	IO_MUX_XTAL_32K_N_MCU_WPU_Msk = 0x8
	// Bit MCU_WPU.
	IO_MUX_XTAL_32K_N_MCU_WPU = 0x8
	// Position of MCU_IE field.
	IO_MUX_XTAL_32K_N_MCU_IE_Pos = 0x4
	// Bit mask of MCU_IE field.
	IO_MUX_XTAL_32K_N_MCU_IE_Msk = 0x10
	// Bit MCU_IE.
	IO_MUX_XTAL_32K_N_MCU_IE = 0x10
	// Position of FUN_WPD field.
	IO_MUX_XTAL_32K_N_FUN_WPD_Pos = 0x7
	// Bit mask of FUN_WPD field.
	IO_MUX_XTAL_32K_N_FUN_WPD_Msk = 0x80
	// Bit FUN_WPD.
	IO_MUX_XTAL_32K_N_FUN_WPD = 0x80
	// Position of FUN_WPU field.
	IO_MUX_XTAL_32K_N_FUN_WPU_Pos = 0x8
	// Bit mask of FUN_WPU field.
	IO_MUX_XTAL_32K_N_FUN_WPU_Msk = 0x100
	// Bit FUN_WPU.
	IO_MUX_XTAL_32K_N_FUN_WPU = 0x100
	// Position of FUN_IE field.
	IO_MUX_XTAL_32K_N_FUN_IE_Pos = 0x9
	// Bit mask of FUN_IE field.
	IO_MUX_XTAL_32K_N_FUN_IE_Msk = 0x200
	// Bit FUN_IE.
	IO_MUX_XTAL_32K_N_FUN_IE = 0x200
	// Position of FUN_DRV field.
	IO_MUX_XTAL_32K_N_FUN_DRV_Pos = 0xa
	// Bit mask of FUN_DRV field.
	IO_MUX_XTAL_32K_N_FUN_DRV_Msk = 0xc00
	// Position of MCU_SEL field.
	IO_MUX_XTAL_32K_N_MCU_SEL_Pos = 0xc
	// Bit mask of MCU_SEL field.
	IO_MUX_XTAL_32K_N_MCU_SEL_Msk = 0x7000
	// Position of FILTER_EN field.
	IO_MUX_XTAL_32K_N_FILTER_EN_Pos = 0xf
	// Bit mask of FILTER_EN field.
	IO_MUX_XTAL_32K_N_FILTER_EN_Msk = 0x8000
	// Bit FILTER_EN.
	IO_MUX_XTAL_32K_N_FILTER_EN = 0x8000

	// DAC_1: Configuration register for pad DAC_1
	// Position of MCU_OE field.
	IO_MUX_DAC_1_MCU_OE_Pos = 0x0
	// Bit mask of MCU_OE field.
	IO_MUX_DAC_1_MCU_OE_Msk = 0x1
	// Bit MCU_OE.
	IO_MUX_DAC_1_MCU_OE = 0x1
	// Position of SLP_SEL field.
	IO_MUX_DAC_1_SLP_SEL_Pos = 0x1
	// Bit mask of SLP_SEL field.
	IO_MUX_DAC_1_SLP_SEL_Msk = 0x2
	// Bit SLP_SEL.
	IO_MUX_DAC_1_SLP_SEL = 0x2
	// Position of MCU_WPD field.
	IO_MUX_DAC_1_MCU_WPD_Pos = 0x2
	// Bit mask of MCU_WPD field.
	IO_MUX_DAC_1_MCU_WPD_Msk = 0x4
	// Bit MCU_WPD.
	IO_MUX_DAC_1_MCU_WPD = 0x4
	// Position of MCU_WPU field.
	IO_MUX_DAC_1_MCU_WPU_Pos = 0x3
	// Bit mask of MCU_WPU field.
	IO_MUX_DAC_1_MCU_WPU_Msk = 0x8
	// Bit MCU_WPU.
	IO_MUX_DAC_1_MCU_WPU = 0x8
	// Position of MCU_IE field.
	IO_MUX_DAC_1_MCU_IE_Pos = 0x4
	// Bit mask of MCU_IE field.
	IO_MUX_DAC_1_MCU_IE_Msk = 0x10
	// Bit MCU_IE.
	IO_MUX_DAC_1_MCU_IE = 0x10
	// Position of FUN_WPD field.
	IO_MUX_DAC_1_FUN_WPD_Pos = 0x7
	// Bit mask of FUN_WPD field.
	IO_MUX_DAC_1_FUN_WPD_Msk = 0x80
	// Bit FUN_WPD.
	IO_MUX_DAC_1_FUN_WPD = 0x80
	// Position of FUN_WPU field.
	IO_MUX_DAC_1_FUN_WPU_Pos = 0x8
	// Bit mask of FUN_WPU field.
	IO_MUX_DAC_1_FUN_WPU_Msk = 0x100
	// Bit FUN_WPU.
	IO_MUX_DAC_1_FUN_WPU = 0x100
	// Position of FUN_IE field.
	IO_MUX_DAC_1_FUN_IE_Pos = 0x9
	// Bit mask of FUN_IE field.
	IO_MUX_DAC_1_FUN_IE_Msk = 0x200
	// Bit FUN_IE.
	IO_MUX_DAC_1_FUN_IE = 0x200
	// Position of FUN_DRV field.
	IO_MUX_DAC_1_FUN_DRV_Pos = 0xa
	// Bit mask of FUN_DRV field.
	IO_MUX_DAC_1_FUN_DRV_Msk = 0xc00
	// Position of MCU_SEL field.
	IO_MUX_DAC_1_MCU_SEL_Pos = 0xc
	// Bit mask of MCU_SEL field.
	IO_MUX_DAC_1_MCU_SEL_Msk = 0x7000
	// Position of FILTER_EN field.
	IO_MUX_DAC_1_FILTER_EN_Pos = 0xf
	// Bit mask of FILTER_EN field.
	IO_MUX_DAC_1_FILTER_EN_Msk = 0x8000
	// Bit FILTER_EN.
	IO_MUX_DAC_1_FILTER_EN = 0x8000

	// DAC_2: Configuration register for pad DAC_2
	// Position of MCU_OE field.
	IO_MUX_DAC_2_MCU_OE_Pos = 0x0
	// Bit mask of MCU_OE field.
	IO_MUX_DAC_2_MCU_OE_Msk = 0x1
	// Bit MCU_OE.
	IO_MUX_DAC_2_MCU_OE = 0x1
	// Position of SLP_SEL field.
	IO_MUX_DAC_2_SLP_SEL_Pos = 0x1
	// Bit mask of SLP_SEL field.
	IO_MUX_DAC_2_SLP_SEL_Msk = 0x2
	// Bit SLP_SEL.
	IO_MUX_DAC_2_SLP_SEL = 0x2
	// Position of MCU_WPD field.
	IO_MUX_DAC_2_MCU_WPD_Pos = 0x2
	// Bit mask of MCU_WPD field.
	IO_MUX_DAC_2_MCU_WPD_Msk = 0x4
	// Bit MCU_WPD.
	IO_MUX_DAC_2_MCU_WPD = 0x4
	// Position of MCU_WPU field.
	IO_MUX_DAC_2_MCU_WPU_Pos = 0x3
	// Bit mask of MCU_WPU field.
	IO_MUX_DAC_2_MCU_WPU_Msk = 0x8
	// Bit MCU_WPU.
	IO_MUX_DAC_2_MCU_WPU = 0x8
	// Position of MCU_IE field.
	IO_MUX_DAC_2_MCU_IE_Pos = 0x4
	// Bit mask of MCU_IE field.
	IO_MUX_DAC_2_MCU_IE_Msk = 0x10
	// Bit MCU_IE.
	IO_MUX_DAC_2_MCU_IE = 0x10
	// Position of FUN_WPD field.
	IO_MUX_DAC_2_FUN_WPD_Pos = 0x7
	// Bit mask of FUN_WPD field.
	IO_MUX_DAC_2_FUN_WPD_Msk = 0x80
	// Bit FUN_WPD.
	IO_MUX_DAC_2_FUN_WPD = 0x80
	// Position of FUN_WPU field.
	IO_MUX_DAC_2_FUN_WPU_Pos = 0x8
	// Bit mask of FUN_WPU field.
	IO_MUX_DAC_2_FUN_WPU_Msk = 0x100
	// Bit FUN_WPU.
	IO_MUX_DAC_2_FUN_WPU = 0x100
	// Position of FUN_IE field.
	IO_MUX_DAC_2_FUN_IE_Pos = 0x9
	// Bit mask of FUN_IE field.
	IO_MUX_DAC_2_FUN_IE_Msk = 0x200
	// Bit FUN_IE.
	IO_MUX_DAC_2_FUN_IE = 0x200
	// Position of FUN_DRV field.
	IO_MUX_DAC_2_FUN_DRV_Pos = 0xa
	// Bit mask of FUN_DRV field.
	IO_MUX_DAC_2_FUN_DRV_Msk = 0xc00
	// Position of MCU_SEL field.
	IO_MUX_DAC_2_MCU_SEL_Pos = 0xc
	// Bit mask of MCU_SEL field.
	IO_MUX_DAC_2_MCU_SEL_Msk = 0x7000
	// Position of FILTER_EN field.
	IO_MUX_DAC_2_FILTER_EN_Pos = 0xf
	// Bit mask of FILTER_EN field.
	IO_MUX_DAC_2_FILTER_EN_Msk = 0x8000
	// Bit FILTER_EN.
	IO_MUX_DAC_2_FILTER_EN = 0x8000

	// GPIO19: Configuration register for pad GPIO19
	// Position of MCU_OE field.
	IO_MUX_GPIO19_MCU_OE_Pos = 0x0
	// Bit mask of MCU_OE field.
	IO_MUX_GPIO19_MCU_OE_Msk = 0x1
	// Bit MCU_OE.
	IO_MUX_GPIO19_MCU_OE = 0x1
	// Position of SLP_SEL field.
	IO_MUX_GPIO19_SLP_SEL_Pos = 0x1
	// Bit mask of SLP_SEL field.
	IO_MUX_GPIO19_SLP_SEL_Msk = 0x2
	// Bit SLP_SEL.
	IO_MUX_GPIO19_SLP_SEL = 0x2
	// Position of MCU_WPD field.
	IO_MUX_GPIO19_MCU_WPD_Pos = 0x2
	// Bit mask of MCU_WPD field.
	IO_MUX_GPIO19_MCU_WPD_Msk = 0x4
	// Bit MCU_WPD.
	IO_MUX_GPIO19_MCU_WPD = 0x4
	// Position of MCU_WPU field.
	IO_MUX_GPIO19_MCU_WPU_Pos = 0x3
	// Bit mask of MCU_WPU field.
	IO_MUX_GPIO19_MCU_WPU_Msk = 0x8
	// Bit MCU_WPU.
	IO_MUX_GPIO19_MCU_WPU = 0x8
	// Position of MCU_IE field.
	IO_MUX_GPIO19_MCU_IE_Pos = 0x4
	// Bit mask of MCU_IE field.
	IO_MUX_GPIO19_MCU_IE_Msk = 0x10
	// Bit MCU_IE.
	IO_MUX_GPIO19_MCU_IE = 0x10
	// Position of FUN_WPD field.
	IO_MUX_GPIO19_FUN_WPD_Pos = 0x7
	// Bit mask of FUN_WPD field.
	IO_MUX_GPIO19_FUN_WPD_Msk = 0x80
	// Bit FUN_WPD.
	IO_MUX_GPIO19_FUN_WPD = 0x80
	// Position of FUN_WPU field.
	IO_MUX_GPIO19_FUN_WPU_Pos = 0x8
	// Bit mask of FUN_WPU field.
	IO_MUX_GPIO19_FUN_WPU_Msk = 0x100
	// Bit FUN_WPU.
	IO_MUX_GPIO19_FUN_WPU = 0x100
	// Position of FUN_IE field.
	IO_MUX_GPIO19_FUN_IE_Pos = 0x9
	// Bit mask of FUN_IE field.
	IO_MUX_GPIO19_FUN_IE_Msk = 0x200
	// Bit FUN_IE.
	IO_MUX_GPIO19_FUN_IE = 0x200
	// Position of FUN_DRV field.
	IO_MUX_GPIO19_FUN_DRV_Pos = 0xa
	// Bit mask of FUN_DRV field.
	IO_MUX_GPIO19_FUN_DRV_Msk = 0xc00
	// Position of MCU_SEL field.
	IO_MUX_GPIO19_MCU_SEL_Pos = 0xc
	// Bit mask of MCU_SEL field.
	IO_MUX_GPIO19_MCU_SEL_Msk = 0x7000
	// Position of FILTER_EN field.
	IO_MUX_GPIO19_FILTER_EN_Pos = 0xf
	// Bit mask of FILTER_EN field.
	IO_MUX_GPIO19_FILTER_EN_Msk = 0x8000
	// Bit FILTER_EN.
	IO_MUX_GPIO19_FILTER_EN = 0x8000

	// GPIO20: Configuration register for pad GPIO20
	// Position of MCU_OE field.
	IO_MUX_GPIO20_MCU_OE_Pos = 0x0
	// Bit mask of MCU_OE field.
	IO_MUX_GPIO20_MCU_OE_Msk = 0x1
	// Bit MCU_OE.
	IO_MUX_GPIO20_MCU_OE = 0x1
	// Position of SLP_SEL field.
	IO_MUX_GPIO20_SLP_SEL_Pos = 0x1
	// Bit mask of SLP_SEL field.
	IO_MUX_GPIO20_SLP_SEL_Msk = 0x2
	// Bit SLP_SEL.
	IO_MUX_GPIO20_SLP_SEL = 0x2
	// Position of MCU_WPD field.
	IO_MUX_GPIO20_MCU_WPD_Pos = 0x2
	// Bit mask of MCU_WPD field.
	IO_MUX_GPIO20_MCU_WPD_Msk = 0x4
	// Bit MCU_WPD.
	IO_MUX_GPIO20_MCU_WPD = 0x4
	// Position of MCU_WPU field.
	IO_MUX_GPIO20_MCU_WPU_Pos = 0x3
	// Bit mask of MCU_WPU field.
	IO_MUX_GPIO20_MCU_WPU_Msk = 0x8
	// Bit MCU_WPU.
	IO_MUX_GPIO20_MCU_WPU = 0x8
	// Position of MCU_IE field.
	IO_MUX_GPIO20_MCU_IE_Pos = 0x4
	// Bit mask of MCU_IE field.
	IO_MUX_GPIO20_MCU_IE_Msk = 0x10
	// Bit MCU_IE.
	IO_MUX_GPIO20_MCU_IE = 0x10
	// Position of FUN_WPD field.
	IO_MUX_GPIO20_FUN_WPD_Pos = 0x7
	// Bit mask of FUN_WPD field.
	IO_MUX_GPIO20_FUN_WPD_Msk = 0x80
	// Bit FUN_WPD.
	IO_MUX_GPIO20_FUN_WPD = 0x80
	// Position of FUN_WPU field.
	IO_MUX_GPIO20_FUN_WPU_Pos = 0x8
	// Bit mask of FUN_WPU field.
	IO_MUX_GPIO20_FUN_WPU_Msk = 0x100
	// Bit FUN_WPU.
	IO_MUX_GPIO20_FUN_WPU = 0x100
	// Position of FUN_IE field.
	IO_MUX_GPIO20_FUN_IE_Pos = 0x9
	// Bit mask of FUN_IE field.
	IO_MUX_GPIO20_FUN_IE_Msk = 0x200
	// Bit FUN_IE.
	IO_MUX_GPIO20_FUN_IE = 0x200
	// Position of FUN_DRV field.
	IO_MUX_GPIO20_FUN_DRV_Pos = 0xa
	// Bit mask of FUN_DRV field.
	IO_MUX_GPIO20_FUN_DRV_Msk = 0xc00
	// Position of MCU_SEL field.
	IO_MUX_GPIO20_MCU_SEL_Pos = 0xc
	// Bit mask of MCU_SEL field.
	IO_MUX_GPIO20_MCU_SEL_Msk = 0x7000
	// Position of FILTER_EN field.
	IO_MUX_GPIO20_FILTER_EN_Pos = 0xf
	// Bit mask of FILTER_EN field.
	IO_MUX_GPIO20_FILTER_EN_Msk = 0x8000
	// Bit FILTER_EN.
	IO_MUX_GPIO20_FILTER_EN = 0x8000

	// GPIO21: Configuration register for pad GPIO21
	// Position of MCU_OE field.
	IO_MUX_GPIO21_MCU_OE_Pos = 0x0
	// Bit mask of MCU_OE field.
	IO_MUX_GPIO21_MCU_OE_Msk = 0x1
	// Bit MCU_OE.
	IO_MUX_GPIO21_MCU_OE = 0x1
	// Position of SLP_SEL field.
	IO_MUX_GPIO21_SLP_SEL_Pos = 0x1
	// Bit mask of SLP_SEL field.
	IO_MUX_GPIO21_SLP_SEL_Msk = 0x2
	// Bit SLP_SEL.
	IO_MUX_GPIO21_SLP_SEL = 0x2
	// Position of MCU_WPD field.
	IO_MUX_GPIO21_MCU_WPD_Pos = 0x2
	// Bit mask of MCU_WPD field.
	IO_MUX_GPIO21_MCU_WPD_Msk = 0x4
	// Bit MCU_WPD.
	IO_MUX_GPIO21_MCU_WPD = 0x4
	// Position of MCU_WPU field.
	IO_MUX_GPIO21_MCU_WPU_Pos = 0x3
	// Bit mask of MCU_WPU field.
	IO_MUX_GPIO21_MCU_WPU_Msk = 0x8
	// Bit MCU_WPU.
	IO_MUX_GPIO21_MCU_WPU = 0x8
	// Position of MCU_IE field.
	IO_MUX_GPIO21_MCU_IE_Pos = 0x4
	// Bit mask of MCU_IE field.
	IO_MUX_GPIO21_MCU_IE_Msk = 0x10
	// Bit MCU_IE.
	IO_MUX_GPIO21_MCU_IE = 0x10
	// Position of FUN_WPD field.
	IO_MUX_GPIO21_FUN_WPD_Pos = 0x7
	// Bit mask of FUN_WPD field.
	IO_MUX_GPIO21_FUN_WPD_Msk = 0x80
	// Bit FUN_WPD.
	IO_MUX_GPIO21_FUN_WPD = 0x80
	// Position of FUN_WPU field.
	IO_MUX_GPIO21_FUN_WPU_Pos = 0x8
	// Bit mask of FUN_WPU field.
	IO_MUX_GPIO21_FUN_WPU_Msk = 0x100
	// Bit FUN_WPU.
	IO_MUX_GPIO21_FUN_WPU = 0x100
	// Position of FUN_IE field.
	IO_MUX_GPIO21_FUN_IE_Pos = 0x9
	// Bit mask of FUN_IE field.
	IO_MUX_GPIO21_FUN_IE_Msk = 0x200
	// Bit FUN_IE.
	IO_MUX_GPIO21_FUN_IE = 0x200
	// Position of FUN_DRV field.
	IO_MUX_GPIO21_FUN_DRV_Pos = 0xa
	// Bit mask of FUN_DRV field.
	IO_MUX_GPIO21_FUN_DRV_Msk = 0xc00
	// Position of MCU_SEL field.
	IO_MUX_GPIO21_MCU_SEL_Pos = 0xc
	// Bit mask of MCU_SEL field.
	IO_MUX_GPIO21_MCU_SEL_Msk = 0x7000
	// Position of FILTER_EN field.
	IO_MUX_GPIO21_FILTER_EN_Pos = 0xf
	// Bit mask of FILTER_EN field.
	IO_MUX_GPIO21_FILTER_EN_Msk = 0x8000
	// Bit FILTER_EN.
	IO_MUX_GPIO21_FILTER_EN = 0x8000

	// SPICS1: Configuration register for pad SPICS1
	// Position of MCU_OE field.
	IO_MUX_SPICS1_MCU_OE_Pos = 0x0
	// Bit mask of MCU_OE field.
	IO_MUX_SPICS1_MCU_OE_Msk = 0x1
	// Bit MCU_OE.
	IO_MUX_SPICS1_MCU_OE = 0x1
	// Position of SLP_SEL field.
	IO_MUX_SPICS1_SLP_SEL_Pos = 0x1
	// Bit mask of SLP_SEL field.
	IO_MUX_SPICS1_SLP_SEL_Msk = 0x2
	// Bit SLP_SEL.
	IO_MUX_SPICS1_SLP_SEL = 0x2
	// Position of MCU_WPD field.
	IO_MUX_SPICS1_MCU_WPD_Pos = 0x2
	// Bit mask of MCU_WPD field.
	IO_MUX_SPICS1_MCU_WPD_Msk = 0x4
	// Bit MCU_WPD.
	IO_MUX_SPICS1_MCU_WPD = 0x4
	// Position of MCU_WPU field.
	IO_MUX_SPICS1_MCU_WPU_Pos = 0x3
	// Bit mask of MCU_WPU field.
	IO_MUX_SPICS1_MCU_WPU_Msk = 0x8
	// Bit MCU_WPU.
	IO_MUX_SPICS1_MCU_WPU = 0x8
	// Position of MCU_IE field.
	IO_MUX_SPICS1_MCU_IE_Pos = 0x4
	// Bit mask of MCU_IE field.
	IO_MUX_SPICS1_MCU_IE_Msk = 0x10
	// Bit MCU_IE.
	IO_MUX_SPICS1_MCU_IE = 0x10
	// Position of FUN_WPD field.
	IO_MUX_SPICS1_FUN_WPD_Pos = 0x7
	// Bit mask of FUN_WPD field.
	IO_MUX_SPICS1_FUN_WPD_Msk = 0x80
	// Bit FUN_WPD.
	IO_MUX_SPICS1_FUN_WPD = 0x80
	// Position of FUN_WPU field.
	IO_MUX_SPICS1_FUN_WPU_Pos = 0x8
	// Bit mask of FUN_WPU field.
	IO_MUX_SPICS1_FUN_WPU_Msk = 0x100
	// Bit FUN_WPU.
	IO_MUX_SPICS1_FUN_WPU = 0x100
	// Position of FUN_IE field.
	IO_MUX_SPICS1_FUN_IE_Pos = 0x9
	// Bit mask of FUN_IE field.
	IO_MUX_SPICS1_FUN_IE_Msk = 0x200
	// Bit FUN_IE.
	IO_MUX_SPICS1_FUN_IE = 0x200
	// Position of FUN_DRV field.
	IO_MUX_SPICS1_FUN_DRV_Pos = 0xa
	// Bit mask of FUN_DRV field.
	IO_MUX_SPICS1_FUN_DRV_Msk = 0xc00
	// Position of MCU_SEL field.
	IO_MUX_SPICS1_MCU_SEL_Pos = 0xc
	// Bit mask of MCU_SEL field.
	IO_MUX_SPICS1_MCU_SEL_Msk = 0x7000
	// Position of FILTER_EN field.
	IO_MUX_SPICS1_FILTER_EN_Pos = 0xf
	// Bit mask of FILTER_EN field.
	IO_MUX_SPICS1_FILTER_EN_Msk = 0x8000
	// Bit FILTER_EN.
	IO_MUX_SPICS1_FILTER_EN = 0x8000

	// SPIHD: Configuration register for pad SPIHD
	// Position of MCU_OE field.
	IO_MUX_SPIHD_MCU_OE_Pos = 0x0
	// Bit mask of MCU_OE field.
	IO_MUX_SPIHD_MCU_OE_Msk = 0x1
	// Bit MCU_OE.
	IO_MUX_SPIHD_MCU_OE = 0x1
	// Position of SLP_SEL field.
	IO_MUX_SPIHD_SLP_SEL_Pos = 0x1
	// Bit mask of SLP_SEL field.
	IO_MUX_SPIHD_SLP_SEL_Msk = 0x2
	// Bit SLP_SEL.
	IO_MUX_SPIHD_SLP_SEL = 0x2
	// Position of MCU_WPD field.
	IO_MUX_SPIHD_MCU_WPD_Pos = 0x2
	// Bit mask of MCU_WPD field.
	IO_MUX_SPIHD_MCU_WPD_Msk = 0x4
	// Bit MCU_WPD.
	IO_MUX_SPIHD_MCU_WPD = 0x4
	// Position of MCU_WPU field.
	IO_MUX_SPIHD_MCU_WPU_Pos = 0x3
	// Bit mask of MCU_WPU field.
	IO_MUX_SPIHD_MCU_WPU_Msk = 0x8
	// Bit MCU_WPU.
	IO_MUX_SPIHD_MCU_WPU = 0x8
	// Position of MCU_IE field.
	IO_MUX_SPIHD_MCU_IE_Pos = 0x4
	// Bit mask of MCU_IE field.
	IO_MUX_SPIHD_MCU_IE_Msk = 0x10
	// Bit MCU_IE.
	IO_MUX_SPIHD_MCU_IE = 0x10
	// Position of FUN_WPD field.
	IO_MUX_SPIHD_FUN_WPD_Pos = 0x7
	// Bit mask of FUN_WPD field.
	IO_MUX_SPIHD_FUN_WPD_Msk = 0x80
	// Bit FUN_WPD.
	IO_MUX_SPIHD_FUN_WPD = 0x80
	// Position of FUN_WPU field.
	IO_MUX_SPIHD_FUN_WPU_Pos = 0x8
	// Bit mask of FUN_WPU field.
	IO_MUX_SPIHD_FUN_WPU_Msk = 0x100
	// Bit FUN_WPU.
	IO_MUX_SPIHD_FUN_WPU = 0x100
	// Position of FUN_IE field.
	IO_MUX_SPIHD_FUN_IE_Pos = 0x9
	// Bit mask of FUN_IE field.
	IO_MUX_SPIHD_FUN_IE_Msk = 0x200
	// Bit FUN_IE.
	IO_MUX_SPIHD_FUN_IE = 0x200
	// Position of FUN_DRV field.
	IO_MUX_SPIHD_FUN_DRV_Pos = 0xa
	// Bit mask of FUN_DRV field.
	IO_MUX_SPIHD_FUN_DRV_Msk = 0xc00
	// Position of MCU_SEL field.
	IO_MUX_SPIHD_MCU_SEL_Pos = 0xc
	// Bit mask of MCU_SEL field.
	IO_MUX_SPIHD_MCU_SEL_Msk = 0x7000
	// Position of FILTER_EN field.
	IO_MUX_SPIHD_FILTER_EN_Pos = 0xf
	// Bit mask of FILTER_EN field.
	IO_MUX_SPIHD_FILTER_EN_Msk = 0x8000
	// Bit FILTER_EN.
	IO_MUX_SPIHD_FILTER_EN = 0x8000

	// SPIWP: Configuration register for pad SPIWP
	// Position of MCU_OE field.
	IO_MUX_SPIWP_MCU_OE_Pos = 0x0
	// Bit mask of MCU_OE field.
	IO_MUX_SPIWP_MCU_OE_Msk = 0x1
	// Bit MCU_OE.
	IO_MUX_SPIWP_MCU_OE = 0x1
	// Position of SLP_SEL field.
	IO_MUX_SPIWP_SLP_SEL_Pos = 0x1
	// Bit mask of SLP_SEL field.
	IO_MUX_SPIWP_SLP_SEL_Msk = 0x2
	// Bit SLP_SEL.
	IO_MUX_SPIWP_SLP_SEL = 0x2
	// Position of MCU_WPD field.
	IO_MUX_SPIWP_MCU_WPD_Pos = 0x2
	// Bit mask of MCU_WPD field.
	IO_MUX_SPIWP_MCU_WPD_Msk = 0x4
	// Bit MCU_WPD.
	IO_MUX_SPIWP_MCU_WPD = 0x4
	// Position of MCU_WPU field.
	IO_MUX_SPIWP_MCU_WPU_Pos = 0x3
	// Bit mask of MCU_WPU field.
	IO_MUX_SPIWP_MCU_WPU_Msk = 0x8
	// Bit MCU_WPU.
	IO_MUX_SPIWP_MCU_WPU = 0x8
	// Position of MCU_IE field.
	IO_MUX_SPIWP_MCU_IE_Pos = 0x4
	// Bit mask of MCU_IE field.
	IO_MUX_SPIWP_MCU_IE_Msk = 0x10
	// Bit MCU_IE.
	IO_MUX_SPIWP_MCU_IE = 0x10
	// Position of FUN_WPD field.
	IO_MUX_SPIWP_FUN_WPD_Pos = 0x7
	// Bit mask of FUN_WPD field.
	IO_MUX_SPIWP_FUN_WPD_Msk = 0x80
	// Bit FUN_WPD.
	IO_MUX_SPIWP_FUN_WPD = 0x80
	// Position of FUN_WPU field.
	IO_MUX_SPIWP_FUN_WPU_Pos = 0x8
	// Bit mask of FUN_WPU field.
	IO_MUX_SPIWP_FUN_WPU_Msk = 0x100
	// Bit FUN_WPU.
	IO_MUX_SPIWP_FUN_WPU = 0x100
	// Position of FUN_IE field.
	IO_MUX_SPIWP_FUN_IE_Pos = 0x9
	// Bit mask of FUN_IE field.
	IO_MUX_SPIWP_FUN_IE_Msk = 0x200
	// Bit FUN_IE.
	IO_MUX_SPIWP_FUN_IE = 0x200
	// Position of FUN_DRV field.
	IO_MUX_SPIWP_FUN_DRV_Pos = 0xa
	// Bit mask of FUN_DRV field.
	IO_MUX_SPIWP_FUN_DRV_Msk = 0xc00
	// Position of MCU_SEL field.
	IO_MUX_SPIWP_MCU_SEL_Pos = 0xc
	// Bit mask of MCU_SEL field.
	IO_MUX_SPIWP_MCU_SEL_Msk = 0x7000
	// Position of FILTER_EN field.
	IO_MUX_SPIWP_FILTER_EN_Pos = 0xf
	// Bit mask of FILTER_EN field.
	IO_MUX_SPIWP_FILTER_EN_Msk = 0x8000
	// Bit FILTER_EN.
	IO_MUX_SPIWP_FILTER_EN = 0x8000

	// SPICS0: Configuration register for pad SPICS0
	// Position of MCU_OE field.
	IO_MUX_SPICS0_MCU_OE_Pos = 0x0
	// Bit mask of MCU_OE field.
	IO_MUX_SPICS0_MCU_OE_Msk = 0x1
	// Bit MCU_OE.
	IO_MUX_SPICS0_MCU_OE = 0x1
	// Position of SLP_SEL field.
	IO_MUX_SPICS0_SLP_SEL_Pos = 0x1
	// Bit mask of SLP_SEL field.
	IO_MUX_SPICS0_SLP_SEL_Msk = 0x2
	// Bit SLP_SEL.
	IO_MUX_SPICS0_SLP_SEL = 0x2
	// Position of MCU_WPD field.
	IO_MUX_SPICS0_MCU_WPD_Pos = 0x2
	// Bit mask of MCU_WPD field.
	IO_MUX_SPICS0_MCU_WPD_Msk = 0x4
	// Bit MCU_WPD.
	IO_MUX_SPICS0_MCU_WPD = 0x4
	// Position of MCU_WPU field.
	IO_MUX_SPICS0_MCU_WPU_Pos = 0x3
	// Bit mask of MCU_WPU field.
	IO_MUX_SPICS0_MCU_WPU_Msk = 0x8
	// Bit MCU_WPU.
	IO_MUX_SPICS0_MCU_WPU = 0x8
	// Position of MCU_IE field.
	IO_MUX_SPICS0_MCU_IE_Pos = 0x4
	// Bit mask of MCU_IE field.
	IO_MUX_SPICS0_MCU_IE_Msk = 0x10
	// Bit MCU_IE.
	IO_MUX_SPICS0_MCU_IE = 0x10
	// Position of FUN_WPD field.
	IO_MUX_SPICS0_FUN_WPD_Pos = 0x7
	// Bit mask of FUN_WPD field.
	IO_MUX_SPICS0_FUN_WPD_Msk = 0x80
	// Bit FUN_WPD.
	IO_MUX_SPICS0_FUN_WPD = 0x80
	// Position of FUN_WPU field.
	IO_MUX_SPICS0_FUN_WPU_Pos = 0x8
	// Bit mask of FUN_WPU field.
	IO_MUX_SPICS0_FUN_WPU_Msk = 0x100
	// Bit FUN_WPU.
	IO_MUX_SPICS0_FUN_WPU = 0x100
	// Position of FUN_IE field.
	IO_MUX_SPICS0_FUN_IE_Pos = 0x9
	// Bit mask of FUN_IE field.
	IO_MUX_SPICS0_FUN_IE_Msk = 0x200
	// Bit FUN_IE.
	IO_MUX_SPICS0_FUN_IE = 0x200
	// Position of FUN_DRV field.
	IO_MUX_SPICS0_FUN_DRV_Pos = 0xa
	// Bit mask of FUN_DRV field.
	IO_MUX_SPICS0_FUN_DRV_Msk = 0xc00
	// Position of MCU_SEL field.
	IO_MUX_SPICS0_MCU_SEL_Pos = 0xc
	// Bit mask of MCU_SEL field.
	IO_MUX_SPICS0_MCU_SEL_Msk = 0x7000
	// Position of FILTER_EN field.
	IO_MUX_SPICS0_FILTER_EN_Pos = 0xf
	// Bit mask of FILTER_EN field.
	IO_MUX_SPICS0_FILTER_EN_Msk = 0x8000
	// Bit FILTER_EN.
	IO_MUX_SPICS0_FILTER_EN = 0x8000

	// SPICLK: Configuration register for pad SPICLK
	// Position of MCU_OE field.
	IO_MUX_SPICLK_MCU_OE_Pos = 0x0
	// Bit mask of MCU_OE field.
	IO_MUX_SPICLK_MCU_OE_Msk = 0x1
	// Bit MCU_OE.
	IO_MUX_SPICLK_MCU_OE = 0x1
	// Position of SLP_SEL field.
	IO_MUX_SPICLK_SLP_SEL_Pos = 0x1
	// Bit mask of SLP_SEL field.
	IO_MUX_SPICLK_SLP_SEL_Msk = 0x2
	// Bit SLP_SEL.
	IO_MUX_SPICLK_SLP_SEL = 0x2
	// Position of MCU_WPD field.
	IO_MUX_SPICLK_MCU_WPD_Pos = 0x2
	// Bit mask of MCU_WPD field.
	IO_MUX_SPICLK_MCU_WPD_Msk = 0x4
	// Bit MCU_WPD.
	IO_MUX_SPICLK_MCU_WPD = 0x4
	// Position of MCU_WPU field.
	IO_MUX_SPICLK_MCU_WPU_Pos = 0x3
	// Bit mask of MCU_WPU field.
	IO_MUX_SPICLK_MCU_WPU_Msk = 0x8
	// Bit MCU_WPU.
	IO_MUX_SPICLK_MCU_WPU = 0x8
	// Position of MCU_IE field.
	IO_MUX_SPICLK_MCU_IE_Pos = 0x4
	// Bit mask of MCU_IE field.
	IO_MUX_SPICLK_MCU_IE_Msk = 0x10
	// Bit MCU_IE.
	IO_MUX_SPICLK_MCU_IE = 0x10
	// Position of FUN_WPD field.
	IO_MUX_SPICLK_FUN_WPD_Pos = 0x7
	// Bit mask of FUN_WPD field.
	IO_MUX_SPICLK_FUN_WPD_Msk = 0x80
	// Bit FUN_WPD.
	IO_MUX_SPICLK_FUN_WPD = 0x80
	// Position of FUN_WPU field.
	IO_MUX_SPICLK_FUN_WPU_Pos = 0x8
	// Bit mask of FUN_WPU field.
	IO_MUX_SPICLK_FUN_WPU_Msk = 0x100
	// Bit FUN_WPU.
	IO_MUX_SPICLK_FUN_WPU = 0x100
	// Position of FUN_IE field.
	IO_MUX_SPICLK_FUN_IE_Pos = 0x9
	// Bit mask of FUN_IE field.
	IO_MUX_SPICLK_FUN_IE_Msk = 0x200
	// Bit FUN_IE.
	IO_MUX_SPICLK_FUN_IE = 0x200
	// Position of FUN_DRV field.
	IO_MUX_SPICLK_FUN_DRV_Pos = 0xa
	// Bit mask of FUN_DRV field.
	IO_MUX_SPICLK_FUN_DRV_Msk = 0xc00
	// Position of MCU_SEL field.
	IO_MUX_SPICLK_MCU_SEL_Pos = 0xc
	// Bit mask of MCU_SEL field.
	IO_MUX_SPICLK_MCU_SEL_Msk = 0x7000
	// Position of FILTER_EN field.
	IO_MUX_SPICLK_FILTER_EN_Pos = 0xf
	// Bit mask of FILTER_EN field.
	IO_MUX_SPICLK_FILTER_EN_Msk = 0x8000
	// Bit FILTER_EN.
	IO_MUX_SPICLK_FILTER_EN = 0x8000

	// SPIQ: Configuration register for pad SPIQ
	// Position of MCU_OE field.
	IO_MUX_SPIQ_MCU_OE_Pos = 0x0
	// Bit mask of MCU_OE field.
	IO_MUX_SPIQ_MCU_OE_Msk = 0x1
	// Bit MCU_OE.
	IO_MUX_SPIQ_MCU_OE = 0x1
	// Position of SLP_SEL field.
	IO_MUX_SPIQ_SLP_SEL_Pos = 0x1
	// Bit mask of SLP_SEL field.
	IO_MUX_SPIQ_SLP_SEL_Msk = 0x2
	// Bit SLP_SEL.
	IO_MUX_SPIQ_SLP_SEL = 0x2
	// Position of MCU_WPD field.
	IO_MUX_SPIQ_MCU_WPD_Pos = 0x2
	// Bit mask of MCU_WPD field.
	IO_MUX_SPIQ_MCU_WPD_Msk = 0x4
	// Bit MCU_WPD.
	IO_MUX_SPIQ_MCU_WPD = 0x4
	// Position of MCU_WPU field.
	IO_MUX_SPIQ_MCU_WPU_Pos = 0x3
	// Bit mask of MCU_WPU field.
	IO_MUX_SPIQ_MCU_WPU_Msk = 0x8
	// Bit MCU_WPU.
	IO_MUX_SPIQ_MCU_WPU = 0x8
	// Position of MCU_IE field.
	IO_MUX_SPIQ_MCU_IE_Pos = 0x4
	// Bit mask of MCU_IE field.
	IO_MUX_SPIQ_MCU_IE_Msk = 0x10
	// Bit MCU_IE.
	IO_MUX_SPIQ_MCU_IE = 0x10
	// Position of FUN_WPD field.
	IO_MUX_SPIQ_FUN_WPD_Pos = 0x7
	// Bit mask of FUN_WPD field.
	IO_MUX_SPIQ_FUN_WPD_Msk = 0x80
	// Bit FUN_WPD.
	IO_MUX_SPIQ_FUN_WPD = 0x80
	// Position of FUN_WPU field.
	IO_MUX_SPIQ_FUN_WPU_Pos = 0x8
	// Bit mask of FUN_WPU field.
	IO_MUX_SPIQ_FUN_WPU_Msk = 0x100
	// Bit FUN_WPU.
	IO_MUX_SPIQ_FUN_WPU = 0x100
	// Position of FUN_IE field.
	IO_MUX_SPIQ_FUN_IE_Pos = 0x9
	// Bit mask of FUN_IE field.
	IO_MUX_SPIQ_FUN_IE_Msk = 0x200
	// Bit FUN_IE.
	IO_MUX_SPIQ_FUN_IE = 0x200
	// Position of FUN_DRV field.
	IO_MUX_SPIQ_FUN_DRV_Pos = 0xa
	// Bit mask of FUN_DRV field.
	IO_MUX_SPIQ_FUN_DRV_Msk = 0xc00
	// Position of MCU_SEL field.
	IO_MUX_SPIQ_MCU_SEL_Pos = 0xc
	// Bit mask of MCU_SEL field.
	IO_MUX_SPIQ_MCU_SEL_Msk = 0x7000
	// Position of FILTER_EN field.
	IO_MUX_SPIQ_FILTER_EN_Pos = 0xf
	// Bit mask of FILTER_EN field.
	IO_MUX_SPIQ_FILTER_EN_Msk = 0x8000
	// Bit FILTER_EN.
	IO_MUX_SPIQ_FILTER_EN = 0x8000

	// SPID: Configuration register for pad SPID
	// Position of MCU_OE field.
	IO_MUX_SPID_MCU_OE_Pos = 0x0
	// Bit mask of MCU_OE field.
	IO_MUX_SPID_MCU_OE_Msk = 0x1
	// Bit MCU_OE.
	IO_MUX_SPID_MCU_OE = 0x1
	// Position of SLP_SEL field.
	IO_MUX_SPID_SLP_SEL_Pos = 0x1
	// Bit mask of SLP_SEL field.
	IO_MUX_SPID_SLP_SEL_Msk = 0x2
	// Bit SLP_SEL.
	IO_MUX_SPID_SLP_SEL = 0x2
	// Position of MCU_WPD field.
	IO_MUX_SPID_MCU_WPD_Pos = 0x2
	// Bit mask of MCU_WPD field.
	IO_MUX_SPID_MCU_WPD_Msk = 0x4
	// Bit MCU_WPD.
	IO_MUX_SPID_MCU_WPD = 0x4
	// Position of MCU_WPU field.
	IO_MUX_SPID_MCU_WPU_Pos = 0x3
	// Bit mask of MCU_WPU field.
	IO_MUX_SPID_MCU_WPU_Msk = 0x8
	// Bit MCU_WPU.
	IO_MUX_SPID_MCU_WPU = 0x8
	// Position of MCU_IE field.
	IO_MUX_SPID_MCU_IE_Pos = 0x4
	// Bit mask of MCU_IE field.
	IO_MUX_SPID_MCU_IE_Msk = 0x10
	// Bit MCU_IE.
	IO_MUX_SPID_MCU_IE = 0x10
	// Position of FUN_WPD field.
	IO_MUX_SPID_FUN_WPD_Pos = 0x7
	// Bit mask of FUN_WPD field.
	IO_MUX_SPID_FUN_WPD_Msk = 0x80
	// Bit FUN_WPD.
	IO_MUX_SPID_FUN_WPD = 0x80
	// Position of FUN_WPU field.
	IO_MUX_SPID_FUN_WPU_Pos = 0x8
	// Bit mask of FUN_WPU field.
	IO_MUX_SPID_FUN_WPU_Msk = 0x100
	// Bit FUN_WPU.
	IO_MUX_SPID_FUN_WPU = 0x100
	// Position of FUN_IE field.
	IO_MUX_SPID_FUN_IE_Pos = 0x9
	// Bit mask of FUN_IE field.
	IO_MUX_SPID_FUN_IE_Msk = 0x200
	// Bit FUN_IE.
	IO_MUX_SPID_FUN_IE = 0x200
	// Position of FUN_DRV field.
	IO_MUX_SPID_FUN_DRV_Pos = 0xa
	// Bit mask of FUN_DRV field.
	IO_MUX_SPID_FUN_DRV_Msk = 0xc00
	// Position of MCU_SEL field.
	IO_MUX_SPID_MCU_SEL_Pos = 0xc
	// Bit mask of MCU_SEL field.
	IO_MUX_SPID_MCU_SEL_Msk = 0x7000
	// Position of FILTER_EN field.
	IO_MUX_SPID_FILTER_EN_Pos = 0xf
	// Bit mask of FILTER_EN field.
	IO_MUX_SPID_FILTER_EN_Msk = 0x8000
	// Bit FILTER_EN.
	IO_MUX_SPID_FILTER_EN = 0x8000

	// GPIO_33: Configuration register for pad GPIO33
	// Position of MCU_OE field.
	IO_MUX_GPIO_33_MCU_OE_Pos = 0x0
	// Bit mask of MCU_OE field.
	IO_MUX_GPIO_33_MCU_OE_Msk = 0x1
	// Bit MCU_OE.
	IO_MUX_GPIO_33_MCU_OE = 0x1
	// Position of SLP_SEL field.
	IO_MUX_GPIO_33_SLP_SEL_Pos = 0x1
	// Bit mask of SLP_SEL field.
	IO_MUX_GPIO_33_SLP_SEL_Msk = 0x2
	// Bit SLP_SEL.
	IO_MUX_GPIO_33_SLP_SEL = 0x2
	// Position of MCU_WPD field.
	IO_MUX_GPIO_33_MCU_WPD_Pos = 0x2
	// Bit mask of MCU_WPD field.
	IO_MUX_GPIO_33_MCU_WPD_Msk = 0x4
	// Bit MCU_WPD.
	IO_MUX_GPIO_33_MCU_WPD = 0x4
	// Position of MCU_WPU field.
	IO_MUX_GPIO_33_MCU_WPU_Pos = 0x3
	// Bit mask of MCU_WPU field.
	IO_MUX_GPIO_33_MCU_WPU_Msk = 0x8
	// Bit MCU_WPU.
	IO_MUX_GPIO_33_MCU_WPU = 0x8
	// Position of MCU_IE field.
	IO_MUX_GPIO_33_MCU_IE_Pos = 0x4
	// Bit mask of MCU_IE field.
	IO_MUX_GPIO_33_MCU_IE_Msk = 0x10
	// Bit MCU_IE.
	IO_MUX_GPIO_33_MCU_IE = 0x10
	// Position of FUN_WPD field.
	IO_MUX_GPIO_33_FUN_WPD_Pos = 0x7
	// Bit mask of FUN_WPD field.
	IO_MUX_GPIO_33_FUN_WPD_Msk = 0x80
	// Bit FUN_WPD.
	IO_MUX_GPIO_33_FUN_WPD = 0x80
	// Position of FUN_WPU field.
	IO_MUX_GPIO_33_FUN_WPU_Pos = 0x8
	// Bit mask of FUN_WPU field.
	IO_MUX_GPIO_33_FUN_WPU_Msk = 0x100
	// Bit FUN_WPU.
	IO_MUX_GPIO_33_FUN_WPU = 0x100
	// Position of FUN_IE field.
	IO_MUX_GPIO_33_FUN_IE_Pos = 0x9
	// Bit mask of FUN_IE field.
	IO_MUX_GPIO_33_FUN_IE_Msk = 0x200
	// Bit FUN_IE.
	IO_MUX_GPIO_33_FUN_IE = 0x200
	// Position of FUN_DRV field.
	IO_MUX_GPIO_33_FUN_DRV_Pos = 0xa
	// Bit mask of FUN_DRV field.
	IO_MUX_GPIO_33_FUN_DRV_Msk = 0xc00
	// Position of MCU_SEL field.
	IO_MUX_GPIO_33_MCU_SEL_Pos = 0xc
	// Bit mask of MCU_SEL field.
	IO_MUX_GPIO_33_MCU_SEL_Msk = 0x7000
	// Position of FILTER_EN field.
	IO_MUX_GPIO_33_FILTER_EN_Pos = 0xf
	// Bit mask of FILTER_EN field.
	IO_MUX_GPIO_33_FILTER_EN_Msk = 0x8000
	// Bit FILTER_EN.
	IO_MUX_GPIO_33_FILTER_EN = 0x8000

	// GPIO_34: Configuration register for pad GPIO34
	// Position of MCU_OE field.
	IO_MUX_GPIO_34_MCU_OE_Pos = 0x0
	// Bit mask of MCU_OE field.
	IO_MUX_GPIO_34_MCU_OE_Msk = 0x1
	// Bit MCU_OE.
	IO_MUX_GPIO_34_MCU_OE = 0x1
	// Position of SLP_SEL field.
	IO_MUX_GPIO_34_SLP_SEL_Pos = 0x1
	// Bit mask of SLP_SEL field.
	IO_MUX_GPIO_34_SLP_SEL_Msk = 0x2
	// Bit SLP_SEL.
	IO_MUX_GPIO_34_SLP_SEL = 0x2
	// Position of MCU_WPD field.
	IO_MUX_GPIO_34_MCU_WPD_Pos = 0x2
	// Bit mask of MCU_WPD field.
	IO_MUX_GPIO_34_MCU_WPD_Msk = 0x4
	// Bit MCU_WPD.
	IO_MUX_GPIO_34_MCU_WPD = 0x4
	// Position of MCU_WPU field.
	IO_MUX_GPIO_34_MCU_WPU_Pos = 0x3
	// Bit mask of MCU_WPU field.
	IO_MUX_GPIO_34_MCU_WPU_Msk = 0x8
	// Bit MCU_WPU.
	IO_MUX_GPIO_34_MCU_WPU = 0x8
	// Position of MCU_IE field.
	IO_MUX_GPIO_34_MCU_IE_Pos = 0x4
	// Bit mask of MCU_IE field.
	IO_MUX_GPIO_34_MCU_IE_Msk = 0x10
	// Bit MCU_IE.
	IO_MUX_GPIO_34_MCU_IE = 0x10
	// Position of FUN_WPD field.
	IO_MUX_GPIO_34_FUN_WPD_Pos = 0x7
	// Bit mask of FUN_WPD field.
	IO_MUX_GPIO_34_FUN_WPD_Msk = 0x80
	// Bit FUN_WPD.
	IO_MUX_GPIO_34_FUN_WPD = 0x80
	// Position of FUN_WPU field.
	IO_MUX_GPIO_34_FUN_WPU_Pos = 0x8
	// Bit mask of FUN_WPU field.
	IO_MUX_GPIO_34_FUN_WPU_Msk = 0x100
	// Bit FUN_WPU.
	IO_MUX_GPIO_34_FUN_WPU = 0x100
	// Position of FUN_IE field.
	IO_MUX_GPIO_34_FUN_IE_Pos = 0x9
	// Bit mask of FUN_IE field.
	IO_MUX_GPIO_34_FUN_IE_Msk = 0x200
	// Bit FUN_IE.
	IO_MUX_GPIO_34_FUN_IE = 0x200
	// Position of FUN_DRV field.
	IO_MUX_GPIO_34_FUN_DRV_Pos = 0xa
	// Bit mask of FUN_DRV field.
	IO_MUX_GPIO_34_FUN_DRV_Msk = 0xc00
	// Position of MCU_SEL field.
	IO_MUX_GPIO_34_MCU_SEL_Pos = 0xc
	// Bit mask of MCU_SEL field.
	IO_MUX_GPIO_34_MCU_SEL_Msk = 0x7000
	// Position of FILTER_EN field.
	IO_MUX_GPIO_34_FILTER_EN_Pos = 0xf
	// Bit mask of FILTER_EN field.
	IO_MUX_GPIO_34_FILTER_EN_Msk = 0x8000
	// Bit FILTER_EN.
	IO_MUX_GPIO_34_FILTER_EN = 0x8000

	// GPIO_35: Configuration register for pad GPIO35
	// Position of MCU_OE field.
	IO_MUX_GPIO_35_MCU_OE_Pos = 0x0
	// Bit mask of MCU_OE field.
	IO_MUX_GPIO_35_MCU_OE_Msk = 0x1
	// Bit MCU_OE.
	IO_MUX_GPIO_35_MCU_OE = 0x1
	// Position of SLP_SEL field.
	IO_MUX_GPIO_35_SLP_SEL_Pos = 0x1
	// Bit mask of SLP_SEL field.
	IO_MUX_GPIO_35_SLP_SEL_Msk = 0x2
	// Bit SLP_SEL.
	IO_MUX_GPIO_35_SLP_SEL = 0x2
	// Position of MCU_WPD field.
	IO_MUX_GPIO_35_MCU_WPD_Pos = 0x2
	// Bit mask of MCU_WPD field.
	IO_MUX_GPIO_35_MCU_WPD_Msk = 0x4
	// Bit MCU_WPD.
	IO_MUX_GPIO_35_MCU_WPD = 0x4
	// Position of MCU_WPU field.
	IO_MUX_GPIO_35_MCU_WPU_Pos = 0x3
	// Bit mask of MCU_WPU field.
	IO_MUX_GPIO_35_MCU_WPU_Msk = 0x8
	// Bit MCU_WPU.
	IO_MUX_GPIO_35_MCU_WPU = 0x8
	// Position of MCU_IE field.
	IO_MUX_GPIO_35_MCU_IE_Pos = 0x4
	// Bit mask of MCU_IE field.
	IO_MUX_GPIO_35_MCU_IE_Msk = 0x10
	// Bit MCU_IE.
	IO_MUX_GPIO_35_MCU_IE = 0x10
	// Position of FUN_WPD field.
	IO_MUX_GPIO_35_FUN_WPD_Pos = 0x7
	// Bit mask of FUN_WPD field.
	IO_MUX_GPIO_35_FUN_WPD_Msk = 0x80
	// Bit FUN_WPD.
	IO_MUX_GPIO_35_FUN_WPD = 0x80
	// Position of FUN_WPU field.
	IO_MUX_GPIO_35_FUN_WPU_Pos = 0x8
	// Bit mask of FUN_WPU field.
	IO_MUX_GPIO_35_FUN_WPU_Msk = 0x100
	// Bit FUN_WPU.
	IO_MUX_GPIO_35_FUN_WPU = 0x100
	// Position of FUN_IE field.
	IO_MUX_GPIO_35_FUN_IE_Pos = 0x9
	// Bit mask of FUN_IE field.
	IO_MUX_GPIO_35_FUN_IE_Msk = 0x200
	// Bit FUN_IE.
	IO_MUX_GPIO_35_FUN_IE = 0x200
	// Position of FUN_DRV field.
	IO_MUX_GPIO_35_FUN_DRV_Pos = 0xa
	// Bit mask of FUN_DRV field.
	IO_MUX_GPIO_35_FUN_DRV_Msk = 0xc00
	// Position of MCU_SEL field.
	IO_MUX_GPIO_35_MCU_SEL_Pos = 0xc
	// Bit mask of MCU_SEL field.
	IO_MUX_GPIO_35_MCU_SEL_Msk = 0x7000
	// Position of FILTER_EN field.
	IO_MUX_GPIO_35_FILTER_EN_Pos = 0xf
	// Bit mask of FILTER_EN field.
	IO_MUX_GPIO_35_FILTER_EN_Msk = 0x8000
	// Bit FILTER_EN.
	IO_MUX_GPIO_35_FILTER_EN = 0x8000

	// GPIO_36: Configuration register for pad GPIO36
	// Position of MCU_OE field.
	IO_MUX_GPIO_36_MCU_OE_Pos = 0x0
	// Bit mask of MCU_OE field.
	IO_MUX_GPIO_36_MCU_OE_Msk = 0x1
	// Bit MCU_OE.
	IO_MUX_GPIO_36_MCU_OE = 0x1
	// Position of SLP_SEL field.
	IO_MUX_GPIO_36_SLP_SEL_Pos = 0x1
	// Bit mask of SLP_SEL field.
	IO_MUX_GPIO_36_SLP_SEL_Msk = 0x2
	// Bit SLP_SEL.
	IO_MUX_GPIO_36_SLP_SEL = 0x2
	// Position of MCU_WPD field.
	IO_MUX_GPIO_36_MCU_WPD_Pos = 0x2
	// Bit mask of MCU_WPD field.
	IO_MUX_GPIO_36_MCU_WPD_Msk = 0x4
	// Bit MCU_WPD.
	IO_MUX_GPIO_36_MCU_WPD = 0x4
	// Position of MCU_WPU field.
	IO_MUX_GPIO_36_MCU_WPU_Pos = 0x3
	// Bit mask of MCU_WPU field.
	IO_MUX_GPIO_36_MCU_WPU_Msk = 0x8
	// Bit MCU_WPU.
	IO_MUX_GPIO_36_MCU_WPU = 0x8
	// Position of MCU_IE field.
	IO_MUX_GPIO_36_MCU_IE_Pos = 0x4
	// Bit mask of MCU_IE field.
	IO_MUX_GPIO_36_MCU_IE_Msk = 0x10
	// Bit MCU_IE.
	IO_MUX_GPIO_36_MCU_IE = 0x10
	// Position of FUN_WPD field.
	IO_MUX_GPIO_36_FUN_WPD_Pos = 0x7
	// Bit mask of FUN_WPD field.
	IO_MUX_GPIO_36_FUN_WPD_Msk = 0x80
	// Bit FUN_WPD.
	IO_MUX_GPIO_36_FUN_WPD = 0x80
	// Position of FUN_WPU field.
	IO_MUX_GPIO_36_FUN_WPU_Pos = 0x8
	// Bit mask of FUN_WPU field.
	IO_MUX_GPIO_36_FUN_WPU_Msk = 0x100
	// Bit FUN_WPU.
	IO_MUX_GPIO_36_FUN_WPU = 0x100
	// Position of FUN_IE field.
	IO_MUX_GPIO_36_FUN_IE_Pos = 0x9
	// Bit mask of FUN_IE field.
	IO_MUX_GPIO_36_FUN_IE_Msk = 0x200
	// Bit FUN_IE.
	IO_MUX_GPIO_36_FUN_IE = 0x200
	// Position of FUN_DRV field.
	IO_MUX_GPIO_36_FUN_DRV_Pos = 0xa
	// Bit mask of FUN_DRV field.
	IO_MUX_GPIO_36_FUN_DRV_Msk = 0xc00
	// Position of MCU_SEL field.
	IO_MUX_GPIO_36_MCU_SEL_Pos = 0xc
	// Bit mask of MCU_SEL field.
	IO_MUX_GPIO_36_MCU_SEL_Msk = 0x7000
	// Position of FILTER_EN field.
	IO_MUX_GPIO_36_FILTER_EN_Pos = 0xf
	// Bit mask of FILTER_EN field.
	IO_MUX_GPIO_36_FILTER_EN_Msk = 0x8000
	// Bit FILTER_EN.
	IO_MUX_GPIO_36_FILTER_EN = 0x8000

	// GPIO_37: Configuration register for pad GPIO37
	// Position of MCU_OE field.
	IO_MUX_GPIO_37_MCU_OE_Pos = 0x0
	// Bit mask of MCU_OE field.
	IO_MUX_GPIO_37_MCU_OE_Msk = 0x1
	// Bit MCU_OE.
	IO_MUX_GPIO_37_MCU_OE = 0x1
	// Position of SLP_SEL field.
	IO_MUX_GPIO_37_SLP_SEL_Pos = 0x1
	// Bit mask of SLP_SEL field.
	IO_MUX_GPIO_37_SLP_SEL_Msk = 0x2
	// Bit SLP_SEL.
	IO_MUX_GPIO_37_SLP_SEL = 0x2
	// Position of MCU_WPD field.
	IO_MUX_GPIO_37_MCU_WPD_Pos = 0x2
	// Bit mask of MCU_WPD field.
	IO_MUX_GPIO_37_MCU_WPD_Msk = 0x4
	// Bit MCU_WPD.
	IO_MUX_GPIO_37_MCU_WPD = 0x4
	// Position of MCU_WPU field.
	IO_MUX_GPIO_37_MCU_WPU_Pos = 0x3
	// Bit mask of MCU_WPU field.
	IO_MUX_GPIO_37_MCU_WPU_Msk = 0x8
	// Bit MCU_WPU.
	IO_MUX_GPIO_37_MCU_WPU = 0x8
	// Position of MCU_IE field.
	IO_MUX_GPIO_37_MCU_IE_Pos = 0x4
	// Bit mask of MCU_IE field.
	IO_MUX_GPIO_37_MCU_IE_Msk = 0x10
	// Bit MCU_IE.
	IO_MUX_GPIO_37_MCU_IE = 0x10
	// Position of FUN_WPD field.
	IO_MUX_GPIO_37_FUN_WPD_Pos = 0x7
	// Bit mask of FUN_WPD field.
	IO_MUX_GPIO_37_FUN_WPD_Msk = 0x80
	// Bit FUN_WPD.
	IO_MUX_GPIO_37_FUN_WPD = 0x80
	// Position of FUN_WPU field.
	IO_MUX_GPIO_37_FUN_WPU_Pos = 0x8
	// Bit mask of FUN_WPU field.
	IO_MUX_GPIO_37_FUN_WPU_Msk = 0x100
	// Bit FUN_WPU.
	IO_MUX_GPIO_37_FUN_WPU = 0x100
	// Position of FUN_IE field.
	IO_MUX_GPIO_37_FUN_IE_Pos = 0x9
	// Bit mask of FUN_IE field.
	IO_MUX_GPIO_37_FUN_IE_Msk = 0x200
	// Bit FUN_IE.
	IO_MUX_GPIO_37_FUN_IE = 0x200
	// Position of FUN_DRV field.
	IO_MUX_GPIO_37_FUN_DRV_Pos = 0xa
	// Bit mask of FUN_DRV field.
	IO_MUX_GPIO_37_FUN_DRV_Msk = 0xc00
	// Position of MCU_SEL field.
	IO_MUX_GPIO_37_MCU_SEL_Pos = 0xc
	// Bit mask of MCU_SEL field.
	IO_MUX_GPIO_37_MCU_SEL_Msk = 0x7000
	// Position of FILTER_EN field.
	IO_MUX_GPIO_37_FILTER_EN_Pos = 0xf
	// Bit mask of FILTER_EN field.
	IO_MUX_GPIO_37_FILTER_EN_Msk = 0x8000
	// Bit FILTER_EN.
	IO_MUX_GPIO_37_FILTER_EN = 0x8000

	// GPIO_38: Configuration register for pad GPIO38
	// Position of MCU_OE field.
	IO_MUX_GPIO_38_MCU_OE_Pos = 0x0
	// Bit mask of MCU_OE field.
	IO_MUX_GPIO_38_MCU_OE_Msk = 0x1
	// Bit MCU_OE.
	IO_MUX_GPIO_38_MCU_OE = 0x1
	// Position of SLP_SEL field.
	IO_MUX_GPIO_38_SLP_SEL_Pos = 0x1
	// Bit mask of SLP_SEL field.
	IO_MUX_GPIO_38_SLP_SEL_Msk = 0x2
	// Bit SLP_SEL.
	IO_MUX_GPIO_38_SLP_SEL = 0x2
	// Position of MCU_WPD field.
	IO_MUX_GPIO_38_MCU_WPD_Pos = 0x2
	// Bit mask of MCU_WPD field.
	IO_MUX_GPIO_38_MCU_WPD_Msk = 0x4
	// Bit MCU_WPD.
	IO_MUX_GPIO_38_MCU_WPD = 0x4
	// Position of MCU_WPU field.
	IO_MUX_GPIO_38_MCU_WPU_Pos = 0x3
	// Bit mask of MCU_WPU field.
	IO_MUX_GPIO_38_MCU_WPU_Msk = 0x8
	// Bit MCU_WPU.
	IO_MUX_GPIO_38_MCU_WPU = 0x8
	// Position of MCU_IE field.
	IO_MUX_GPIO_38_MCU_IE_Pos = 0x4
	// Bit mask of MCU_IE field.
	IO_MUX_GPIO_38_MCU_IE_Msk = 0x10
	// Bit MCU_IE.
	IO_MUX_GPIO_38_MCU_IE = 0x10
	// Position of FUN_WPD field.
	IO_MUX_GPIO_38_FUN_WPD_Pos = 0x7
	// Bit mask of FUN_WPD field.
	IO_MUX_GPIO_38_FUN_WPD_Msk = 0x80
	// Bit FUN_WPD.
	IO_MUX_GPIO_38_FUN_WPD = 0x80
	// Position of FUN_WPU field.
	IO_MUX_GPIO_38_FUN_WPU_Pos = 0x8
	// Bit mask of FUN_WPU field.
	IO_MUX_GPIO_38_FUN_WPU_Msk = 0x100
	// Bit FUN_WPU.
	IO_MUX_GPIO_38_FUN_WPU = 0x100
	// Position of FUN_IE field.
	IO_MUX_GPIO_38_FUN_IE_Pos = 0x9
	// Bit mask of FUN_IE field.
	IO_MUX_GPIO_38_FUN_IE_Msk = 0x200
	// Bit FUN_IE.
	IO_MUX_GPIO_38_FUN_IE = 0x200
	// Position of FUN_DRV field.
	IO_MUX_GPIO_38_FUN_DRV_Pos = 0xa
	// Bit mask of FUN_DRV field.
	IO_MUX_GPIO_38_FUN_DRV_Msk = 0xc00
	// Position of MCU_SEL field.
	IO_MUX_GPIO_38_MCU_SEL_Pos = 0xc
	// Bit mask of MCU_SEL field.
	IO_MUX_GPIO_38_MCU_SEL_Msk = 0x7000
	// Position of FILTER_EN field.
	IO_MUX_GPIO_38_FILTER_EN_Pos = 0xf
	// Bit mask of FILTER_EN field.
	IO_MUX_GPIO_38_FILTER_EN_Msk = 0x8000
	// Bit FILTER_EN.
	IO_MUX_GPIO_38_FILTER_EN = 0x8000

	// MTCK: Configuration register for pad MTCK
	// Position of MCU_OE field.
	IO_MUX_MTCK_MCU_OE_Pos = 0x0
	// Bit mask of MCU_OE field.
	IO_MUX_MTCK_MCU_OE_Msk = 0x1
	// Bit MCU_OE.
	IO_MUX_MTCK_MCU_OE = 0x1
	// Position of SLP_SEL field.
	IO_MUX_MTCK_SLP_SEL_Pos = 0x1
	// Bit mask of SLP_SEL field.
	IO_MUX_MTCK_SLP_SEL_Msk = 0x2
	// Bit SLP_SEL.
	IO_MUX_MTCK_SLP_SEL = 0x2
	// Position of MCU_WPD field.
	IO_MUX_MTCK_MCU_WPD_Pos = 0x2
	// Bit mask of MCU_WPD field.
	IO_MUX_MTCK_MCU_WPD_Msk = 0x4
	// Bit MCU_WPD.
	IO_MUX_MTCK_MCU_WPD = 0x4
	// Position of MCU_WPU field.
	IO_MUX_MTCK_MCU_WPU_Pos = 0x3
	// Bit mask of MCU_WPU field.
	IO_MUX_MTCK_MCU_WPU_Msk = 0x8
	// Bit MCU_WPU.
	IO_MUX_MTCK_MCU_WPU = 0x8
	// Position of MCU_IE field.
	IO_MUX_MTCK_MCU_IE_Pos = 0x4
	// Bit mask of MCU_IE field.
	IO_MUX_MTCK_MCU_IE_Msk = 0x10
	// Bit MCU_IE.
	IO_MUX_MTCK_MCU_IE = 0x10
	// Position of FUN_WPD field.
	IO_MUX_MTCK_FUN_WPD_Pos = 0x7
	// Bit mask of FUN_WPD field.
	IO_MUX_MTCK_FUN_WPD_Msk = 0x80
	// Bit FUN_WPD.
	IO_MUX_MTCK_FUN_WPD = 0x80
	// Position of FUN_WPU field.
	IO_MUX_MTCK_FUN_WPU_Pos = 0x8
	// Bit mask of FUN_WPU field.
	IO_MUX_MTCK_FUN_WPU_Msk = 0x100
	// Bit FUN_WPU.
	IO_MUX_MTCK_FUN_WPU = 0x100
	// Position of FUN_IE field.
	IO_MUX_MTCK_FUN_IE_Pos = 0x9
	// Bit mask of FUN_IE field.
	IO_MUX_MTCK_FUN_IE_Msk = 0x200
	// Bit FUN_IE.
	IO_MUX_MTCK_FUN_IE = 0x200
	// Position of FUN_DRV field.
	IO_MUX_MTCK_FUN_DRV_Pos = 0xa
	// Bit mask of FUN_DRV field.
	IO_MUX_MTCK_FUN_DRV_Msk = 0xc00
	// Position of MCU_SEL field.
	IO_MUX_MTCK_MCU_SEL_Pos = 0xc
	// Bit mask of MCU_SEL field.
	IO_MUX_MTCK_MCU_SEL_Msk = 0x7000
	// Position of FILTER_EN field.
	IO_MUX_MTCK_FILTER_EN_Pos = 0xf
	// Bit mask of FILTER_EN field.
	IO_MUX_MTCK_FILTER_EN_Msk = 0x8000
	// Bit FILTER_EN.
	IO_MUX_MTCK_FILTER_EN = 0x8000

	// MTDO: Configuration register for pad MTDO
	// Position of MCU_OE field.
	IO_MUX_MTDO_MCU_OE_Pos = 0x0
	// Bit mask of MCU_OE field.
	IO_MUX_MTDO_MCU_OE_Msk = 0x1
	// Bit MCU_OE.
	IO_MUX_MTDO_MCU_OE = 0x1
	// Position of SLP_SEL field.
	IO_MUX_MTDO_SLP_SEL_Pos = 0x1
	// Bit mask of SLP_SEL field.
	IO_MUX_MTDO_SLP_SEL_Msk = 0x2
	// Bit SLP_SEL.
	IO_MUX_MTDO_SLP_SEL = 0x2
	// Position of MCU_WPD field.
	IO_MUX_MTDO_MCU_WPD_Pos = 0x2
	// Bit mask of MCU_WPD field.
	IO_MUX_MTDO_MCU_WPD_Msk = 0x4
	// Bit MCU_WPD.
	IO_MUX_MTDO_MCU_WPD = 0x4
	// Position of MCU_WPU field.
	IO_MUX_MTDO_MCU_WPU_Pos = 0x3
	// Bit mask of MCU_WPU field.
	IO_MUX_MTDO_MCU_WPU_Msk = 0x8
	// Bit MCU_WPU.
	IO_MUX_MTDO_MCU_WPU = 0x8
	// Position of MCU_IE field.
	IO_MUX_MTDO_MCU_IE_Pos = 0x4
	// Bit mask of MCU_IE field.
	IO_MUX_MTDO_MCU_IE_Msk = 0x10
	// Bit MCU_IE.
	IO_MUX_MTDO_MCU_IE = 0x10
	// Position of FUN_WPD field.
	IO_MUX_MTDO_FUN_WPD_Pos = 0x7
	// Bit mask of FUN_WPD field.
	IO_MUX_MTDO_FUN_WPD_Msk = 0x80
	// Bit FUN_WPD.
	IO_MUX_MTDO_FUN_WPD = 0x80
	// Position of FUN_WPU field.
	IO_MUX_MTDO_FUN_WPU_Pos = 0x8
	// Bit mask of FUN_WPU field.
	IO_MUX_MTDO_FUN_WPU_Msk = 0x100
	// Bit FUN_WPU.
	IO_MUX_MTDO_FUN_WPU = 0x100
	// Position of FUN_IE field.
	IO_MUX_MTDO_FUN_IE_Pos = 0x9
	// Bit mask of FUN_IE field.
	IO_MUX_MTDO_FUN_IE_Msk = 0x200
	// Bit FUN_IE.
	IO_MUX_MTDO_FUN_IE = 0x200
	// Position of FUN_DRV field.
	IO_MUX_MTDO_FUN_DRV_Pos = 0xa
	// Bit mask of FUN_DRV field.
	IO_MUX_MTDO_FUN_DRV_Msk = 0xc00
	// Position of MCU_SEL field.
	IO_MUX_MTDO_MCU_SEL_Pos = 0xc
	// Bit mask of MCU_SEL field.
	IO_MUX_MTDO_MCU_SEL_Msk = 0x7000
	// Position of FILTER_EN field.
	IO_MUX_MTDO_FILTER_EN_Pos = 0xf
	// Bit mask of FILTER_EN field.
	IO_MUX_MTDO_FILTER_EN_Msk = 0x8000
	// Bit FILTER_EN.
	IO_MUX_MTDO_FILTER_EN = 0x8000

	// MTDI: Configuration register for pad MTDI
	// Position of MCU_OE field.
	IO_MUX_MTDI_MCU_OE_Pos = 0x0
	// Bit mask of MCU_OE field.
	IO_MUX_MTDI_MCU_OE_Msk = 0x1
	// Bit MCU_OE.
	IO_MUX_MTDI_MCU_OE = 0x1
	// Position of SLP_SEL field.
	IO_MUX_MTDI_SLP_SEL_Pos = 0x1
	// Bit mask of SLP_SEL field.
	IO_MUX_MTDI_SLP_SEL_Msk = 0x2
	// Bit SLP_SEL.
	IO_MUX_MTDI_SLP_SEL = 0x2
	// Position of MCU_WPD field.
	IO_MUX_MTDI_MCU_WPD_Pos = 0x2
	// Bit mask of MCU_WPD field.
	IO_MUX_MTDI_MCU_WPD_Msk = 0x4
	// Bit MCU_WPD.
	IO_MUX_MTDI_MCU_WPD = 0x4
	// Position of MCU_WPU field.
	IO_MUX_MTDI_MCU_WPU_Pos = 0x3
	// Bit mask of MCU_WPU field.
	IO_MUX_MTDI_MCU_WPU_Msk = 0x8
	// Bit MCU_WPU.
	IO_MUX_MTDI_MCU_WPU = 0x8
	// Position of MCU_IE field.
	IO_MUX_MTDI_MCU_IE_Pos = 0x4
	// Bit mask of MCU_IE field.
	IO_MUX_MTDI_MCU_IE_Msk = 0x10
	// Bit MCU_IE.
	IO_MUX_MTDI_MCU_IE = 0x10
	// Position of FUN_WPD field.
	IO_MUX_MTDI_FUN_WPD_Pos = 0x7
	// Bit mask of FUN_WPD field.
	IO_MUX_MTDI_FUN_WPD_Msk = 0x80
	// Bit FUN_WPD.
	IO_MUX_MTDI_FUN_WPD = 0x80
	// Position of FUN_WPU field.
	IO_MUX_MTDI_FUN_WPU_Pos = 0x8
	// Bit mask of FUN_WPU field.
	IO_MUX_MTDI_FUN_WPU_Msk = 0x100
	// Bit FUN_WPU.
	IO_MUX_MTDI_FUN_WPU = 0x100
	// Position of FUN_IE field.
	IO_MUX_MTDI_FUN_IE_Pos = 0x9
	// Bit mask of FUN_IE field.
	IO_MUX_MTDI_FUN_IE_Msk = 0x200
	// Bit FUN_IE.
	IO_MUX_MTDI_FUN_IE = 0x200
	// Position of FUN_DRV field.
	IO_MUX_MTDI_FUN_DRV_Pos = 0xa
	// Bit mask of FUN_DRV field.
	IO_MUX_MTDI_FUN_DRV_Msk = 0xc00
	// Position of MCU_SEL field.
	IO_MUX_MTDI_MCU_SEL_Pos = 0xc
	// Bit mask of MCU_SEL field.
	IO_MUX_MTDI_MCU_SEL_Msk = 0x7000
	// Position of FILTER_EN field.
	IO_MUX_MTDI_FILTER_EN_Pos = 0xf
	// Bit mask of FILTER_EN field.
	IO_MUX_MTDI_FILTER_EN_Msk = 0x8000
	// Bit FILTER_EN.
	IO_MUX_MTDI_FILTER_EN = 0x8000

	// MTMS: Configuration register for pad MTMS
	// Position of MCU_OE field.
	IO_MUX_MTMS_MCU_OE_Pos = 0x0
	// Bit mask of MCU_OE field.
	IO_MUX_MTMS_MCU_OE_Msk = 0x1
	// Bit MCU_OE.
	IO_MUX_MTMS_MCU_OE = 0x1
	// Position of SLP_SEL field.
	IO_MUX_MTMS_SLP_SEL_Pos = 0x1
	// Bit mask of SLP_SEL field.
	IO_MUX_MTMS_SLP_SEL_Msk = 0x2
	// Bit SLP_SEL.
	IO_MUX_MTMS_SLP_SEL = 0x2
	// Position of MCU_WPD field.
	IO_MUX_MTMS_MCU_WPD_Pos = 0x2
	// Bit mask of MCU_WPD field.
	IO_MUX_MTMS_MCU_WPD_Msk = 0x4
	// Bit MCU_WPD.
	IO_MUX_MTMS_MCU_WPD = 0x4
	// Position of MCU_WPU field.
	IO_MUX_MTMS_MCU_WPU_Pos = 0x3
	// Bit mask of MCU_WPU field.
	IO_MUX_MTMS_MCU_WPU_Msk = 0x8
	// Bit MCU_WPU.
	IO_MUX_MTMS_MCU_WPU = 0x8
	// Position of MCU_IE field.
	IO_MUX_MTMS_MCU_IE_Pos = 0x4
	// Bit mask of MCU_IE field.
	IO_MUX_MTMS_MCU_IE_Msk = 0x10
	// Bit MCU_IE.
	IO_MUX_MTMS_MCU_IE = 0x10
	// Position of FUN_WPD field.
	IO_MUX_MTMS_FUN_WPD_Pos = 0x7
	// Bit mask of FUN_WPD field.
	IO_MUX_MTMS_FUN_WPD_Msk = 0x80
	// Bit FUN_WPD.
	IO_MUX_MTMS_FUN_WPD = 0x80
	// Position of FUN_WPU field.
	IO_MUX_MTMS_FUN_WPU_Pos = 0x8
	// Bit mask of FUN_WPU field.
	IO_MUX_MTMS_FUN_WPU_Msk = 0x100
	// Bit FUN_WPU.
	IO_MUX_MTMS_FUN_WPU = 0x100
	// Position of FUN_IE field.
	IO_MUX_MTMS_FUN_IE_Pos = 0x9
	// Bit mask of FUN_IE field.
	IO_MUX_MTMS_FUN_IE_Msk = 0x200
	// Bit FUN_IE.
	IO_MUX_MTMS_FUN_IE = 0x200
	// Position of FUN_DRV field.
	IO_MUX_MTMS_FUN_DRV_Pos = 0xa
	// Bit mask of FUN_DRV field.
	IO_MUX_MTMS_FUN_DRV_Msk = 0xc00
	// Position of MCU_SEL field.
	IO_MUX_MTMS_MCU_SEL_Pos = 0xc
	// Bit mask of MCU_SEL field.
	IO_MUX_MTMS_MCU_SEL_Msk = 0x7000
	// Position of FILTER_EN field.
	IO_MUX_MTMS_FILTER_EN_Pos = 0xf
	// Bit mask of FILTER_EN field.
	IO_MUX_MTMS_FILTER_EN_Msk = 0x8000
	// Bit FILTER_EN.
	IO_MUX_MTMS_FILTER_EN = 0x8000

	// U0TXD: Configuration register for pad U0TXD
	// Position of MCU_OE field.
	IO_MUX_U0TXD_MCU_OE_Pos = 0x0
	// Bit mask of MCU_OE field.
	IO_MUX_U0TXD_MCU_OE_Msk = 0x1
	// Bit MCU_OE.
	IO_MUX_U0TXD_MCU_OE = 0x1
	// Position of SLP_SEL field.
	IO_MUX_U0TXD_SLP_SEL_Pos = 0x1
	// Bit mask of SLP_SEL field.
	IO_MUX_U0TXD_SLP_SEL_Msk = 0x2
	// Bit SLP_SEL.
	IO_MUX_U0TXD_SLP_SEL = 0x2
	// Position of MCU_WPD field.
	IO_MUX_U0TXD_MCU_WPD_Pos = 0x2
	// Bit mask of MCU_WPD field.
	IO_MUX_U0TXD_MCU_WPD_Msk = 0x4
	// Bit MCU_WPD.
	IO_MUX_U0TXD_MCU_WPD = 0x4
	// Position of MCU_WPU field.
	IO_MUX_U0TXD_MCU_WPU_Pos = 0x3
	// Bit mask of MCU_WPU field.
	IO_MUX_U0TXD_MCU_WPU_Msk = 0x8
	// Bit MCU_WPU.
	IO_MUX_U0TXD_MCU_WPU = 0x8
	// Position of MCU_IE field.
	IO_MUX_U0TXD_MCU_IE_Pos = 0x4
	// Bit mask of MCU_IE field.
	IO_MUX_U0TXD_MCU_IE_Msk = 0x10
	// Bit MCU_IE.
	IO_MUX_U0TXD_MCU_IE = 0x10
	// Position of FUN_WPD field.
	IO_MUX_U0TXD_FUN_WPD_Pos = 0x7
	// Bit mask of FUN_WPD field.
	IO_MUX_U0TXD_FUN_WPD_Msk = 0x80
	// Bit FUN_WPD.
	IO_MUX_U0TXD_FUN_WPD = 0x80
	// Position of FUN_WPU field.
	IO_MUX_U0TXD_FUN_WPU_Pos = 0x8
	// Bit mask of FUN_WPU field.
	IO_MUX_U0TXD_FUN_WPU_Msk = 0x100
	// Bit FUN_WPU.
	IO_MUX_U0TXD_FUN_WPU = 0x100
	// Position of FUN_IE field.
	IO_MUX_U0TXD_FUN_IE_Pos = 0x9
	// Bit mask of FUN_IE field.
	IO_MUX_U0TXD_FUN_IE_Msk = 0x200
	// Bit FUN_IE.
	IO_MUX_U0TXD_FUN_IE = 0x200
	// Position of FUN_DRV field.
	IO_MUX_U0TXD_FUN_DRV_Pos = 0xa
	// Bit mask of FUN_DRV field.
	IO_MUX_U0TXD_FUN_DRV_Msk = 0xc00
	// Position of MCU_SEL field.
	IO_MUX_U0TXD_MCU_SEL_Pos = 0xc
	// Bit mask of MCU_SEL field.
	IO_MUX_U0TXD_MCU_SEL_Msk = 0x7000
	// Position of FILTER_EN field.
	IO_MUX_U0TXD_FILTER_EN_Pos = 0xf
	// Bit mask of FILTER_EN field.
	IO_MUX_U0TXD_FILTER_EN_Msk = 0x8000
	// Bit FILTER_EN.
	IO_MUX_U0TXD_FILTER_EN = 0x8000

	// U0RXD: Configuration register for pad U0RXD
	// Position of MCU_OE field.
	IO_MUX_U0RXD_MCU_OE_Pos = 0x0
	// Bit mask of MCU_OE field.
	IO_MUX_U0RXD_MCU_OE_Msk = 0x1
	// Bit MCU_OE.
	IO_MUX_U0RXD_MCU_OE = 0x1
	// Position of SLP_SEL field.
	IO_MUX_U0RXD_SLP_SEL_Pos = 0x1
	// Bit mask of SLP_SEL field.
	IO_MUX_U0RXD_SLP_SEL_Msk = 0x2
	// Bit SLP_SEL.
	IO_MUX_U0RXD_SLP_SEL = 0x2
	// Position of MCU_WPD field.
	IO_MUX_U0RXD_MCU_WPD_Pos = 0x2
	// Bit mask of MCU_WPD field.
	IO_MUX_U0RXD_MCU_WPD_Msk = 0x4
	// Bit MCU_WPD.
	IO_MUX_U0RXD_MCU_WPD = 0x4
	// Position of MCU_WPU field.
	IO_MUX_U0RXD_MCU_WPU_Pos = 0x3
	// Bit mask of MCU_WPU field.
	IO_MUX_U0RXD_MCU_WPU_Msk = 0x8
	// Bit MCU_WPU.
	IO_MUX_U0RXD_MCU_WPU = 0x8
	// Position of MCU_IE field.
	IO_MUX_U0RXD_MCU_IE_Pos = 0x4
	// Bit mask of MCU_IE field.
	IO_MUX_U0RXD_MCU_IE_Msk = 0x10
	// Bit MCU_IE.
	IO_MUX_U0RXD_MCU_IE = 0x10
	// Position of FUN_WPD field.
	IO_MUX_U0RXD_FUN_WPD_Pos = 0x7
	// Bit mask of FUN_WPD field.
	IO_MUX_U0RXD_FUN_WPD_Msk = 0x80
	// Bit FUN_WPD.
	IO_MUX_U0RXD_FUN_WPD = 0x80
	// Position of FUN_WPU field.
	IO_MUX_U0RXD_FUN_WPU_Pos = 0x8
	// Bit mask of FUN_WPU field.
	IO_MUX_U0RXD_FUN_WPU_Msk = 0x100
	// Bit FUN_WPU.
	IO_MUX_U0RXD_FUN_WPU = 0x100
	// Position of FUN_IE field.
	IO_MUX_U0RXD_FUN_IE_Pos = 0x9
	// Bit mask of FUN_IE field.
	IO_MUX_U0RXD_FUN_IE_Msk = 0x200
	// Bit FUN_IE.
	IO_MUX_U0RXD_FUN_IE = 0x200
	// Position of FUN_DRV field.
	IO_MUX_U0RXD_FUN_DRV_Pos = 0xa
	// Bit mask of FUN_DRV field.
	IO_MUX_U0RXD_FUN_DRV_Msk = 0xc00
	// Position of MCU_SEL field.
	IO_MUX_U0RXD_MCU_SEL_Pos = 0xc
	// Bit mask of MCU_SEL field.
	IO_MUX_U0RXD_MCU_SEL_Msk = 0x7000
	// Position of FILTER_EN field.
	IO_MUX_U0RXD_FILTER_EN_Pos = 0xf
	// Bit mask of FILTER_EN field.
	IO_MUX_U0RXD_FILTER_EN_Msk = 0x8000
	// Bit FILTER_EN.
	IO_MUX_U0RXD_FILTER_EN = 0x8000

	// GPIO_45: Configuration register for pad GPIO45
	// Position of MCU_OE field.
	IO_MUX_GPIO_45_MCU_OE_Pos = 0x0
	// Bit mask of MCU_OE field.
	IO_MUX_GPIO_45_MCU_OE_Msk = 0x1
	// Bit MCU_OE.
	IO_MUX_GPIO_45_MCU_OE = 0x1
	// Position of SLP_SEL field.
	IO_MUX_GPIO_45_SLP_SEL_Pos = 0x1
	// Bit mask of SLP_SEL field.
	IO_MUX_GPIO_45_SLP_SEL_Msk = 0x2
	// Bit SLP_SEL.
	IO_MUX_GPIO_45_SLP_SEL = 0x2
	// Position of MCU_WPD field.
	IO_MUX_GPIO_45_MCU_WPD_Pos = 0x2
	// Bit mask of MCU_WPD field.
	IO_MUX_GPIO_45_MCU_WPD_Msk = 0x4
	// Bit MCU_WPD.
	IO_MUX_GPIO_45_MCU_WPD = 0x4
	// Position of MCU_WPU field.
	IO_MUX_GPIO_45_MCU_WPU_Pos = 0x3
	// Bit mask of MCU_WPU field.
	IO_MUX_GPIO_45_MCU_WPU_Msk = 0x8
	// Bit MCU_WPU.
	IO_MUX_GPIO_45_MCU_WPU = 0x8
	// Position of MCU_IE field.
	IO_MUX_GPIO_45_MCU_IE_Pos = 0x4
	// Bit mask of MCU_IE field.
	IO_MUX_GPIO_45_MCU_IE_Msk = 0x10
	// Bit MCU_IE.
	IO_MUX_GPIO_45_MCU_IE = 0x10
	// Position of FUN_WPD field.
	IO_MUX_GPIO_45_FUN_WPD_Pos = 0x7
	// Bit mask of FUN_WPD field.
	IO_MUX_GPIO_45_FUN_WPD_Msk = 0x80
	// Bit FUN_WPD.
	IO_MUX_GPIO_45_FUN_WPD = 0x80
	// Position of FUN_WPU field.
	IO_MUX_GPIO_45_FUN_WPU_Pos = 0x8
	// Bit mask of FUN_WPU field.
	IO_MUX_GPIO_45_FUN_WPU_Msk = 0x100
	// Bit FUN_WPU.
	IO_MUX_GPIO_45_FUN_WPU = 0x100
	// Position of FUN_IE field.
	IO_MUX_GPIO_45_FUN_IE_Pos = 0x9
	// Bit mask of FUN_IE field.
	IO_MUX_GPIO_45_FUN_IE_Msk = 0x200
	// Bit FUN_IE.
	IO_MUX_GPIO_45_FUN_IE = 0x200
	// Position of FUN_DRV field.
	IO_MUX_GPIO_45_FUN_DRV_Pos = 0xa
	// Bit mask of FUN_DRV field.
	IO_MUX_GPIO_45_FUN_DRV_Msk = 0xc00
	// Position of MCU_SEL field.
	IO_MUX_GPIO_45_MCU_SEL_Pos = 0xc
	// Bit mask of MCU_SEL field.
	IO_MUX_GPIO_45_MCU_SEL_Msk = 0x7000
	// Position of FILTER_EN field.
	IO_MUX_GPIO_45_FILTER_EN_Pos = 0xf
	// Bit mask of FILTER_EN field.
	IO_MUX_GPIO_45_FILTER_EN_Msk = 0x8000
	// Bit FILTER_EN.
	IO_MUX_GPIO_45_FILTER_EN = 0x8000

	// GPIO_46: Configuration register for pad GPIO46
	// Position of MCU_OE field.
	IO_MUX_GPIO_46_MCU_OE_Pos = 0x0
	// Bit mask of MCU_OE field.
	IO_MUX_GPIO_46_MCU_OE_Msk = 0x1
	// Bit MCU_OE.
	IO_MUX_GPIO_46_MCU_OE = 0x1
	// Position of SLP_SEL field.
	IO_MUX_GPIO_46_SLP_SEL_Pos = 0x1
	// Bit mask of SLP_SEL field.
	IO_MUX_GPIO_46_SLP_SEL_Msk = 0x2
	// Bit SLP_SEL.
	IO_MUX_GPIO_46_SLP_SEL = 0x2
	// Position of MCU_WPD field.
	IO_MUX_GPIO_46_MCU_WPD_Pos = 0x2
	// Bit mask of MCU_WPD field.
	IO_MUX_GPIO_46_MCU_WPD_Msk = 0x4
	// Bit MCU_WPD.
	IO_MUX_GPIO_46_MCU_WPD = 0x4
	// Position of MCU_WPU field.
	IO_MUX_GPIO_46_MCU_WPU_Pos = 0x3
	// Bit mask of MCU_WPU field.
	IO_MUX_GPIO_46_MCU_WPU_Msk = 0x8
	// Bit MCU_WPU.
	IO_MUX_GPIO_46_MCU_WPU = 0x8
	// Position of MCU_IE field.
	IO_MUX_GPIO_46_MCU_IE_Pos = 0x4
	// Bit mask of MCU_IE field.
	IO_MUX_GPIO_46_MCU_IE_Msk = 0x10
	// Bit MCU_IE.
	IO_MUX_GPIO_46_MCU_IE = 0x10
	// Position of FUN_WPD field.
	IO_MUX_GPIO_46_FUN_WPD_Pos = 0x7
	// Bit mask of FUN_WPD field.
	IO_MUX_GPIO_46_FUN_WPD_Msk = 0x80
	// Bit FUN_WPD.
	IO_MUX_GPIO_46_FUN_WPD = 0x80
	// Position of FUN_WPU field.
	IO_MUX_GPIO_46_FUN_WPU_Pos = 0x8
	// Bit mask of FUN_WPU field.
	IO_MUX_GPIO_46_FUN_WPU_Msk = 0x100
	// Bit FUN_WPU.
	IO_MUX_GPIO_46_FUN_WPU = 0x100
	// Position of FUN_IE field.
	IO_MUX_GPIO_46_FUN_IE_Pos = 0x9
	// Bit mask of FUN_IE field.
	IO_MUX_GPIO_46_FUN_IE_Msk = 0x200
	// Bit FUN_IE.
	IO_MUX_GPIO_46_FUN_IE = 0x200
	// Position of FUN_DRV field.
	IO_MUX_GPIO_46_FUN_DRV_Pos = 0xa
	// Bit mask of FUN_DRV field.
	IO_MUX_GPIO_46_FUN_DRV_Msk = 0xc00
	// Position of MCU_SEL field.
	IO_MUX_GPIO_46_MCU_SEL_Pos = 0xc
	// Bit mask of MCU_SEL field.
	IO_MUX_GPIO_46_MCU_SEL_Msk = 0x7000
	// Position of FILTER_EN field.
	IO_MUX_GPIO_46_FILTER_EN_Pos = 0xf
	// Bit mask of FILTER_EN field.
	IO_MUX_GPIO_46_FILTER_EN_Msk = 0x8000
	// Bit FILTER_EN.
	IO_MUX_GPIO_46_FILTER_EN = 0x8000

	// DATE: Version control register
	// Position of VERSION field.
	IO_MUX_DATE_VERSION_Pos = 0x0
	// Bit mask of VERSION field.
	IO_MUX_DATE_VERSION_Msk = 0xfffffff
)

// Constants for LEDC: Peripheral LEDC
const (
	// CH0_CONF0: Configuration register 0 for channel %s
	// Position of TIMER_SEL_CH0 field.
	LEDC_CH_CONF0_TIMER_SEL_CH0_Pos = 0x0
	// Bit mask of TIMER_SEL_CH0 field.
	LEDC_CH_CONF0_TIMER_SEL_CH0_Msk = 0x3
	// Position of SIG_OUT_EN_CH0 field.
	LEDC_CH_CONF0_SIG_OUT_EN_CH0_Pos = 0x2
	// Bit mask of SIG_OUT_EN_CH0 field.
	LEDC_CH_CONF0_SIG_OUT_EN_CH0_Msk = 0x4
	// Bit SIG_OUT_EN_CH0.
	LEDC_CH_CONF0_SIG_OUT_EN_CH0 = 0x4
	// Position of IDLE_LV_CH0 field.
	LEDC_CH_CONF0_IDLE_LV_CH0_Pos = 0x3
	// Bit mask of IDLE_LV_CH0 field.
	LEDC_CH_CONF0_IDLE_LV_CH0_Msk = 0x8
	// Bit IDLE_LV_CH0.
	LEDC_CH_CONF0_IDLE_LV_CH0 = 0x8
	// Position of PARA_UP_CH0 field.
	LEDC_CH_CONF0_PARA_UP_CH0_Pos = 0x4
	// Bit mask of PARA_UP_CH0 field.
	LEDC_CH_CONF0_PARA_UP_CH0_Msk = 0x10
	// Bit PARA_UP_CH0.
	LEDC_CH_CONF0_PARA_UP_CH0 = 0x10
	// Position of OVF_NUM_CH0 field.
	LEDC_CH_CONF0_OVF_NUM_CH0_Pos = 0x5
	// Bit mask of OVF_NUM_CH0 field.
	LEDC_CH_CONF0_OVF_NUM_CH0_Msk = 0x7fe0
	// Position of OVF_CNT_EN_CH0 field.
	LEDC_CH_CONF0_OVF_CNT_EN_CH0_Pos = 0xf
	// Bit mask of OVF_CNT_EN_CH0 field.
	LEDC_CH_CONF0_OVF_CNT_EN_CH0_Msk = 0x8000
	// Bit OVF_CNT_EN_CH0.
	LEDC_CH_CONF0_OVF_CNT_EN_CH0 = 0x8000
	// Position of OVF_CNT_RESET_CH0 field.
	LEDC_CH_CONF0_OVF_CNT_RESET_CH0_Pos = 0x10
	// Bit mask of OVF_CNT_RESET_CH0 field.
	LEDC_CH_CONF0_OVF_CNT_RESET_CH0_Msk = 0x10000
	// Bit OVF_CNT_RESET_CH0.
	LEDC_CH_CONF0_OVF_CNT_RESET_CH0 = 0x10000
	// Position of OVF_CNT_RESET_ST_CH0 field.
	LEDC_CH_CONF0_OVF_CNT_RESET_ST_CH0_Pos = 0x11
	// Bit mask of OVF_CNT_RESET_ST_CH0 field.
	LEDC_CH_CONF0_OVF_CNT_RESET_ST_CH0_Msk = 0x20000
	// Bit OVF_CNT_RESET_ST_CH0.
	LEDC_CH_CONF0_OVF_CNT_RESET_ST_CH0 = 0x20000

	// CH0_HPOINT: High point register for channel %s
	// Position of HPOINT_CH0 field.
	LEDC_CH_HPOINT_HPOINT_CH0_Pos = 0x0
	// Bit mask of HPOINT_CH0 field.
	LEDC_CH_HPOINT_HPOINT_CH0_Msk = 0x3fff

	// CH0_DUTY: Initial duty cycle for channel %s
	// Position of DUTY_CH0 field.
	LEDC_CH_DUTY_DUTY_CH0_Pos = 0x0
	// Bit mask of DUTY_CH0 field.
	LEDC_CH_DUTY_DUTY_CH0_Msk = 0x7ffff

	// CH0_CONF1: Configuration register 1 for channel %s
	// Position of DUTY_SCALE_CH0 field.
	LEDC_CH_CONF1_DUTY_SCALE_CH0_Pos = 0x0
	// Bit mask of DUTY_SCALE_CH0 field.
	LEDC_CH_CONF1_DUTY_SCALE_CH0_Msk = 0x3ff
	// Position of DUTY_CYCLE_CH0 field.
	LEDC_CH_CONF1_DUTY_CYCLE_CH0_Pos = 0xa
	// Bit mask of DUTY_CYCLE_CH0 field.
	LEDC_CH_CONF1_DUTY_CYCLE_CH0_Msk = 0xffc00
	// Position of DUTY_NUM_CH0 field.
	LEDC_CH_CONF1_DUTY_NUM_CH0_Pos = 0x14
	// Bit mask of DUTY_NUM_CH0 field.
	LEDC_CH_CONF1_DUTY_NUM_CH0_Msk = 0x3ff00000
	// Position of DUTY_INC_CH0 field.
	LEDC_CH_CONF1_DUTY_INC_CH0_Pos = 0x1e
	// Bit mask of DUTY_INC_CH0 field.
	LEDC_CH_CONF1_DUTY_INC_CH0_Msk = 0x40000000
	// Bit DUTY_INC_CH0.
	LEDC_CH_CONF1_DUTY_INC_CH0 = 0x40000000
	// Position of DUTY_START_CH0 field.
	LEDC_CH_CONF1_DUTY_START_CH0_Pos = 0x1f
	// Bit mask of DUTY_START_CH0 field.
	LEDC_CH_CONF1_DUTY_START_CH0_Msk = 0x80000000
	// Bit DUTY_START_CH0.
	LEDC_CH_CONF1_DUTY_START_CH0 = 0x80000000

	// CH0_DUTY_R: Current duty cycle for channel %s
	// Position of DUTY_R_CH0 field.
	LEDC_CH_DUTY_R_DUTY_R_CH0_Pos = 0x0
	// Bit mask of DUTY_R_CH0 field.
	LEDC_CH_DUTY_R_DUTY_R_CH0_Msk = 0x7ffff

	// TIMER0_CONF: Timer %s configuration
	// Position of TIMER0_DUTY_RES field.
	LEDC_TIMER_CONF_TIMER0_DUTY_RES_Pos = 0x0
	// Bit mask of TIMER0_DUTY_RES field.
	LEDC_TIMER_CONF_TIMER0_DUTY_RES_Msk = 0xf
	// Position of CLK_DIV_TIMER0 field.
	LEDC_TIMER_CONF_CLK_DIV_TIMER0_Pos = 0x4
	// Bit mask of CLK_DIV_TIMER0 field.
	LEDC_TIMER_CONF_CLK_DIV_TIMER0_Msk = 0x3ffff0
	// Position of TIMER0_PAUSE field.
	LEDC_TIMER_CONF_TIMER0_PAUSE_Pos = 0x16
	// Bit mask of TIMER0_PAUSE field.
	LEDC_TIMER_CONF_TIMER0_PAUSE_Msk = 0x400000
	// Bit TIMER0_PAUSE.
	LEDC_TIMER_CONF_TIMER0_PAUSE = 0x400000
	// Position of TIMER0_RST field.
	LEDC_TIMER_CONF_TIMER0_RST_Pos = 0x17
	// Bit mask of TIMER0_RST field.
	LEDC_TIMER_CONF_TIMER0_RST_Msk = 0x800000
	// Bit TIMER0_RST.
	LEDC_TIMER_CONF_TIMER0_RST = 0x800000
	// Position of TICK_SEL_TIMER0 field.
	LEDC_TIMER_CONF_TICK_SEL_TIMER0_Pos = 0x18
	// Bit mask of TICK_SEL_TIMER0 field.
	LEDC_TIMER_CONF_TICK_SEL_TIMER0_Msk = 0x1000000
	// Bit TICK_SEL_TIMER0.
	LEDC_TIMER_CONF_TICK_SEL_TIMER0 = 0x1000000
	// Position of TIMER0_PARA_UP field.
	LEDC_TIMER_CONF_TIMER0_PARA_UP_Pos = 0x19
	// Bit mask of TIMER0_PARA_UP field.
	LEDC_TIMER_CONF_TIMER0_PARA_UP_Msk = 0x2000000
	// Bit TIMER0_PARA_UP.
	LEDC_TIMER_CONF_TIMER0_PARA_UP = 0x2000000

	// TIMER0_VALUE: Timer %s current counter value
	// Position of TIMER0_CNT field.
	LEDC_TIMER_VALUE_TIMER0_CNT_Pos = 0x0
	// Bit mask of TIMER0_CNT field.
	LEDC_TIMER_VALUE_TIMER0_CNT_Msk = 0x3fff

	// INT_RAW: Raw interrupt status
	// Position of TIMER0_OVF_INT_RAW field.
	LEDC_INT_RAW_TIMER0_OVF_INT_RAW_Pos = 0x0
	// Bit mask of TIMER0_OVF_INT_RAW field.
	LEDC_INT_RAW_TIMER0_OVF_INT_RAW_Msk = 0x1
	// Bit TIMER0_OVF_INT_RAW.
	LEDC_INT_RAW_TIMER0_OVF_INT_RAW = 0x1
	// Position of TIMER1_OVF_INT_RAW field.
	LEDC_INT_RAW_TIMER1_OVF_INT_RAW_Pos = 0x1
	// Bit mask of TIMER1_OVF_INT_RAW field.
	LEDC_INT_RAW_TIMER1_OVF_INT_RAW_Msk = 0x2
	// Bit TIMER1_OVF_INT_RAW.
	LEDC_INT_RAW_TIMER1_OVF_INT_RAW = 0x2
	// Position of TIMER2_OVF_INT_RAW field.
	LEDC_INT_RAW_TIMER2_OVF_INT_RAW_Pos = 0x2
	// Bit mask of TIMER2_OVF_INT_RAW field.
	LEDC_INT_RAW_TIMER2_OVF_INT_RAW_Msk = 0x4
	// Bit TIMER2_OVF_INT_RAW.
	LEDC_INT_RAW_TIMER2_OVF_INT_RAW = 0x4
	// Position of TIMER3_OVF_INT_RAW field.
	LEDC_INT_RAW_TIMER3_OVF_INT_RAW_Pos = 0x3
	// Bit mask of TIMER3_OVF_INT_RAW field.
	LEDC_INT_RAW_TIMER3_OVF_INT_RAW_Msk = 0x8
	// Bit TIMER3_OVF_INT_RAW.
	LEDC_INT_RAW_TIMER3_OVF_INT_RAW = 0x8
	// Position of DUTY_CHNG_END_CH0_INT_RAW field.
	LEDC_INT_RAW_DUTY_CHNG_END_CH0_INT_RAW_Pos = 0x4
	// Bit mask of DUTY_CHNG_END_CH0_INT_RAW field.
	LEDC_INT_RAW_DUTY_CHNG_END_CH0_INT_RAW_Msk = 0x10
	// Bit DUTY_CHNG_END_CH0_INT_RAW.
	LEDC_INT_RAW_DUTY_CHNG_END_CH0_INT_RAW = 0x10
	// Position of DUTY_CHNG_END_CH1_INT_RAW field.
	LEDC_INT_RAW_DUTY_CHNG_END_CH1_INT_RAW_Pos = 0x5
	// Bit mask of DUTY_CHNG_END_CH1_INT_RAW field.
	LEDC_INT_RAW_DUTY_CHNG_END_CH1_INT_RAW_Msk = 0x20
	// Bit DUTY_CHNG_END_CH1_INT_RAW.
	LEDC_INT_RAW_DUTY_CHNG_END_CH1_INT_RAW = 0x20
	// Position of DUTY_CHNG_END_CH2_INT_RAW field.
	LEDC_INT_RAW_DUTY_CHNG_END_CH2_INT_RAW_Pos = 0x6
	// Bit mask of DUTY_CHNG_END_CH2_INT_RAW field.
	LEDC_INT_RAW_DUTY_CHNG_END_CH2_INT_RAW_Msk = 0x40
	// Bit DUTY_CHNG_END_CH2_INT_RAW.
	LEDC_INT_RAW_DUTY_CHNG_END_CH2_INT_RAW = 0x40
	// Position of DUTY_CHNG_END_CH3_INT_RAW field.
	LEDC_INT_RAW_DUTY_CHNG_END_CH3_INT_RAW_Pos = 0x7
	// Bit mask of DUTY_CHNG_END_CH3_INT_RAW field.
	LEDC_INT_RAW_DUTY_CHNG_END_CH3_INT_RAW_Msk = 0x80
	// Bit DUTY_CHNG_END_CH3_INT_RAW.
	LEDC_INT_RAW_DUTY_CHNG_END_CH3_INT_RAW = 0x80
	// Position of DUTY_CHNG_END_CH4_INT_RAW field.
	LEDC_INT_RAW_DUTY_CHNG_END_CH4_INT_RAW_Pos = 0x8
	// Bit mask of DUTY_CHNG_END_CH4_INT_RAW field.
	LEDC_INT_RAW_DUTY_CHNG_END_CH4_INT_RAW_Msk = 0x100
	// Bit DUTY_CHNG_END_CH4_INT_RAW.
	LEDC_INT_RAW_DUTY_CHNG_END_CH4_INT_RAW = 0x100
	// Position of DUTY_CHNG_END_CH5_INT_RAW field.
	LEDC_INT_RAW_DUTY_CHNG_END_CH5_INT_RAW_Pos = 0x9
	// Bit mask of DUTY_CHNG_END_CH5_INT_RAW field.
	LEDC_INT_RAW_DUTY_CHNG_END_CH5_INT_RAW_Msk = 0x200
	// Bit DUTY_CHNG_END_CH5_INT_RAW.
	LEDC_INT_RAW_DUTY_CHNG_END_CH5_INT_RAW = 0x200
	// Position of DUTY_CHNG_END_CH6_INT_RAW field.
	LEDC_INT_RAW_DUTY_CHNG_END_CH6_INT_RAW_Pos = 0xa
	// Bit mask of DUTY_CHNG_END_CH6_INT_RAW field.
	LEDC_INT_RAW_DUTY_CHNG_END_CH6_INT_RAW_Msk = 0x400
	// Bit DUTY_CHNG_END_CH6_INT_RAW.
	LEDC_INT_RAW_DUTY_CHNG_END_CH6_INT_RAW = 0x400
	// Position of DUTY_CHNG_END_CH7_INT_RAW field.
	LEDC_INT_RAW_DUTY_CHNG_END_CH7_INT_RAW_Pos = 0xb
	// Bit mask of DUTY_CHNG_END_CH7_INT_RAW field.
	LEDC_INT_RAW_DUTY_CHNG_END_CH7_INT_RAW_Msk = 0x800
	// Bit DUTY_CHNG_END_CH7_INT_RAW.
	LEDC_INT_RAW_DUTY_CHNG_END_CH7_INT_RAW = 0x800
	// Position of OVF_CNT_CH0_INT_RAW field.
	LEDC_INT_RAW_OVF_CNT_CH0_INT_RAW_Pos = 0xc
	// Bit mask of OVF_CNT_CH0_INT_RAW field.
	LEDC_INT_RAW_OVF_CNT_CH0_INT_RAW_Msk = 0x1000
	// Bit OVF_CNT_CH0_INT_RAW.
	LEDC_INT_RAW_OVF_CNT_CH0_INT_RAW = 0x1000
	// Position of OVF_CNT_CH1_INT_RAW field.
	LEDC_INT_RAW_OVF_CNT_CH1_INT_RAW_Pos = 0xd
	// Bit mask of OVF_CNT_CH1_INT_RAW field.
	LEDC_INT_RAW_OVF_CNT_CH1_INT_RAW_Msk = 0x2000
	// Bit OVF_CNT_CH1_INT_RAW.
	LEDC_INT_RAW_OVF_CNT_CH1_INT_RAW = 0x2000
	// Position of OVF_CNT_CH2_INT_RAW field.
	LEDC_INT_RAW_OVF_CNT_CH2_INT_RAW_Pos = 0xe
	// Bit mask of OVF_CNT_CH2_INT_RAW field.
	LEDC_INT_RAW_OVF_CNT_CH2_INT_RAW_Msk = 0x4000
	// Bit OVF_CNT_CH2_INT_RAW.
	LEDC_INT_RAW_OVF_CNT_CH2_INT_RAW = 0x4000
	// Position of OVF_CNT_CH3_INT_RAW field.
	LEDC_INT_RAW_OVF_CNT_CH3_INT_RAW_Pos = 0xf
	// Bit mask of OVF_CNT_CH3_INT_RAW field.
	LEDC_INT_RAW_OVF_CNT_CH3_INT_RAW_Msk = 0x8000
	// Bit OVF_CNT_CH3_INT_RAW.
	LEDC_INT_RAW_OVF_CNT_CH3_INT_RAW = 0x8000
	// Position of OVF_CNT_CH4_INT_RAW field.
	LEDC_INT_RAW_OVF_CNT_CH4_INT_RAW_Pos = 0x10
	// Bit mask of OVF_CNT_CH4_INT_RAW field.
	LEDC_INT_RAW_OVF_CNT_CH4_INT_RAW_Msk = 0x10000
	// Bit OVF_CNT_CH4_INT_RAW.
	LEDC_INT_RAW_OVF_CNT_CH4_INT_RAW = 0x10000
	// Position of OVF_CNT_CH5_INT_RAW field.
	LEDC_INT_RAW_OVF_CNT_CH5_INT_RAW_Pos = 0x11
	// Bit mask of OVF_CNT_CH5_INT_RAW field.
	LEDC_INT_RAW_OVF_CNT_CH5_INT_RAW_Msk = 0x20000
	// Bit OVF_CNT_CH5_INT_RAW.
	LEDC_INT_RAW_OVF_CNT_CH5_INT_RAW = 0x20000
	// Position of OVF_CNT_CH6_INT_RAW field.
	LEDC_INT_RAW_OVF_CNT_CH6_INT_RAW_Pos = 0x12
	// Bit mask of OVF_CNT_CH6_INT_RAW field.
	LEDC_INT_RAW_OVF_CNT_CH6_INT_RAW_Msk = 0x40000
	// Bit OVF_CNT_CH6_INT_RAW.
	LEDC_INT_RAW_OVF_CNT_CH6_INT_RAW = 0x40000
	// Position of OVF_CNT_CH7_INT_RAW field.
	LEDC_INT_RAW_OVF_CNT_CH7_INT_RAW_Pos = 0x13
	// Bit mask of OVF_CNT_CH7_INT_RAW field.
	LEDC_INT_RAW_OVF_CNT_CH7_INT_RAW_Msk = 0x80000
	// Bit OVF_CNT_CH7_INT_RAW.
	LEDC_INT_RAW_OVF_CNT_CH7_INT_RAW = 0x80000

	// INT_ST: Masked interrupt status
	// Position of TIMER0_OVF_INT_ST field.
	LEDC_INT_ST_TIMER0_OVF_INT_ST_Pos = 0x0
	// Bit mask of TIMER0_OVF_INT_ST field.
	LEDC_INT_ST_TIMER0_OVF_INT_ST_Msk = 0x1
	// Bit TIMER0_OVF_INT_ST.
	LEDC_INT_ST_TIMER0_OVF_INT_ST = 0x1
	// Position of TIMER1_OVF_INT_ST field.
	LEDC_INT_ST_TIMER1_OVF_INT_ST_Pos = 0x1
	// Bit mask of TIMER1_OVF_INT_ST field.
	LEDC_INT_ST_TIMER1_OVF_INT_ST_Msk = 0x2
	// Bit TIMER1_OVF_INT_ST.
	LEDC_INT_ST_TIMER1_OVF_INT_ST = 0x2
	// Position of TIMER2_OVF_INT_ST field.
	LEDC_INT_ST_TIMER2_OVF_INT_ST_Pos = 0x2
	// Bit mask of TIMER2_OVF_INT_ST field.
	LEDC_INT_ST_TIMER2_OVF_INT_ST_Msk = 0x4
	// Bit TIMER2_OVF_INT_ST.
	LEDC_INT_ST_TIMER2_OVF_INT_ST = 0x4
	// Position of TIMER3_OVF_INT_ST field.
	LEDC_INT_ST_TIMER3_OVF_INT_ST_Pos = 0x3
	// Bit mask of TIMER3_OVF_INT_ST field.
	LEDC_INT_ST_TIMER3_OVF_INT_ST_Msk = 0x8
	// Bit TIMER3_OVF_INT_ST.
	LEDC_INT_ST_TIMER3_OVF_INT_ST = 0x8
	// Position of DUTY_CHNG_END_CH0_INT_ST field.
	LEDC_INT_ST_DUTY_CHNG_END_CH0_INT_ST_Pos = 0x4
	// Bit mask of DUTY_CHNG_END_CH0_INT_ST field.
	LEDC_INT_ST_DUTY_CHNG_END_CH0_INT_ST_Msk = 0x10
	// Bit DUTY_CHNG_END_CH0_INT_ST.
	LEDC_INT_ST_DUTY_CHNG_END_CH0_INT_ST = 0x10
	// Position of DUTY_CHNG_END_CH1_INT_ST field.
	LEDC_INT_ST_DUTY_CHNG_END_CH1_INT_ST_Pos = 0x5
	// Bit mask of DUTY_CHNG_END_CH1_INT_ST field.
	LEDC_INT_ST_DUTY_CHNG_END_CH1_INT_ST_Msk = 0x20
	// Bit DUTY_CHNG_END_CH1_INT_ST.
	LEDC_INT_ST_DUTY_CHNG_END_CH1_INT_ST = 0x20
	// Position of DUTY_CHNG_END_CH2_INT_ST field.
	LEDC_INT_ST_DUTY_CHNG_END_CH2_INT_ST_Pos = 0x6
	// Bit mask of DUTY_CHNG_END_CH2_INT_ST field.
	LEDC_INT_ST_DUTY_CHNG_END_CH2_INT_ST_Msk = 0x40
	// Bit DUTY_CHNG_END_CH2_INT_ST.
	LEDC_INT_ST_DUTY_CHNG_END_CH2_INT_ST = 0x40
	// Position of DUTY_CHNG_END_CH3_INT_ST field.
	LEDC_INT_ST_DUTY_CHNG_END_CH3_INT_ST_Pos = 0x7
	// Bit mask of DUTY_CHNG_END_CH3_INT_ST field.
	LEDC_INT_ST_DUTY_CHNG_END_CH3_INT_ST_Msk = 0x80
	// Bit DUTY_CHNG_END_CH3_INT_ST.
	LEDC_INT_ST_DUTY_CHNG_END_CH3_INT_ST = 0x80
	// Position of DUTY_CHNG_END_CH4_INT_ST field.
	LEDC_INT_ST_DUTY_CHNG_END_CH4_INT_ST_Pos = 0x8
	// Bit mask of DUTY_CHNG_END_CH4_INT_ST field.
	LEDC_INT_ST_DUTY_CHNG_END_CH4_INT_ST_Msk = 0x100
	// Bit DUTY_CHNG_END_CH4_INT_ST.
	LEDC_INT_ST_DUTY_CHNG_END_CH4_INT_ST = 0x100
	// Position of DUTY_CHNG_END_CH5_INT_ST field.
	LEDC_INT_ST_DUTY_CHNG_END_CH5_INT_ST_Pos = 0x9
	// Bit mask of DUTY_CHNG_END_CH5_INT_ST field.
	LEDC_INT_ST_DUTY_CHNG_END_CH5_INT_ST_Msk = 0x200
	// Bit DUTY_CHNG_END_CH5_INT_ST.
	LEDC_INT_ST_DUTY_CHNG_END_CH5_INT_ST = 0x200
	// Position of DUTY_CHNG_END_CH6_INT_ST field.
	LEDC_INT_ST_DUTY_CHNG_END_CH6_INT_ST_Pos = 0xa
	// Bit mask of DUTY_CHNG_END_CH6_INT_ST field.
	LEDC_INT_ST_DUTY_CHNG_END_CH6_INT_ST_Msk = 0x400
	// Bit DUTY_CHNG_END_CH6_INT_ST.
	LEDC_INT_ST_DUTY_CHNG_END_CH6_INT_ST = 0x400
	// Position of DUTY_CHNG_END_CH7_INT_ST field.
	LEDC_INT_ST_DUTY_CHNG_END_CH7_INT_ST_Pos = 0xb
	// Bit mask of DUTY_CHNG_END_CH7_INT_ST field.
	LEDC_INT_ST_DUTY_CHNG_END_CH7_INT_ST_Msk = 0x800
	// Bit DUTY_CHNG_END_CH7_INT_ST.
	LEDC_INT_ST_DUTY_CHNG_END_CH7_INT_ST = 0x800
	// Position of OVF_CNT_CH0_INT_ST field.
	LEDC_INT_ST_OVF_CNT_CH0_INT_ST_Pos = 0xc
	// Bit mask of OVF_CNT_CH0_INT_ST field.
	LEDC_INT_ST_OVF_CNT_CH0_INT_ST_Msk = 0x1000
	// Bit OVF_CNT_CH0_INT_ST.
	LEDC_INT_ST_OVF_CNT_CH0_INT_ST = 0x1000
	// Position of OVF_CNT_CH1_INT_ST field.
	LEDC_INT_ST_OVF_CNT_CH1_INT_ST_Pos = 0xd
	// Bit mask of OVF_CNT_CH1_INT_ST field.
	LEDC_INT_ST_OVF_CNT_CH1_INT_ST_Msk = 0x2000
	// Bit OVF_CNT_CH1_INT_ST.
	LEDC_INT_ST_OVF_CNT_CH1_INT_ST = 0x2000
	// Position of OVF_CNT_CH2_INT_ST field.
	LEDC_INT_ST_OVF_CNT_CH2_INT_ST_Pos = 0xe
	// Bit mask of OVF_CNT_CH2_INT_ST field.
	LEDC_INT_ST_OVF_CNT_CH2_INT_ST_Msk = 0x4000
	// Bit OVF_CNT_CH2_INT_ST.
	LEDC_INT_ST_OVF_CNT_CH2_INT_ST = 0x4000
	// Position of OVF_CNT_CH3_INT_ST field.
	LEDC_INT_ST_OVF_CNT_CH3_INT_ST_Pos = 0xf
	// Bit mask of OVF_CNT_CH3_INT_ST field.
	LEDC_INT_ST_OVF_CNT_CH3_INT_ST_Msk = 0x8000
	// Bit OVF_CNT_CH3_INT_ST.
	LEDC_INT_ST_OVF_CNT_CH3_INT_ST = 0x8000
	// Position of OVF_CNT_CH4_INT_ST field.
	LEDC_INT_ST_OVF_CNT_CH4_INT_ST_Pos = 0x10
	// Bit mask of OVF_CNT_CH4_INT_ST field.
	LEDC_INT_ST_OVF_CNT_CH4_INT_ST_Msk = 0x10000
	// Bit OVF_CNT_CH4_INT_ST.
	LEDC_INT_ST_OVF_CNT_CH4_INT_ST = 0x10000
	// Position of OVF_CNT_CH5_INT_ST field.
	LEDC_INT_ST_OVF_CNT_CH5_INT_ST_Pos = 0x11
	// Bit mask of OVF_CNT_CH5_INT_ST field.
	LEDC_INT_ST_OVF_CNT_CH5_INT_ST_Msk = 0x20000
	// Bit OVF_CNT_CH5_INT_ST.
	LEDC_INT_ST_OVF_CNT_CH5_INT_ST = 0x20000
	// Position of OVF_CNT_CH6_INT_ST field.
	LEDC_INT_ST_OVF_CNT_CH6_INT_ST_Pos = 0x12
	// Bit mask of OVF_CNT_CH6_INT_ST field.
	LEDC_INT_ST_OVF_CNT_CH6_INT_ST_Msk = 0x40000
	// Bit OVF_CNT_CH6_INT_ST.
	LEDC_INT_ST_OVF_CNT_CH6_INT_ST = 0x40000
	// Position of OVF_CNT_CH7_INT_ST field.
	LEDC_INT_ST_OVF_CNT_CH7_INT_ST_Pos = 0x13
	// Bit mask of OVF_CNT_CH7_INT_ST field.
	LEDC_INT_ST_OVF_CNT_CH7_INT_ST_Msk = 0x80000
	// Bit OVF_CNT_CH7_INT_ST.
	LEDC_INT_ST_OVF_CNT_CH7_INT_ST = 0x80000

	// INT_ENA: Interrupt enable bits
	// Position of TIMER0_OVF_INT_ENA field.
	LEDC_INT_ENA_TIMER0_OVF_INT_ENA_Pos = 0x0
	// Bit mask of TIMER0_OVF_INT_ENA field.
	LEDC_INT_ENA_TIMER0_OVF_INT_ENA_Msk = 0x1
	// Bit TIMER0_OVF_INT_ENA.
	LEDC_INT_ENA_TIMER0_OVF_INT_ENA = 0x1
	// Position of TIMER1_OVF_INT_ENA field.
	LEDC_INT_ENA_TIMER1_OVF_INT_ENA_Pos = 0x1
	// Bit mask of TIMER1_OVF_INT_ENA field.
	LEDC_INT_ENA_TIMER1_OVF_INT_ENA_Msk = 0x2
	// Bit TIMER1_OVF_INT_ENA.
	LEDC_INT_ENA_TIMER1_OVF_INT_ENA = 0x2
	// Position of TIMER2_OVF_INT_ENA field.
	LEDC_INT_ENA_TIMER2_OVF_INT_ENA_Pos = 0x2
	// Bit mask of TIMER2_OVF_INT_ENA field.
	LEDC_INT_ENA_TIMER2_OVF_INT_ENA_Msk = 0x4
	// Bit TIMER2_OVF_INT_ENA.
	LEDC_INT_ENA_TIMER2_OVF_INT_ENA = 0x4
	// Position of TIMER3_OVF_INT_ENA field.
	LEDC_INT_ENA_TIMER3_OVF_INT_ENA_Pos = 0x3
	// Bit mask of TIMER3_OVF_INT_ENA field.
	LEDC_INT_ENA_TIMER3_OVF_INT_ENA_Msk = 0x8
	// Bit TIMER3_OVF_INT_ENA.
	LEDC_INT_ENA_TIMER3_OVF_INT_ENA = 0x8
	// Position of DUTY_CHNG_END_CH0_INT_ENA field.
	LEDC_INT_ENA_DUTY_CHNG_END_CH0_INT_ENA_Pos = 0x4
	// Bit mask of DUTY_CHNG_END_CH0_INT_ENA field.
	LEDC_INT_ENA_DUTY_CHNG_END_CH0_INT_ENA_Msk = 0x10
	// Bit DUTY_CHNG_END_CH0_INT_ENA.
	LEDC_INT_ENA_DUTY_CHNG_END_CH0_INT_ENA = 0x10
	// Position of DUTY_CHNG_END_CH1_INT_ENA field.
	LEDC_INT_ENA_DUTY_CHNG_END_CH1_INT_ENA_Pos = 0x5
	// Bit mask of DUTY_CHNG_END_CH1_INT_ENA field.
	LEDC_INT_ENA_DUTY_CHNG_END_CH1_INT_ENA_Msk = 0x20
	// Bit DUTY_CHNG_END_CH1_INT_ENA.
	LEDC_INT_ENA_DUTY_CHNG_END_CH1_INT_ENA = 0x20
	// Position of DUTY_CHNG_END_CH2_INT_ENA field.
	LEDC_INT_ENA_DUTY_CHNG_END_CH2_INT_ENA_Pos = 0x6
	// Bit mask of DUTY_CHNG_END_CH2_INT_ENA field.
	LEDC_INT_ENA_DUTY_CHNG_END_CH2_INT_ENA_Msk = 0x40
	// Bit DUTY_CHNG_END_CH2_INT_ENA.
	LEDC_INT_ENA_DUTY_CHNG_END_CH2_INT_ENA = 0x40
	// Position of DUTY_CHNG_END_CH3_INT_ENA field.
	LEDC_INT_ENA_DUTY_CHNG_END_CH3_INT_ENA_Pos = 0x7
	// Bit mask of DUTY_CHNG_END_CH3_INT_ENA field.
	LEDC_INT_ENA_DUTY_CHNG_END_CH3_INT_ENA_Msk = 0x80
	// Bit DUTY_CHNG_END_CH3_INT_ENA.
	LEDC_INT_ENA_DUTY_CHNG_END_CH3_INT_ENA = 0x80
	// Position of DUTY_CHNG_END_CH4_INT_ENA field.
	LEDC_INT_ENA_DUTY_CHNG_END_CH4_INT_ENA_Pos = 0x8
	// Bit mask of DUTY_CHNG_END_CH4_INT_ENA field.
	LEDC_INT_ENA_DUTY_CHNG_END_CH4_INT_ENA_Msk = 0x100
	// Bit DUTY_CHNG_END_CH4_INT_ENA.
	LEDC_INT_ENA_DUTY_CHNG_END_CH4_INT_ENA = 0x100
	// Position of DUTY_CHNG_END_CH5_INT_ENA field.
	LEDC_INT_ENA_DUTY_CHNG_END_CH5_INT_ENA_Pos = 0x9
	// Bit mask of DUTY_CHNG_END_CH5_INT_ENA field.
	LEDC_INT_ENA_DUTY_CHNG_END_CH5_INT_ENA_Msk = 0x200
	// Bit DUTY_CHNG_END_CH5_INT_ENA.
	LEDC_INT_ENA_DUTY_CHNG_END_CH5_INT_ENA = 0x200
	// Position of DUTY_CHNG_END_CH6_INT_ENA field.
	LEDC_INT_ENA_DUTY_CHNG_END_CH6_INT_ENA_Pos = 0xa
	// Bit mask of DUTY_CHNG_END_CH6_INT_ENA field.
	LEDC_INT_ENA_DUTY_CHNG_END_CH6_INT_ENA_Msk = 0x400
	// Bit DUTY_CHNG_END_CH6_INT_ENA.
	LEDC_INT_ENA_DUTY_CHNG_END_CH6_INT_ENA = 0x400
	// Position of DUTY_CHNG_END_CH7_INT_ENA field.
	LEDC_INT_ENA_DUTY_CHNG_END_CH7_INT_ENA_Pos = 0xb
	// Bit mask of DUTY_CHNG_END_CH7_INT_ENA field.
	LEDC_INT_ENA_DUTY_CHNG_END_CH7_INT_ENA_Msk = 0x800
	// Bit DUTY_CHNG_END_CH7_INT_ENA.
	LEDC_INT_ENA_DUTY_CHNG_END_CH7_INT_ENA = 0x800
	// Position of OVF_CNT_CH0_INT_ENA field.
	LEDC_INT_ENA_OVF_CNT_CH0_INT_ENA_Pos = 0xc
	// Bit mask of OVF_CNT_CH0_INT_ENA field.
	LEDC_INT_ENA_OVF_CNT_CH0_INT_ENA_Msk = 0x1000
	// Bit OVF_CNT_CH0_INT_ENA.
	LEDC_INT_ENA_OVF_CNT_CH0_INT_ENA = 0x1000
	// Position of OVF_CNT_CH1_INT_ENA field.
	LEDC_INT_ENA_OVF_CNT_CH1_INT_ENA_Pos = 0xd
	// Bit mask of OVF_CNT_CH1_INT_ENA field.
	LEDC_INT_ENA_OVF_CNT_CH1_INT_ENA_Msk = 0x2000
	// Bit OVF_CNT_CH1_INT_ENA.
	LEDC_INT_ENA_OVF_CNT_CH1_INT_ENA = 0x2000
	// Position of OVF_CNT_CH2_INT_ENA field.
	LEDC_INT_ENA_OVF_CNT_CH2_INT_ENA_Pos = 0xe
	// Bit mask of OVF_CNT_CH2_INT_ENA field.
	LEDC_INT_ENA_OVF_CNT_CH2_INT_ENA_Msk = 0x4000
	// Bit OVF_CNT_CH2_INT_ENA.
	LEDC_INT_ENA_OVF_CNT_CH2_INT_ENA = 0x4000
	// Position of OVF_CNT_CH3_INT_ENA field.
	LEDC_INT_ENA_OVF_CNT_CH3_INT_ENA_Pos = 0xf
	// Bit mask of OVF_CNT_CH3_INT_ENA field.
	LEDC_INT_ENA_OVF_CNT_CH3_INT_ENA_Msk = 0x8000
	// Bit OVF_CNT_CH3_INT_ENA.
	LEDC_INT_ENA_OVF_CNT_CH3_INT_ENA = 0x8000
	// Position of OVF_CNT_CH4_INT_ENA field.
	LEDC_INT_ENA_OVF_CNT_CH4_INT_ENA_Pos = 0x10
	// Bit mask of OVF_CNT_CH4_INT_ENA field.
	LEDC_INT_ENA_OVF_CNT_CH4_INT_ENA_Msk = 0x10000
	// Bit OVF_CNT_CH4_INT_ENA.
	LEDC_INT_ENA_OVF_CNT_CH4_INT_ENA = 0x10000
	// Position of OVF_CNT_CH5_INT_ENA field.
	LEDC_INT_ENA_OVF_CNT_CH5_INT_ENA_Pos = 0x11
	// Bit mask of OVF_CNT_CH5_INT_ENA field.
	LEDC_INT_ENA_OVF_CNT_CH5_INT_ENA_Msk = 0x20000
	// Bit OVF_CNT_CH5_INT_ENA.
	LEDC_INT_ENA_OVF_CNT_CH5_INT_ENA = 0x20000
	// Position of OVF_CNT_CH6_INT_ENA field.
	LEDC_INT_ENA_OVF_CNT_CH6_INT_ENA_Pos = 0x12
	// Bit mask of OVF_CNT_CH6_INT_ENA field.
	LEDC_INT_ENA_OVF_CNT_CH6_INT_ENA_Msk = 0x40000
	// Bit OVF_CNT_CH6_INT_ENA.
	LEDC_INT_ENA_OVF_CNT_CH6_INT_ENA = 0x40000
	// Position of OVF_CNT_CH7_INT_ENA field.
	LEDC_INT_ENA_OVF_CNT_CH7_INT_ENA_Pos = 0x13
	// Bit mask of OVF_CNT_CH7_INT_ENA field.
	LEDC_INT_ENA_OVF_CNT_CH7_INT_ENA_Msk = 0x80000
	// Bit OVF_CNT_CH7_INT_ENA.
	LEDC_INT_ENA_OVF_CNT_CH7_INT_ENA = 0x80000

	// INT_CLR: Interrupt clear bits
	// Position of TIMER0_OVF_INT_CLR field.
	LEDC_INT_CLR_TIMER0_OVF_INT_CLR_Pos = 0x0
	// Bit mask of TIMER0_OVF_INT_CLR field.
	LEDC_INT_CLR_TIMER0_OVF_INT_CLR_Msk = 0x1
	// Bit TIMER0_OVF_INT_CLR.
	LEDC_INT_CLR_TIMER0_OVF_INT_CLR = 0x1
	// Position of TIMER1_OVF_INT_CLR field.
	LEDC_INT_CLR_TIMER1_OVF_INT_CLR_Pos = 0x1
	// Bit mask of TIMER1_OVF_INT_CLR field.
	LEDC_INT_CLR_TIMER1_OVF_INT_CLR_Msk = 0x2
	// Bit TIMER1_OVF_INT_CLR.
	LEDC_INT_CLR_TIMER1_OVF_INT_CLR = 0x2
	// Position of TIMER2_OVF_INT_CLR field.
	LEDC_INT_CLR_TIMER2_OVF_INT_CLR_Pos = 0x2
	// Bit mask of TIMER2_OVF_INT_CLR field.
	LEDC_INT_CLR_TIMER2_OVF_INT_CLR_Msk = 0x4
	// Bit TIMER2_OVF_INT_CLR.
	LEDC_INT_CLR_TIMER2_OVF_INT_CLR = 0x4
	// Position of TIMER3_OVF_INT_CLR field.
	LEDC_INT_CLR_TIMER3_OVF_INT_CLR_Pos = 0x3
	// Bit mask of TIMER3_OVF_INT_CLR field.
	LEDC_INT_CLR_TIMER3_OVF_INT_CLR_Msk = 0x8
	// Bit TIMER3_OVF_INT_CLR.
	LEDC_INT_CLR_TIMER3_OVF_INT_CLR = 0x8
	// Position of DUTY_CHNG_END_CH0_INT_CLR field.
	LEDC_INT_CLR_DUTY_CHNG_END_CH0_INT_CLR_Pos = 0x4
	// Bit mask of DUTY_CHNG_END_CH0_INT_CLR field.
	LEDC_INT_CLR_DUTY_CHNG_END_CH0_INT_CLR_Msk = 0x10
	// Bit DUTY_CHNG_END_CH0_INT_CLR.
	LEDC_INT_CLR_DUTY_CHNG_END_CH0_INT_CLR = 0x10
	// Position of DUTY_CHNG_END_CH1_INT_CLR field.
	LEDC_INT_CLR_DUTY_CHNG_END_CH1_INT_CLR_Pos = 0x5
	// Bit mask of DUTY_CHNG_END_CH1_INT_CLR field.
	LEDC_INT_CLR_DUTY_CHNG_END_CH1_INT_CLR_Msk = 0x20
	// Bit DUTY_CHNG_END_CH1_INT_CLR.
	LEDC_INT_CLR_DUTY_CHNG_END_CH1_INT_CLR = 0x20
	// Position of DUTY_CHNG_END_CH2_INT_CLR field.
	LEDC_INT_CLR_DUTY_CHNG_END_CH2_INT_CLR_Pos = 0x6
	// Bit mask of DUTY_CHNG_END_CH2_INT_CLR field.
	LEDC_INT_CLR_DUTY_CHNG_END_CH2_INT_CLR_Msk = 0x40
	// Bit DUTY_CHNG_END_CH2_INT_CLR.
	LEDC_INT_CLR_DUTY_CHNG_END_CH2_INT_CLR = 0x40
	// Position of DUTY_CHNG_END_CH3_INT_CLR field.
	LEDC_INT_CLR_DUTY_CHNG_END_CH3_INT_CLR_Pos = 0x7
	// Bit mask of DUTY_CHNG_END_CH3_INT_CLR field.
	LEDC_INT_CLR_DUTY_CHNG_END_CH3_INT_CLR_Msk = 0x80
	// Bit DUTY_CHNG_END_CH3_INT_CLR.
	LEDC_INT_CLR_DUTY_CHNG_END_CH3_INT_CLR = 0x80
	// Position of DUTY_CHNG_END_CH4_INT_CLR field.
	LEDC_INT_CLR_DUTY_CHNG_END_CH4_INT_CLR_Pos = 0x8
	// Bit mask of DUTY_CHNG_END_CH4_INT_CLR field.
	LEDC_INT_CLR_DUTY_CHNG_END_CH4_INT_CLR_Msk = 0x100
	// Bit DUTY_CHNG_END_CH4_INT_CLR.
	LEDC_INT_CLR_DUTY_CHNG_END_CH4_INT_CLR = 0x100
	// Position of DUTY_CHNG_END_CH5_INT_CLR field.
	LEDC_INT_CLR_DUTY_CHNG_END_CH5_INT_CLR_Pos = 0x9
	// Bit mask of DUTY_CHNG_END_CH5_INT_CLR field.
	LEDC_INT_CLR_DUTY_CHNG_END_CH5_INT_CLR_Msk = 0x200
	// Bit DUTY_CHNG_END_CH5_INT_CLR.
	LEDC_INT_CLR_DUTY_CHNG_END_CH5_INT_CLR = 0x200
	// Position of DUTY_CHNG_END_CH6_INT_CLR field.
	LEDC_INT_CLR_DUTY_CHNG_END_CH6_INT_CLR_Pos = 0xa
	// Bit mask of DUTY_CHNG_END_CH6_INT_CLR field.
	LEDC_INT_CLR_DUTY_CHNG_END_CH6_INT_CLR_Msk = 0x400
	// Bit DUTY_CHNG_END_CH6_INT_CLR.
	LEDC_INT_CLR_DUTY_CHNG_END_CH6_INT_CLR = 0x400
	// Position of DUTY_CHNG_END_CH7_INT_CLR field.
	LEDC_INT_CLR_DUTY_CHNG_END_CH7_INT_CLR_Pos = 0xb
	// Bit mask of DUTY_CHNG_END_CH7_INT_CLR field.
	LEDC_INT_CLR_DUTY_CHNG_END_CH7_INT_CLR_Msk = 0x800
	// Bit DUTY_CHNG_END_CH7_INT_CLR.
	LEDC_INT_CLR_DUTY_CHNG_END_CH7_INT_CLR = 0x800
	// Position of OVF_CNT_CH0_INT_CLR field.
	LEDC_INT_CLR_OVF_CNT_CH0_INT_CLR_Pos = 0xc
	// Bit mask of OVF_CNT_CH0_INT_CLR field.
	LEDC_INT_CLR_OVF_CNT_CH0_INT_CLR_Msk = 0x1000
	// Bit OVF_CNT_CH0_INT_CLR.
	LEDC_INT_CLR_OVF_CNT_CH0_INT_CLR = 0x1000
	// Position of OVF_CNT_CH1_INT_CLR field.
	LEDC_INT_CLR_OVF_CNT_CH1_INT_CLR_Pos = 0xd
	// Bit mask of OVF_CNT_CH1_INT_CLR field.
	LEDC_INT_CLR_OVF_CNT_CH1_INT_CLR_Msk = 0x2000
	// Bit OVF_CNT_CH1_INT_CLR.
	LEDC_INT_CLR_OVF_CNT_CH1_INT_CLR = 0x2000
	// Position of OVF_CNT_CH2_INT_CLR field.
	LEDC_INT_CLR_OVF_CNT_CH2_INT_CLR_Pos = 0xe
	// Bit mask of OVF_CNT_CH2_INT_CLR field.
	LEDC_INT_CLR_OVF_CNT_CH2_INT_CLR_Msk = 0x4000
	// Bit OVF_CNT_CH2_INT_CLR.
	LEDC_INT_CLR_OVF_CNT_CH2_INT_CLR = 0x4000
	// Position of OVF_CNT_CH3_INT_CLR field.
	LEDC_INT_CLR_OVF_CNT_CH3_INT_CLR_Pos = 0xf
	// Bit mask of OVF_CNT_CH3_INT_CLR field.
	LEDC_INT_CLR_OVF_CNT_CH3_INT_CLR_Msk = 0x8000
	// Bit OVF_CNT_CH3_INT_CLR.
	LEDC_INT_CLR_OVF_CNT_CH3_INT_CLR = 0x8000
	// Position of OVF_CNT_CH4_INT_CLR field.
	LEDC_INT_CLR_OVF_CNT_CH4_INT_CLR_Pos = 0x10
	// Bit mask of OVF_CNT_CH4_INT_CLR field.
	LEDC_INT_CLR_OVF_CNT_CH4_INT_CLR_Msk = 0x10000
	// Bit OVF_CNT_CH4_INT_CLR.
	LEDC_INT_CLR_OVF_CNT_CH4_INT_CLR = 0x10000
	// Position of OVF_CNT_CH5_INT_CLR field.
	LEDC_INT_CLR_OVF_CNT_CH5_INT_CLR_Pos = 0x11
	// Bit mask of OVF_CNT_CH5_INT_CLR field.
	LEDC_INT_CLR_OVF_CNT_CH5_INT_CLR_Msk = 0x20000
	// Bit OVF_CNT_CH5_INT_CLR.
	LEDC_INT_CLR_OVF_CNT_CH5_INT_CLR = 0x20000
	// Position of OVF_CNT_CH6_INT_CLR field.
	LEDC_INT_CLR_OVF_CNT_CH6_INT_CLR_Pos = 0x12
	// Bit mask of OVF_CNT_CH6_INT_CLR field.
	LEDC_INT_CLR_OVF_CNT_CH6_INT_CLR_Msk = 0x40000
	// Bit OVF_CNT_CH6_INT_CLR.
	LEDC_INT_CLR_OVF_CNT_CH6_INT_CLR = 0x40000
	// Position of OVF_CNT_CH7_INT_CLR field.
	LEDC_INT_CLR_OVF_CNT_CH7_INT_CLR_Pos = 0x13
	// Bit mask of OVF_CNT_CH7_INT_CLR field.
	LEDC_INT_CLR_OVF_CNT_CH7_INT_CLR_Msk = 0x80000
	// Bit OVF_CNT_CH7_INT_CLR.
	LEDC_INT_CLR_OVF_CNT_CH7_INT_CLR = 0x80000

	// CONF: Global ledc configuration register
	// Position of APB_CLK_SEL field.
	LEDC_CONF_APB_CLK_SEL_Pos = 0x0
	// Bit mask of APB_CLK_SEL field.
	LEDC_CONF_APB_CLK_SEL_Msk = 0x3
	// Position of CLK_EN field.
	LEDC_CONF_CLK_EN_Pos = 0x1f
	// Bit mask of CLK_EN field.
	LEDC_CONF_CLK_EN_Msk = 0x80000000
	// Bit CLK_EN.
	LEDC_CONF_CLK_EN = 0x80000000

	// DATE: Version control register
	// Position of DATE field.
	LEDC_DATE_DATE_Pos = 0x0
	// Bit mask of DATE field.
	LEDC_DATE_DATE_Msk = 0xffffffff
)

// Constants for PCNT: Peripheral PCNT
const (
	// U0_CONF0: Configuration register 0 for unit %s
	// Position of FILTER_THRES_U field.
	PCNT_U_CONF0_FILTER_THRES_U_Pos = 0x0
	// Bit mask of FILTER_THRES_U field.
	PCNT_U_CONF0_FILTER_THRES_U_Msk = 0x3ff
	// Position of FILTER_EN_U field.
	PCNT_U_CONF0_FILTER_EN_U_Pos = 0xa
	// Bit mask of FILTER_EN_U field.
	PCNT_U_CONF0_FILTER_EN_U_Msk = 0x400
	// Bit FILTER_EN_U.
	PCNT_U_CONF0_FILTER_EN_U = 0x400
	// Position of THR_ZERO_EN_U field.
	PCNT_U_CONF0_THR_ZERO_EN_U_Pos = 0xb
	// Bit mask of THR_ZERO_EN_U field.
	PCNT_U_CONF0_THR_ZERO_EN_U_Msk = 0x800
	// Bit THR_ZERO_EN_U.
	PCNT_U_CONF0_THR_ZERO_EN_U = 0x800
	// Position of THR_H_LIM_EN_U field.
	PCNT_U_CONF0_THR_H_LIM_EN_U_Pos = 0xc
	// Bit mask of THR_H_LIM_EN_U field.
	PCNT_U_CONF0_THR_H_LIM_EN_U_Msk = 0x1000
	// Bit THR_H_LIM_EN_U.
	PCNT_U_CONF0_THR_H_LIM_EN_U = 0x1000
	// Position of THR_L_LIM_EN_U field.
	PCNT_U_CONF0_THR_L_LIM_EN_U_Pos = 0xd
	// Bit mask of THR_L_LIM_EN_U field.
	PCNT_U_CONF0_THR_L_LIM_EN_U_Msk = 0x2000
	// Bit THR_L_LIM_EN_U.
	PCNT_U_CONF0_THR_L_LIM_EN_U = 0x2000
	// Position of THR_THRES0_EN_U field.
	PCNT_U_CONF0_THR_THRES0_EN_U_Pos = 0xe
	// Bit mask of THR_THRES0_EN_U field.
	PCNT_U_CONF0_THR_THRES0_EN_U_Msk = 0x4000
	// Bit THR_THRES0_EN_U.
	PCNT_U_CONF0_THR_THRES0_EN_U = 0x4000
	// Position of THR_THRES1_EN_U field.
	PCNT_U_CONF0_THR_THRES1_EN_U_Pos = 0xf
	// Bit mask of THR_THRES1_EN_U field.
	PCNT_U_CONF0_THR_THRES1_EN_U_Msk = 0x8000
	// Bit THR_THRES1_EN_U.
	PCNT_U_CONF0_THR_THRES1_EN_U = 0x8000
	// Position of CH0_NEG_MODE_U field.
	PCNT_U_CONF0_CH0_NEG_MODE_U_Pos = 0x10
	// Bit mask of CH0_NEG_MODE_U field.
	PCNT_U_CONF0_CH0_NEG_MODE_U_Msk = 0x30000
	// Position of CH0_POS_MODE_U field.
	PCNT_U_CONF0_CH0_POS_MODE_U_Pos = 0x12
	// Bit mask of CH0_POS_MODE_U field.
	PCNT_U_CONF0_CH0_POS_MODE_U_Msk = 0xc0000
	// Position of CH0_HCTRL_MODE_U field.
	PCNT_U_CONF0_CH0_HCTRL_MODE_U_Pos = 0x14
	// Bit mask of CH0_HCTRL_MODE_U field.
	PCNT_U_CONF0_CH0_HCTRL_MODE_U_Msk = 0x300000
	// Position of CH0_LCTRL_MODE_U field.
	PCNT_U_CONF0_CH0_LCTRL_MODE_U_Pos = 0x16
	// Bit mask of CH0_LCTRL_MODE_U field.
	PCNT_U_CONF0_CH0_LCTRL_MODE_U_Msk = 0xc00000
	// Position of CH1_NEG_MODE_U field.
	PCNT_U_CONF0_CH1_NEG_MODE_U_Pos = 0x18
	// Bit mask of CH1_NEG_MODE_U field.
	PCNT_U_CONF0_CH1_NEG_MODE_U_Msk = 0x3000000
	// Position of CH1_POS_MODE_U field.
	PCNT_U_CONF0_CH1_POS_MODE_U_Pos = 0x1a
	// Bit mask of CH1_POS_MODE_U field.
	PCNT_U_CONF0_CH1_POS_MODE_U_Msk = 0xc000000
	// Position of CH1_HCTRL_MODE_U field.
	PCNT_U_CONF0_CH1_HCTRL_MODE_U_Pos = 0x1c
	// Bit mask of CH1_HCTRL_MODE_U field.
	PCNT_U_CONF0_CH1_HCTRL_MODE_U_Msk = 0x30000000
	// Position of CH1_LCTRL_MODE_U field.
	PCNT_U_CONF0_CH1_LCTRL_MODE_U_Pos = 0x1e
	// Bit mask of CH1_LCTRL_MODE_U field.
	PCNT_U_CONF0_CH1_LCTRL_MODE_U_Msk = 0xc0000000

	// U0_CONF1: Configuration register 1 for unit %s
	// Position of CNT_THRES0_U field.
	PCNT_U_CONF1_CNT_THRES0_U_Pos = 0x0
	// Bit mask of CNT_THRES0_U field.
	PCNT_U_CONF1_CNT_THRES0_U_Msk = 0xffff
	// Position of CNT_THRES1_U field.
	PCNT_U_CONF1_CNT_THRES1_U_Pos = 0x10
	// Bit mask of CNT_THRES1_U field.
	PCNT_U_CONF1_CNT_THRES1_U_Msk = 0xffff0000

	// U0_CONF2: Configuration register 2 for unit %s
	// Position of CNT_H_LIM_U field.
	PCNT_U_CONF2_CNT_H_LIM_U_Pos = 0x0
	// Bit mask of CNT_H_LIM_U field.
	PCNT_U_CONF2_CNT_H_LIM_U_Msk = 0xffff
	// Position of CNT_L_LIM_U field.
	PCNT_U_CONF2_CNT_L_LIM_U_Pos = 0x10
	// Bit mask of CNT_L_LIM_U field.
	PCNT_U_CONF2_CNT_L_LIM_U_Msk = 0xffff0000

	// U0_CNT: Counter value for unit %s
	// Position of PULSE_CNT_U field.
	PCNT_U_CNT_PULSE_CNT_U_Pos = 0x0
	// Bit mask of PULSE_CNT_U field.
	PCNT_U_CNT_PULSE_CNT_U_Msk = 0xffff

	// INT_RAW: Interrupt raw status register
	// Position of CNT_THR_EVENT_U0_INT_RAW field.
	PCNT_INT_RAW_CNT_THR_EVENT_U0_INT_RAW_Pos = 0x0
	// Bit mask of CNT_THR_EVENT_U0_INT_RAW field.
	PCNT_INT_RAW_CNT_THR_EVENT_U0_INT_RAW_Msk = 0x1
	// Bit CNT_THR_EVENT_U0_INT_RAW.
	PCNT_INT_RAW_CNT_THR_EVENT_U0_INT_RAW = 0x1
	// Position of CNT_THR_EVENT_U1_INT_RAW field.
	PCNT_INT_RAW_CNT_THR_EVENT_U1_INT_RAW_Pos = 0x1
	// Bit mask of CNT_THR_EVENT_U1_INT_RAW field.
	PCNT_INT_RAW_CNT_THR_EVENT_U1_INT_RAW_Msk = 0x2
	// Bit CNT_THR_EVENT_U1_INT_RAW.
	PCNT_INT_RAW_CNT_THR_EVENT_U1_INT_RAW = 0x2
	// Position of CNT_THR_EVENT_U2_INT_RAW field.
	PCNT_INT_RAW_CNT_THR_EVENT_U2_INT_RAW_Pos = 0x2
	// Bit mask of CNT_THR_EVENT_U2_INT_RAW field.
	PCNT_INT_RAW_CNT_THR_EVENT_U2_INT_RAW_Msk = 0x4
	// Bit CNT_THR_EVENT_U2_INT_RAW.
	PCNT_INT_RAW_CNT_THR_EVENT_U2_INT_RAW = 0x4
	// Position of CNT_THR_EVENT_U3_INT_RAW field.
	PCNT_INT_RAW_CNT_THR_EVENT_U3_INT_RAW_Pos = 0x3
	// Bit mask of CNT_THR_EVENT_U3_INT_RAW field.
	PCNT_INT_RAW_CNT_THR_EVENT_U3_INT_RAW_Msk = 0x8
	// Bit CNT_THR_EVENT_U3_INT_RAW.
	PCNT_INT_RAW_CNT_THR_EVENT_U3_INT_RAW = 0x8

	// INT_ST: Interrupt status register
	// Position of CNT_THR_EVENT_U0_INT_ST field.
	PCNT_INT_ST_CNT_THR_EVENT_U0_INT_ST_Pos = 0x0
	// Bit mask of CNT_THR_EVENT_U0_INT_ST field.
	PCNT_INT_ST_CNT_THR_EVENT_U0_INT_ST_Msk = 0x1
	// Bit CNT_THR_EVENT_U0_INT_ST.
	PCNT_INT_ST_CNT_THR_EVENT_U0_INT_ST = 0x1
	// Position of CNT_THR_EVENT_U1_INT_ST field.
	PCNT_INT_ST_CNT_THR_EVENT_U1_INT_ST_Pos = 0x1
	// Bit mask of CNT_THR_EVENT_U1_INT_ST field.
	PCNT_INT_ST_CNT_THR_EVENT_U1_INT_ST_Msk = 0x2
	// Bit CNT_THR_EVENT_U1_INT_ST.
	PCNT_INT_ST_CNT_THR_EVENT_U1_INT_ST = 0x2
	// Position of CNT_THR_EVENT_U2_INT_ST field.
	PCNT_INT_ST_CNT_THR_EVENT_U2_INT_ST_Pos = 0x2
	// Bit mask of CNT_THR_EVENT_U2_INT_ST field.
	PCNT_INT_ST_CNT_THR_EVENT_U2_INT_ST_Msk = 0x4
	// Bit CNT_THR_EVENT_U2_INT_ST.
	PCNT_INT_ST_CNT_THR_EVENT_U2_INT_ST = 0x4
	// Position of CNT_THR_EVENT_U3_INT_ST field.
	PCNT_INT_ST_CNT_THR_EVENT_U3_INT_ST_Pos = 0x3
	// Bit mask of CNT_THR_EVENT_U3_INT_ST field.
	PCNT_INT_ST_CNT_THR_EVENT_U3_INT_ST_Msk = 0x8
	// Bit CNT_THR_EVENT_U3_INT_ST.
	PCNT_INT_ST_CNT_THR_EVENT_U3_INT_ST = 0x8

	// INT_ENA: Interrupt enable register
	// Position of CNT_THR_EVENT_U0_INT_ENA field.
	PCNT_INT_ENA_CNT_THR_EVENT_U0_INT_ENA_Pos = 0x0
	// Bit mask of CNT_THR_EVENT_U0_INT_ENA field.
	PCNT_INT_ENA_CNT_THR_EVENT_U0_INT_ENA_Msk = 0x1
	// Bit CNT_THR_EVENT_U0_INT_ENA.
	PCNT_INT_ENA_CNT_THR_EVENT_U0_INT_ENA = 0x1
	// Position of CNT_THR_EVENT_U1_INT_ENA field.
	PCNT_INT_ENA_CNT_THR_EVENT_U1_INT_ENA_Pos = 0x1
	// Bit mask of CNT_THR_EVENT_U1_INT_ENA field.
	PCNT_INT_ENA_CNT_THR_EVENT_U1_INT_ENA_Msk = 0x2
	// Bit CNT_THR_EVENT_U1_INT_ENA.
	PCNT_INT_ENA_CNT_THR_EVENT_U1_INT_ENA = 0x2
	// Position of CNT_THR_EVENT_U2_INT_ENA field.
	PCNT_INT_ENA_CNT_THR_EVENT_U2_INT_ENA_Pos = 0x2
	// Bit mask of CNT_THR_EVENT_U2_INT_ENA field.
	PCNT_INT_ENA_CNT_THR_EVENT_U2_INT_ENA_Msk = 0x4
	// Bit CNT_THR_EVENT_U2_INT_ENA.
	PCNT_INT_ENA_CNT_THR_EVENT_U2_INT_ENA = 0x4
	// Position of CNT_THR_EVENT_U3_INT_ENA field.
	PCNT_INT_ENA_CNT_THR_EVENT_U3_INT_ENA_Pos = 0x3
	// Bit mask of CNT_THR_EVENT_U3_INT_ENA field.
	PCNT_INT_ENA_CNT_THR_EVENT_U3_INT_ENA_Msk = 0x8
	// Bit CNT_THR_EVENT_U3_INT_ENA.
	PCNT_INT_ENA_CNT_THR_EVENT_U3_INT_ENA = 0x8

	// INT_CLR: Interrupt clear register
	// Position of CNT_THR_EVENT_U0_INT_CLR field.
	PCNT_INT_CLR_CNT_THR_EVENT_U0_INT_CLR_Pos = 0x0
	// Bit mask of CNT_THR_EVENT_U0_INT_CLR field.
	PCNT_INT_CLR_CNT_THR_EVENT_U0_INT_CLR_Msk = 0x1
	// Bit CNT_THR_EVENT_U0_INT_CLR.
	PCNT_INT_CLR_CNT_THR_EVENT_U0_INT_CLR = 0x1
	// Position of CNT_THR_EVENT_U1_INT_CLR field.
	PCNT_INT_CLR_CNT_THR_EVENT_U1_INT_CLR_Pos = 0x1
	// Bit mask of CNT_THR_EVENT_U1_INT_CLR field.
	PCNT_INT_CLR_CNT_THR_EVENT_U1_INT_CLR_Msk = 0x2
	// Bit CNT_THR_EVENT_U1_INT_CLR.
	PCNT_INT_CLR_CNT_THR_EVENT_U1_INT_CLR = 0x2
	// Position of CNT_THR_EVENT_U2_INT_CLR field.
	PCNT_INT_CLR_CNT_THR_EVENT_U2_INT_CLR_Pos = 0x2
	// Bit mask of CNT_THR_EVENT_U2_INT_CLR field.
	PCNT_INT_CLR_CNT_THR_EVENT_U2_INT_CLR_Msk = 0x4
	// Bit CNT_THR_EVENT_U2_INT_CLR.
	PCNT_INT_CLR_CNT_THR_EVENT_U2_INT_CLR = 0x4
	// Position of CNT_THR_EVENT_U3_INT_CLR field.
	PCNT_INT_CLR_CNT_THR_EVENT_U3_INT_CLR_Pos = 0x3
	// Bit mask of CNT_THR_EVENT_U3_INT_CLR field.
	PCNT_INT_CLR_CNT_THR_EVENT_U3_INT_CLR_Msk = 0x8
	// Bit CNT_THR_EVENT_U3_INT_CLR.
	PCNT_INT_CLR_CNT_THR_EVENT_U3_INT_CLR = 0x8

	// U0_STATUS: PNCT UNIT%s status register
	// Position of CNT_THR_ZERO_MODE_U field.
	PCNT_U_STATUS_CNT_THR_ZERO_MODE_U_Pos = 0x0
	// Bit mask of CNT_THR_ZERO_MODE_U field.
	PCNT_U_STATUS_CNT_THR_ZERO_MODE_U_Msk = 0x3
	// Position of CNT_THR_THRES1_LAT_U field.
	PCNT_U_STATUS_CNT_THR_THRES1_LAT_U_Pos = 0x2
	// Bit mask of CNT_THR_THRES1_LAT_U field.
	PCNT_U_STATUS_CNT_THR_THRES1_LAT_U_Msk = 0x4
	// Bit CNT_THR_THRES1_LAT_U.
	PCNT_U_STATUS_CNT_THR_THRES1_LAT_U = 0x4
	// Position of CNT_THR_THRES0_LAT_U field.
	PCNT_U_STATUS_CNT_THR_THRES0_LAT_U_Pos = 0x3
	// Bit mask of CNT_THR_THRES0_LAT_U field.
	PCNT_U_STATUS_CNT_THR_THRES0_LAT_U_Msk = 0x8
	// Bit CNT_THR_THRES0_LAT_U.
	PCNT_U_STATUS_CNT_THR_THRES0_LAT_U = 0x8
	// Position of CNT_THR_L_LIM_LAT_U field.
	PCNT_U_STATUS_CNT_THR_L_LIM_LAT_U_Pos = 0x4
	// Bit mask of CNT_THR_L_LIM_LAT_U field.
	PCNT_U_STATUS_CNT_THR_L_LIM_LAT_U_Msk = 0x10
	// Bit CNT_THR_L_LIM_LAT_U.
	PCNT_U_STATUS_CNT_THR_L_LIM_LAT_U = 0x10
	// Position of CNT_THR_H_LIM_LAT_U field.
	PCNT_U_STATUS_CNT_THR_H_LIM_LAT_U_Pos = 0x5
	// Bit mask of CNT_THR_H_LIM_LAT_U field.
	PCNT_U_STATUS_CNT_THR_H_LIM_LAT_U_Msk = 0x20
	// Bit CNT_THR_H_LIM_LAT_U.
	PCNT_U_STATUS_CNT_THR_H_LIM_LAT_U = 0x20
	// Position of CNT_THR_ZERO_LAT_U field.
	PCNT_U_STATUS_CNT_THR_ZERO_LAT_U_Pos = 0x6
	// Bit mask of CNT_THR_ZERO_LAT_U field.
	PCNT_U_STATUS_CNT_THR_ZERO_LAT_U_Msk = 0x40
	// Bit CNT_THR_ZERO_LAT_U.
	PCNT_U_STATUS_CNT_THR_ZERO_LAT_U = 0x40

	// CTRL: Control register for all counters
	// Position of PULSE_CNT_RST_U0 field.
	PCNT_CTRL_PULSE_CNT_RST_U0_Pos = 0x0
	// Bit mask of PULSE_CNT_RST_U0 field.
	PCNT_CTRL_PULSE_CNT_RST_U0_Msk = 0x1
	// Bit PULSE_CNT_RST_U0.
	PCNT_CTRL_PULSE_CNT_RST_U0 = 0x1
	// Position of CNT_PAUSE_U0 field.
	PCNT_CTRL_CNT_PAUSE_U0_Pos = 0x1
	// Bit mask of CNT_PAUSE_U0 field.
	PCNT_CTRL_CNT_PAUSE_U0_Msk = 0x2
	// Bit CNT_PAUSE_U0.
	PCNT_CTRL_CNT_PAUSE_U0 = 0x2
	// Position of PULSE_CNT_RST_U1 field.
	PCNT_CTRL_PULSE_CNT_RST_U1_Pos = 0x2
	// Bit mask of PULSE_CNT_RST_U1 field.
	PCNT_CTRL_PULSE_CNT_RST_U1_Msk = 0x4
	// Bit PULSE_CNT_RST_U1.
	PCNT_CTRL_PULSE_CNT_RST_U1 = 0x4
	// Position of CNT_PAUSE_U1 field.
	PCNT_CTRL_CNT_PAUSE_U1_Pos = 0x3
	// Bit mask of CNT_PAUSE_U1 field.
	PCNT_CTRL_CNT_PAUSE_U1_Msk = 0x8
	// Bit CNT_PAUSE_U1.
	PCNT_CTRL_CNT_PAUSE_U1 = 0x8
	// Position of PULSE_CNT_RST_U2 field.
	PCNT_CTRL_PULSE_CNT_RST_U2_Pos = 0x4
	// Bit mask of PULSE_CNT_RST_U2 field.
	PCNT_CTRL_PULSE_CNT_RST_U2_Msk = 0x10
	// Bit PULSE_CNT_RST_U2.
	PCNT_CTRL_PULSE_CNT_RST_U2 = 0x10
	// Position of CNT_PAUSE_U2 field.
	PCNT_CTRL_CNT_PAUSE_U2_Pos = 0x5
	// Bit mask of CNT_PAUSE_U2 field.
	PCNT_CTRL_CNT_PAUSE_U2_Msk = 0x20
	// Bit CNT_PAUSE_U2.
	PCNT_CTRL_CNT_PAUSE_U2 = 0x20
	// Position of PULSE_CNT_RST_U3 field.
	PCNT_CTRL_PULSE_CNT_RST_U3_Pos = 0x6
	// Bit mask of PULSE_CNT_RST_U3 field.
	PCNT_CTRL_PULSE_CNT_RST_U3_Msk = 0x40
	// Bit PULSE_CNT_RST_U3.
	PCNT_CTRL_PULSE_CNT_RST_U3 = 0x40
	// Position of CNT_PAUSE_U3 field.
	PCNT_CTRL_CNT_PAUSE_U3_Pos = 0x7
	// Bit mask of CNT_PAUSE_U3 field.
	PCNT_CTRL_CNT_PAUSE_U3_Msk = 0x80
	// Bit CNT_PAUSE_U3.
	PCNT_CTRL_CNT_PAUSE_U3 = 0x80
	// Position of CLK_EN field.
	PCNT_CTRL_CLK_EN_Pos = 0x10
	// Bit mask of CLK_EN field.
	PCNT_CTRL_CLK_EN_Msk = 0x10000
	// Bit CLK_EN.
	PCNT_CTRL_CLK_EN = 0x10000

	// DATE: PCNT version control register
	// Position of DATE field.
	PCNT_DATE_DATE_Pos = 0x0
	// Bit mask of DATE field.
	PCNT_DATE_DATE_Msk = 0xffffffff
)

// Constants for RMT: Peripheral RMT
const (
	// CH0DATA: The read and write data register for CHANNEL%s by apb fifo access.
	// Position of CH_DATA field.
	RMT_CHDATA_CH_DATA_Pos = 0x0
	// Bit mask of CH_DATA field.
	RMT_CHDATA_CH_DATA_Msk = 0xffffffff

	// CH0CONF0: Channel %s configure register 0
	// Position of DIV_CNT_CH field.
	RMT_CHCONF0_DIV_CNT_CH_Pos = 0x0
	// Bit mask of DIV_CNT_CH field.
	RMT_CHCONF0_DIV_CNT_CH_Msk = 0xff
	// Position of IDLE_THRES_CH field.
	RMT_CHCONF0_IDLE_THRES_CH_Pos = 0x8
	// Bit mask of IDLE_THRES_CH field.
	RMT_CHCONF0_IDLE_THRES_CH_Msk = 0xffff00
	// Position of MEM_SIZE_CH field.
	RMT_CHCONF0_MEM_SIZE_CH_Pos = 0x18
	// Bit mask of MEM_SIZE_CH field.
	RMT_CHCONF0_MEM_SIZE_CH_Msk = 0x7000000
	// Position of CARRIER_EFF_EN_CH field.
	RMT_CHCONF0_CARRIER_EFF_EN_CH_Pos = 0x1b
	// Bit mask of CARRIER_EFF_EN_CH field.
	RMT_CHCONF0_CARRIER_EFF_EN_CH_Msk = 0x8000000
	// Bit CARRIER_EFF_EN_CH.
	RMT_CHCONF0_CARRIER_EFF_EN_CH = 0x8000000
	// Position of CARRIER_EN_CH field.
	RMT_CHCONF0_CARRIER_EN_CH_Pos = 0x1c
	// Bit mask of CARRIER_EN_CH field.
	RMT_CHCONF0_CARRIER_EN_CH_Msk = 0x10000000
	// Bit CARRIER_EN_CH.
	RMT_CHCONF0_CARRIER_EN_CH = 0x10000000
	// Position of CARRIER_OUT_LV_CH field.
	RMT_CHCONF0_CARRIER_OUT_LV_CH_Pos = 0x1d
	// Bit mask of CARRIER_OUT_LV_CH field.
	RMT_CHCONF0_CARRIER_OUT_LV_CH_Msk = 0x20000000
	// Bit CARRIER_OUT_LV_CH.
	RMT_CHCONF0_CARRIER_OUT_LV_CH = 0x20000000

	// CH0CONF1: Channel %s configure register 1
	// Position of TX_START_CH0 field.
	RMT_CHCONF1_TX_START_CH0_Pos = 0x0
	// Bit mask of TX_START_CH0 field.
	RMT_CHCONF1_TX_START_CH0_Msk = 0x1
	// Bit TX_START_CH0.
	RMT_CHCONF1_TX_START_CH0 = 0x1
	// Position of RX_EN_CH0 field.
	RMT_CHCONF1_RX_EN_CH0_Pos = 0x1
	// Bit mask of RX_EN_CH0 field.
	RMT_CHCONF1_RX_EN_CH0_Msk = 0x2
	// Bit RX_EN_CH0.
	RMT_CHCONF1_RX_EN_CH0 = 0x2
	// Position of MEM_WR_RST_CH0 field.
	RMT_CHCONF1_MEM_WR_RST_CH0_Pos = 0x2
	// Bit mask of MEM_WR_RST_CH0 field.
	RMT_CHCONF1_MEM_WR_RST_CH0_Msk = 0x4
	// Bit MEM_WR_RST_CH0.
	RMT_CHCONF1_MEM_WR_RST_CH0 = 0x4
	// Position of MEM_RD_RST_CH0 field.
	RMT_CHCONF1_MEM_RD_RST_CH0_Pos = 0x3
	// Bit mask of MEM_RD_RST_CH0 field.
	RMT_CHCONF1_MEM_RD_RST_CH0_Msk = 0x8
	// Bit MEM_RD_RST_CH0.
	RMT_CHCONF1_MEM_RD_RST_CH0 = 0x8
	// Position of APB_MEM_RST_CH0 field.
	RMT_CHCONF1_APB_MEM_RST_CH0_Pos = 0x4
	// Bit mask of APB_MEM_RST_CH0 field.
	RMT_CHCONF1_APB_MEM_RST_CH0_Msk = 0x10
	// Bit APB_MEM_RST_CH0.
	RMT_CHCONF1_APB_MEM_RST_CH0 = 0x10
	// Position of MEM_OWNER_CH0 field.
	RMT_CHCONF1_MEM_OWNER_CH0_Pos = 0x5
	// Bit mask of MEM_OWNER_CH0 field.
	RMT_CHCONF1_MEM_OWNER_CH0_Msk = 0x20
	// Bit MEM_OWNER_CH0.
	RMT_CHCONF1_MEM_OWNER_CH0 = 0x20
	// Position of TX_CONTI_MODE_CH0 field.
	RMT_CHCONF1_TX_CONTI_MODE_CH0_Pos = 0x6
	// Bit mask of TX_CONTI_MODE_CH0 field.
	RMT_CHCONF1_TX_CONTI_MODE_CH0_Msk = 0x40
	// Bit TX_CONTI_MODE_CH0.
	RMT_CHCONF1_TX_CONTI_MODE_CH0 = 0x40
	// Position of RX_FILTER_EN_CH0 field.
	RMT_CHCONF1_RX_FILTER_EN_CH0_Pos = 0x7
	// Bit mask of RX_FILTER_EN_CH0 field.
	RMT_CHCONF1_RX_FILTER_EN_CH0_Msk = 0x80
	// Bit RX_FILTER_EN_CH0.
	RMT_CHCONF1_RX_FILTER_EN_CH0 = 0x80
	// Position of RX_FILTER_THRES_CH0 field.
	RMT_CHCONF1_RX_FILTER_THRES_CH0_Pos = 0x8
	// Bit mask of RX_FILTER_THRES_CH0 field.
	RMT_CHCONF1_RX_FILTER_THRES_CH0_Msk = 0xff00
	// Position of CHK_RX_CARRIER_EN_CH0 field.
	RMT_CHCONF1_CHK_RX_CARRIER_EN_CH0_Pos = 0x10
	// Bit mask of CHK_RX_CARRIER_EN_CH0 field.
	RMT_CHCONF1_CHK_RX_CARRIER_EN_CH0_Msk = 0x10000
	// Bit CHK_RX_CARRIER_EN_CH0.
	RMT_CHCONF1_CHK_RX_CARRIER_EN_CH0 = 0x10000
	// Position of REF_ALWAYS_ON_CH0 field.
	RMT_CHCONF1_REF_ALWAYS_ON_CH0_Pos = 0x11
	// Bit mask of REF_ALWAYS_ON_CH0 field.
	RMT_CHCONF1_REF_ALWAYS_ON_CH0_Msk = 0x20000
	// Bit REF_ALWAYS_ON_CH0.
	RMT_CHCONF1_REF_ALWAYS_ON_CH0 = 0x20000
	// Position of IDLE_OUT_LV_CH0 field.
	RMT_CHCONF1_IDLE_OUT_LV_CH0_Pos = 0x12
	// Bit mask of IDLE_OUT_LV_CH0 field.
	RMT_CHCONF1_IDLE_OUT_LV_CH0_Msk = 0x40000
	// Bit IDLE_OUT_LV_CH0.
	RMT_CHCONF1_IDLE_OUT_LV_CH0 = 0x40000
	// Position of IDLE_OUT_EN_CH0 field.
	RMT_CHCONF1_IDLE_OUT_EN_CH0_Pos = 0x13
	// Bit mask of IDLE_OUT_EN_CH0 field.
	RMT_CHCONF1_IDLE_OUT_EN_CH0_Msk = 0x80000
	// Bit IDLE_OUT_EN_CH0.
	RMT_CHCONF1_IDLE_OUT_EN_CH0 = 0x80000
	// Position of TX_STOP_CH0 field.
	RMT_CHCONF1_TX_STOP_CH0_Pos = 0x14
	// Bit mask of TX_STOP_CH0 field.
	RMT_CHCONF1_TX_STOP_CH0_Msk = 0x100000
	// Bit TX_STOP_CH0.
	RMT_CHCONF1_TX_STOP_CH0 = 0x100000

	// CH0STATUS: Channel %s status register
	// Position of MEM_WADDR_EX_CH0 field.
	RMT_CHSTATUS_MEM_WADDR_EX_CH0_Pos = 0x0
	// Bit mask of MEM_WADDR_EX_CH0 field.
	RMT_CHSTATUS_MEM_WADDR_EX_CH0_Msk = 0x1ff
	// Position of MEM_RADDR_EX_CH0 field.
	RMT_CHSTATUS_MEM_RADDR_EX_CH0_Pos = 0xa
	// Bit mask of MEM_RADDR_EX_CH0 field.
	RMT_CHSTATUS_MEM_RADDR_EX_CH0_Msk = 0x7fc00
	// Position of STATE_CH0 field.
	RMT_CHSTATUS_STATE_CH0_Pos = 0x14
	// Bit mask of STATE_CH0 field.
	RMT_CHSTATUS_STATE_CH0_Msk = 0x700000
	// Position of MEM_OWNER_ERR_CH0 field.
	RMT_CHSTATUS_MEM_OWNER_ERR_CH0_Pos = 0x17
	// Bit mask of MEM_OWNER_ERR_CH0 field.
	RMT_CHSTATUS_MEM_OWNER_ERR_CH0_Msk = 0x800000
	// Bit MEM_OWNER_ERR_CH0.
	RMT_CHSTATUS_MEM_OWNER_ERR_CH0 = 0x800000
	// Position of MEM_FULL_CH0 field.
	RMT_CHSTATUS_MEM_FULL_CH0_Pos = 0x18
	// Bit mask of MEM_FULL_CH0 field.
	RMT_CHSTATUS_MEM_FULL_CH0_Msk = 0x1000000
	// Bit MEM_FULL_CH0.
	RMT_CHSTATUS_MEM_FULL_CH0 = 0x1000000
	// Position of MEM_EMPTY_CH0 field.
	RMT_CHSTATUS_MEM_EMPTY_CH0_Pos = 0x19
	// Bit mask of MEM_EMPTY_CH0 field.
	RMT_CHSTATUS_MEM_EMPTY_CH0_Msk = 0x2000000
	// Bit MEM_EMPTY_CH0.
	RMT_CHSTATUS_MEM_EMPTY_CH0 = 0x2000000
	// Position of APB_MEM_WR_ERR_CH0 field.
	RMT_CHSTATUS_APB_MEM_WR_ERR_CH0_Pos = 0x1a
	// Bit mask of APB_MEM_WR_ERR_CH0 field.
	RMT_CHSTATUS_APB_MEM_WR_ERR_CH0_Msk = 0x4000000
	// Bit APB_MEM_WR_ERR_CH0.
	RMT_CHSTATUS_APB_MEM_WR_ERR_CH0 = 0x4000000
	// Position of APB_MEM_RD_ERR_CH0 field.
	RMT_CHSTATUS_APB_MEM_RD_ERR_CH0_Pos = 0x1b
	// Bit mask of APB_MEM_RD_ERR_CH0 field.
	RMT_CHSTATUS_APB_MEM_RD_ERR_CH0_Msk = 0x8000000
	// Bit APB_MEM_RD_ERR_CH0.
	RMT_CHSTATUS_APB_MEM_RD_ERR_CH0 = 0x8000000

	// CH0ADDR: Channel %s address register
	// Position of APB_MEM_WADDR_CH0 field.
	RMT_CHADDR_APB_MEM_WADDR_CH0_Pos = 0x0
	// Bit mask of APB_MEM_WADDR_CH0 field.
	RMT_CHADDR_APB_MEM_WADDR_CH0_Msk = 0x1ff
	// Position of APB_MEM_RADDR_CH0 field.
	RMT_CHADDR_APB_MEM_RADDR_CH0_Pos = 0xa
	// Bit mask of APB_MEM_RADDR_CH0 field.
	RMT_CHADDR_APB_MEM_RADDR_CH0_Msk = 0x7fc00

	// INT_RAW: Raw interrupt status
	// Position of CH0_TX_END_INT_RAW field.
	RMT_INT_RAW_CH0_TX_END_INT_RAW_Pos = 0x0
	// Bit mask of CH0_TX_END_INT_RAW field.
	RMT_INT_RAW_CH0_TX_END_INT_RAW_Msk = 0x1
	// Bit CH0_TX_END_INT_RAW.
	RMT_INT_RAW_CH0_TX_END_INT_RAW = 0x1
	// Position of CH0_RX_END_INT_RAW field.
	RMT_INT_RAW_CH0_RX_END_INT_RAW_Pos = 0x1
	// Bit mask of CH0_RX_END_INT_RAW field.
	RMT_INT_RAW_CH0_RX_END_INT_RAW_Msk = 0x2
	// Bit CH0_RX_END_INT_RAW.
	RMT_INT_RAW_CH0_RX_END_INT_RAW = 0x2
	// Position of CH0_ERR_INT_RAW field.
	RMT_INT_RAW_CH0_ERR_INT_RAW_Pos = 0x2
	// Bit mask of CH0_ERR_INT_RAW field.
	RMT_INT_RAW_CH0_ERR_INT_RAW_Msk = 0x4
	// Bit CH0_ERR_INT_RAW.
	RMT_INT_RAW_CH0_ERR_INT_RAW = 0x4
	// Position of CH1_TX_END_INT_RAW field.
	RMT_INT_RAW_CH1_TX_END_INT_RAW_Pos = 0x3
	// Bit mask of CH1_TX_END_INT_RAW field.
	RMT_INT_RAW_CH1_TX_END_INT_RAW_Msk = 0x8
	// Bit CH1_TX_END_INT_RAW.
	RMT_INT_RAW_CH1_TX_END_INT_RAW = 0x8
	// Position of CH1_RX_END_INT_RAW field.
	RMT_INT_RAW_CH1_RX_END_INT_RAW_Pos = 0x4
	// Bit mask of CH1_RX_END_INT_RAW field.
	RMT_INT_RAW_CH1_RX_END_INT_RAW_Msk = 0x10
	// Bit CH1_RX_END_INT_RAW.
	RMT_INT_RAW_CH1_RX_END_INT_RAW = 0x10
	// Position of CH1_ERR_INT_RAW field.
	RMT_INT_RAW_CH1_ERR_INT_RAW_Pos = 0x5
	// Bit mask of CH1_ERR_INT_RAW field.
	RMT_INT_RAW_CH1_ERR_INT_RAW_Msk = 0x20
	// Bit CH1_ERR_INT_RAW.
	RMT_INT_RAW_CH1_ERR_INT_RAW = 0x20
	// Position of CH2_TX_END_INT_RAW field.
	RMT_INT_RAW_CH2_TX_END_INT_RAW_Pos = 0x6
	// Bit mask of CH2_TX_END_INT_RAW field.
	RMT_INT_RAW_CH2_TX_END_INT_RAW_Msk = 0x40
	// Bit CH2_TX_END_INT_RAW.
	RMT_INT_RAW_CH2_TX_END_INT_RAW = 0x40
	// Position of CH2_RX_END_INT_RAW field.
	RMT_INT_RAW_CH2_RX_END_INT_RAW_Pos = 0x7
	// Bit mask of CH2_RX_END_INT_RAW field.
	RMT_INT_RAW_CH2_RX_END_INT_RAW_Msk = 0x80
	// Bit CH2_RX_END_INT_RAW.
	RMT_INT_RAW_CH2_RX_END_INT_RAW = 0x80
	// Position of CH2_ERR_INT_RAW field.
	RMT_INT_RAW_CH2_ERR_INT_RAW_Pos = 0x8
	// Bit mask of CH2_ERR_INT_RAW field.
	RMT_INT_RAW_CH2_ERR_INT_RAW_Msk = 0x100
	// Bit CH2_ERR_INT_RAW.
	RMT_INT_RAW_CH2_ERR_INT_RAW = 0x100
	// Position of CH3_TX_END_INT_RAW field.
	RMT_INT_RAW_CH3_TX_END_INT_RAW_Pos = 0x9
	// Bit mask of CH3_TX_END_INT_RAW field.
	RMT_INT_RAW_CH3_TX_END_INT_RAW_Msk = 0x200
	// Bit CH3_TX_END_INT_RAW.
	RMT_INT_RAW_CH3_TX_END_INT_RAW = 0x200
	// Position of CH3_RX_END_INT_RAW field.
	RMT_INT_RAW_CH3_RX_END_INT_RAW_Pos = 0xa
	// Bit mask of CH3_RX_END_INT_RAW field.
	RMT_INT_RAW_CH3_RX_END_INT_RAW_Msk = 0x400
	// Bit CH3_RX_END_INT_RAW.
	RMT_INT_RAW_CH3_RX_END_INT_RAW = 0x400
	// Position of CH3_ERR_INT_RAW field.
	RMT_INT_RAW_CH3_ERR_INT_RAW_Pos = 0xb
	// Bit mask of CH3_ERR_INT_RAW field.
	RMT_INT_RAW_CH3_ERR_INT_RAW_Msk = 0x800
	// Bit CH3_ERR_INT_RAW.
	RMT_INT_RAW_CH3_ERR_INT_RAW = 0x800
	// Position of CH0_TX_THR_EVENT_INT_RAW field.
	RMT_INT_RAW_CH0_TX_THR_EVENT_INT_RAW_Pos = 0xc
	// Bit mask of CH0_TX_THR_EVENT_INT_RAW field.
	RMT_INT_RAW_CH0_TX_THR_EVENT_INT_RAW_Msk = 0x1000
	// Bit CH0_TX_THR_EVENT_INT_RAW.
	RMT_INT_RAW_CH0_TX_THR_EVENT_INT_RAW = 0x1000
	// Position of CH1_TX_THR_EVENT_INT_RAW field.
	RMT_INT_RAW_CH1_TX_THR_EVENT_INT_RAW_Pos = 0xd
	// Bit mask of CH1_TX_THR_EVENT_INT_RAW field.
	RMT_INT_RAW_CH1_TX_THR_EVENT_INT_RAW_Msk = 0x2000
	// Bit CH1_TX_THR_EVENT_INT_RAW.
	RMT_INT_RAW_CH1_TX_THR_EVENT_INT_RAW = 0x2000
	// Position of CH2_TX_THR_EVENT_INT_RAW field.
	RMT_INT_RAW_CH2_TX_THR_EVENT_INT_RAW_Pos = 0xe
	// Bit mask of CH2_TX_THR_EVENT_INT_RAW field.
	RMT_INT_RAW_CH2_TX_THR_EVENT_INT_RAW_Msk = 0x4000
	// Bit CH2_TX_THR_EVENT_INT_RAW.
	RMT_INT_RAW_CH2_TX_THR_EVENT_INT_RAW = 0x4000
	// Position of CH3_TX_THR_EVENT_INT_RAW field.
	RMT_INT_RAW_CH3_TX_THR_EVENT_INT_RAW_Pos = 0xf
	// Bit mask of CH3_TX_THR_EVENT_INT_RAW field.
	RMT_INT_RAW_CH3_TX_THR_EVENT_INT_RAW_Msk = 0x8000
	// Bit CH3_TX_THR_EVENT_INT_RAW.
	RMT_INT_RAW_CH3_TX_THR_EVENT_INT_RAW = 0x8000
	// Position of CH0_TX_LOOP_INT_RAW field.
	RMT_INT_RAW_CH0_TX_LOOP_INT_RAW_Pos = 0x10
	// Bit mask of CH0_TX_LOOP_INT_RAW field.
	RMT_INT_RAW_CH0_TX_LOOP_INT_RAW_Msk = 0x10000
	// Bit CH0_TX_LOOP_INT_RAW.
	RMT_INT_RAW_CH0_TX_LOOP_INT_RAW = 0x10000
	// Position of CH1_TX_LOOP_INT_RAW field.
	RMT_INT_RAW_CH1_TX_LOOP_INT_RAW_Pos = 0x11
	// Bit mask of CH1_TX_LOOP_INT_RAW field.
	RMT_INT_RAW_CH1_TX_LOOP_INT_RAW_Msk = 0x20000
	// Bit CH1_TX_LOOP_INT_RAW.
	RMT_INT_RAW_CH1_TX_LOOP_INT_RAW = 0x20000
	// Position of CH2_TX_LOOP_INT_RAW field.
	RMT_INT_RAW_CH2_TX_LOOP_INT_RAW_Pos = 0x12
	// Bit mask of CH2_TX_LOOP_INT_RAW field.
	RMT_INT_RAW_CH2_TX_LOOP_INT_RAW_Msk = 0x40000
	// Bit CH2_TX_LOOP_INT_RAW.
	RMT_INT_RAW_CH2_TX_LOOP_INT_RAW = 0x40000
	// Position of CH3_TX_LOOP_INT_RAW field.
	RMT_INT_RAW_CH3_TX_LOOP_INT_RAW_Pos = 0x13
	// Bit mask of CH3_TX_LOOP_INT_RAW field.
	RMT_INT_RAW_CH3_TX_LOOP_INT_RAW_Msk = 0x80000
	// Bit CH3_TX_LOOP_INT_RAW.
	RMT_INT_RAW_CH3_TX_LOOP_INT_RAW = 0x80000

	// INT_ST: Masked interrupt status
	// Position of CH0_TX_END_INT_ST field.
	RMT_INT_ST_CH0_TX_END_INT_ST_Pos = 0x0
	// Bit mask of CH0_TX_END_INT_ST field.
	RMT_INT_ST_CH0_TX_END_INT_ST_Msk = 0x1
	// Bit CH0_TX_END_INT_ST.
	RMT_INT_ST_CH0_TX_END_INT_ST = 0x1
	// Position of CH0_RX_END_INT_ST field.
	RMT_INT_ST_CH0_RX_END_INT_ST_Pos = 0x1
	// Bit mask of CH0_RX_END_INT_ST field.
	RMT_INT_ST_CH0_RX_END_INT_ST_Msk = 0x2
	// Bit CH0_RX_END_INT_ST.
	RMT_INT_ST_CH0_RX_END_INT_ST = 0x2
	// Position of CH0_ERR_INT_ST field.
	RMT_INT_ST_CH0_ERR_INT_ST_Pos = 0x2
	// Bit mask of CH0_ERR_INT_ST field.
	RMT_INT_ST_CH0_ERR_INT_ST_Msk = 0x4
	// Bit CH0_ERR_INT_ST.
	RMT_INT_ST_CH0_ERR_INT_ST = 0x4
	// Position of CH1_TX_END_INT_ST field.
	RMT_INT_ST_CH1_TX_END_INT_ST_Pos = 0x3
	// Bit mask of CH1_TX_END_INT_ST field.
	RMT_INT_ST_CH1_TX_END_INT_ST_Msk = 0x8
	// Bit CH1_TX_END_INT_ST.
	RMT_INT_ST_CH1_TX_END_INT_ST = 0x8
	// Position of CH1_RX_END_INT_ST field.
	RMT_INT_ST_CH1_RX_END_INT_ST_Pos = 0x4
	// Bit mask of CH1_RX_END_INT_ST field.
	RMT_INT_ST_CH1_RX_END_INT_ST_Msk = 0x10
	// Bit CH1_RX_END_INT_ST.
	RMT_INT_ST_CH1_RX_END_INT_ST = 0x10
	// Position of CH1_ERR_INT_ST field.
	RMT_INT_ST_CH1_ERR_INT_ST_Pos = 0x5
	// Bit mask of CH1_ERR_INT_ST field.
	RMT_INT_ST_CH1_ERR_INT_ST_Msk = 0x20
	// Bit CH1_ERR_INT_ST.
	RMT_INT_ST_CH1_ERR_INT_ST = 0x20
	// Position of CH2_TX_END_INT_ST field.
	RMT_INT_ST_CH2_TX_END_INT_ST_Pos = 0x6
	// Bit mask of CH2_TX_END_INT_ST field.
	RMT_INT_ST_CH2_TX_END_INT_ST_Msk = 0x40
	// Bit CH2_TX_END_INT_ST.
	RMT_INT_ST_CH2_TX_END_INT_ST = 0x40
	// Position of CH2_RX_END_INT_ST field.
	RMT_INT_ST_CH2_RX_END_INT_ST_Pos = 0x7
	// Bit mask of CH2_RX_END_INT_ST field.
	RMT_INT_ST_CH2_RX_END_INT_ST_Msk = 0x80
	// Bit CH2_RX_END_INT_ST.
	RMT_INT_ST_CH2_RX_END_INT_ST = 0x80
	// Position of CH2_ERR_INT_ST field.
	RMT_INT_ST_CH2_ERR_INT_ST_Pos = 0x8
	// Bit mask of CH2_ERR_INT_ST field.
	RMT_INT_ST_CH2_ERR_INT_ST_Msk = 0x100
	// Bit CH2_ERR_INT_ST.
	RMT_INT_ST_CH2_ERR_INT_ST = 0x100
	// Position of CH3_TX_END_INT_ST field.
	RMT_INT_ST_CH3_TX_END_INT_ST_Pos = 0x9
	// Bit mask of CH3_TX_END_INT_ST field.
	RMT_INT_ST_CH3_TX_END_INT_ST_Msk = 0x200
	// Bit CH3_TX_END_INT_ST.
	RMT_INT_ST_CH3_TX_END_INT_ST = 0x200
	// Position of CH3_RX_END_INT_ST field.
	RMT_INT_ST_CH3_RX_END_INT_ST_Pos = 0xa
	// Bit mask of CH3_RX_END_INT_ST field.
	RMT_INT_ST_CH3_RX_END_INT_ST_Msk = 0x400
	// Bit CH3_RX_END_INT_ST.
	RMT_INT_ST_CH3_RX_END_INT_ST = 0x400
	// Position of CH3_ERR_INT_ST field.
	RMT_INT_ST_CH3_ERR_INT_ST_Pos = 0xb
	// Bit mask of CH3_ERR_INT_ST field.
	RMT_INT_ST_CH3_ERR_INT_ST_Msk = 0x800
	// Bit CH3_ERR_INT_ST.
	RMT_INT_ST_CH3_ERR_INT_ST = 0x800
	// Position of CH0_TX_THR_EVENT_INT_ST field.
	RMT_INT_ST_CH0_TX_THR_EVENT_INT_ST_Pos = 0xc
	// Bit mask of CH0_TX_THR_EVENT_INT_ST field.
	RMT_INT_ST_CH0_TX_THR_EVENT_INT_ST_Msk = 0x1000
	// Bit CH0_TX_THR_EVENT_INT_ST.
	RMT_INT_ST_CH0_TX_THR_EVENT_INT_ST = 0x1000
	// Position of CH1_TX_THR_EVENT_INT_ST field.
	RMT_INT_ST_CH1_TX_THR_EVENT_INT_ST_Pos = 0xd
	// Bit mask of CH1_TX_THR_EVENT_INT_ST field.
	RMT_INT_ST_CH1_TX_THR_EVENT_INT_ST_Msk = 0x2000
	// Bit CH1_TX_THR_EVENT_INT_ST.
	RMT_INT_ST_CH1_TX_THR_EVENT_INT_ST = 0x2000
	// Position of CH2_TX_THR_EVENT_INT_ST field.
	RMT_INT_ST_CH2_TX_THR_EVENT_INT_ST_Pos = 0xe
	// Bit mask of CH2_TX_THR_EVENT_INT_ST field.
	RMT_INT_ST_CH2_TX_THR_EVENT_INT_ST_Msk = 0x4000
	// Bit CH2_TX_THR_EVENT_INT_ST.
	RMT_INT_ST_CH2_TX_THR_EVENT_INT_ST = 0x4000
	// Position of CH3_TX_THR_EVENT_INT_ST field.
	RMT_INT_ST_CH3_TX_THR_EVENT_INT_ST_Pos = 0xf
	// Bit mask of CH3_TX_THR_EVENT_INT_ST field.
	RMT_INT_ST_CH3_TX_THR_EVENT_INT_ST_Msk = 0x8000
	// Bit CH3_TX_THR_EVENT_INT_ST.
	RMT_INT_ST_CH3_TX_THR_EVENT_INT_ST = 0x8000
	// Position of CH0_TX_LOOP_INT_ST field.
	RMT_INT_ST_CH0_TX_LOOP_INT_ST_Pos = 0x10
	// Bit mask of CH0_TX_LOOP_INT_ST field.
	RMT_INT_ST_CH0_TX_LOOP_INT_ST_Msk = 0x10000
	// Bit CH0_TX_LOOP_INT_ST.
	RMT_INT_ST_CH0_TX_LOOP_INT_ST = 0x10000
	// Position of CH1_TX_LOOP_INT_ST field.
	RMT_INT_ST_CH1_TX_LOOP_INT_ST_Pos = 0x11
	// Bit mask of CH1_TX_LOOP_INT_ST field.
	RMT_INT_ST_CH1_TX_LOOP_INT_ST_Msk = 0x20000
	// Bit CH1_TX_LOOP_INT_ST.
	RMT_INT_ST_CH1_TX_LOOP_INT_ST = 0x20000
	// Position of CH2_TX_LOOP_INT_ST field.
	RMT_INT_ST_CH2_TX_LOOP_INT_ST_Pos = 0x12
	// Bit mask of CH2_TX_LOOP_INT_ST field.
	RMT_INT_ST_CH2_TX_LOOP_INT_ST_Msk = 0x40000
	// Bit CH2_TX_LOOP_INT_ST.
	RMT_INT_ST_CH2_TX_LOOP_INT_ST = 0x40000
	// Position of CH3_TX_LOOP_INT_ST field.
	RMT_INT_ST_CH3_TX_LOOP_INT_ST_Pos = 0x13
	// Bit mask of CH3_TX_LOOP_INT_ST field.
	RMT_INT_ST_CH3_TX_LOOP_INT_ST_Msk = 0x80000
	// Bit CH3_TX_LOOP_INT_ST.
	RMT_INT_ST_CH3_TX_LOOP_INT_ST = 0x80000

	// INT_ENA: Interrupt enable bits
	// Position of CH0_TX_END_INT_ENA field.
	RMT_INT_ENA_CH0_TX_END_INT_ENA_Pos = 0x0
	// Bit mask of CH0_TX_END_INT_ENA field.
	RMT_INT_ENA_CH0_TX_END_INT_ENA_Msk = 0x1
	// Bit CH0_TX_END_INT_ENA.
	RMT_INT_ENA_CH0_TX_END_INT_ENA = 0x1
	// Position of CH0_RX_END_INT_ENA field.
	RMT_INT_ENA_CH0_RX_END_INT_ENA_Pos = 0x1
	// Bit mask of CH0_RX_END_INT_ENA field.
	RMT_INT_ENA_CH0_RX_END_INT_ENA_Msk = 0x2
	// Bit CH0_RX_END_INT_ENA.
	RMT_INT_ENA_CH0_RX_END_INT_ENA = 0x2
	// Position of CH0_ERR_INT_ENA field.
	RMT_INT_ENA_CH0_ERR_INT_ENA_Pos = 0x2
	// Bit mask of CH0_ERR_INT_ENA field.
	RMT_INT_ENA_CH0_ERR_INT_ENA_Msk = 0x4
	// Bit CH0_ERR_INT_ENA.
	RMT_INT_ENA_CH0_ERR_INT_ENA = 0x4
	// Position of CH1_TX_END_INT_ENA field.
	RMT_INT_ENA_CH1_TX_END_INT_ENA_Pos = 0x3
	// Bit mask of CH1_TX_END_INT_ENA field.
	RMT_INT_ENA_CH1_TX_END_INT_ENA_Msk = 0x8
	// Bit CH1_TX_END_INT_ENA.
	RMT_INT_ENA_CH1_TX_END_INT_ENA = 0x8
	// Position of CH1_RX_END_INT_ENA field.
	RMT_INT_ENA_CH1_RX_END_INT_ENA_Pos = 0x4
	// Bit mask of CH1_RX_END_INT_ENA field.
	RMT_INT_ENA_CH1_RX_END_INT_ENA_Msk = 0x10
	// Bit CH1_RX_END_INT_ENA.
	RMT_INT_ENA_CH1_RX_END_INT_ENA = 0x10
	// Position of CH1_ERR_INT_ENA field.
	RMT_INT_ENA_CH1_ERR_INT_ENA_Pos = 0x5
	// Bit mask of CH1_ERR_INT_ENA field.
	RMT_INT_ENA_CH1_ERR_INT_ENA_Msk = 0x20
	// Bit CH1_ERR_INT_ENA.
	RMT_INT_ENA_CH1_ERR_INT_ENA = 0x20
	// Position of CH2_TX_END_INT_ENA field.
	RMT_INT_ENA_CH2_TX_END_INT_ENA_Pos = 0x6
	// Bit mask of CH2_TX_END_INT_ENA field.
	RMT_INT_ENA_CH2_TX_END_INT_ENA_Msk = 0x40
	// Bit CH2_TX_END_INT_ENA.
	RMT_INT_ENA_CH2_TX_END_INT_ENA = 0x40
	// Position of CH2_RX_END_INT_ENA field.
	RMT_INT_ENA_CH2_RX_END_INT_ENA_Pos = 0x7
	// Bit mask of CH2_RX_END_INT_ENA field.
	RMT_INT_ENA_CH2_RX_END_INT_ENA_Msk = 0x80
	// Bit CH2_RX_END_INT_ENA.
	RMT_INT_ENA_CH2_RX_END_INT_ENA = 0x80
	// Position of CH2_ERR_INT_ENA field.
	RMT_INT_ENA_CH2_ERR_INT_ENA_Pos = 0x8
	// Bit mask of CH2_ERR_INT_ENA field.
	RMT_INT_ENA_CH2_ERR_INT_ENA_Msk = 0x100
	// Bit CH2_ERR_INT_ENA.
	RMT_INT_ENA_CH2_ERR_INT_ENA = 0x100
	// Position of CH3_TX_END_INT_ENA field.
	RMT_INT_ENA_CH3_TX_END_INT_ENA_Pos = 0x9
	// Bit mask of CH3_TX_END_INT_ENA field.
	RMT_INT_ENA_CH3_TX_END_INT_ENA_Msk = 0x200
	// Bit CH3_TX_END_INT_ENA.
	RMT_INT_ENA_CH3_TX_END_INT_ENA = 0x200
	// Position of CH3_RX_END_INT_ENA field.
	RMT_INT_ENA_CH3_RX_END_INT_ENA_Pos = 0xa
	// Bit mask of CH3_RX_END_INT_ENA field.
	RMT_INT_ENA_CH3_RX_END_INT_ENA_Msk = 0x400
	// Bit CH3_RX_END_INT_ENA.
	RMT_INT_ENA_CH3_RX_END_INT_ENA = 0x400
	// Position of CH3_ERR_INT_ENA field.
	RMT_INT_ENA_CH3_ERR_INT_ENA_Pos = 0xb
	// Bit mask of CH3_ERR_INT_ENA field.
	RMT_INT_ENA_CH3_ERR_INT_ENA_Msk = 0x800
	// Bit CH3_ERR_INT_ENA.
	RMT_INT_ENA_CH3_ERR_INT_ENA = 0x800
	// Position of CH0_TX_THR_EVENT_INT_ENA field.
	RMT_INT_ENA_CH0_TX_THR_EVENT_INT_ENA_Pos = 0xc
	// Bit mask of CH0_TX_THR_EVENT_INT_ENA field.
	RMT_INT_ENA_CH0_TX_THR_EVENT_INT_ENA_Msk = 0x1000
	// Bit CH0_TX_THR_EVENT_INT_ENA.
	RMT_INT_ENA_CH0_TX_THR_EVENT_INT_ENA = 0x1000
	// Position of CH1_TX_THR_EVENT_INT_ENA field.
	RMT_INT_ENA_CH1_TX_THR_EVENT_INT_ENA_Pos = 0xd
	// Bit mask of CH1_TX_THR_EVENT_INT_ENA field.
	RMT_INT_ENA_CH1_TX_THR_EVENT_INT_ENA_Msk = 0x2000
	// Bit CH1_TX_THR_EVENT_INT_ENA.
	RMT_INT_ENA_CH1_TX_THR_EVENT_INT_ENA = 0x2000
	// Position of CH2_TX_THR_EVENT_INT_ENA field.
	RMT_INT_ENA_CH2_TX_THR_EVENT_INT_ENA_Pos = 0xe
	// Bit mask of CH2_TX_THR_EVENT_INT_ENA field.
	RMT_INT_ENA_CH2_TX_THR_EVENT_INT_ENA_Msk = 0x4000
	// Bit CH2_TX_THR_EVENT_INT_ENA.
	RMT_INT_ENA_CH2_TX_THR_EVENT_INT_ENA = 0x4000
	// Position of CH3_TX_THR_EVENT_INT_ENA field.
	RMT_INT_ENA_CH3_TX_THR_EVENT_INT_ENA_Pos = 0xf
	// Bit mask of CH3_TX_THR_EVENT_INT_ENA field.
	RMT_INT_ENA_CH3_TX_THR_EVENT_INT_ENA_Msk = 0x8000
	// Bit CH3_TX_THR_EVENT_INT_ENA.
	RMT_INT_ENA_CH3_TX_THR_EVENT_INT_ENA = 0x8000
	// Position of CH0_TX_LOOP_INT_ENA field.
	RMT_INT_ENA_CH0_TX_LOOP_INT_ENA_Pos = 0x10
	// Bit mask of CH0_TX_LOOP_INT_ENA field.
	RMT_INT_ENA_CH0_TX_LOOP_INT_ENA_Msk = 0x10000
	// Bit CH0_TX_LOOP_INT_ENA.
	RMT_INT_ENA_CH0_TX_LOOP_INT_ENA = 0x10000
	// Position of CH1_TX_LOOP_INT_ENA field.
	RMT_INT_ENA_CH1_TX_LOOP_INT_ENA_Pos = 0x11
	// Bit mask of CH1_TX_LOOP_INT_ENA field.
	RMT_INT_ENA_CH1_TX_LOOP_INT_ENA_Msk = 0x20000
	// Bit CH1_TX_LOOP_INT_ENA.
	RMT_INT_ENA_CH1_TX_LOOP_INT_ENA = 0x20000
	// Position of CH2_TX_LOOP_INT_ENA field.
	RMT_INT_ENA_CH2_TX_LOOP_INT_ENA_Pos = 0x12
	// Bit mask of CH2_TX_LOOP_INT_ENA field.
	RMT_INT_ENA_CH2_TX_LOOP_INT_ENA_Msk = 0x40000
	// Bit CH2_TX_LOOP_INT_ENA.
	RMT_INT_ENA_CH2_TX_LOOP_INT_ENA = 0x40000
	// Position of CH3_TX_LOOP_INT_ENA field.
	RMT_INT_ENA_CH3_TX_LOOP_INT_ENA_Pos = 0x13
	// Bit mask of CH3_TX_LOOP_INT_ENA field.
	RMT_INT_ENA_CH3_TX_LOOP_INT_ENA_Msk = 0x80000
	// Bit CH3_TX_LOOP_INT_ENA.
	RMT_INT_ENA_CH3_TX_LOOP_INT_ENA = 0x80000

	// INT_CLR: Interrupt clear bits
	// Position of CH0_TX_END_INT_CLR field.
	RMT_INT_CLR_CH0_TX_END_INT_CLR_Pos = 0x0
	// Bit mask of CH0_TX_END_INT_CLR field.
	RMT_INT_CLR_CH0_TX_END_INT_CLR_Msk = 0x1
	// Bit CH0_TX_END_INT_CLR.
	RMT_INT_CLR_CH0_TX_END_INT_CLR = 0x1
	// Position of CH0_RX_END_INT_CLR field.
	RMT_INT_CLR_CH0_RX_END_INT_CLR_Pos = 0x1
	// Bit mask of CH0_RX_END_INT_CLR field.
	RMT_INT_CLR_CH0_RX_END_INT_CLR_Msk = 0x2
	// Bit CH0_RX_END_INT_CLR.
	RMT_INT_CLR_CH0_RX_END_INT_CLR = 0x2
	// Position of CH0_ERR_INT_CLR field.
	RMT_INT_CLR_CH0_ERR_INT_CLR_Pos = 0x2
	// Bit mask of CH0_ERR_INT_CLR field.
	RMT_INT_CLR_CH0_ERR_INT_CLR_Msk = 0x4
	// Bit CH0_ERR_INT_CLR.
	RMT_INT_CLR_CH0_ERR_INT_CLR = 0x4
	// Position of CH1_TX_END_INT_CLR field.
	RMT_INT_CLR_CH1_TX_END_INT_CLR_Pos = 0x3
	// Bit mask of CH1_TX_END_INT_CLR field.
	RMT_INT_CLR_CH1_TX_END_INT_CLR_Msk = 0x8
	// Bit CH1_TX_END_INT_CLR.
	RMT_INT_CLR_CH1_TX_END_INT_CLR = 0x8
	// Position of CH1_RX_END_INT_CLR field.
	RMT_INT_CLR_CH1_RX_END_INT_CLR_Pos = 0x4
	// Bit mask of CH1_RX_END_INT_CLR field.
	RMT_INT_CLR_CH1_RX_END_INT_CLR_Msk = 0x10
	// Bit CH1_RX_END_INT_CLR.
	RMT_INT_CLR_CH1_RX_END_INT_CLR = 0x10
	// Position of CH1_ERR_INT_CLR field.
	RMT_INT_CLR_CH1_ERR_INT_CLR_Pos = 0x5
	// Bit mask of CH1_ERR_INT_CLR field.
	RMT_INT_CLR_CH1_ERR_INT_CLR_Msk = 0x20
	// Bit CH1_ERR_INT_CLR.
	RMT_INT_CLR_CH1_ERR_INT_CLR = 0x20
	// Position of CH2_TX_END_INT_CLR field.
	RMT_INT_CLR_CH2_TX_END_INT_CLR_Pos = 0x6
	// Bit mask of CH2_TX_END_INT_CLR field.
	RMT_INT_CLR_CH2_TX_END_INT_CLR_Msk = 0x40
	// Bit CH2_TX_END_INT_CLR.
	RMT_INT_CLR_CH2_TX_END_INT_CLR = 0x40
	// Position of CH2_RX_END_INT_CLR field.
	RMT_INT_CLR_CH2_RX_END_INT_CLR_Pos = 0x7
	// Bit mask of CH2_RX_END_INT_CLR field.
	RMT_INT_CLR_CH2_RX_END_INT_CLR_Msk = 0x80
	// Bit CH2_RX_END_INT_CLR.
	RMT_INT_CLR_CH2_RX_END_INT_CLR = 0x80
	// Position of CH2_ERR_INT_CLR field.
	RMT_INT_CLR_CH2_ERR_INT_CLR_Pos = 0x8
	// Bit mask of CH2_ERR_INT_CLR field.
	RMT_INT_CLR_CH2_ERR_INT_CLR_Msk = 0x100
	// Bit CH2_ERR_INT_CLR.
	RMT_INT_CLR_CH2_ERR_INT_CLR = 0x100
	// Position of CH3_TX_END_INT_CLR field.
	RMT_INT_CLR_CH3_TX_END_INT_CLR_Pos = 0x9
	// Bit mask of CH3_TX_END_INT_CLR field.
	RMT_INT_CLR_CH3_TX_END_INT_CLR_Msk = 0x200
	// Bit CH3_TX_END_INT_CLR.
	RMT_INT_CLR_CH3_TX_END_INT_CLR = 0x200
	// Position of CH3_RX_END_INT_CLR field.
	RMT_INT_CLR_CH3_RX_END_INT_CLR_Pos = 0xa
	// Bit mask of CH3_RX_END_INT_CLR field.
	RMT_INT_CLR_CH3_RX_END_INT_CLR_Msk = 0x400
	// Bit CH3_RX_END_INT_CLR.
	RMT_INT_CLR_CH3_RX_END_INT_CLR = 0x400
	// Position of CH3_ERR_INT_CLR field.
	RMT_INT_CLR_CH3_ERR_INT_CLR_Pos = 0xb
	// Bit mask of CH3_ERR_INT_CLR field.
	RMT_INT_CLR_CH3_ERR_INT_CLR_Msk = 0x800
	// Bit CH3_ERR_INT_CLR.
	RMT_INT_CLR_CH3_ERR_INT_CLR = 0x800
	// Position of CH0_TX_THR_EVENT_INT_CLR field.
	RMT_INT_CLR_CH0_TX_THR_EVENT_INT_CLR_Pos = 0xc
	// Bit mask of CH0_TX_THR_EVENT_INT_CLR field.
	RMT_INT_CLR_CH0_TX_THR_EVENT_INT_CLR_Msk = 0x1000
	// Bit CH0_TX_THR_EVENT_INT_CLR.
	RMT_INT_CLR_CH0_TX_THR_EVENT_INT_CLR = 0x1000
	// Position of CH1_TX_THR_EVENT_INT_CLR field.
	RMT_INT_CLR_CH1_TX_THR_EVENT_INT_CLR_Pos = 0xd
	// Bit mask of CH1_TX_THR_EVENT_INT_CLR field.
	RMT_INT_CLR_CH1_TX_THR_EVENT_INT_CLR_Msk = 0x2000
	// Bit CH1_TX_THR_EVENT_INT_CLR.
	RMT_INT_CLR_CH1_TX_THR_EVENT_INT_CLR = 0x2000
	// Position of CH2_TX_THR_EVENT_INT_CLR field.
	RMT_INT_CLR_CH2_TX_THR_EVENT_INT_CLR_Pos = 0xe
	// Bit mask of CH2_TX_THR_EVENT_INT_CLR field.
	RMT_INT_CLR_CH2_TX_THR_EVENT_INT_CLR_Msk = 0x4000
	// Bit CH2_TX_THR_EVENT_INT_CLR.
	RMT_INT_CLR_CH2_TX_THR_EVENT_INT_CLR = 0x4000
	// Position of CH3_TX_THR_EVENT_INT_CLR field.
	RMT_INT_CLR_CH3_TX_THR_EVENT_INT_CLR_Pos = 0xf
	// Bit mask of CH3_TX_THR_EVENT_INT_CLR field.
	RMT_INT_CLR_CH3_TX_THR_EVENT_INT_CLR_Msk = 0x8000
	// Bit CH3_TX_THR_EVENT_INT_CLR.
	RMT_INT_CLR_CH3_TX_THR_EVENT_INT_CLR = 0x8000
	// Position of CH0_TX_LOOP_INT_CLR field.
	RMT_INT_CLR_CH0_TX_LOOP_INT_CLR_Pos = 0x10
	// Bit mask of CH0_TX_LOOP_INT_CLR field.
	RMT_INT_CLR_CH0_TX_LOOP_INT_CLR_Msk = 0x10000
	// Bit CH0_TX_LOOP_INT_CLR.
	RMT_INT_CLR_CH0_TX_LOOP_INT_CLR = 0x10000
	// Position of CH1_TX_LOOP_INT_CLR field.
	RMT_INT_CLR_CH1_TX_LOOP_INT_CLR_Pos = 0x11
	// Bit mask of CH1_TX_LOOP_INT_CLR field.
	RMT_INT_CLR_CH1_TX_LOOP_INT_CLR_Msk = 0x20000
	// Bit CH1_TX_LOOP_INT_CLR.
	RMT_INT_CLR_CH1_TX_LOOP_INT_CLR = 0x20000
	// Position of CH2_TX_LOOP_INT_CLR field.
	RMT_INT_CLR_CH2_TX_LOOP_INT_CLR_Pos = 0x12
	// Bit mask of CH2_TX_LOOP_INT_CLR field.
	RMT_INT_CLR_CH2_TX_LOOP_INT_CLR_Msk = 0x40000
	// Bit CH2_TX_LOOP_INT_CLR.
	RMT_INT_CLR_CH2_TX_LOOP_INT_CLR = 0x40000
	// Position of CH3_TX_LOOP_INT_CLR field.
	RMT_INT_CLR_CH3_TX_LOOP_INT_CLR_Pos = 0x13
	// Bit mask of CH3_TX_LOOP_INT_CLR field.
	RMT_INT_CLR_CH3_TX_LOOP_INT_CLR_Msk = 0x80000
	// Bit CH3_TX_LOOP_INT_CLR.
	RMT_INT_CLR_CH3_TX_LOOP_INT_CLR = 0x80000

	// CH0CARRIER_DUTY: Channel %s duty cycle configuration register
	// Position of CARRIER_LOW_CH0 field.
	RMT_CHCARRIER_DUTY_CARRIER_LOW_CH0_Pos = 0x0
	// Bit mask of CARRIER_LOW_CH0 field.
	RMT_CHCARRIER_DUTY_CARRIER_LOW_CH0_Msk = 0xffff
	// Position of CARRIER_HIGH_CH0 field.
	RMT_CHCARRIER_DUTY_CARRIER_HIGH_CH0_Pos = 0x10
	// Bit mask of CARRIER_HIGH_CH0 field.
	RMT_CHCARRIER_DUTY_CARRIER_HIGH_CH0_Msk = 0xffff0000

	// CH0_TX_LIM: Channel %s Tx event configuration register
	// Position of TX_LIM_CH0 field.
	RMT_CH_TX_LIM_TX_LIM_CH0_Pos = 0x0
	// Bit mask of TX_LIM_CH0 field.
	RMT_CH_TX_LIM_TX_LIM_CH0_Msk = 0x1ff
	// Position of TX_LOOP_NUM_CH0 field.
	RMT_CH_TX_LIM_TX_LOOP_NUM_CH0_Pos = 0x9
	// Bit mask of TX_LOOP_NUM_CH0 field.
	RMT_CH_TX_LIM_TX_LOOP_NUM_CH0_Msk = 0x7fe00
	// Position of TX_LOOP_CNT_EN_CH0 field.
	RMT_CH_TX_LIM_TX_LOOP_CNT_EN_CH0_Pos = 0x13
	// Bit mask of TX_LOOP_CNT_EN_CH0 field.
	RMT_CH_TX_LIM_TX_LOOP_CNT_EN_CH0_Msk = 0x80000
	// Bit TX_LOOP_CNT_EN_CH0.
	RMT_CH_TX_LIM_TX_LOOP_CNT_EN_CH0 = 0x80000
	// Position of LOOP_COUNT_RESET_CH0 field.
	RMT_CH_TX_LIM_LOOP_COUNT_RESET_CH0_Pos = 0x14
	// Bit mask of LOOP_COUNT_RESET_CH0 field.
	RMT_CH_TX_LIM_LOOP_COUNT_RESET_CH0_Msk = 0x100000
	// Bit LOOP_COUNT_RESET_CH0.
	RMT_CH_TX_LIM_LOOP_COUNT_RESET_CH0 = 0x100000

	// APB_CONF: RMT apb configuration register
	// Position of APB_FIFO_MASK field.
	RMT_APB_CONF_APB_FIFO_MASK_Pos = 0x0
	// Bit mask of APB_FIFO_MASK field.
	RMT_APB_CONF_APB_FIFO_MASK_Msk = 0x1
	// Bit APB_FIFO_MASK.
	RMT_APB_CONF_APB_FIFO_MASK = 0x1
	// Position of MEM_TX_WRAP_EN field.
	RMT_APB_CONF_MEM_TX_WRAP_EN_Pos = 0x1
	// Bit mask of MEM_TX_WRAP_EN field.
	RMT_APB_CONF_MEM_TX_WRAP_EN_Msk = 0x2
	// Bit MEM_TX_WRAP_EN.
	RMT_APB_CONF_MEM_TX_WRAP_EN = 0x2
	// Position of MEM_CLK_FORCE_ON field.
	RMT_APB_CONF_MEM_CLK_FORCE_ON_Pos = 0x2
	// Bit mask of MEM_CLK_FORCE_ON field.
	RMT_APB_CONF_MEM_CLK_FORCE_ON_Msk = 0x4
	// Bit MEM_CLK_FORCE_ON.
	RMT_APB_CONF_MEM_CLK_FORCE_ON = 0x4
	// Position of MEM_FORCE_PD field.
	RMT_APB_CONF_MEM_FORCE_PD_Pos = 0x3
	// Bit mask of MEM_FORCE_PD field.
	RMT_APB_CONF_MEM_FORCE_PD_Msk = 0x8
	// Bit MEM_FORCE_PD.
	RMT_APB_CONF_MEM_FORCE_PD = 0x8
	// Position of MEM_FORCE_PU field.
	RMT_APB_CONF_MEM_FORCE_PU_Pos = 0x4
	// Bit mask of MEM_FORCE_PU field.
	RMT_APB_CONF_MEM_FORCE_PU_Msk = 0x10
	// Bit MEM_FORCE_PU.
	RMT_APB_CONF_MEM_FORCE_PU = 0x10
	// Position of CLK_EN field.
	RMT_APB_CONF_CLK_EN_Pos = 0x1f
	// Bit mask of CLK_EN field.
	RMT_APB_CONF_CLK_EN_Msk = 0x80000000
	// Bit CLK_EN.
	RMT_APB_CONF_CLK_EN = 0x80000000

	// TX_SIM: RMT TX synchronous register
	// Position of CH0 field.
	RMT_TX_SIM_CH0_Pos = 0x0
	// Bit mask of CH0 field.
	RMT_TX_SIM_CH0_Msk = 0x1
	// Bit CH0.
	RMT_TX_SIM_CH0 = 0x1
	// Position of CH1 field.
	RMT_TX_SIM_CH1_Pos = 0x1
	// Bit mask of CH1 field.
	RMT_TX_SIM_CH1_Msk = 0x2
	// Bit CH1.
	RMT_TX_SIM_CH1 = 0x2
	// Position of CH2 field.
	RMT_TX_SIM_CH2_Pos = 0x2
	// Bit mask of CH2 field.
	RMT_TX_SIM_CH2_Msk = 0x4
	// Bit CH2.
	RMT_TX_SIM_CH2 = 0x4
	// Position of CH3 field.
	RMT_TX_SIM_CH3_Pos = 0x3
	// Bit mask of CH3 field.
	RMT_TX_SIM_CH3_Msk = 0x8
	// Bit CH3.
	RMT_TX_SIM_CH3 = 0x8
	// Position of EN field.
	RMT_TX_SIM_EN_Pos = 0x4
	// Bit mask of EN field.
	RMT_TX_SIM_EN_Msk = 0x10
	// Bit EN.
	RMT_TX_SIM_EN = 0x10

	// REF_CNT_RST: RMT clock divider reset register
	// Position of CH0 field.
	RMT_REF_CNT_RST_CH0_Pos = 0x0
	// Bit mask of CH0 field.
	RMT_REF_CNT_RST_CH0_Msk = 0x1
	// Bit CH0.
	RMT_REF_CNT_RST_CH0 = 0x1
	// Position of CH1 field.
	RMT_REF_CNT_RST_CH1_Pos = 0x1
	// Bit mask of CH1 field.
	RMT_REF_CNT_RST_CH1_Msk = 0x2
	// Bit CH1.
	RMT_REF_CNT_RST_CH1 = 0x2
	// Position of CH2 field.
	RMT_REF_CNT_RST_CH2_Pos = 0x2
	// Bit mask of CH2 field.
	RMT_REF_CNT_RST_CH2_Msk = 0x4
	// Bit CH2.
	RMT_REF_CNT_RST_CH2 = 0x4
	// Position of CH3 field.
	RMT_REF_CNT_RST_CH3_Pos = 0x3
	// Bit mask of CH3 field.
	RMT_REF_CNT_RST_CH3_Msk = 0x8
	// Bit CH3.
	RMT_REF_CNT_RST_CH3 = 0x8

	// CH0_RX_CARRIER_RM: Channel %s carrier remove register
	// Position of CARRIER_LOW_THRES_CH0 field.
	RMT_CH_RX_CARRIER_RM_CARRIER_LOW_THRES_CH0_Pos = 0x0
	// Bit mask of CARRIER_LOW_THRES_CH0 field.
	RMT_CH_RX_CARRIER_RM_CARRIER_LOW_THRES_CH0_Msk = 0xffff
	// Position of CARRIER_HIGH_THRES_CH0 field.
	RMT_CH_RX_CARRIER_RM_CARRIER_HIGH_THRES_CH0_Pos = 0x10
	// Bit mask of CARRIER_HIGH_THRES_CH0 field.
	RMT_CH_RX_CARRIER_RM_CARRIER_HIGH_THRES_CH0_Msk = 0xffff0000

	// DATE: RMT version register
	// Position of DATE field.
	RMT_DATE_DATE_Pos = 0x0
	// Bit mask of DATE field.
	RMT_DATE_DATE_Msk = 0xffffffff
)

// Constants for RSA: Peripheral RSA
const (
	// M_PRIME: Register to store M'
	// Position of M_PRIME field.
	RSA_M_PRIME_M_PRIME_Pos = 0x0
	// Bit mask of M_PRIME field.
	RSA_M_PRIME_M_PRIME_Msk = 0xffffffff

	// MODE: RSA length mode
	// Position of MODE field.
	RSA_MODE_MODE_Pos = 0x0
	// Bit mask of MODE field.
	RSA_MODE_MODE_Msk = 0x7f

	// CLEAN: RSA clean register
	// Position of CLEAN field.
	RSA_CLEAN_CLEAN_Pos = 0x0
	// Bit mask of CLEAN field.
	RSA_CLEAN_CLEAN_Msk = 0x1
	// Bit CLEAN.
	RSA_CLEAN_CLEAN = 0x1

	// MODEXP_START: Modular exponentiation starting bit
	// Position of MODEXP_START field.
	RSA_MODEXP_START_MODEXP_START_Pos = 0x0
	// Bit mask of MODEXP_START field.
	RSA_MODEXP_START_MODEXP_START_Msk = 0x1
	// Bit MODEXP_START.
	RSA_MODEXP_START_MODEXP_START = 0x1

	// MODMULT_START: Modular multiplication starting bit
	// Position of MODMULT_START field.
	RSA_MODMULT_START_MODMULT_START_Pos = 0x0
	// Bit mask of MODMULT_START field.
	RSA_MODMULT_START_MODMULT_START_Msk = 0x1
	// Bit MODMULT_START.
	RSA_MODMULT_START_MODMULT_START = 0x1

	// MULT_START: Normal multiplicaiton starting bit
	// Position of MULT_START field.
	RSA_MULT_START_MULT_START_Pos = 0x0
	// Bit mask of MULT_START field.
	RSA_MULT_START_MULT_START_Msk = 0x1
	// Bit MULT_START.
	RSA_MULT_START_MULT_START = 0x1

	// IDLE: RSA idle register
	// Position of IDLE field.
	RSA_IDLE_IDLE_Pos = 0x0
	// Bit mask of IDLE field.
	RSA_IDLE_IDLE_Msk = 0x1
	// Bit IDLE.
	RSA_IDLE_IDLE = 0x1

	// CLEAR_INTERRUPT: RSA clear interrupt register
	// Position of CLEAR_INTERRUPT field.
	RSA_CLEAR_INTERRUPT_CLEAR_INTERRUPT_Pos = 0x0
	// Bit mask of CLEAR_INTERRUPT field.
	RSA_CLEAR_INTERRUPT_CLEAR_INTERRUPT_Msk = 0x1
	// Bit CLEAR_INTERRUPT.
	RSA_CLEAR_INTERRUPT_CLEAR_INTERRUPT = 0x1

	// CONSTANT_TIME: The constant_time option
	// Position of CONSTANT_TIME field.
	RSA_CONSTANT_TIME_CONSTANT_TIME_Pos = 0x0
	// Bit mask of CONSTANT_TIME field.
	RSA_CONSTANT_TIME_CONSTANT_TIME_Msk = 0x1
	// Bit CONSTANT_TIME.
	RSA_CONSTANT_TIME_CONSTANT_TIME = 0x1

	// SEARCH_ENABLE: The search option
	// Position of SEARCH_ENABLE field.
	RSA_SEARCH_ENABLE_SEARCH_ENABLE_Pos = 0x0
	// Bit mask of SEARCH_ENABLE field.
	RSA_SEARCH_ENABLE_SEARCH_ENABLE_Msk = 0x1
	// Bit SEARCH_ENABLE.
	RSA_SEARCH_ENABLE_SEARCH_ENABLE = 0x1

	// SEARCH_POS: The search position
	// Position of SEARCH_POS field.
	RSA_SEARCH_POS_SEARCH_POS_Pos = 0x0
	// Bit mask of SEARCH_POS field.
	RSA_SEARCH_POS_SEARCH_POS_Msk = 0xfff

	// INTERRUPT_ENA: RSA interrupt enable register
	// Position of INTERRUPT_ENA field.
	RSA_INTERRUPT_ENA_INTERRUPT_ENA_Pos = 0x0
	// Bit mask of INTERRUPT_ENA field.
	RSA_INTERRUPT_ENA_INTERRUPT_ENA_Msk = 0x1
	// Bit INTERRUPT_ENA.
	RSA_INTERRUPT_ENA_INTERRUPT_ENA = 0x1

	// DATE: Version control register
	// Position of DATE field.
	RSA_DATE_DATE_Pos = 0x0
	// Bit mask of DATE field.
	RSA_DATE_DATE_Msk = 0x3fffffff
)

// Constants for RTCIO: Peripheral RTCIO
const (
	// RTC_GPIO_OUT: RTC GPIO output register
	// Position of GPIO_OUT_DATA field.
	RTCIO_RTC_GPIO_OUT_GPIO_OUT_DATA_Pos = 0xa
	// Bit mask of GPIO_OUT_DATA field.
	RTCIO_RTC_GPIO_OUT_GPIO_OUT_DATA_Msk = 0xfffffc00

	// RTC_GPIO_OUT_W1TS: RTC GPIO output bit set register
	// Position of GPIO_OUT_DATA_W1TS field.
	RTCIO_RTC_GPIO_OUT_W1TS_GPIO_OUT_DATA_W1TS_Pos = 0xa
	// Bit mask of GPIO_OUT_DATA_W1TS field.
	RTCIO_RTC_GPIO_OUT_W1TS_GPIO_OUT_DATA_W1TS_Msk = 0xfffffc00

	// RTC_GPIO_OUT_W1TC: RTC GPIO output bit clear register
	// Position of GPIO_OUT_DATA_W1TC field.
	RTCIO_RTC_GPIO_OUT_W1TC_GPIO_OUT_DATA_W1TC_Pos = 0xa
	// Bit mask of GPIO_OUT_DATA_W1TC field.
	RTCIO_RTC_GPIO_OUT_W1TC_GPIO_OUT_DATA_W1TC_Msk = 0xfffffc00

	// RTC_GPIO_ENABLE: RTC GPIO output enable register
	// Position of REG_RTCIO_REG_GPIO_ENABLE field.
	RTCIO_RTC_GPIO_ENABLE_REG_RTCIO_REG_GPIO_ENABLE_Pos = 0xa
	// Bit mask of REG_RTCIO_REG_GPIO_ENABLE field.
	RTCIO_RTC_GPIO_ENABLE_REG_RTCIO_REG_GPIO_ENABLE_Msk = 0xfffffc00

	// RTC_GPIO_ENABLE_W1TS: RTC GPIO output enable bit set register
	// Position of REG_RTCIO_REG_GPIO_ENABLE_W1TS field.
	RTCIO_RTC_GPIO_ENABLE_W1TS_REG_RTCIO_REG_GPIO_ENABLE_W1TS_Pos = 0xa
	// Bit mask of REG_RTCIO_REG_GPIO_ENABLE_W1TS field.
	RTCIO_RTC_GPIO_ENABLE_W1TS_REG_RTCIO_REG_GPIO_ENABLE_W1TS_Msk = 0xfffffc00

	// RTC_GPIO_ENABLE_W1TC: RTC GPIO output enable bit clear register
	// Position of REG_RTCIO_REG_GPIO_ENABLE_W1TC field.
	RTCIO_RTC_GPIO_ENABLE_W1TC_REG_RTCIO_REG_GPIO_ENABLE_W1TC_Pos = 0xa
	// Bit mask of REG_RTCIO_REG_GPIO_ENABLE_W1TC field.
	RTCIO_RTC_GPIO_ENABLE_W1TC_REG_RTCIO_REG_GPIO_ENABLE_W1TC_Msk = 0xfffffc00

	// RTC_GPIO_STATUS: RTC GPIO interrupt status register
	// Position of GPIO_STATUS_INT field.
	RTCIO_RTC_GPIO_STATUS_GPIO_STATUS_INT_Pos = 0xa
	// Bit mask of GPIO_STATUS_INT field.
	RTCIO_RTC_GPIO_STATUS_GPIO_STATUS_INT_Msk = 0xfffffc00

	// RTC_GPIO_STATUS_W1TS: RTC GPIO interrupt status bit set register
	// Position of GPIO_STATUS_INT_W1TS field.
	RTCIO_RTC_GPIO_STATUS_W1TS_GPIO_STATUS_INT_W1TS_Pos = 0xa
	// Bit mask of GPIO_STATUS_INT_W1TS field.
	RTCIO_RTC_GPIO_STATUS_W1TS_GPIO_STATUS_INT_W1TS_Msk = 0xfffffc00

	// RTC_GPIO_STATUS_W1TC: RTC GPIO interrupt status bit clear register
	// Position of GPIO_STATUS_INT_W1TC field.
	RTCIO_RTC_GPIO_STATUS_W1TC_GPIO_STATUS_INT_W1TC_Pos = 0xa
	// Bit mask of GPIO_STATUS_INT_W1TC field.
	RTCIO_RTC_GPIO_STATUS_W1TC_GPIO_STATUS_INT_W1TC_Msk = 0xfffffc00

	// RTC_GPIO_IN: RTC GPIO input register
	// Position of GPIO_IN_NEXT field.
	RTCIO_RTC_GPIO_IN_GPIO_IN_NEXT_Pos = 0xa
	// Bit mask of GPIO_IN_NEXT field.
	RTCIO_RTC_GPIO_IN_GPIO_IN_NEXT_Msk = 0xfffffc00

	// RTC_GPIO_PIN0: RTC configuration for pin %s
	// Position of GPIO_PIN0_PAD_DRIVER field.
	RTCIO_RTC_GPIO_PIN_GPIO_PIN0_PAD_DRIVER_Pos = 0x2
	// Bit mask of GPIO_PIN0_PAD_DRIVER field.
	RTCIO_RTC_GPIO_PIN_GPIO_PIN0_PAD_DRIVER_Msk = 0x4
	// Bit GPIO_PIN0_PAD_DRIVER.
	RTCIO_RTC_GPIO_PIN_GPIO_PIN0_PAD_DRIVER = 0x4
	// Position of GPIO_PIN0_INT_TYPE field.
	RTCIO_RTC_GPIO_PIN_GPIO_PIN0_INT_TYPE_Pos = 0x7
	// Bit mask of GPIO_PIN0_INT_TYPE field.
	RTCIO_RTC_GPIO_PIN_GPIO_PIN0_INT_TYPE_Msk = 0x380
	// Position of GPIO_PIN0_WAKEUP_ENABLE field.
	RTCIO_RTC_GPIO_PIN_GPIO_PIN0_WAKEUP_ENABLE_Pos = 0xa
	// Bit mask of GPIO_PIN0_WAKEUP_ENABLE field.
	RTCIO_RTC_GPIO_PIN_GPIO_PIN0_WAKEUP_ENABLE_Msk = 0x400
	// Bit GPIO_PIN0_WAKEUP_ENABLE.
	RTCIO_RTC_GPIO_PIN_GPIO_PIN0_WAKEUP_ENABLE = 0x400

	// RTC_DEBUG_SEL: RTC debug select register
	// Position of RTC_DEBUG_SEL0 field.
	RTCIO_RTC_DEBUG_SEL_RTC_DEBUG_SEL0_Pos = 0x0
	// Bit mask of RTC_DEBUG_SEL0 field.
	RTCIO_RTC_DEBUG_SEL_RTC_DEBUG_SEL0_Msk = 0x1f
	// Position of RTC_DEBUG_SEL1 field.
	RTCIO_RTC_DEBUG_SEL_RTC_DEBUG_SEL1_Pos = 0x5
	// Bit mask of RTC_DEBUG_SEL1 field.
	RTCIO_RTC_DEBUG_SEL_RTC_DEBUG_SEL1_Msk = 0x3e0
	// Position of RTC_DEBUG_SEL2 field.
	RTCIO_RTC_DEBUG_SEL_RTC_DEBUG_SEL2_Pos = 0xa
	// Bit mask of RTC_DEBUG_SEL2 field.
	RTCIO_RTC_DEBUG_SEL_RTC_DEBUG_SEL2_Msk = 0x7c00
	// Position of RTC_DEBUG_SEL3 field.
	RTCIO_RTC_DEBUG_SEL_RTC_DEBUG_SEL3_Pos = 0xf
	// Bit mask of RTC_DEBUG_SEL3 field.
	RTCIO_RTC_DEBUG_SEL_RTC_DEBUG_SEL3_Msk = 0xf8000
	// Position of RTC_DEBUG_SEL4 field.
	RTCIO_RTC_DEBUG_SEL_RTC_DEBUG_SEL4_Pos = 0x14
	// Bit mask of RTC_DEBUG_SEL4 field.
	RTCIO_RTC_DEBUG_SEL_RTC_DEBUG_SEL4_Msk = 0x1f00000
	// Position of RTC_DEBUG_12M_NO_GATING field.
	RTCIO_RTC_DEBUG_SEL_RTC_DEBUG_12M_NO_GATING_Pos = 0x19
	// Bit mask of RTC_DEBUG_12M_NO_GATING field.
	RTCIO_RTC_DEBUG_SEL_RTC_DEBUG_12M_NO_GATING_Msk = 0x2000000
	// Bit RTC_DEBUG_12M_NO_GATING.
	RTCIO_RTC_DEBUG_SEL_RTC_DEBUG_12M_NO_GATING = 0x2000000

	// TOUCH_PAD0: Touch pad %s configuration register
	// Position of TOUCH_PAD0_FUN_IE field.
	RTCIO_TOUCH_PAD_TOUCH_PAD0_FUN_IE_Pos = 0xd
	// Bit mask of TOUCH_PAD0_FUN_IE field.
	RTCIO_TOUCH_PAD_TOUCH_PAD0_FUN_IE_Msk = 0x2000
	// Bit TOUCH_PAD0_FUN_IE.
	RTCIO_TOUCH_PAD_TOUCH_PAD0_FUN_IE = 0x2000
	// Position of TOUCH_PAD0_SLP_OE field.
	RTCIO_TOUCH_PAD_TOUCH_PAD0_SLP_OE_Pos = 0xe
	// Bit mask of TOUCH_PAD0_SLP_OE field.
	RTCIO_TOUCH_PAD_TOUCH_PAD0_SLP_OE_Msk = 0x4000
	// Bit TOUCH_PAD0_SLP_OE.
	RTCIO_TOUCH_PAD_TOUCH_PAD0_SLP_OE = 0x4000
	// Position of TOUCH_PAD0_SLP_IE field.
	RTCIO_TOUCH_PAD_TOUCH_PAD0_SLP_IE_Pos = 0xf
	// Bit mask of TOUCH_PAD0_SLP_IE field.
	RTCIO_TOUCH_PAD_TOUCH_PAD0_SLP_IE_Msk = 0x8000
	// Bit TOUCH_PAD0_SLP_IE.
	RTCIO_TOUCH_PAD_TOUCH_PAD0_SLP_IE = 0x8000
	// Position of TOUCH_PAD0_SLP_SEL field.
	RTCIO_TOUCH_PAD_TOUCH_PAD0_SLP_SEL_Pos = 0x10
	// Bit mask of TOUCH_PAD0_SLP_SEL field.
	RTCIO_TOUCH_PAD_TOUCH_PAD0_SLP_SEL_Msk = 0x10000
	// Bit TOUCH_PAD0_SLP_SEL.
	RTCIO_TOUCH_PAD_TOUCH_PAD0_SLP_SEL = 0x10000
	// Position of TOUCH_PAD0_FUN_SEL field.
	RTCIO_TOUCH_PAD_TOUCH_PAD0_FUN_SEL_Pos = 0x11
	// Bit mask of TOUCH_PAD0_FUN_SEL field.
	RTCIO_TOUCH_PAD_TOUCH_PAD0_FUN_SEL_Msk = 0x60000
	// Position of TOUCH_PAD0_MUX_SEL field.
	RTCIO_TOUCH_PAD_TOUCH_PAD0_MUX_SEL_Pos = 0x13
	// Bit mask of TOUCH_PAD0_MUX_SEL field.
	RTCIO_TOUCH_PAD_TOUCH_PAD0_MUX_SEL_Msk = 0x80000
	// Bit TOUCH_PAD0_MUX_SEL.
	RTCIO_TOUCH_PAD_TOUCH_PAD0_MUX_SEL = 0x80000
	// Position of TOUCH_PAD0_XPD field.
	RTCIO_TOUCH_PAD_TOUCH_PAD0_XPD_Pos = 0x14
	// Bit mask of TOUCH_PAD0_XPD field.
	RTCIO_TOUCH_PAD_TOUCH_PAD0_XPD_Msk = 0x100000
	// Bit TOUCH_PAD0_XPD.
	RTCIO_TOUCH_PAD_TOUCH_PAD0_XPD = 0x100000
	// Position of TOUCH_PAD0_TIE_OPT field.
	RTCIO_TOUCH_PAD_TOUCH_PAD0_TIE_OPT_Pos = 0x15
	// Bit mask of TOUCH_PAD0_TIE_OPT field.
	RTCIO_TOUCH_PAD_TOUCH_PAD0_TIE_OPT_Msk = 0x200000
	// Bit TOUCH_PAD0_TIE_OPT.
	RTCIO_TOUCH_PAD_TOUCH_PAD0_TIE_OPT = 0x200000
	// Position of TOUCH_PAD0_START field.
	RTCIO_TOUCH_PAD_TOUCH_PAD0_START_Pos = 0x16
	// Bit mask of TOUCH_PAD0_START field.
	RTCIO_TOUCH_PAD_TOUCH_PAD0_START_Msk = 0x400000
	// Bit TOUCH_PAD0_START.
	RTCIO_TOUCH_PAD_TOUCH_PAD0_START = 0x400000
	// Position of TOUCH_PAD0_DAC field.
	RTCIO_TOUCH_PAD_TOUCH_PAD0_DAC_Pos = 0x17
	// Bit mask of TOUCH_PAD0_DAC field.
	RTCIO_TOUCH_PAD_TOUCH_PAD0_DAC_Msk = 0x3800000
	// Position of TOUCH_PAD0_RUE field.
	RTCIO_TOUCH_PAD_TOUCH_PAD0_RUE_Pos = 0x1b
	// Bit mask of TOUCH_PAD0_RUE field.
	RTCIO_TOUCH_PAD_TOUCH_PAD0_RUE_Msk = 0x8000000
	// Bit TOUCH_PAD0_RUE.
	RTCIO_TOUCH_PAD_TOUCH_PAD0_RUE = 0x8000000
	// Position of TOUCH_PAD0_RDE field.
	RTCIO_TOUCH_PAD_TOUCH_PAD0_RDE_Pos = 0x1c
	// Bit mask of TOUCH_PAD0_RDE field.
	RTCIO_TOUCH_PAD_TOUCH_PAD0_RDE_Msk = 0x10000000
	// Bit TOUCH_PAD0_RDE.
	RTCIO_TOUCH_PAD_TOUCH_PAD0_RDE = 0x10000000
	// Position of TOUCH_PAD0_DRV field.
	RTCIO_TOUCH_PAD_TOUCH_PAD0_DRV_Pos = 0x1d
	// Bit mask of TOUCH_PAD0_DRV field.
	RTCIO_TOUCH_PAD_TOUCH_PAD0_DRV_Msk = 0x60000000

	// XTAL_32P_PAD: 32KHz crystal P-pad configuration register
	// Position of X32P_FUN_IE field.
	RTCIO_XTAL_32P_PAD_X32P_FUN_IE_Pos = 0xd
	// Bit mask of X32P_FUN_IE field.
	RTCIO_XTAL_32P_PAD_X32P_FUN_IE_Msk = 0x2000
	// Bit X32P_FUN_IE.
	RTCIO_XTAL_32P_PAD_X32P_FUN_IE = 0x2000
	// Position of X32P_SLP_OE field.
	RTCIO_XTAL_32P_PAD_X32P_SLP_OE_Pos = 0xe
	// Bit mask of X32P_SLP_OE field.
	RTCIO_XTAL_32P_PAD_X32P_SLP_OE_Msk = 0x4000
	// Bit X32P_SLP_OE.
	RTCIO_XTAL_32P_PAD_X32P_SLP_OE = 0x4000
	// Position of X32P_SLP_IE field.
	RTCIO_XTAL_32P_PAD_X32P_SLP_IE_Pos = 0xf
	// Bit mask of X32P_SLP_IE field.
	RTCIO_XTAL_32P_PAD_X32P_SLP_IE_Msk = 0x8000
	// Bit X32P_SLP_IE.
	RTCIO_XTAL_32P_PAD_X32P_SLP_IE = 0x8000
	// Position of X32P_SLP_SEL field.
	RTCIO_XTAL_32P_PAD_X32P_SLP_SEL_Pos = 0x10
	// Bit mask of X32P_SLP_SEL field.
	RTCIO_XTAL_32P_PAD_X32P_SLP_SEL_Msk = 0x10000
	// Bit X32P_SLP_SEL.
	RTCIO_XTAL_32P_PAD_X32P_SLP_SEL = 0x10000
	// Position of X32P_FUN_SEL field.
	RTCIO_XTAL_32P_PAD_X32P_FUN_SEL_Pos = 0x11
	// Bit mask of X32P_FUN_SEL field.
	RTCIO_XTAL_32P_PAD_X32P_FUN_SEL_Msk = 0x60000
	// Position of X32P_MUX_SEL field.
	RTCIO_XTAL_32P_PAD_X32P_MUX_SEL_Pos = 0x13
	// Bit mask of X32P_MUX_SEL field.
	RTCIO_XTAL_32P_PAD_X32P_MUX_SEL_Msk = 0x80000
	// Bit X32P_MUX_SEL.
	RTCIO_XTAL_32P_PAD_X32P_MUX_SEL = 0x80000
	// Position of X32P_RUE field.
	RTCIO_XTAL_32P_PAD_X32P_RUE_Pos = 0x1b
	// Bit mask of X32P_RUE field.
	RTCIO_XTAL_32P_PAD_X32P_RUE_Msk = 0x8000000
	// Bit X32P_RUE.
	RTCIO_XTAL_32P_PAD_X32P_RUE = 0x8000000
	// Position of X32P_RDE field.
	RTCIO_XTAL_32P_PAD_X32P_RDE_Pos = 0x1c
	// Bit mask of X32P_RDE field.
	RTCIO_XTAL_32P_PAD_X32P_RDE_Msk = 0x10000000
	// Bit X32P_RDE.
	RTCIO_XTAL_32P_PAD_X32P_RDE = 0x10000000
	// Position of X32P_DRV field.
	RTCIO_XTAL_32P_PAD_X32P_DRV_Pos = 0x1d
	// Bit mask of X32P_DRV field.
	RTCIO_XTAL_32P_PAD_X32P_DRV_Msk = 0x60000000

	// XTAL_32N_PAD: 32KHz crystal N-pad configuration register
	// Position of X32N_FUN_IE field.
	RTCIO_XTAL_32N_PAD_X32N_FUN_IE_Pos = 0xd
	// Bit mask of X32N_FUN_IE field.
	RTCIO_XTAL_32N_PAD_X32N_FUN_IE_Msk = 0x2000
	// Bit X32N_FUN_IE.
	RTCIO_XTAL_32N_PAD_X32N_FUN_IE = 0x2000
	// Position of X32N_SLP_OE field.
	RTCIO_XTAL_32N_PAD_X32N_SLP_OE_Pos = 0xe
	// Bit mask of X32N_SLP_OE field.
	RTCIO_XTAL_32N_PAD_X32N_SLP_OE_Msk = 0x4000
	// Bit X32N_SLP_OE.
	RTCIO_XTAL_32N_PAD_X32N_SLP_OE = 0x4000
	// Position of X32N_SLP_IE field.
	RTCIO_XTAL_32N_PAD_X32N_SLP_IE_Pos = 0xf
	// Bit mask of X32N_SLP_IE field.
	RTCIO_XTAL_32N_PAD_X32N_SLP_IE_Msk = 0x8000
	// Bit X32N_SLP_IE.
	RTCIO_XTAL_32N_PAD_X32N_SLP_IE = 0x8000
	// Position of X32N_SLP_SEL field.
	RTCIO_XTAL_32N_PAD_X32N_SLP_SEL_Pos = 0x10
	// Bit mask of X32N_SLP_SEL field.
	RTCIO_XTAL_32N_PAD_X32N_SLP_SEL_Msk = 0x10000
	// Bit X32N_SLP_SEL.
	RTCIO_XTAL_32N_PAD_X32N_SLP_SEL = 0x10000
	// Position of X32N_FUN_SEL field.
	RTCIO_XTAL_32N_PAD_X32N_FUN_SEL_Pos = 0x11
	// Bit mask of X32N_FUN_SEL field.
	RTCIO_XTAL_32N_PAD_X32N_FUN_SEL_Msk = 0x60000
	// Position of X32N_MUX_SEL field.
	RTCIO_XTAL_32N_PAD_X32N_MUX_SEL_Pos = 0x13
	// Bit mask of X32N_MUX_SEL field.
	RTCIO_XTAL_32N_PAD_X32N_MUX_SEL_Msk = 0x80000
	// Bit X32N_MUX_SEL.
	RTCIO_XTAL_32N_PAD_X32N_MUX_SEL = 0x80000
	// Position of X32N_RUE field.
	RTCIO_XTAL_32N_PAD_X32N_RUE_Pos = 0x1b
	// Bit mask of X32N_RUE field.
	RTCIO_XTAL_32N_PAD_X32N_RUE_Msk = 0x8000000
	// Bit X32N_RUE.
	RTCIO_XTAL_32N_PAD_X32N_RUE = 0x8000000
	// Position of X32N_RDE field.
	RTCIO_XTAL_32N_PAD_X32N_RDE_Pos = 0x1c
	// Bit mask of X32N_RDE field.
	RTCIO_XTAL_32N_PAD_X32N_RDE_Msk = 0x10000000
	// Bit X32N_RDE.
	RTCIO_XTAL_32N_PAD_X32N_RDE = 0x10000000
	// Position of X32N_DRV field.
	RTCIO_XTAL_32N_PAD_X32N_DRV_Pos = 0x1d
	// Bit mask of X32N_DRV field.
	RTCIO_XTAL_32N_PAD_X32N_DRV_Msk = 0x60000000

	// PAD_DAC1: DAC1 configuration register
	// Position of PDAC1_DAC field.
	RTCIO_PAD_DAC1_PDAC1_DAC_Pos = 0x3
	// Bit mask of PDAC1_DAC field.
	RTCIO_PAD_DAC1_PDAC1_DAC_Msk = 0x7f8
	// Position of PDAC1_XPD_DAC field.
	RTCIO_PAD_DAC1_PDAC1_XPD_DAC_Pos = 0xb
	// Bit mask of PDAC1_XPD_DAC field.
	RTCIO_PAD_DAC1_PDAC1_XPD_DAC_Msk = 0x800
	// Bit PDAC1_XPD_DAC.
	RTCIO_PAD_DAC1_PDAC1_XPD_DAC = 0x800
	// Position of PDAC1_DAC_XPD_FORCE field.
	RTCIO_PAD_DAC1_PDAC1_DAC_XPD_FORCE_Pos = 0xc
	// Bit mask of PDAC1_DAC_XPD_FORCE field.
	RTCIO_PAD_DAC1_PDAC1_DAC_XPD_FORCE_Msk = 0x1000
	// Bit PDAC1_DAC_XPD_FORCE.
	RTCIO_PAD_DAC1_PDAC1_DAC_XPD_FORCE = 0x1000
	// Position of PDAC1_FUN_IE field.
	RTCIO_PAD_DAC1_PDAC1_FUN_IE_Pos = 0xd
	// Bit mask of PDAC1_FUN_IE field.
	RTCIO_PAD_DAC1_PDAC1_FUN_IE_Msk = 0x2000
	// Bit PDAC1_FUN_IE.
	RTCIO_PAD_DAC1_PDAC1_FUN_IE = 0x2000
	// Position of PDAC1_SLP_OE field.
	RTCIO_PAD_DAC1_PDAC1_SLP_OE_Pos = 0xe
	// Bit mask of PDAC1_SLP_OE field.
	RTCIO_PAD_DAC1_PDAC1_SLP_OE_Msk = 0x4000
	// Bit PDAC1_SLP_OE.
	RTCIO_PAD_DAC1_PDAC1_SLP_OE = 0x4000
	// Position of PDAC1_SLP_IE field.
	RTCIO_PAD_DAC1_PDAC1_SLP_IE_Pos = 0xf
	// Bit mask of PDAC1_SLP_IE field.
	RTCIO_PAD_DAC1_PDAC1_SLP_IE_Msk = 0x8000
	// Bit PDAC1_SLP_IE.
	RTCIO_PAD_DAC1_PDAC1_SLP_IE = 0x8000
	// Position of PDAC1_SLP_SEL field.
	RTCIO_PAD_DAC1_PDAC1_SLP_SEL_Pos = 0x10
	// Bit mask of PDAC1_SLP_SEL field.
	RTCIO_PAD_DAC1_PDAC1_SLP_SEL_Msk = 0x10000
	// Bit PDAC1_SLP_SEL.
	RTCIO_PAD_DAC1_PDAC1_SLP_SEL = 0x10000
	// Position of PDAC1_FUN_SEL field.
	RTCIO_PAD_DAC1_PDAC1_FUN_SEL_Pos = 0x11
	// Bit mask of PDAC1_FUN_SEL field.
	RTCIO_PAD_DAC1_PDAC1_FUN_SEL_Msk = 0x60000
	// Position of PDAC1_MUX_SEL field.
	RTCIO_PAD_DAC1_PDAC1_MUX_SEL_Pos = 0x13
	// Bit mask of PDAC1_MUX_SEL field.
	RTCIO_PAD_DAC1_PDAC1_MUX_SEL_Msk = 0x80000
	// Bit PDAC1_MUX_SEL.
	RTCIO_PAD_DAC1_PDAC1_MUX_SEL = 0x80000
	// Position of PDAC1_RUE field.
	RTCIO_PAD_DAC1_PDAC1_RUE_Pos = 0x1b
	// Bit mask of PDAC1_RUE field.
	RTCIO_PAD_DAC1_PDAC1_RUE_Msk = 0x8000000
	// Bit PDAC1_RUE.
	RTCIO_PAD_DAC1_PDAC1_RUE = 0x8000000
	// Position of PDAC1_RDE field.
	RTCIO_PAD_DAC1_PDAC1_RDE_Pos = 0x1c
	// Bit mask of PDAC1_RDE field.
	RTCIO_PAD_DAC1_PDAC1_RDE_Msk = 0x10000000
	// Bit PDAC1_RDE.
	RTCIO_PAD_DAC1_PDAC1_RDE = 0x10000000
	// Position of PDAC1_DRV field.
	RTCIO_PAD_DAC1_PDAC1_DRV_Pos = 0x1d
	// Bit mask of PDAC1_DRV field.
	RTCIO_PAD_DAC1_PDAC1_DRV_Msk = 0x60000000

	// PAD_DAC2: DAC2 configuration register
	// Position of PDAC2_DAC field.
	RTCIO_PAD_DAC2_PDAC2_DAC_Pos = 0x3
	// Bit mask of PDAC2_DAC field.
	RTCIO_PAD_DAC2_PDAC2_DAC_Msk = 0x7f8
	// Position of PDAC2_XPD_DAC field.
	RTCIO_PAD_DAC2_PDAC2_XPD_DAC_Pos = 0xb
	// Bit mask of PDAC2_XPD_DAC field.
	RTCIO_PAD_DAC2_PDAC2_XPD_DAC_Msk = 0x800
	// Bit PDAC2_XPD_DAC.
	RTCIO_PAD_DAC2_PDAC2_XPD_DAC = 0x800
	// Position of PDAC2_DAC_XPD_FORCE field.
	RTCIO_PAD_DAC2_PDAC2_DAC_XPD_FORCE_Pos = 0xc
	// Bit mask of PDAC2_DAC_XPD_FORCE field.
	RTCIO_PAD_DAC2_PDAC2_DAC_XPD_FORCE_Msk = 0x1000
	// Bit PDAC2_DAC_XPD_FORCE.
	RTCIO_PAD_DAC2_PDAC2_DAC_XPD_FORCE = 0x1000
	// Position of PDAC2_FUN_IE field.
	RTCIO_PAD_DAC2_PDAC2_FUN_IE_Pos = 0xd
	// Bit mask of PDAC2_FUN_IE field.
	RTCIO_PAD_DAC2_PDAC2_FUN_IE_Msk = 0x2000
	// Bit PDAC2_FUN_IE.
	RTCIO_PAD_DAC2_PDAC2_FUN_IE = 0x2000
	// Position of PDAC2_SLP_OE field.
	RTCIO_PAD_DAC2_PDAC2_SLP_OE_Pos = 0xe
	// Bit mask of PDAC2_SLP_OE field.
	RTCIO_PAD_DAC2_PDAC2_SLP_OE_Msk = 0x4000
	// Bit PDAC2_SLP_OE.
	RTCIO_PAD_DAC2_PDAC2_SLP_OE = 0x4000
	// Position of PDAC2_SLP_IE field.
	RTCIO_PAD_DAC2_PDAC2_SLP_IE_Pos = 0xf
	// Bit mask of PDAC2_SLP_IE field.
	RTCIO_PAD_DAC2_PDAC2_SLP_IE_Msk = 0x8000
	// Bit PDAC2_SLP_IE.
	RTCIO_PAD_DAC2_PDAC2_SLP_IE = 0x8000
	// Position of PDAC2_SLP_SEL field.
	RTCIO_PAD_DAC2_PDAC2_SLP_SEL_Pos = 0x10
	// Bit mask of PDAC2_SLP_SEL field.
	RTCIO_PAD_DAC2_PDAC2_SLP_SEL_Msk = 0x10000
	// Bit PDAC2_SLP_SEL.
	RTCIO_PAD_DAC2_PDAC2_SLP_SEL = 0x10000
	// Position of PDAC2_FUN_SEL field.
	RTCIO_PAD_DAC2_PDAC2_FUN_SEL_Pos = 0x11
	// Bit mask of PDAC2_FUN_SEL field.
	RTCIO_PAD_DAC2_PDAC2_FUN_SEL_Msk = 0x60000
	// Position of PDAC2_MUX_SEL field.
	RTCIO_PAD_DAC2_PDAC2_MUX_SEL_Pos = 0x13
	// Bit mask of PDAC2_MUX_SEL field.
	RTCIO_PAD_DAC2_PDAC2_MUX_SEL_Msk = 0x80000
	// Bit PDAC2_MUX_SEL.
	RTCIO_PAD_DAC2_PDAC2_MUX_SEL = 0x80000
	// Position of PDAC2_RUE field.
	RTCIO_PAD_DAC2_PDAC2_RUE_Pos = 0x1b
	// Bit mask of PDAC2_RUE field.
	RTCIO_PAD_DAC2_PDAC2_RUE_Msk = 0x8000000
	// Bit PDAC2_RUE.
	RTCIO_PAD_DAC2_PDAC2_RUE = 0x8000000
	// Position of PDAC2_RDE field.
	RTCIO_PAD_DAC2_PDAC2_RDE_Pos = 0x1c
	// Bit mask of PDAC2_RDE field.
	RTCIO_PAD_DAC2_PDAC2_RDE_Msk = 0x10000000
	// Bit PDAC2_RDE.
	RTCIO_PAD_DAC2_PDAC2_RDE = 0x10000000
	// Position of PDAC2_DRV field.
	RTCIO_PAD_DAC2_PDAC2_DRV_Pos = 0x1d
	// Bit mask of PDAC2_DRV field.
	RTCIO_PAD_DAC2_PDAC2_DRV_Msk = 0x60000000

	// RTC_PAD19: Touch pad 19 configuration register
	// Position of FUN_IE field.
	RTCIO_RTC_PAD19_FUN_IE_Pos = 0xd
	// Bit mask of FUN_IE field.
	RTCIO_RTC_PAD19_FUN_IE_Msk = 0x2000
	// Bit FUN_IE.
	RTCIO_RTC_PAD19_FUN_IE = 0x2000
	// Position of SLP_OE field.
	RTCIO_RTC_PAD19_SLP_OE_Pos = 0xe
	// Bit mask of SLP_OE field.
	RTCIO_RTC_PAD19_SLP_OE_Msk = 0x4000
	// Bit SLP_OE.
	RTCIO_RTC_PAD19_SLP_OE = 0x4000
	// Position of SLP_IE field.
	RTCIO_RTC_PAD19_SLP_IE_Pos = 0xf
	// Bit mask of SLP_IE field.
	RTCIO_RTC_PAD19_SLP_IE_Msk = 0x8000
	// Bit SLP_IE.
	RTCIO_RTC_PAD19_SLP_IE = 0x8000
	// Position of SLP_SEL field.
	RTCIO_RTC_PAD19_SLP_SEL_Pos = 0x10
	// Bit mask of SLP_SEL field.
	RTCIO_RTC_PAD19_SLP_SEL_Msk = 0x10000
	// Bit SLP_SEL.
	RTCIO_RTC_PAD19_SLP_SEL = 0x10000
	// Position of FUN_SEL field.
	RTCIO_RTC_PAD19_FUN_SEL_Pos = 0x11
	// Bit mask of FUN_SEL field.
	RTCIO_RTC_PAD19_FUN_SEL_Msk = 0x60000
	// Position of MUX_SEL field.
	RTCIO_RTC_PAD19_MUX_SEL_Pos = 0x13
	// Bit mask of MUX_SEL field.
	RTCIO_RTC_PAD19_MUX_SEL_Msk = 0x80000
	// Bit MUX_SEL.
	RTCIO_RTC_PAD19_MUX_SEL = 0x80000
	// Position of RUE field.
	RTCIO_RTC_PAD19_RUE_Pos = 0x1b
	// Bit mask of RUE field.
	RTCIO_RTC_PAD19_RUE_Msk = 0x8000000
	// Bit RUE.
	RTCIO_RTC_PAD19_RUE = 0x8000000
	// Position of RDE field.
	RTCIO_RTC_PAD19_RDE_Pos = 0x1c
	// Bit mask of RDE field.
	RTCIO_RTC_PAD19_RDE_Msk = 0x10000000
	// Bit RDE.
	RTCIO_RTC_PAD19_RDE = 0x10000000
	// Position of DRV field.
	RTCIO_RTC_PAD19_DRV_Pos = 0x1d
	// Bit mask of DRV field.
	RTCIO_RTC_PAD19_DRV_Msk = 0x60000000

	// RTC_PAD20: Touch pad 20 configuration register
	// Position of FUN_IE field.
	RTCIO_RTC_PAD20_FUN_IE_Pos = 0xd
	// Bit mask of FUN_IE field.
	RTCIO_RTC_PAD20_FUN_IE_Msk = 0x2000
	// Bit FUN_IE.
	RTCIO_RTC_PAD20_FUN_IE = 0x2000
	// Position of SLP_OE field.
	RTCIO_RTC_PAD20_SLP_OE_Pos = 0xe
	// Bit mask of SLP_OE field.
	RTCIO_RTC_PAD20_SLP_OE_Msk = 0x4000
	// Bit SLP_OE.
	RTCIO_RTC_PAD20_SLP_OE = 0x4000
	// Position of SLP_IE field.
	RTCIO_RTC_PAD20_SLP_IE_Pos = 0xf
	// Bit mask of SLP_IE field.
	RTCIO_RTC_PAD20_SLP_IE_Msk = 0x8000
	// Bit SLP_IE.
	RTCIO_RTC_PAD20_SLP_IE = 0x8000
	// Position of SLP_SEL field.
	RTCIO_RTC_PAD20_SLP_SEL_Pos = 0x10
	// Bit mask of SLP_SEL field.
	RTCIO_RTC_PAD20_SLP_SEL_Msk = 0x10000
	// Bit SLP_SEL.
	RTCIO_RTC_PAD20_SLP_SEL = 0x10000
	// Position of FUN_SEL field.
	RTCIO_RTC_PAD20_FUN_SEL_Pos = 0x11
	// Bit mask of FUN_SEL field.
	RTCIO_RTC_PAD20_FUN_SEL_Msk = 0x60000
	// Position of MUX_SEL field.
	RTCIO_RTC_PAD20_MUX_SEL_Pos = 0x13
	// Bit mask of MUX_SEL field.
	RTCIO_RTC_PAD20_MUX_SEL_Msk = 0x80000
	// Bit MUX_SEL.
	RTCIO_RTC_PAD20_MUX_SEL = 0x80000
	// Position of RUE field.
	RTCIO_RTC_PAD20_RUE_Pos = 0x1b
	// Bit mask of RUE field.
	RTCIO_RTC_PAD20_RUE_Msk = 0x8000000
	// Bit RUE.
	RTCIO_RTC_PAD20_RUE = 0x8000000
	// Position of RDE field.
	RTCIO_RTC_PAD20_RDE_Pos = 0x1c
	// Bit mask of RDE field.
	RTCIO_RTC_PAD20_RDE_Msk = 0x10000000
	// Bit RDE.
	RTCIO_RTC_PAD20_RDE = 0x10000000
	// Position of DRV field.
	RTCIO_RTC_PAD20_DRV_Pos = 0x1d
	// Bit mask of DRV field.
	RTCIO_RTC_PAD20_DRV_Msk = 0x60000000

	// RTC_PAD21: Touch pad 21 configuration register
	// Position of FUN_IE field.
	RTCIO_RTC_PAD21_FUN_IE_Pos = 0xd
	// Bit mask of FUN_IE field.
	RTCIO_RTC_PAD21_FUN_IE_Msk = 0x2000
	// Bit FUN_IE.
	RTCIO_RTC_PAD21_FUN_IE = 0x2000
	// Position of SLP_OE field.
	RTCIO_RTC_PAD21_SLP_OE_Pos = 0xe
	// Bit mask of SLP_OE field.
	RTCIO_RTC_PAD21_SLP_OE_Msk = 0x4000
	// Bit SLP_OE.
	RTCIO_RTC_PAD21_SLP_OE = 0x4000
	// Position of SLP_IE field.
	RTCIO_RTC_PAD21_SLP_IE_Pos = 0xf
	// Bit mask of SLP_IE field.
	RTCIO_RTC_PAD21_SLP_IE_Msk = 0x8000
	// Bit SLP_IE.
	RTCIO_RTC_PAD21_SLP_IE = 0x8000
	// Position of SLP_SEL field.
	RTCIO_RTC_PAD21_SLP_SEL_Pos = 0x10
	// Bit mask of SLP_SEL field.
	RTCIO_RTC_PAD21_SLP_SEL_Msk = 0x10000
	// Bit SLP_SEL.
	RTCIO_RTC_PAD21_SLP_SEL = 0x10000
	// Position of FUN_SEL field.
	RTCIO_RTC_PAD21_FUN_SEL_Pos = 0x11
	// Bit mask of FUN_SEL field.
	RTCIO_RTC_PAD21_FUN_SEL_Msk = 0x60000
	// Position of MUX_SEL field.
	RTCIO_RTC_PAD21_MUX_SEL_Pos = 0x13
	// Bit mask of MUX_SEL field.
	RTCIO_RTC_PAD21_MUX_SEL_Msk = 0x80000
	// Bit MUX_SEL.
	RTCIO_RTC_PAD21_MUX_SEL = 0x80000
	// Position of RUE field.
	RTCIO_RTC_PAD21_RUE_Pos = 0x1b
	// Bit mask of RUE field.
	RTCIO_RTC_PAD21_RUE_Msk = 0x8000000
	// Bit RUE.
	RTCIO_RTC_PAD21_RUE = 0x8000000
	// Position of RDE field.
	RTCIO_RTC_PAD21_RDE_Pos = 0x1c
	// Bit mask of RDE field.
	RTCIO_RTC_PAD21_RDE_Msk = 0x10000000
	// Bit RDE.
	RTCIO_RTC_PAD21_RDE = 0x10000000
	// Position of DRV field.
	RTCIO_RTC_PAD21_DRV_Pos = 0x1d
	// Bit mask of DRV field.
	RTCIO_RTC_PAD21_DRV_Msk = 0x60000000

	// EXT_WAKEUP0: External wake up configuration register
	// Position of SEL field.
	RTCIO_EXT_WAKEUP0_SEL_Pos = 0x1b
	// Bit mask of SEL field.
	RTCIO_EXT_WAKEUP0_SEL_Msk = 0xf8000000

	// XTL_EXT_CTR: Crystal power down enable GPIO source
	// Position of SEL field.
	RTCIO_XTL_EXT_CTR_SEL_Pos = 0x1b
	// Bit mask of SEL field.
	RTCIO_XTL_EXT_CTR_SEL_Msk = 0xf8000000

	// SAR_I2C_IO: RTC I²C pad selection
	// Position of SAR_DEBUG_BIT_SEL field.
	RTCIO_SAR_I2C_IO_SAR_DEBUG_BIT_SEL_Pos = 0x17
	// Bit mask of SAR_DEBUG_BIT_SEL field.
	RTCIO_SAR_I2C_IO_SAR_DEBUG_BIT_SEL_Msk = 0xf800000
	// Position of SAR_I2C_SCL_SEL field.
	RTCIO_SAR_I2C_IO_SAR_I2C_SCL_SEL_Pos = 0x1c
	// Bit mask of SAR_I2C_SCL_SEL field.
	RTCIO_SAR_I2C_IO_SAR_I2C_SCL_SEL_Msk = 0x30000000
	// Position of SAR_I2C_SDA_SEL field.
	RTCIO_SAR_I2C_IO_SAR_I2C_SDA_SEL_Pos = 0x1e
	// Bit mask of SAR_I2C_SDA_SEL field.
	RTCIO_SAR_I2C_IO_SAR_I2C_SDA_SEL_Msk = 0xc0000000

	// RTC_IO_TOUCH_CTRL: Touch Control register
	// Position of IO_TOUCH_BUFSEL field.
	RTCIO_RTC_IO_TOUCH_CTRL_IO_TOUCH_BUFSEL_Pos = 0x0
	// Bit mask of IO_TOUCH_BUFSEL field.
	RTCIO_RTC_IO_TOUCH_CTRL_IO_TOUCH_BUFSEL_Msk = 0xf
	// Position of IO_TOUCH_BUFMODE field.
	RTCIO_RTC_IO_TOUCH_CTRL_IO_TOUCH_BUFMODE_Pos = 0x4
	// Bit mask of IO_TOUCH_BUFMODE field.
	RTCIO_RTC_IO_TOUCH_CTRL_IO_TOUCH_BUFMODE_Msk = 0x10
	// Bit IO_TOUCH_BUFMODE.
	RTCIO_RTC_IO_TOUCH_CTRL_IO_TOUCH_BUFMODE = 0x10

	// RTC_IO_DATE: Version control register
	// Position of IO_DATE field.
	RTCIO_RTC_IO_DATE_IO_DATE_Pos = 0x0
	// Bit mask of IO_DATE field.
	RTCIO_RTC_IO_DATE_IO_DATE_Msk = 0xfffffff
)

// Constants for RTC_CNTL: Peripheral RTC_CNTL
const (
	// OPTIONS0: Sets the power options of crystal and PLL clocks, and initiates reset by software
	// Position of SW_STALL_APPCPU_C0 field.
	RTC_CNTL_OPTIONS0_SW_STALL_APPCPU_C0_Pos = 0x0
	// Bit mask of SW_STALL_APPCPU_C0 field.
	RTC_CNTL_OPTIONS0_SW_STALL_APPCPU_C0_Msk = 0x3
	// Position of SW_STALL_PROCPU_C0 field.
	RTC_CNTL_OPTIONS0_SW_STALL_PROCPU_C0_Pos = 0x2
	// Bit mask of SW_STALL_PROCPU_C0 field.
	RTC_CNTL_OPTIONS0_SW_STALL_PROCPU_C0_Msk = 0xc
	// Position of SW_APPCPU_RST field.
	RTC_CNTL_OPTIONS0_SW_APPCPU_RST_Pos = 0x4
	// Bit mask of SW_APPCPU_RST field.
	RTC_CNTL_OPTIONS0_SW_APPCPU_RST_Msk = 0x10
	// Bit SW_APPCPU_RST.
	RTC_CNTL_OPTIONS0_SW_APPCPU_RST = 0x10
	// Position of SW_PROCPU_RST field.
	RTC_CNTL_OPTIONS0_SW_PROCPU_RST_Pos = 0x5
	// Bit mask of SW_PROCPU_RST field.
	RTC_CNTL_OPTIONS0_SW_PROCPU_RST_Msk = 0x20
	// Bit SW_PROCPU_RST.
	RTC_CNTL_OPTIONS0_SW_PROCPU_RST = 0x20
	// Position of BB_I2C_FORCE_PD field.
	RTC_CNTL_OPTIONS0_BB_I2C_FORCE_PD_Pos = 0x6
	// Bit mask of BB_I2C_FORCE_PD field.
	RTC_CNTL_OPTIONS0_BB_I2C_FORCE_PD_Msk = 0x40
	// Bit BB_I2C_FORCE_PD.
	RTC_CNTL_OPTIONS0_BB_I2C_FORCE_PD = 0x40
	// Position of BB_I2C_FORCE_PU field.
	RTC_CNTL_OPTIONS0_BB_I2C_FORCE_PU_Pos = 0x7
	// Bit mask of BB_I2C_FORCE_PU field.
	RTC_CNTL_OPTIONS0_BB_I2C_FORCE_PU_Msk = 0x80
	// Bit BB_I2C_FORCE_PU.
	RTC_CNTL_OPTIONS0_BB_I2C_FORCE_PU = 0x80
	// Position of BBPLL_I2C_FORCE_PD field.
	RTC_CNTL_OPTIONS0_BBPLL_I2C_FORCE_PD_Pos = 0x8
	// Bit mask of BBPLL_I2C_FORCE_PD field.
	RTC_CNTL_OPTIONS0_BBPLL_I2C_FORCE_PD_Msk = 0x100
	// Bit BBPLL_I2C_FORCE_PD.
	RTC_CNTL_OPTIONS0_BBPLL_I2C_FORCE_PD = 0x100
	// Position of BBPLL_I2C_FORCE_PU field.
	RTC_CNTL_OPTIONS0_BBPLL_I2C_FORCE_PU_Pos = 0x9
	// Bit mask of BBPLL_I2C_FORCE_PU field.
	RTC_CNTL_OPTIONS0_BBPLL_I2C_FORCE_PU_Msk = 0x200
	// Bit BBPLL_I2C_FORCE_PU.
	RTC_CNTL_OPTIONS0_BBPLL_I2C_FORCE_PU = 0x200
	// Position of BBPLL_FORCE_PD field.
	RTC_CNTL_OPTIONS0_BBPLL_FORCE_PD_Pos = 0xa
	// Bit mask of BBPLL_FORCE_PD field.
	RTC_CNTL_OPTIONS0_BBPLL_FORCE_PD_Msk = 0x400
	// Bit BBPLL_FORCE_PD.
	RTC_CNTL_OPTIONS0_BBPLL_FORCE_PD = 0x400
	// Position of BBPLL_FORCE_PU field.
	RTC_CNTL_OPTIONS0_BBPLL_FORCE_PU_Pos = 0xb
	// Bit mask of BBPLL_FORCE_PU field.
	RTC_CNTL_OPTIONS0_BBPLL_FORCE_PU_Msk = 0x800
	// Bit BBPLL_FORCE_PU.
	RTC_CNTL_OPTIONS0_BBPLL_FORCE_PU = 0x800
	// Position of XTL_FORCE_PD field.
	RTC_CNTL_OPTIONS0_XTL_FORCE_PD_Pos = 0xc
	// Bit mask of XTL_FORCE_PD field.
	RTC_CNTL_OPTIONS0_XTL_FORCE_PD_Msk = 0x1000
	// Bit XTL_FORCE_PD.
	RTC_CNTL_OPTIONS0_XTL_FORCE_PD = 0x1000
	// Position of XTL_FORCE_PU field.
	RTC_CNTL_OPTIONS0_XTL_FORCE_PU_Pos = 0xd
	// Bit mask of XTL_FORCE_PU field.
	RTC_CNTL_OPTIONS0_XTL_FORCE_PU_Msk = 0x2000
	// Bit XTL_FORCE_PU.
	RTC_CNTL_OPTIONS0_XTL_FORCE_PU = 0x2000
	// Position of XTL_FORCE_ISO field.
	RTC_CNTL_OPTIONS0_XTL_FORCE_ISO_Pos = 0x17
	// Bit mask of XTL_FORCE_ISO field.
	RTC_CNTL_OPTIONS0_XTL_FORCE_ISO_Msk = 0x800000
	// Bit XTL_FORCE_ISO.
	RTC_CNTL_OPTIONS0_XTL_FORCE_ISO = 0x800000
	// Position of PLL_FORCE_ISO field.
	RTC_CNTL_OPTIONS0_PLL_FORCE_ISO_Pos = 0x18
	// Bit mask of PLL_FORCE_ISO field.
	RTC_CNTL_OPTIONS0_PLL_FORCE_ISO_Msk = 0x1000000
	// Bit PLL_FORCE_ISO.
	RTC_CNTL_OPTIONS0_PLL_FORCE_ISO = 0x1000000
	// Position of ANALOG_FORCE_ISO field.
	RTC_CNTL_OPTIONS0_ANALOG_FORCE_ISO_Pos = 0x19
	// Bit mask of ANALOG_FORCE_ISO field.
	RTC_CNTL_OPTIONS0_ANALOG_FORCE_ISO_Msk = 0x2000000
	// Bit ANALOG_FORCE_ISO.
	RTC_CNTL_OPTIONS0_ANALOG_FORCE_ISO = 0x2000000
	// Position of XTL_FORCE_NOISO field.
	RTC_CNTL_OPTIONS0_XTL_FORCE_NOISO_Pos = 0x1a
	// Bit mask of XTL_FORCE_NOISO field.
	RTC_CNTL_OPTIONS0_XTL_FORCE_NOISO_Msk = 0x4000000
	// Bit XTL_FORCE_NOISO.
	RTC_CNTL_OPTIONS0_XTL_FORCE_NOISO = 0x4000000
	// Position of PLL_FORCE_NOISO field.
	RTC_CNTL_OPTIONS0_PLL_FORCE_NOISO_Pos = 0x1b
	// Bit mask of PLL_FORCE_NOISO field.
	RTC_CNTL_OPTIONS0_PLL_FORCE_NOISO_Msk = 0x8000000
	// Bit PLL_FORCE_NOISO.
	RTC_CNTL_OPTIONS0_PLL_FORCE_NOISO = 0x8000000
	// Position of ANALOG_FORCE_NOISO field.
	RTC_CNTL_OPTIONS0_ANALOG_FORCE_NOISO_Pos = 0x1c
	// Bit mask of ANALOG_FORCE_NOISO field.
	RTC_CNTL_OPTIONS0_ANALOG_FORCE_NOISO_Msk = 0x10000000
	// Bit ANALOG_FORCE_NOISO.
	RTC_CNTL_OPTIONS0_ANALOG_FORCE_NOISO = 0x10000000
	// Position of DG_WRAP_FORCE_RST field.
	RTC_CNTL_OPTIONS0_DG_WRAP_FORCE_RST_Pos = 0x1d
	// Bit mask of DG_WRAP_FORCE_RST field.
	RTC_CNTL_OPTIONS0_DG_WRAP_FORCE_RST_Msk = 0x20000000
	// Bit DG_WRAP_FORCE_RST.
	RTC_CNTL_OPTIONS0_DG_WRAP_FORCE_RST = 0x20000000
	// Position of DG_WRAP_FORCE_NORST field.
	RTC_CNTL_OPTIONS0_DG_WRAP_FORCE_NORST_Pos = 0x1e
	// Bit mask of DG_WRAP_FORCE_NORST field.
	RTC_CNTL_OPTIONS0_DG_WRAP_FORCE_NORST_Msk = 0x40000000
	// Bit DG_WRAP_FORCE_NORST.
	RTC_CNTL_OPTIONS0_DG_WRAP_FORCE_NORST = 0x40000000
	// Position of SW_SYS_RST field.
	RTC_CNTL_OPTIONS0_SW_SYS_RST_Pos = 0x1f
	// Bit mask of SW_SYS_RST field.
	RTC_CNTL_OPTIONS0_SW_SYS_RST_Msk = 0x80000000
	// Bit SW_SYS_RST.
	RTC_CNTL_OPTIONS0_SW_SYS_RST = 0x80000000

	// SLP_TIMER0: RTC timer threshold register 0
	// Position of SLP_VAL_LO field.
	RTC_CNTL_SLP_TIMER0_SLP_VAL_LO_Pos = 0x0
	// Bit mask of SLP_VAL_LO field.
	RTC_CNTL_SLP_TIMER0_SLP_VAL_LO_Msk = 0xffffffff

	// SLP_TIMER1: RTC timer threshold register 1
	// Position of SLP_VAL_HI field.
	RTC_CNTL_SLP_TIMER1_SLP_VAL_HI_Pos = 0x0
	// Bit mask of SLP_VAL_HI field.
	RTC_CNTL_SLP_TIMER1_SLP_VAL_HI_Msk = 0xffff
	// Position of MAIN_TIMER_ALARM_EN field.
	RTC_CNTL_SLP_TIMER1_MAIN_TIMER_ALARM_EN_Pos = 0x10
	// Bit mask of MAIN_TIMER_ALARM_EN field.
	RTC_CNTL_SLP_TIMER1_MAIN_TIMER_ALARM_EN_Msk = 0x10000
	// Bit MAIN_TIMER_ALARM_EN.
	RTC_CNTL_SLP_TIMER1_MAIN_TIMER_ALARM_EN = 0x10000

	// TIME_UPDATE: RTC timer update control register
	// Position of TIMER_SYS_STALL field.
	RTC_CNTL_TIME_UPDATE_TIMER_SYS_STALL_Pos = 0x1b
	// Bit mask of TIMER_SYS_STALL field.
	RTC_CNTL_TIME_UPDATE_TIMER_SYS_STALL_Msk = 0x8000000
	// Bit TIMER_SYS_STALL.
	RTC_CNTL_TIME_UPDATE_TIMER_SYS_STALL = 0x8000000
	// Position of TIMER_XTL_OFF field.
	RTC_CNTL_TIME_UPDATE_TIMER_XTL_OFF_Pos = 0x1c
	// Bit mask of TIMER_XTL_OFF field.
	RTC_CNTL_TIME_UPDATE_TIMER_XTL_OFF_Msk = 0x10000000
	// Bit TIMER_XTL_OFF.
	RTC_CNTL_TIME_UPDATE_TIMER_XTL_OFF = 0x10000000
	// Position of TIMER_SYS_RST field.
	RTC_CNTL_TIME_UPDATE_TIMER_SYS_RST_Pos = 0x1d
	// Bit mask of TIMER_SYS_RST field.
	RTC_CNTL_TIME_UPDATE_TIMER_SYS_RST_Msk = 0x20000000
	// Bit TIMER_SYS_RST.
	RTC_CNTL_TIME_UPDATE_TIMER_SYS_RST = 0x20000000
	// Position of TIME_UPDATE field.
	RTC_CNTL_TIME_UPDATE_TIME_UPDATE_Pos = 0x1f
	// Bit mask of TIME_UPDATE field.
	RTC_CNTL_TIME_UPDATE_TIME_UPDATE_Msk = 0x80000000
	// Bit TIME_UPDATE.
	RTC_CNTL_TIME_UPDATE_TIME_UPDATE = 0x80000000

	// TIME_LOW0: Stores the lower 32 bits of RTC timer 0
	// Position of TIMER_VALUE0_LOW field.
	RTC_CNTL_TIME_LOW0_TIMER_VALUE0_LOW_Pos = 0x0
	// Bit mask of TIMER_VALUE0_LOW field.
	RTC_CNTL_TIME_LOW0_TIMER_VALUE0_LOW_Msk = 0xffffffff

	// TIME_HIGH0: Stores the higher 16 bits of RTC timer 0
	// Position of TIMER_VALUE0_HIGH field.
	RTC_CNTL_TIME_HIGH0_TIMER_VALUE0_HIGH_Pos = 0x0
	// Bit mask of TIMER_VALUE0_HIGH field.
	RTC_CNTL_TIME_HIGH0_TIMER_VALUE0_HIGH_Msk = 0xffff

	// STATE0: Configures the sleep / reject / wakeup state
	// Position of SW_CPU_INT field.
	RTC_CNTL_STATE0_SW_CPU_INT_Pos = 0x0
	// Bit mask of SW_CPU_INT field.
	RTC_CNTL_STATE0_SW_CPU_INT_Msk = 0x1
	// Bit SW_CPU_INT.
	RTC_CNTL_STATE0_SW_CPU_INT = 0x1
	// Position of SLP_REJECT_CAUSE_CLR field.
	RTC_CNTL_STATE0_SLP_REJECT_CAUSE_CLR_Pos = 0x1
	// Bit mask of SLP_REJECT_CAUSE_CLR field.
	RTC_CNTL_STATE0_SLP_REJECT_CAUSE_CLR_Msk = 0x2
	// Bit SLP_REJECT_CAUSE_CLR.
	RTC_CNTL_STATE0_SLP_REJECT_CAUSE_CLR = 0x2
	// Position of APB2RTC_BRIDGE_SEL field.
	RTC_CNTL_STATE0_APB2RTC_BRIDGE_SEL_Pos = 0x16
	// Bit mask of APB2RTC_BRIDGE_SEL field.
	RTC_CNTL_STATE0_APB2RTC_BRIDGE_SEL_Msk = 0x400000
	// Bit APB2RTC_BRIDGE_SEL.
	RTC_CNTL_STATE0_APB2RTC_BRIDGE_SEL = 0x400000
	// Position of SDIO_ACTIVE_IND field.
	RTC_CNTL_STATE0_SDIO_ACTIVE_IND_Pos = 0x1c
	// Bit mask of SDIO_ACTIVE_IND field.
	RTC_CNTL_STATE0_SDIO_ACTIVE_IND_Msk = 0x10000000
	// Bit SDIO_ACTIVE_IND.
	RTC_CNTL_STATE0_SDIO_ACTIVE_IND = 0x10000000
	// Position of SLP_WAKEUP field.
	RTC_CNTL_STATE0_SLP_WAKEUP_Pos = 0x1d
	// Bit mask of SLP_WAKEUP field.
	RTC_CNTL_STATE0_SLP_WAKEUP_Msk = 0x20000000
	// Bit SLP_WAKEUP.
	RTC_CNTL_STATE0_SLP_WAKEUP = 0x20000000
	// Position of SLP_REJECT field.
	RTC_CNTL_STATE0_SLP_REJECT_Pos = 0x1e
	// Bit mask of SLP_REJECT field.
	RTC_CNTL_STATE0_SLP_REJECT_Msk = 0x40000000
	// Bit SLP_REJECT.
	RTC_CNTL_STATE0_SLP_REJECT = 0x40000000
	// Position of SLEEP_EN field.
	RTC_CNTL_STATE0_SLEEP_EN_Pos = 0x1f
	// Bit mask of SLEEP_EN field.
	RTC_CNTL_STATE0_SLEEP_EN_Msk = 0x80000000
	// Bit SLEEP_EN.
	RTC_CNTL_STATE0_SLEEP_EN = 0x80000000

	// TIMER1: Configures CPU stall options
	// Position of CPU_STALL_EN field.
	RTC_CNTL_TIMER1_CPU_STALL_EN_Pos = 0x0
	// Bit mask of CPU_STALL_EN field.
	RTC_CNTL_TIMER1_CPU_STALL_EN_Msk = 0x1
	// Bit CPU_STALL_EN.
	RTC_CNTL_TIMER1_CPU_STALL_EN = 0x1
	// Position of CPU_STALL_WAIT field.
	RTC_CNTL_TIMER1_CPU_STALL_WAIT_Pos = 0x1
	// Bit mask of CPU_STALL_WAIT field.
	RTC_CNTL_TIMER1_CPU_STALL_WAIT_Msk = 0x3e
	// Position of CK8M_WAIT field.
	RTC_CNTL_TIMER1_CK8M_WAIT_Pos = 0x6
	// Bit mask of CK8M_WAIT field.
	RTC_CNTL_TIMER1_CK8M_WAIT_Msk = 0x3fc0
	// Position of XTL_BUF_WAIT field.
	RTC_CNTL_TIMER1_XTL_BUF_WAIT_Pos = 0xe
	// Bit mask of XTL_BUF_WAIT field.
	RTC_CNTL_TIMER1_XTL_BUF_WAIT_Msk = 0xffc000
	// Position of PLL_BUF_WAIT field.
	RTC_CNTL_TIMER1_PLL_BUF_WAIT_Pos = 0x18
	// Bit mask of PLL_BUF_WAIT field.
	RTC_CNTL_TIMER1_PLL_BUF_WAIT_Msk = 0xff000000

	// TIMER2: Configures RTC slow clock and touch controller
	// Position of ULPCP_TOUCH_START_WAIT field.
	RTC_CNTL_TIMER2_ULPCP_TOUCH_START_WAIT_Pos = 0xf
	// Bit mask of ULPCP_TOUCH_START_WAIT field.
	RTC_CNTL_TIMER2_ULPCP_TOUCH_START_WAIT_Msk = 0xff8000
	// Position of MIN_TIME_CK8M_OFF field.
	RTC_CNTL_TIMER2_MIN_TIME_CK8M_OFF_Pos = 0x18
	// Bit mask of MIN_TIME_CK8M_OFF field.
	RTC_CNTL_TIMER2_MIN_TIME_CK8M_OFF_Msk = 0xff000000

	// TIMER3: configure some wait time for power on
	// Position of WIFI_WAIT_TIMER field.
	RTC_CNTL_TIMER3_WIFI_WAIT_TIMER_Pos = 0x0
	// Bit mask of WIFI_WAIT_TIMER field.
	RTC_CNTL_TIMER3_WIFI_WAIT_TIMER_Msk = 0x1ff
	// Position of WIFI_POWERUP_TIMER field.
	RTC_CNTL_TIMER3_WIFI_POWERUP_TIMER_Pos = 0x9
	// Bit mask of WIFI_POWERUP_TIMER field.
	RTC_CNTL_TIMER3_WIFI_POWERUP_TIMER_Msk = 0xfe00
	// Position of ROM_RAM_WAIT_TIMER field.
	RTC_CNTL_TIMER3_ROM_RAM_WAIT_TIMER_Pos = 0x10
	// Bit mask of ROM_RAM_WAIT_TIMER field.
	RTC_CNTL_TIMER3_ROM_RAM_WAIT_TIMER_Msk = 0x1ff0000
	// Position of ROM_RAM_POWERUP_TIMER field.
	RTC_CNTL_TIMER3_ROM_RAM_POWERUP_TIMER_Pos = 0x19
	// Bit mask of ROM_RAM_POWERUP_TIMER field.
	RTC_CNTL_TIMER3_ROM_RAM_POWERUP_TIMER_Msk = 0xfe000000

	// TIMER4: configure some wait time for power on
	// Position of WAIT_TIMER field.
	RTC_CNTL_TIMER4_WAIT_TIMER_Pos = 0x0
	// Bit mask of WAIT_TIMER field.
	RTC_CNTL_TIMER4_WAIT_TIMER_Msk = 0x1ff
	// Position of POWERUP_TIMER field.
	RTC_CNTL_TIMER4_POWERUP_TIMER_Pos = 0x9
	// Bit mask of POWERUP_TIMER field.
	RTC_CNTL_TIMER4_POWERUP_TIMER_Msk = 0xfe00
	// Position of DG_WRAP_WAIT_TIMER field.
	RTC_CNTL_TIMER4_DG_WRAP_WAIT_TIMER_Pos = 0x10
	// Bit mask of DG_WRAP_WAIT_TIMER field.
	RTC_CNTL_TIMER4_DG_WRAP_WAIT_TIMER_Msk = 0x1ff0000
	// Position of DG_WRAP_POWERUP_TIMER field.
	RTC_CNTL_TIMER4_DG_WRAP_POWERUP_TIMER_Pos = 0x19
	// Bit mask of DG_WRAP_POWERUP_TIMER field.
	RTC_CNTL_TIMER4_DG_WRAP_POWERUP_TIMER_Msk = 0xfe000000

	// TIMER5: Configures the minimal sleep cycles
	// Position of MIN_SLP_VAL field.
	RTC_CNTL_TIMER5_MIN_SLP_VAL_Pos = 0x8
	// Bit mask of MIN_SLP_VAL field.
	RTC_CNTL_TIMER5_MIN_SLP_VAL_Msk = 0xff00
	// Position of RTCMEM_WAIT_TIMER field.
	RTC_CNTL_TIMER5_RTCMEM_WAIT_TIMER_Pos = 0x10
	// Bit mask of RTCMEM_WAIT_TIMER field.
	RTC_CNTL_TIMER5_RTCMEM_WAIT_TIMER_Msk = 0x1ff0000
	// Position of RTCMEM_POWERUP_TIMER field.
	RTC_CNTL_TIMER5_RTCMEM_POWERUP_TIMER_Pos = 0x19
	// Bit mask of RTCMEM_POWERUP_TIMER field.
	RTC_CNTL_TIMER5_RTCMEM_POWERUP_TIMER_Msk = 0xfe000000

	// TIMER6: Configure minimal sleep cycles register
	// Position of DG_DCDC_WAIT_TIMER field.
	RTC_CNTL_TIMER6_DG_DCDC_WAIT_TIMER_Pos = 0x10
	// Bit mask of DG_DCDC_WAIT_TIMER field.
	RTC_CNTL_TIMER6_DG_DCDC_WAIT_TIMER_Msk = 0x1ff0000
	// Position of DG_DCDC_POWERUP_TIMER field.
	RTC_CNTL_TIMER6_DG_DCDC_POWERUP_TIMER_Pos = 0x19
	// Bit mask of DG_DCDC_POWERUP_TIMER field.
	RTC_CNTL_TIMER6_DG_DCDC_POWERUP_TIMER_Msk = 0xfe000000

	// ANA_CONF: Configures the power options for I2C and PLLA
	// Position of I2C_RESET_POR_FORCE_PD field.
	RTC_CNTL_ANA_CONF_I2C_RESET_POR_FORCE_PD_Pos = 0x12
	// Bit mask of I2C_RESET_POR_FORCE_PD field.
	RTC_CNTL_ANA_CONF_I2C_RESET_POR_FORCE_PD_Msk = 0x40000
	// Bit I2C_RESET_POR_FORCE_PD.
	RTC_CNTL_ANA_CONF_I2C_RESET_POR_FORCE_PD = 0x40000
	// Position of I2C_RESET_POR_FORCE_PU field.
	RTC_CNTL_ANA_CONF_I2C_RESET_POR_FORCE_PU_Pos = 0x13
	// Bit mask of I2C_RESET_POR_FORCE_PU field.
	RTC_CNTL_ANA_CONF_I2C_RESET_POR_FORCE_PU_Msk = 0x80000
	// Bit I2C_RESET_POR_FORCE_PU.
	RTC_CNTL_ANA_CONF_I2C_RESET_POR_FORCE_PU = 0x80000
	// Position of GLITCH_RST_EN field.
	RTC_CNTL_ANA_CONF_GLITCH_RST_EN_Pos = 0x14
	// Bit mask of GLITCH_RST_EN field.
	RTC_CNTL_ANA_CONF_GLITCH_RST_EN_Msk = 0x100000
	// Bit GLITCH_RST_EN.
	RTC_CNTL_ANA_CONF_GLITCH_RST_EN = 0x100000
	// Position of SAR_I2C_FORCE_PD field.
	RTC_CNTL_ANA_CONF_SAR_I2C_FORCE_PD_Pos = 0x15
	// Bit mask of SAR_I2C_FORCE_PD field.
	RTC_CNTL_ANA_CONF_SAR_I2C_FORCE_PD_Msk = 0x200000
	// Bit SAR_I2C_FORCE_PD.
	RTC_CNTL_ANA_CONF_SAR_I2C_FORCE_PD = 0x200000
	// Position of SAR_I2C_FORCE_PU field.
	RTC_CNTL_ANA_CONF_SAR_I2C_FORCE_PU_Pos = 0x16
	// Bit mask of SAR_I2C_FORCE_PU field.
	RTC_CNTL_ANA_CONF_SAR_I2C_FORCE_PU_Msk = 0x400000
	// Bit SAR_I2C_FORCE_PU.
	RTC_CNTL_ANA_CONF_SAR_I2C_FORCE_PU = 0x400000
	// Position of PLLA_FORCE_PD field.
	RTC_CNTL_ANA_CONF_PLLA_FORCE_PD_Pos = 0x17
	// Bit mask of PLLA_FORCE_PD field.
	RTC_CNTL_ANA_CONF_PLLA_FORCE_PD_Msk = 0x800000
	// Bit PLLA_FORCE_PD.
	RTC_CNTL_ANA_CONF_PLLA_FORCE_PD = 0x800000
	// Position of PLLA_FORCE_PU field.
	RTC_CNTL_ANA_CONF_PLLA_FORCE_PU_Pos = 0x18
	// Bit mask of PLLA_FORCE_PU field.
	RTC_CNTL_ANA_CONF_PLLA_FORCE_PU_Msk = 0x1000000
	// Bit PLLA_FORCE_PU.
	RTC_CNTL_ANA_CONF_PLLA_FORCE_PU = 0x1000000
	// Position of BBPLL_CAL_SLP_START field.
	RTC_CNTL_ANA_CONF_BBPLL_CAL_SLP_START_Pos = 0x19
	// Bit mask of BBPLL_CAL_SLP_START field.
	RTC_CNTL_ANA_CONF_BBPLL_CAL_SLP_START_Msk = 0x2000000
	// Bit BBPLL_CAL_SLP_START.
	RTC_CNTL_ANA_CONF_BBPLL_CAL_SLP_START = 0x2000000
	// Position of PVTMON_PU field.
	RTC_CNTL_ANA_CONF_PVTMON_PU_Pos = 0x1a
	// Bit mask of PVTMON_PU field.
	RTC_CNTL_ANA_CONF_PVTMON_PU_Msk = 0x4000000
	// Bit PVTMON_PU.
	RTC_CNTL_ANA_CONF_PVTMON_PU = 0x4000000
	// Position of TXRF_I2C_PU field.
	RTC_CNTL_ANA_CONF_TXRF_I2C_PU_Pos = 0x1b
	// Bit mask of TXRF_I2C_PU field.
	RTC_CNTL_ANA_CONF_TXRF_I2C_PU_Msk = 0x8000000
	// Bit TXRF_I2C_PU.
	RTC_CNTL_ANA_CONF_TXRF_I2C_PU = 0x8000000
	// Position of RFRX_PBUS_PU field.
	RTC_CNTL_ANA_CONF_RFRX_PBUS_PU_Pos = 0x1c
	// Bit mask of RFRX_PBUS_PU field.
	RTC_CNTL_ANA_CONF_RFRX_PBUS_PU_Msk = 0x10000000
	// Bit RFRX_PBUS_PU.
	RTC_CNTL_ANA_CONF_RFRX_PBUS_PU = 0x10000000
	// Position of CKGEN_I2C_PU field.
	RTC_CNTL_ANA_CONF_CKGEN_I2C_PU_Pos = 0x1e
	// Bit mask of CKGEN_I2C_PU field.
	RTC_CNTL_ANA_CONF_CKGEN_I2C_PU_Msk = 0x40000000
	// Bit CKGEN_I2C_PU.
	RTC_CNTL_ANA_CONF_CKGEN_I2C_PU = 0x40000000
	// Position of PLL_I2C_PU field.
	RTC_CNTL_ANA_CONF_PLL_I2C_PU_Pos = 0x1f
	// Bit mask of PLL_I2C_PU field.
	RTC_CNTL_ANA_CONF_PLL_I2C_PU_Msk = 0x80000000
	// Bit PLL_I2C_PU.
	RTC_CNTL_ANA_CONF_PLL_I2C_PU = 0x80000000

	// RESET_STATE: Indicates the CPU reset source. For more information about the reset cause, please refer to Table \ref{table:resetreasons} in Chapter \ref{module:ResetandClock} \textit{\nameref{module:ResetandClock}}.
	// Position of RESET_CAUSE_PROCPU field.
	RTC_CNTL_RESET_STATE_RESET_CAUSE_PROCPU_Pos = 0x0
	// Bit mask of RESET_CAUSE_PROCPU field.
	RTC_CNTL_RESET_STATE_RESET_CAUSE_PROCPU_Msk = 0x3f
	// Position of RESET_CAUSE_APPCPU field.
	RTC_CNTL_RESET_STATE_RESET_CAUSE_APPCPU_Pos = 0x6
	// Bit mask of RESET_CAUSE_APPCPU field.
	RTC_CNTL_RESET_STATE_RESET_CAUSE_APPCPU_Msk = 0xfc0
	// Position of APPCPU_STAT_VECTOR_SEL field.
	RTC_CNTL_RESET_STATE_APPCPU_STAT_VECTOR_SEL_Pos = 0xc
	// Bit mask of APPCPU_STAT_VECTOR_SEL field.
	RTC_CNTL_RESET_STATE_APPCPU_STAT_VECTOR_SEL_Msk = 0x1000
	// Bit APPCPU_STAT_VECTOR_SEL.
	RTC_CNTL_RESET_STATE_APPCPU_STAT_VECTOR_SEL = 0x1000
	// Position of PROCPU_STAT_VECTOR_SEL field.
	RTC_CNTL_RESET_STATE_PROCPU_STAT_VECTOR_SEL_Pos = 0xd
	// Bit mask of PROCPU_STAT_VECTOR_SEL field.
	RTC_CNTL_RESET_STATE_PROCPU_STAT_VECTOR_SEL_Msk = 0x2000
	// Bit PROCPU_STAT_VECTOR_SEL.
	RTC_CNTL_RESET_STATE_PROCPU_STAT_VECTOR_SEL = 0x2000

	// WAKEUP_STATE: Wakeup bitmap enabling register
	// Position of WAKEUP_ENA field.
	RTC_CNTL_WAKEUP_STATE_WAKEUP_ENA_Pos = 0xf
	// Bit mask of WAKEUP_ENA field.
	RTC_CNTL_WAKEUP_STATE_WAKEUP_ENA_Msk = 0xffff8000

	// INT_ENA_RTC: RTC interrupt enabling register
	// Position of SLP_WAKEUP_INT_ENA field.
	RTC_CNTL_INT_ENA_RTC_SLP_WAKEUP_INT_ENA_Pos = 0x0
	// Bit mask of SLP_WAKEUP_INT_ENA field.
	RTC_CNTL_INT_ENA_RTC_SLP_WAKEUP_INT_ENA_Msk = 0x1
	// Bit SLP_WAKEUP_INT_ENA.
	RTC_CNTL_INT_ENA_RTC_SLP_WAKEUP_INT_ENA = 0x1
	// Position of SLP_REJECT_INT_ENA field.
	RTC_CNTL_INT_ENA_RTC_SLP_REJECT_INT_ENA_Pos = 0x1
	// Bit mask of SLP_REJECT_INT_ENA field.
	RTC_CNTL_INT_ENA_RTC_SLP_REJECT_INT_ENA_Msk = 0x2
	// Bit SLP_REJECT_INT_ENA.
	RTC_CNTL_INT_ENA_RTC_SLP_REJECT_INT_ENA = 0x2
	// Position of SDIO_IDLE_INT_ENA field.
	RTC_CNTL_INT_ENA_RTC_SDIO_IDLE_INT_ENA_Pos = 0x2
	// Bit mask of SDIO_IDLE_INT_ENA field.
	RTC_CNTL_INT_ENA_RTC_SDIO_IDLE_INT_ENA_Msk = 0x4
	// Bit SDIO_IDLE_INT_ENA.
	RTC_CNTL_INT_ENA_RTC_SDIO_IDLE_INT_ENA = 0x4
	// Position of WDT_INT_ENA field.
	RTC_CNTL_INT_ENA_RTC_WDT_INT_ENA_Pos = 0x3
	// Bit mask of WDT_INT_ENA field.
	RTC_CNTL_INT_ENA_RTC_WDT_INT_ENA_Msk = 0x8
	// Bit WDT_INT_ENA.
	RTC_CNTL_INT_ENA_RTC_WDT_INT_ENA = 0x8
	// Position of TOUCH_SCAN_DONE_INT_ENA field.
	RTC_CNTL_INT_ENA_RTC_TOUCH_SCAN_DONE_INT_ENA_Pos = 0x4
	// Bit mask of TOUCH_SCAN_DONE_INT_ENA field.
	RTC_CNTL_INT_ENA_RTC_TOUCH_SCAN_DONE_INT_ENA_Msk = 0x10
	// Bit TOUCH_SCAN_DONE_INT_ENA.
	RTC_CNTL_INT_ENA_RTC_TOUCH_SCAN_DONE_INT_ENA = 0x10
	// Position of ULP_CP_INT_ENA field.
	RTC_CNTL_INT_ENA_RTC_ULP_CP_INT_ENA_Pos = 0x5
	// Bit mask of ULP_CP_INT_ENA field.
	RTC_CNTL_INT_ENA_RTC_ULP_CP_INT_ENA_Msk = 0x20
	// Bit ULP_CP_INT_ENA.
	RTC_CNTL_INT_ENA_RTC_ULP_CP_INT_ENA = 0x20
	// Position of TOUCH_DONE_INT_ENA field.
	RTC_CNTL_INT_ENA_RTC_TOUCH_DONE_INT_ENA_Pos = 0x6
	// Bit mask of TOUCH_DONE_INT_ENA field.
	RTC_CNTL_INT_ENA_RTC_TOUCH_DONE_INT_ENA_Msk = 0x40
	// Bit TOUCH_DONE_INT_ENA.
	RTC_CNTL_INT_ENA_RTC_TOUCH_DONE_INT_ENA = 0x40
	// Position of TOUCH_ACTIVE_INT_ENA field.
	RTC_CNTL_INT_ENA_RTC_TOUCH_ACTIVE_INT_ENA_Pos = 0x7
	// Bit mask of TOUCH_ACTIVE_INT_ENA field.
	RTC_CNTL_INT_ENA_RTC_TOUCH_ACTIVE_INT_ENA_Msk = 0x80
	// Bit TOUCH_ACTIVE_INT_ENA.
	RTC_CNTL_INT_ENA_RTC_TOUCH_ACTIVE_INT_ENA = 0x80
	// Position of TOUCH_INACTIVE_INT_ENA field.
	RTC_CNTL_INT_ENA_RTC_TOUCH_INACTIVE_INT_ENA_Pos = 0x8
	// Bit mask of TOUCH_INACTIVE_INT_ENA field.
	RTC_CNTL_INT_ENA_RTC_TOUCH_INACTIVE_INT_ENA_Msk = 0x100
	// Bit TOUCH_INACTIVE_INT_ENA.
	RTC_CNTL_INT_ENA_RTC_TOUCH_INACTIVE_INT_ENA = 0x100
	// Position of BROWN_OUT_INT_ENA field.
	RTC_CNTL_INT_ENA_RTC_BROWN_OUT_INT_ENA_Pos = 0x9
	// Bit mask of BROWN_OUT_INT_ENA field.
	RTC_CNTL_INT_ENA_RTC_BROWN_OUT_INT_ENA_Msk = 0x200
	// Bit BROWN_OUT_INT_ENA.
	RTC_CNTL_INT_ENA_RTC_BROWN_OUT_INT_ENA = 0x200
	// Position of MAIN_TIMER_INT_ENA field.
	RTC_CNTL_INT_ENA_RTC_MAIN_TIMER_INT_ENA_Pos = 0xa
	// Bit mask of MAIN_TIMER_INT_ENA field.
	RTC_CNTL_INT_ENA_RTC_MAIN_TIMER_INT_ENA_Msk = 0x400
	// Bit MAIN_TIMER_INT_ENA.
	RTC_CNTL_INT_ENA_RTC_MAIN_TIMER_INT_ENA = 0x400
	// Position of SARADC1_INT_ENA field.
	RTC_CNTL_INT_ENA_RTC_SARADC1_INT_ENA_Pos = 0xb
	// Bit mask of SARADC1_INT_ENA field.
	RTC_CNTL_INT_ENA_RTC_SARADC1_INT_ENA_Msk = 0x800
	// Bit SARADC1_INT_ENA.
	RTC_CNTL_INT_ENA_RTC_SARADC1_INT_ENA = 0x800
	// Position of TSENS_INT_ENA field.
	RTC_CNTL_INT_ENA_RTC_TSENS_INT_ENA_Pos = 0xc
	// Bit mask of TSENS_INT_ENA field.
	RTC_CNTL_INT_ENA_RTC_TSENS_INT_ENA_Msk = 0x1000
	// Bit TSENS_INT_ENA.
	RTC_CNTL_INT_ENA_RTC_TSENS_INT_ENA = 0x1000
	// Position of COCPU_INT_ENA field.
	RTC_CNTL_INT_ENA_RTC_COCPU_INT_ENA_Pos = 0xd
	// Bit mask of COCPU_INT_ENA field.
	RTC_CNTL_INT_ENA_RTC_COCPU_INT_ENA_Msk = 0x2000
	// Bit COCPU_INT_ENA.
	RTC_CNTL_INT_ENA_RTC_COCPU_INT_ENA = 0x2000
	// Position of SARADC2_INT_ENA field.
	RTC_CNTL_INT_ENA_RTC_SARADC2_INT_ENA_Pos = 0xe
	// Bit mask of SARADC2_INT_ENA field.
	RTC_CNTL_INT_ENA_RTC_SARADC2_INT_ENA_Msk = 0x4000
	// Bit SARADC2_INT_ENA.
	RTC_CNTL_INT_ENA_RTC_SARADC2_INT_ENA = 0x4000
	// Position of SWD_INT_ENA field.
	RTC_CNTL_INT_ENA_RTC_SWD_INT_ENA_Pos = 0xf
	// Bit mask of SWD_INT_ENA field.
	RTC_CNTL_INT_ENA_RTC_SWD_INT_ENA_Msk = 0x8000
	// Bit SWD_INT_ENA.
	RTC_CNTL_INT_ENA_RTC_SWD_INT_ENA = 0x8000
	// Position of XTAL32K_DEAD_INT_ENA field.
	RTC_CNTL_INT_ENA_RTC_XTAL32K_DEAD_INT_ENA_Pos = 0x10
	// Bit mask of XTAL32K_DEAD_INT_ENA field.
	RTC_CNTL_INT_ENA_RTC_XTAL32K_DEAD_INT_ENA_Msk = 0x10000
	// Bit XTAL32K_DEAD_INT_ENA.
	RTC_CNTL_INT_ENA_RTC_XTAL32K_DEAD_INT_ENA = 0x10000
	// Position of COCPU_TRAP_INT_ENA field.
	RTC_CNTL_INT_ENA_RTC_COCPU_TRAP_INT_ENA_Pos = 0x11
	// Bit mask of COCPU_TRAP_INT_ENA field.
	RTC_CNTL_INT_ENA_RTC_COCPU_TRAP_INT_ENA_Msk = 0x20000
	// Bit COCPU_TRAP_INT_ENA.
	RTC_CNTL_INT_ENA_RTC_COCPU_TRAP_INT_ENA = 0x20000
	// Position of TOUCH_TIMEOUT_INT_ENA field.
	RTC_CNTL_INT_ENA_RTC_TOUCH_TIMEOUT_INT_ENA_Pos = 0x12
	// Bit mask of TOUCH_TIMEOUT_INT_ENA field.
	RTC_CNTL_INT_ENA_RTC_TOUCH_TIMEOUT_INT_ENA_Msk = 0x40000
	// Bit TOUCH_TIMEOUT_INT_ENA.
	RTC_CNTL_INT_ENA_RTC_TOUCH_TIMEOUT_INT_ENA = 0x40000
	// Position of GLITCH_DET_INT_ENA field.
	RTC_CNTL_INT_ENA_RTC_GLITCH_DET_INT_ENA_Pos = 0x13
	// Bit mask of GLITCH_DET_INT_ENA field.
	RTC_CNTL_INT_ENA_RTC_GLITCH_DET_INT_ENA_Msk = 0x80000
	// Bit GLITCH_DET_INT_ENA.
	RTC_CNTL_INT_ENA_RTC_GLITCH_DET_INT_ENA = 0x80000

	// INT_RAW_RTC: RTC interrupt raw register
	// Position of SLP_WAKEUP_INT_RAW field.
	RTC_CNTL_INT_RAW_RTC_SLP_WAKEUP_INT_RAW_Pos = 0x0
	// Bit mask of SLP_WAKEUP_INT_RAW field.
	RTC_CNTL_INT_RAW_RTC_SLP_WAKEUP_INT_RAW_Msk = 0x1
	// Bit SLP_WAKEUP_INT_RAW.
	RTC_CNTL_INT_RAW_RTC_SLP_WAKEUP_INT_RAW = 0x1
	// Position of SLP_REJECT_INT_RAW field.
	RTC_CNTL_INT_RAW_RTC_SLP_REJECT_INT_RAW_Pos = 0x1
	// Bit mask of SLP_REJECT_INT_RAW field.
	RTC_CNTL_INT_RAW_RTC_SLP_REJECT_INT_RAW_Msk = 0x2
	// Bit SLP_REJECT_INT_RAW.
	RTC_CNTL_INT_RAW_RTC_SLP_REJECT_INT_RAW = 0x2
	// Position of SDIO_IDLE_INT_RAW field.
	RTC_CNTL_INT_RAW_RTC_SDIO_IDLE_INT_RAW_Pos = 0x2
	// Bit mask of SDIO_IDLE_INT_RAW field.
	RTC_CNTL_INT_RAW_RTC_SDIO_IDLE_INT_RAW_Msk = 0x4
	// Bit SDIO_IDLE_INT_RAW.
	RTC_CNTL_INT_RAW_RTC_SDIO_IDLE_INT_RAW = 0x4
	// Position of WDT_INT_RAW field.
	RTC_CNTL_INT_RAW_RTC_WDT_INT_RAW_Pos = 0x3
	// Bit mask of WDT_INT_RAW field.
	RTC_CNTL_INT_RAW_RTC_WDT_INT_RAW_Msk = 0x8
	// Bit WDT_INT_RAW.
	RTC_CNTL_INT_RAW_RTC_WDT_INT_RAW = 0x8
	// Position of TOUCH_SCAN_DONE_INT_RAW field.
	RTC_CNTL_INT_RAW_RTC_TOUCH_SCAN_DONE_INT_RAW_Pos = 0x4
	// Bit mask of TOUCH_SCAN_DONE_INT_RAW field.
	RTC_CNTL_INT_RAW_RTC_TOUCH_SCAN_DONE_INT_RAW_Msk = 0x10
	// Bit TOUCH_SCAN_DONE_INT_RAW.
	RTC_CNTL_INT_RAW_RTC_TOUCH_SCAN_DONE_INT_RAW = 0x10
	// Position of ULP_CP_INT_RAW field.
	RTC_CNTL_INT_RAW_RTC_ULP_CP_INT_RAW_Pos = 0x5
	// Bit mask of ULP_CP_INT_RAW field.
	RTC_CNTL_INT_RAW_RTC_ULP_CP_INT_RAW_Msk = 0x20
	// Bit ULP_CP_INT_RAW.
	RTC_CNTL_INT_RAW_RTC_ULP_CP_INT_RAW = 0x20
	// Position of TOUCH_DONE_INT_RAW field.
	RTC_CNTL_INT_RAW_RTC_TOUCH_DONE_INT_RAW_Pos = 0x6
	// Bit mask of TOUCH_DONE_INT_RAW field.
	RTC_CNTL_INT_RAW_RTC_TOUCH_DONE_INT_RAW_Msk = 0x40
	// Bit TOUCH_DONE_INT_RAW.
	RTC_CNTL_INT_RAW_RTC_TOUCH_DONE_INT_RAW = 0x40
	// Position of TOUCH_ACTIVE_INT_RAW field.
	RTC_CNTL_INT_RAW_RTC_TOUCH_ACTIVE_INT_RAW_Pos = 0x7
	// Bit mask of TOUCH_ACTIVE_INT_RAW field.
	RTC_CNTL_INT_RAW_RTC_TOUCH_ACTIVE_INT_RAW_Msk = 0x80
	// Bit TOUCH_ACTIVE_INT_RAW.
	RTC_CNTL_INT_RAW_RTC_TOUCH_ACTIVE_INT_RAW = 0x80
	// Position of TOUCH_INACTIVE_INT_RAW field.
	RTC_CNTL_INT_RAW_RTC_TOUCH_INACTIVE_INT_RAW_Pos = 0x8
	// Bit mask of TOUCH_INACTIVE_INT_RAW field.
	RTC_CNTL_INT_RAW_RTC_TOUCH_INACTIVE_INT_RAW_Msk = 0x100
	// Bit TOUCH_INACTIVE_INT_RAW.
	RTC_CNTL_INT_RAW_RTC_TOUCH_INACTIVE_INT_RAW = 0x100
	// Position of BROWN_OUT_INT_RAW field.
	RTC_CNTL_INT_RAW_RTC_BROWN_OUT_INT_RAW_Pos = 0x9
	// Bit mask of BROWN_OUT_INT_RAW field.
	RTC_CNTL_INT_RAW_RTC_BROWN_OUT_INT_RAW_Msk = 0x200
	// Bit BROWN_OUT_INT_RAW.
	RTC_CNTL_INT_RAW_RTC_BROWN_OUT_INT_RAW = 0x200
	// Position of MAIN_TIMER_INT_RAW field.
	RTC_CNTL_INT_RAW_RTC_MAIN_TIMER_INT_RAW_Pos = 0xa
	// Bit mask of MAIN_TIMER_INT_RAW field.
	RTC_CNTL_INT_RAW_RTC_MAIN_TIMER_INT_RAW_Msk = 0x400
	// Bit MAIN_TIMER_INT_RAW.
	RTC_CNTL_INT_RAW_RTC_MAIN_TIMER_INT_RAW = 0x400
	// Position of SARADC1_INT_RAW field.
	RTC_CNTL_INT_RAW_RTC_SARADC1_INT_RAW_Pos = 0xb
	// Bit mask of SARADC1_INT_RAW field.
	RTC_CNTL_INT_RAW_RTC_SARADC1_INT_RAW_Msk = 0x800
	// Bit SARADC1_INT_RAW.
	RTC_CNTL_INT_RAW_RTC_SARADC1_INT_RAW = 0x800
	// Position of TSENS_INT_RAW field.
	RTC_CNTL_INT_RAW_RTC_TSENS_INT_RAW_Pos = 0xc
	// Bit mask of TSENS_INT_RAW field.
	RTC_CNTL_INT_RAW_RTC_TSENS_INT_RAW_Msk = 0x1000
	// Bit TSENS_INT_RAW.
	RTC_CNTL_INT_RAW_RTC_TSENS_INT_RAW = 0x1000
	// Position of COCPU_INT_RAW field.
	RTC_CNTL_INT_RAW_RTC_COCPU_INT_RAW_Pos = 0xd
	// Bit mask of COCPU_INT_RAW field.
	RTC_CNTL_INT_RAW_RTC_COCPU_INT_RAW_Msk = 0x2000
	// Bit COCPU_INT_RAW.
	RTC_CNTL_INT_RAW_RTC_COCPU_INT_RAW = 0x2000
	// Position of SARADC2_INT_RAW field.
	RTC_CNTL_INT_RAW_RTC_SARADC2_INT_RAW_Pos = 0xe
	// Bit mask of SARADC2_INT_RAW field.
	RTC_CNTL_INT_RAW_RTC_SARADC2_INT_RAW_Msk = 0x4000
	// Bit SARADC2_INT_RAW.
	RTC_CNTL_INT_RAW_RTC_SARADC2_INT_RAW = 0x4000
	// Position of SWD_INT_RAW field.
	RTC_CNTL_INT_RAW_RTC_SWD_INT_RAW_Pos = 0xf
	// Bit mask of SWD_INT_RAW field.
	RTC_CNTL_INT_RAW_RTC_SWD_INT_RAW_Msk = 0x8000
	// Bit SWD_INT_RAW.
	RTC_CNTL_INT_RAW_RTC_SWD_INT_RAW = 0x8000
	// Position of XTAL32K_DEAD_INT_RAW field.
	RTC_CNTL_INT_RAW_RTC_XTAL32K_DEAD_INT_RAW_Pos = 0x10
	// Bit mask of XTAL32K_DEAD_INT_RAW field.
	RTC_CNTL_INT_RAW_RTC_XTAL32K_DEAD_INT_RAW_Msk = 0x10000
	// Bit XTAL32K_DEAD_INT_RAW.
	RTC_CNTL_INT_RAW_RTC_XTAL32K_DEAD_INT_RAW = 0x10000
	// Position of COCPU_TRAP_INT_RAW field.
	RTC_CNTL_INT_RAW_RTC_COCPU_TRAP_INT_RAW_Pos = 0x11
	// Bit mask of COCPU_TRAP_INT_RAW field.
	RTC_CNTL_INT_RAW_RTC_COCPU_TRAP_INT_RAW_Msk = 0x20000
	// Bit COCPU_TRAP_INT_RAW.
	RTC_CNTL_INT_RAW_RTC_COCPU_TRAP_INT_RAW = 0x20000
	// Position of TOUCH_TIMEOUT_INT_RAW field.
	RTC_CNTL_INT_RAW_RTC_TOUCH_TIMEOUT_INT_RAW_Pos = 0x12
	// Bit mask of TOUCH_TIMEOUT_INT_RAW field.
	RTC_CNTL_INT_RAW_RTC_TOUCH_TIMEOUT_INT_RAW_Msk = 0x40000
	// Bit TOUCH_TIMEOUT_INT_RAW.
	RTC_CNTL_INT_RAW_RTC_TOUCH_TIMEOUT_INT_RAW = 0x40000
	// Position of GLITCH_DET_INT_RAW field.
	RTC_CNTL_INT_RAW_RTC_GLITCH_DET_INT_RAW_Pos = 0x13
	// Bit mask of GLITCH_DET_INT_RAW field.
	RTC_CNTL_INT_RAW_RTC_GLITCH_DET_INT_RAW_Msk = 0x80000
	// Bit GLITCH_DET_INT_RAW.
	RTC_CNTL_INT_RAW_RTC_GLITCH_DET_INT_RAW = 0x80000

	// INT_ST_RTC: RTC interrupt state register
	// Position of SLP_WAKEUP_INT_ST field.
	RTC_CNTL_INT_ST_RTC_SLP_WAKEUP_INT_ST_Pos = 0x0
	// Bit mask of SLP_WAKEUP_INT_ST field.
	RTC_CNTL_INT_ST_RTC_SLP_WAKEUP_INT_ST_Msk = 0x1
	// Bit SLP_WAKEUP_INT_ST.
	RTC_CNTL_INT_ST_RTC_SLP_WAKEUP_INT_ST = 0x1
	// Position of SLP_REJECT_INT_ST field.
	RTC_CNTL_INT_ST_RTC_SLP_REJECT_INT_ST_Pos = 0x1
	// Bit mask of SLP_REJECT_INT_ST field.
	RTC_CNTL_INT_ST_RTC_SLP_REJECT_INT_ST_Msk = 0x2
	// Bit SLP_REJECT_INT_ST.
	RTC_CNTL_INT_ST_RTC_SLP_REJECT_INT_ST = 0x2
	// Position of SDIO_IDLE_INT_ST field.
	RTC_CNTL_INT_ST_RTC_SDIO_IDLE_INT_ST_Pos = 0x2
	// Bit mask of SDIO_IDLE_INT_ST field.
	RTC_CNTL_INT_ST_RTC_SDIO_IDLE_INT_ST_Msk = 0x4
	// Bit SDIO_IDLE_INT_ST.
	RTC_CNTL_INT_ST_RTC_SDIO_IDLE_INT_ST = 0x4
	// Position of WDT_INT_ST field.
	RTC_CNTL_INT_ST_RTC_WDT_INT_ST_Pos = 0x3
	// Bit mask of WDT_INT_ST field.
	RTC_CNTL_INT_ST_RTC_WDT_INT_ST_Msk = 0x8
	// Bit WDT_INT_ST.
	RTC_CNTL_INT_ST_RTC_WDT_INT_ST = 0x8
	// Position of TOUCH_SCAN_DONE_INT_ST field.
	RTC_CNTL_INT_ST_RTC_TOUCH_SCAN_DONE_INT_ST_Pos = 0x4
	// Bit mask of TOUCH_SCAN_DONE_INT_ST field.
	RTC_CNTL_INT_ST_RTC_TOUCH_SCAN_DONE_INT_ST_Msk = 0x10
	// Bit TOUCH_SCAN_DONE_INT_ST.
	RTC_CNTL_INT_ST_RTC_TOUCH_SCAN_DONE_INT_ST = 0x10
	// Position of ULP_CP_INT_ST field.
	RTC_CNTL_INT_ST_RTC_ULP_CP_INT_ST_Pos = 0x5
	// Bit mask of ULP_CP_INT_ST field.
	RTC_CNTL_INT_ST_RTC_ULP_CP_INT_ST_Msk = 0x20
	// Bit ULP_CP_INT_ST.
	RTC_CNTL_INT_ST_RTC_ULP_CP_INT_ST = 0x20
	// Position of TOUCH_DONE_INT_ST field.
	RTC_CNTL_INT_ST_RTC_TOUCH_DONE_INT_ST_Pos = 0x6
	// Bit mask of TOUCH_DONE_INT_ST field.
	RTC_CNTL_INT_ST_RTC_TOUCH_DONE_INT_ST_Msk = 0x40
	// Bit TOUCH_DONE_INT_ST.
	RTC_CNTL_INT_ST_RTC_TOUCH_DONE_INT_ST = 0x40
	// Position of TOUCH_ACTIVE_INT_ST field.
	RTC_CNTL_INT_ST_RTC_TOUCH_ACTIVE_INT_ST_Pos = 0x7
	// Bit mask of TOUCH_ACTIVE_INT_ST field.
	RTC_CNTL_INT_ST_RTC_TOUCH_ACTIVE_INT_ST_Msk = 0x80
	// Bit TOUCH_ACTIVE_INT_ST.
	RTC_CNTL_INT_ST_RTC_TOUCH_ACTIVE_INT_ST = 0x80
	// Position of TOUCH_INACTIVE_INT_ST field.
	RTC_CNTL_INT_ST_RTC_TOUCH_INACTIVE_INT_ST_Pos = 0x8
	// Bit mask of TOUCH_INACTIVE_INT_ST field.
	RTC_CNTL_INT_ST_RTC_TOUCH_INACTIVE_INT_ST_Msk = 0x100
	// Bit TOUCH_INACTIVE_INT_ST.
	RTC_CNTL_INT_ST_RTC_TOUCH_INACTIVE_INT_ST = 0x100
	// Position of BROWN_OUT_INT_ST field.
	RTC_CNTL_INT_ST_RTC_BROWN_OUT_INT_ST_Pos = 0x9
	// Bit mask of BROWN_OUT_INT_ST field.
	RTC_CNTL_INT_ST_RTC_BROWN_OUT_INT_ST_Msk = 0x200
	// Bit BROWN_OUT_INT_ST.
	RTC_CNTL_INT_ST_RTC_BROWN_OUT_INT_ST = 0x200
	// Position of MAIN_TIMER_INT_ST field.
	RTC_CNTL_INT_ST_RTC_MAIN_TIMER_INT_ST_Pos = 0xa
	// Bit mask of MAIN_TIMER_INT_ST field.
	RTC_CNTL_INT_ST_RTC_MAIN_TIMER_INT_ST_Msk = 0x400
	// Bit MAIN_TIMER_INT_ST.
	RTC_CNTL_INT_ST_RTC_MAIN_TIMER_INT_ST = 0x400
	// Position of SARADC1_INT_ST field.
	RTC_CNTL_INT_ST_RTC_SARADC1_INT_ST_Pos = 0xb
	// Bit mask of SARADC1_INT_ST field.
	RTC_CNTL_INT_ST_RTC_SARADC1_INT_ST_Msk = 0x800
	// Bit SARADC1_INT_ST.
	RTC_CNTL_INT_ST_RTC_SARADC1_INT_ST = 0x800
	// Position of TSENS_INT_ST field.
	RTC_CNTL_INT_ST_RTC_TSENS_INT_ST_Pos = 0xc
	// Bit mask of TSENS_INT_ST field.
	RTC_CNTL_INT_ST_RTC_TSENS_INT_ST_Msk = 0x1000
	// Bit TSENS_INT_ST.
	RTC_CNTL_INT_ST_RTC_TSENS_INT_ST = 0x1000
	// Position of COCPU_INT_ST field.
	RTC_CNTL_INT_ST_RTC_COCPU_INT_ST_Pos = 0xd
	// Bit mask of COCPU_INT_ST field.
	RTC_CNTL_INT_ST_RTC_COCPU_INT_ST_Msk = 0x2000
	// Bit COCPU_INT_ST.
	RTC_CNTL_INT_ST_RTC_COCPU_INT_ST = 0x2000
	// Position of SARADC2_INT_ST field.
	RTC_CNTL_INT_ST_RTC_SARADC2_INT_ST_Pos = 0xe
	// Bit mask of SARADC2_INT_ST field.
	RTC_CNTL_INT_ST_RTC_SARADC2_INT_ST_Msk = 0x4000
	// Bit SARADC2_INT_ST.
	RTC_CNTL_INT_ST_RTC_SARADC2_INT_ST = 0x4000
	// Position of SWD_INT_ST field.
	RTC_CNTL_INT_ST_RTC_SWD_INT_ST_Pos = 0xf
	// Bit mask of SWD_INT_ST field.
	RTC_CNTL_INT_ST_RTC_SWD_INT_ST_Msk = 0x8000
	// Bit SWD_INT_ST.
	RTC_CNTL_INT_ST_RTC_SWD_INT_ST = 0x8000
	// Position of XTAL32K_DEAD_INT_ST field.
	RTC_CNTL_INT_ST_RTC_XTAL32K_DEAD_INT_ST_Pos = 0x10
	// Bit mask of XTAL32K_DEAD_INT_ST field.
	RTC_CNTL_INT_ST_RTC_XTAL32K_DEAD_INT_ST_Msk = 0x10000
	// Bit XTAL32K_DEAD_INT_ST.
	RTC_CNTL_INT_ST_RTC_XTAL32K_DEAD_INT_ST = 0x10000
	// Position of COCPU_TRAP_INT_ST field.
	RTC_CNTL_INT_ST_RTC_COCPU_TRAP_INT_ST_Pos = 0x11
	// Bit mask of COCPU_TRAP_INT_ST field.
	RTC_CNTL_INT_ST_RTC_COCPU_TRAP_INT_ST_Msk = 0x20000
	// Bit COCPU_TRAP_INT_ST.
	RTC_CNTL_INT_ST_RTC_COCPU_TRAP_INT_ST = 0x20000
	// Position of TOUCH_TIMEOUT_INT_ST field.
	RTC_CNTL_INT_ST_RTC_TOUCH_TIMEOUT_INT_ST_Pos = 0x12
	// Bit mask of TOUCH_TIMEOUT_INT_ST field.
	RTC_CNTL_INT_ST_RTC_TOUCH_TIMEOUT_INT_ST_Msk = 0x40000
	// Bit TOUCH_TIMEOUT_INT_ST.
	RTC_CNTL_INT_ST_RTC_TOUCH_TIMEOUT_INT_ST = 0x40000
	// Position of GLITCH_DET_INT_ST field.
	RTC_CNTL_INT_ST_RTC_GLITCH_DET_INT_ST_Pos = 0x13
	// Bit mask of GLITCH_DET_INT_ST field.
	RTC_CNTL_INT_ST_RTC_GLITCH_DET_INT_ST_Msk = 0x80000
	// Bit GLITCH_DET_INT_ST.
	RTC_CNTL_INT_ST_RTC_GLITCH_DET_INT_ST = 0x80000

	// INT_CLR_RTC: RTC interrupt clear register
	// Position of SLP_WAKEUP_INT_CLR field.
	RTC_CNTL_INT_CLR_RTC_SLP_WAKEUP_INT_CLR_Pos = 0x0
	// Bit mask of SLP_WAKEUP_INT_CLR field.
	RTC_CNTL_INT_CLR_RTC_SLP_WAKEUP_INT_CLR_Msk = 0x1
	// Bit SLP_WAKEUP_INT_CLR.
	RTC_CNTL_INT_CLR_RTC_SLP_WAKEUP_INT_CLR = 0x1
	// Position of SLP_REJECT_INT_CLR field.
	RTC_CNTL_INT_CLR_RTC_SLP_REJECT_INT_CLR_Pos = 0x1
	// Bit mask of SLP_REJECT_INT_CLR field.
	RTC_CNTL_INT_CLR_RTC_SLP_REJECT_INT_CLR_Msk = 0x2
	// Bit SLP_REJECT_INT_CLR.
	RTC_CNTL_INT_CLR_RTC_SLP_REJECT_INT_CLR = 0x2
	// Position of SDIO_IDLE_INT_CLR field.
	RTC_CNTL_INT_CLR_RTC_SDIO_IDLE_INT_CLR_Pos = 0x2
	// Bit mask of SDIO_IDLE_INT_CLR field.
	RTC_CNTL_INT_CLR_RTC_SDIO_IDLE_INT_CLR_Msk = 0x4
	// Bit SDIO_IDLE_INT_CLR.
	RTC_CNTL_INT_CLR_RTC_SDIO_IDLE_INT_CLR = 0x4
	// Position of WDT_INT_CLR field.
	RTC_CNTL_INT_CLR_RTC_WDT_INT_CLR_Pos = 0x3
	// Bit mask of WDT_INT_CLR field.
	RTC_CNTL_INT_CLR_RTC_WDT_INT_CLR_Msk = 0x8
	// Bit WDT_INT_CLR.
	RTC_CNTL_INT_CLR_RTC_WDT_INT_CLR = 0x8
	// Position of TOUCH_SCAN_DONE_INT_CLR field.
	RTC_CNTL_INT_CLR_RTC_TOUCH_SCAN_DONE_INT_CLR_Pos = 0x4
	// Bit mask of TOUCH_SCAN_DONE_INT_CLR field.
	RTC_CNTL_INT_CLR_RTC_TOUCH_SCAN_DONE_INT_CLR_Msk = 0x10
	// Bit TOUCH_SCAN_DONE_INT_CLR.
	RTC_CNTL_INT_CLR_RTC_TOUCH_SCAN_DONE_INT_CLR = 0x10
	// Position of ULP_CP_INT_CLR field.
	RTC_CNTL_INT_CLR_RTC_ULP_CP_INT_CLR_Pos = 0x5
	// Bit mask of ULP_CP_INT_CLR field.
	RTC_CNTL_INT_CLR_RTC_ULP_CP_INT_CLR_Msk = 0x20
	// Bit ULP_CP_INT_CLR.
	RTC_CNTL_INT_CLR_RTC_ULP_CP_INT_CLR = 0x20
	// Position of TOUCH_DONE_INT_CLR field.
	RTC_CNTL_INT_CLR_RTC_TOUCH_DONE_INT_CLR_Pos = 0x6
	// Bit mask of TOUCH_DONE_INT_CLR field.
	RTC_CNTL_INT_CLR_RTC_TOUCH_DONE_INT_CLR_Msk = 0x40
	// Bit TOUCH_DONE_INT_CLR.
	RTC_CNTL_INT_CLR_RTC_TOUCH_DONE_INT_CLR = 0x40
	// Position of TOUCH_ACTIVE_INT_CLR field.
	RTC_CNTL_INT_CLR_RTC_TOUCH_ACTIVE_INT_CLR_Pos = 0x7
	// Bit mask of TOUCH_ACTIVE_INT_CLR field.
	RTC_CNTL_INT_CLR_RTC_TOUCH_ACTIVE_INT_CLR_Msk = 0x80
	// Bit TOUCH_ACTIVE_INT_CLR.
	RTC_CNTL_INT_CLR_RTC_TOUCH_ACTIVE_INT_CLR = 0x80
	// Position of TOUCH_INACTIVE_INT_CLR field.
	RTC_CNTL_INT_CLR_RTC_TOUCH_INACTIVE_INT_CLR_Pos = 0x8
	// Bit mask of TOUCH_INACTIVE_INT_CLR field.
	RTC_CNTL_INT_CLR_RTC_TOUCH_INACTIVE_INT_CLR_Msk = 0x100
	// Bit TOUCH_INACTIVE_INT_CLR.
	RTC_CNTL_INT_CLR_RTC_TOUCH_INACTIVE_INT_CLR = 0x100
	// Position of BROWN_OUT_INT_CLR field.
	RTC_CNTL_INT_CLR_RTC_BROWN_OUT_INT_CLR_Pos = 0x9
	// Bit mask of BROWN_OUT_INT_CLR field.
	RTC_CNTL_INT_CLR_RTC_BROWN_OUT_INT_CLR_Msk = 0x200
	// Bit BROWN_OUT_INT_CLR.
	RTC_CNTL_INT_CLR_RTC_BROWN_OUT_INT_CLR = 0x200
	// Position of MAIN_TIMER_INT_CLR field.
	RTC_CNTL_INT_CLR_RTC_MAIN_TIMER_INT_CLR_Pos = 0xa
	// Bit mask of MAIN_TIMER_INT_CLR field.
	RTC_CNTL_INT_CLR_RTC_MAIN_TIMER_INT_CLR_Msk = 0x400
	// Bit MAIN_TIMER_INT_CLR.
	RTC_CNTL_INT_CLR_RTC_MAIN_TIMER_INT_CLR = 0x400
	// Position of SARADC1_INT_CLR field.
	RTC_CNTL_INT_CLR_RTC_SARADC1_INT_CLR_Pos = 0xb
	// Bit mask of SARADC1_INT_CLR field.
	RTC_CNTL_INT_CLR_RTC_SARADC1_INT_CLR_Msk = 0x800
	// Bit SARADC1_INT_CLR.
	RTC_CNTL_INT_CLR_RTC_SARADC1_INT_CLR = 0x800
	// Position of TSENS_INT_CLR field.
	RTC_CNTL_INT_CLR_RTC_TSENS_INT_CLR_Pos = 0xc
	// Bit mask of TSENS_INT_CLR field.
	RTC_CNTL_INT_CLR_RTC_TSENS_INT_CLR_Msk = 0x1000
	// Bit TSENS_INT_CLR.
	RTC_CNTL_INT_CLR_RTC_TSENS_INT_CLR = 0x1000
	// Position of COCPU_INT_CLR field.
	RTC_CNTL_INT_CLR_RTC_COCPU_INT_CLR_Pos = 0xd
	// Bit mask of COCPU_INT_CLR field.
	RTC_CNTL_INT_CLR_RTC_COCPU_INT_CLR_Msk = 0x2000
	// Bit COCPU_INT_CLR.
	RTC_CNTL_INT_CLR_RTC_COCPU_INT_CLR = 0x2000
	// Position of SARADC2_INT_CLR field.
	RTC_CNTL_INT_CLR_RTC_SARADC2_INT_CLR_Pos = 0xe
	// Bit mask of SARADC2_INT_CLR field.
	RTC_CNTL_INT_CLR_RTC_SARADC2_INT_CLR_Msk = 0x4000
	// Bit SARADC2_INT_CLR.
	RTC_CNTL_INT_CLR_RTC_SARADC2_INT_CLR = 0x4000
	// Position of SWD_INT_CLR field.
	RTC_CNTL_INT_CLR_RTC_SWD_INT_CLR_Pos = 0xf
	// Bit mask of SWD_INT_CLR field.
	RTC_CNTL_INT_CLR_RTC_SWD_INT_CLR_Msk = 0x8000
	// Bit SWD_INT_CLR.
	RTC_CNTL_INT_CLR_RTC_SWD_INT_CLR = 0x8000
	// Position of XTAL32K_DEAD_INT_CLR field.
	RTC_CNTL_INT_CLR_RTC_XTAL32K_DEAD_INT_CLR_Pos = 0x10
	// Bit mask of XTAL32K_DEAD_INT_CLR field.
	RTC_CNTL_INT_CLR_RTC_XTAL32K_DEAD_INT_CLR_Msk = 0x10000
	// Bit XTAL32K_DEAD_INT_CLR.
	RTC_CNTL_INT_CLR_RTC_XTAL32K_DEAD_INT_CLR = 0x10000
	// Position of COCPU_TRAP_INT_CLR field.
	RTC_CNTL_INT_CLR_RTC_COCPU_TRAP_INT_CLR_Pos = 0x11
	// Bit mask of COCPU_TRAP_INT_CLR field.
	RTC_CNTL_INT_CLR_RTC_COCPU_TRAP_INT_CLR_Msk = 0x20000
	// Bit COCPU_TRAP_INT_CLR.
	RTC_CNTL_INT_CLR_RTC_COCPU_TRAP_INT_CLR = 0x20000
	// Position of TOUCH_TIMEOUT_INT_CLR field.
	RTC_CNTL_INT_CLR_RTC_TOUCH_TIMEOUT_INT_CLR_Pos = 0x12
	// Bit mask of TOUCH_TIMEOUT_INT_CLR field.
	RTC_CNTL_INT_CLR_RTC_TOUCH_TIMEOUT_INT_CLR_Msk = 0x40000
	// Bit TOUCH_TIMEOUT_INT_CLR.
	RTC_CNTL_INT_CLR_RTC_TOUCH_TIMEOUT_INT_CLR = 0x40000
	// Position of GLITCH_DET_INT_CLR field.
	RTC_CNTL_INT_CLR_RTC_GLITCH_DET_INT_CLR_Pos = 0x13
	// Bit mask of GLITCH_DET_INT_CLR field.
	RTC_CNTL_INT_CLR_RTC_GLITCH_DET_INT_CLR_Msk = 0x80000
	// Bit GLITCH_DET_INT_CLR.
	RTC_CNTL_INT_CLR_RTC_GLITCH_DET_INT_CLR = 0x80000

	// STORE0: Reservation register 0
	// Position of SCRATCH0 field.
	RTC_CNTL_STORE0_SCRATCH0_Pos = 0x0
	// Bit mask of SCRATCH0 field.
	RTC_CNTL_STORE0_SCRATCH0_Msk = 0xffffffff

	// STORE1: Reservation register 1
	// Position of SCRATCH1 field.
	RTC_CNTL_STORE1_SCRATCH1_Pos = 0x0
	// Bit mask of SCRATCH1 field.
	RTC_CNTL_STORE1_SCRATCH1_Msk = 0xffffffff

	// STORE2: Reservation register 2
	// Position of SCRATCH2 field.
	RTC_CNTL_STORE2_SCRATCH2_Pos = 0x0
	// Bit mask of SCRATCH2 field.
	RTC_CNTL_STORE2_SCRATCH2_Msk = 0xffffffff

	// STORE3: Reservation register 3
	// Position of SCRATCH3 field.
	RTC_CNTL_STORE3_SCRATCH3_Pos = 0x0
	// Bit mask of SCRATCH3 field.
	RTC_CNTL_STORE3_SCRATCH3_Msk = 0xffffffff

	// EXT_XTL_CONF: 32 kHz crystal oscillator configuration register
	// Position of XTAL32K_WDT_EN field.
	RTC_CNTL_EXT_XTL_CONF_XTAL32K_WDT_EN_Pos = 0x0
	// Bit mask of XTAL32K_WDT_EN field.
	RTC_CNTL_EXT_XTL_CONF_XTAL32K_WDT_EN_Msk = 0x1
	// Bit XTAL32K_WDT_EN.
	RTC_CNTL_EXT_XTL_CONF_XTAL32K_WDT_EN = 0x1
	// Position of XTAL32K_WDT_CLK_FO field.
	RTC_CNTL_EXT_XTL_CONF_XTAL32K_WDT_CLK_FO_Pos = 0x1
	// Bit mask of XTAL32K_WDT_CLK_FO field.
	RTC_CNTL_EXT_XTL_CONF_XTAL32K_WDT_CLK_FO_Msk = 0x2
	// Bit XTAL32K_WDT_CLK_FO.
	RTC_CNTL_EXT_XTL_CONF_XTAL32K_WDT_CLK_FO = 0x2
	// Position of XTAL32K_WDT_RESET field.
	RTC_CNTL_EXT_XTL_CONF_XTAL32K_WDT_RESET_Pos = 0x2
	// Bit mask of XTAL32K_WDT_RESET field.
	RTC_CNTL_EXT_XTL_CONF_XTAL32K_WDT_RESET_Msk = 0x4
	// Bit XTAL32K_WDT_RESET.
	RTC_CNTL_EXT_XTL_CONF_XTAL32K_WDT_RESET = 0x4
	// Position of XTAL32K_EXT_CLK_FO field.
	RTC_CNTL_EXT_XTL_CONF_XTAL32K_EXT_CLK_FO_Pos = 0x3
	// Bit mask of XTAL32K_EXT_CLK_FO field.
	RTC_CNTL_EXT_XTL_CONF_XTAL32K_EXT_CLK_FO_Msk = 0x8
	// Bit XTAL32K_EXT_CLK_FO.
	RTC_CNTL_EXT_XTL_CONF_XTAL32K_EXT_CLK_FO = 0x8
	// Position of XTAL32K_AUTO_BACKUP field.
	RTC_CNTL_EXT_XTL_CONF_XTAL32K_AUTO_BACKUP_Pos = 0x4
	// Bit mask of XTAL32K_AUTO_BACKUP field.
	RTC_CNTL_EXT_XTL_CONF_XTAL32K_AUTO_BACKUP_Msk = 0x10
	// Bit XTAL32K_AUTO_BACKUP.
	RTC_CNTL_EXT_XTL_CONF_XTAL32K_AUTO_BACKUP = 0x10
	// Position of XTAL32K_AUTO_RESTART field.
	RTC_CNTL_EXT_XTL_CONF_XTAL32K_AUTO_RESTART_Pos = 0x5
	// Bit mask of XTAL32K_AUTO_RESTART field.
	RTC_CNTL_EXT_XTL_CONF_XTAL32K_AUTO_RESTART_Msk = 0x20
	// Bit XTAL32K_AUTO_RESTART.
	RTC_CNTL_EXT_XTL_CONF_XTAL32K_AUTO_RESTART = 0x20
	// Position of XTAL32K_AUTO_RETURN field.
	RTC_CNTL_EXT_XTL_CONF_XTAL32K_AUTO_RETURN_Pos = 0x6
	// Bit mask of XTAL32K_AUTO_RETURN field.
	RTC_CNTL_EXT_XTL_CONF_XTAL32K_AUTO_RETURN_Msk = 0x40
	// Bit XTAL32K_AUTO_RETURN.
	RTC_CNTL_EXT_XTL_CONF_XTAL32K_AUTO_RETURN = 0x40
	// Position of XTAL32K_XPD_FORCE field.
	RTC_CNTL_EXT_XTL_CONF_XTAL32K_XPD_FORCE_Pos = 0x7
	// Bit mask of XTAL32K_XPD_FORCE field.
	RTC_CNTL_EXT_XTL_CONF_XTAL32K_XPD_FORCE_Msk = 0x80
	// Bit XTAL32K_XPD_FORCE.
	RTC_CNTL_EXT_XTL_CONF_XTAL32K_XPD_FORCE = 0x80
	// Position of ENCKINIT_XTAL_32K field.
	RTC_CNTL_EXT_XTL_CONF_ENCKINIT_XTAL_32K_Pos = 0x8
	// Bit mask of ENCKINIT_XTAL_32K field.
	RTC_CNTL_EXT_XTL_CONF_ENCKINIT_XTAL_32K_Msk = 0x100
	// Bit ENCKINIT_XTAL_32K.
	RTC_CNTL_EXT_XTL_CONF_ENCKINIT_XTAL_32K = 0x100
	// Position of DBUF_XTAL_32K field.
	RTC_CNTL_EXT_XTL_CONF_DBUF_XTAL_32K_Pos = 0x9
	// Bit mask of DBUF_XTAL_32K field.
	RTC_CNTL_EXT_XTL_CONF_DBUF_XTAL_32K_Msk = 0x200
	// Bit DBUF_XTAL_32K.
	RTC_CNTL_EXT_XTL_CONF_DBUF_XTAL_32K = 0x200
	// Position of DGM_XTAL_32K field.
	RTC_CNTL_EXT_XTL_CONF_DGM_XTAL_32K_Pos = 0xa
	// Bit mask of DGM_XTAL_32K field.
	RTC_CNTL_EXT_XTL_CONF_DGM_XTAL_32K_Msk = 0x1c00
	// Position of DRES_XTAL_32K field.
	RTC_CNTL_EXT_XTL_CONF_DRES_XTAL_32K_Pos = 0xd
	// Bit mask of DRES_XTAL_32K field.
	RTC_CNTL_EXT_XTL_CONF_DRES_XTAL_32K_Msk = 0xe000
	// Position of XPD_XTAL_32K field.
	RTC_CNTL_EXT_XTL_CONF_XPD_XTAL_32K_Pos = 0x10
	// Bit mask of XPD_XTAL_32K field.
	RTC_CNTL_EXT_XTL_CONF_XPD_XTAL_32K_Msk = 0x10000
	// Bit XPD_XTAL_32K.
	RTC_CNTL_EXT_XTL_CONF_XPD_XTAL_32K = 0x10000
	// Position of DAC_XTAL_32K field.
	RTC_CNTL_EXT_XTL_CONF_DAC_XTAL_32K_Pos = 0x11
	// Bit mask of DAC_XTAL_32K field.
	RTC_CNTL_EXT_XTL_CONF_DAC_XTAL_32K_Msk = 0xe0000
	// Position of WDT_STATE field.
	RTC_CNTL_EXT_XTL_CONF_WDT_STATE_Pos = 0x14
	// Bit mask of WDT_STATE field.
	RTC_CNTL_EXT_XTL_CONF_WDT_STATE_Msk = 0x700000
	// Position of XTAL32K_GPIO_SEL field.
	RTC_CNTL_EXT_XTL_CONF_XTAL32K_GPIO_SEL_Pos = 0x17
	// Bit mask of XTAL32K_GPIO_SEL field.
	RTC_CNTL_EXT_XTL_CONF_XTAL32K_GPIO_SEL_Msk = 0x800000
	// Bit XTAL32K_GPIO_SEL.
	RTC_CNTL_EXT_XTL_CONF_XTAL32K_GPIO_SEL = 0x800000
	// Position of XTL_EXT_CTR_LV field.
	RTC_CNTL_EXT_XTL_CONF_XTL_EXT_CTR_LV_Pos = 0x1e
	// Bit mask of XTL_EXT_CTR_LV field.
	RTC_CNTL_EXT_XTL_CONF_XTL_EXT_CTR_LV_Msk = 0x40000000
	// Bit XTL_EXT_CTR_LV.
	RTC_CNTL_EXT_XTL_CONF_XTL_EXT_CTR_LV = 0x40000000
	// Position of XTL_EXT_CTR_EN field.
	RTC_CNTL_EXT_XTL_CONF_XTL_EXT_CTR_EN_Pos = 0x1f
	// Bit mask of XTL_EXT_CTR_EN field.
	RTC_CNTL_EXT_XTL_CONF_XTL_EXT_CTR_EN_Msk = 0x80000000
	// Bit XTL_EXT_CTR_EN.
	RTC_CNTL_EXT_XTL_CONF_XTL_EXT_CTR_EN = 0x80000000

	// EXT_WAKEUP_CONF: GPIO wakeup configuration register
	// Position of GPIO_WAKEUP_FILTER field.
	RTC_CNTL_EXT_WAKEUP_CONF_GPIO_WAKEUP_FILTER_Pos = 0x1d
	// Bit mask of GPIO_WAKEUP_FILTER field.
	RTC_CNTL_EXT_WAKEUP_CONF_GPIO_WAKEUP_FILTER_Msk = 0x20000000
	// Bit GPIO_WAKEUP_FILTER.
	RTC_CNTL_EXT_WAKEUP_CONF_GPIO_WAKEUP_FILTER = 0x20000000
	// Position of EXT_WAKEUP0_LV field.
	RTC_CNTL_EXT_WAKEUP_CONF_EXT_WAKEUP0_LV_Pos = 0x1e
	// Bit mask of EXT_WAKEUP0_LV field.
	RTC_CNTL_EXT_WAKEUP_CONF_EXT_WAKEUP0_LV_Msk = 0x40000000
	// Bit EXT_WAKEUP0_LV.
	RTC_CNTL_EXT_WAKEUP_CONF_EXT_WAKEUP0_LV = 0x40000000
	// Position of EXT_WAKEUP1_LV field.
	RTC_CNTL_EXT_WAKEUP_CONF_EXT_WAKEUP1_LV_Pos = 0x1f
	// Bit mask of EXT_WAKEUP1_LV field.
	RTC_CNTL_EXT_WAKEUP_CONF_EXT_WAKEUP1_LV_Msk = 0x80000000
	// Bit EXT_WAKEUP1_LV.
	RTC_CNTL_EXT_WAKEUP_CONF_EXT_WAKEUP1_LV = 0x80000000

	// SLP_REJECT_CONF: Configures sleep / reject options
	// Position of SLEEP_REJECT_ENA field.
	RTC_CNTL_SLP_REJECT_CONF_SLEEP_REJECT_ENA_Pos = 0xd
	// Bit mask of SLEEP_REJECT_ENA field.
	RTC_CNTL_SLP_REJECT_CONF_SLEEP_REJECT_ENA_Msk = 0x3fffe000
	// Position of LIGHT_SLP_REJECT_EN field.
	RTC_CNTL_SLP_REJECT_CONF_LIGHT_SLP_REJECT_EN_Pos = 0x1e
	// Bit mask of LIGHT_SLP_REJECT_EN field.
	RTC_CNTL_SLP_REJECT_CONF_LIGHT_SLP_REJECT_EN_Msk = 0x40000000
	// Bit LIGHT_SLP_REJECT_EN.
	RTC_CNTL_SLP_REJECT_CONF_LIGHT_SLP_REJECT_EN = 0x40000000
	// Position of DEEP_SLP_REJECT_EN field.
	RTC_CNTL_SLP_REJECT_CONF_DEEP_SLP_REJECT_EN_Pos = 0x1f
	// Bit mask of DEEP_SLP_REJECT_EN field.
	RTC_CNTL_SLP_REJECT_CONF_DEEP_SLP_REJECT_EN_Msk = 0x80000000
	// Bit DEEP_SLP_REJECT_EN.
	RTC_CNTL_SLP_REJECT_CONF_DEEP_SLP_REJECT_EN = 0x80000000

	// CPU_PERIOD_CONF: CPU sel option
	// Position of CPUSEL_CONF field.
	RTC_CNTL_CPU_PERIOD_CONF_CPUSEL_CONF_Pos = 0x1d
	// Bit mask of CPUSEL_CONF field.
	RTC_CNTL_CPU_PERIOD_CONF_CPUSEL_CONF_Msk = 0x20000000
	// Bit CPUSEL_CONF.
	RTC_CNTL_CPU_PERIOD_CONF_CPUSEL_CONF = 0x20000000
	// Position of CPUPERIOD_SEL field.
	RTC_CNTL_CPU_PERIOD_CONF_CPUPERIOD_SEL_Pos = 0x1e
	// Bit mask of CPUPERIOD_SEL field.
	RTC_CNTL_CPU_PERIOD_CONF_CPUPERIOD_SEL_Msk = 0xc0000000

	// SDIO_ACT_CONF: configure sdio active register
	// Position of SDIO_ACT_DNUM field.
	RTC_CNTL_SDIO_ACT_CONF_SDIO_ACT_DNUM_Pos = 0x16
	// Bit mask of SDIO_ACT_DNUM field.
	RTC_CNTL_SDIO_ACT_CONF_SDIO_ACT_DNUM_Msk = 0xffc00000

	// CLK_CONF: RTC clock configuration register
	// Position of CK8M_DIV_SEL_VLD field.
	RTC_CNTL_CLK_CONF_CK8M_DIV_SEL_VLD_Pos = 0x3
	// Bit mask of CK8M_DIV_SEL_VLD field.
	RTC_CNTL_CLK_CONF_CK8M_DIV_SEL_VLD_Msk = 0x8
	// Bit CK8M_DIV_SEL_VLD.
	RTC_CNTL_CLK_CONF_CK8M_DIV_SEL_VLD = 0x8
	// Position of CK8M_DIV field.
	RTC_CNTL_CLK_CONF_CK8M_DIV_Pos = 0x4
	// Bit mask of CK8M_DIV field.
	RTC_CNTL_CLK_CONF_CK8M_DIV_Msk = 0x30
	// Position of ENB_CK8M field.
	RTC_CNTL_CLK_CONF_ENB_CK8M_Pos = 0x6
	// Bit mask of ENB_CK8M field.
	RTC_CNTL_CLK_CONF_ENB_CK8M_Msk = 0x40
	// Bit ENB_CK8M.
	RTC_CNTL_CLK_CONF_ENB_CK8M = 0x40
	// Position of ENB_CK8M_DIV field.
	RTC_CNTL_CLK_CONF_ENB_CK8M_DIV_Pos = 0x7
	// Bit mask of ENB_CK8M_DIV field.
	RTC_CNTL_CLK_CONF_ENB_CK8M_DIV_Msk = 0x80
	// Bit ENB_CK8M_DIV.
	RTC_CNTL_CLK_CONF_ENB_CK8M_DIV = 0x80
	// Position of DIG_XTAL32K_EN field.
	RTC_CNTL_CLK_CONF_DIG_XTAL32K_EN_Pos = 0x8
	// Bit mask of DIG_XTAL32K_EN field.
	RTC_CNTL_CLK_CONF_DIG_XTAL32K_EN_Msk = 0x100
	// Bit DIG_XTAL32K_EN.
	RTC_CNTL_CLK_CONF_DIG_XTAL32K_EN = 0x100
	// Position of DIG_CLK8M_D256_EN field.
	RTC_CNTL_CLK_CONF_DIG_CLK8M_D256_EN_Pos = 0x9
	// Bit mask of DIG_CLK8M_D256_EN field.
	RTC_CNTL_CLK_CONF_DIG_CLK8M_D256_EN_Msk = 0x200
	// Bit DIG_CLK8M_D256_EN.
	RTC_CNTL_CLK_CONF_DIG_CLK8M_D256_EN = 0x200
	// Position of DIG_CLK8M_EN field.
	RTC_CNTL_CLK_CONF_DIG_CLK8M_EN_Pos = 0xa
	// Bit mask of DIG_CLK8M_EN field.
	RTC_CNTL_CLK_CONF_DIG_CLK8M_EN_Msk = 0x400
	// Bit DIG_CLK8M_EN.
	RTC_CNTL_CLK_CONF_DIG_CLK8M_EN = 0x400
	// Position of CK8M_DIV_SEL field.
	RTC_CNTL_CLK_CONF_CK8M_DIV_SEL_Pos = 0xc
	// Bit mask of CK8M_DIV_SEL field.
	RTC_CNTL_CLK_CONF_CK8M_DIV_SEL_Msk = 0x7000
	// Position of XTAL_FORCE_NOGATING field.
	RTC_CNTL_CLK_CONF_XTAL_FORCE_NOGATING_Pos = 0xf
	// Bit mask of XTAL_FORCE_NOGATING field.
	RTC_CNTL_CLK_CONF_XTAL_FORCE_NOGATING_Msk = 0x8000
	// Bit XTAL_FORCE_NOGATING.
	RTC_CNTL_CLK_CONF_XTAL_FORCE_NOGATING = 0x8000
	// Position of CK8M_FORCE_NOGATING field.
	RTC_CNTL_CLK_CONF_CK8M_FORCE_NOGATING_Pos = 0x10
	// Bit mask of CK8M_FORCE_NOGATING field.
	RTC_CNTL_CLK_CONF_CK8M_FORCE_NOGATING_Msk = 0x10000
	// Bit CK8M_FORCE_NOGATING.
	RTC_CNTL_CLK_CONF_CK8M_FORCE_NOGATING = 0x10000
	// Position of CK8M_DFREQ field.
	RTC_CNTL_CLK_CONF_CK8M_DFREQ_Pos = 0x11
	// Bit mask of CK8M_DFREQ field.
	RTC_CNTL_CLK_CONF_CK8M_DFREQ_Msk = 0x1fe0000
	// Position of CK8M_FORCE_PD field.
	RTC_CNTL_CLK_CONF_CK8M_FORCE_PD_Pos = 0x19
	// Bit mask of CK8M_FORCE_PD field.
	RTC_CNTL_CLK_CONF_CK8M_FORCE_PD_Msk = 0x2000000
	// Bit CK8M_FORCE_PD.
	RTC_CNTL_CLK_CONF_CK8M_FORCE_PD = 0x2000000
	// Position of CK8M_FORCE_PU field.
	RTC_CNTL_CLK_CONF_CK8M_FORCE_PU_Pos = 0x1a
	// Bit mask of CK8M_FORCE_PU field.
	RTC_CNTL_CLK_CONF_CK8M_FORCE_PU_Msk = 0x4000000
	// Bit CK8M_FORCE_PU.
	RTC_CNTL_CLK_CONF_CK8M_FORCE_PU = 0x4000000
	// Position of FAST_CLK_RTC_SEL field.
	RTC_CNTL_CLK_CONF_FAST_CLK_RTC_SEL_Pos = 0x1d
	// Bit mask of FAST_CLK_RTC_SEL field.
	RTC_CNTL_CLK_CONF_FAST_CLK_RTC_SEL_Msk = 0x20000000
	// Bit FAST_CLK_RTC_SEL.
	RTC_CNTL_CLK_CONF_FAST_CLK_RTC_SEL = 0x20000000
	// Position of ANA_CLK_RTC_SEL field.
	RTC_CNTL_CLK_CONF_ANA_CLK_RTC_SEL_Pos = 0x1e
	// Bit mask of ANA_CLK_RTC_SEL field.
	RTC_CNTL_CLK_CONF_ANA_CLK_RTC_SEL_Msk = 0xc0000000

	// SLOW_CLK_CONF: RTC slow clock configuration register
	// Position of ANA_CLK_DIV_VLD field.
	RTC_CNTL_SLOW_CLK_CONF_ANA_CLK_DIV_VLD_Pos = 0x16
	// Bit mask of ANA_CLK_DIV_VLD field.
	RTC_CNTL_SLOW_CLK_CONF_ANA_CLK_DIV_VLD_Msk = 0x400000
	// Bit ANA_CLK_DIV_VLD.
	RTC_CNTL_SLOW_CLK_CONF_ANA_CLK_DIV_VLD = 0x400000
	// Position of ANA_CLK_DIV field.
	RTC_CNTL_SLOW_CLK_CONF_ANA_CLK_DIV_Pos = 0x17
	// Bit mask of ANA_CLK_DIV field.
	RTC_CNTL_SLOW_CLK_CONF_ANA_CLK_DIV_Msk = 0x7f800000
	// Position of SLOW_CLK_NEXT_EDGE field.
	RTC_CNTL_SLOW_CLK_CONF_SLOW_CLK_NEXT_EDGE_Pos = 0x1f
	// Bit mask of SLOW_CLK_NEXT_EDGE field.
	RTC_CNTL_SLOW_CLK_CONF_SLOW_CLK_NEXT_EDGE_Msk = 0x80000000
	// Bit SLOW_CLK_NEXT_EDGE.
	RTC_CNTL_SLOW_CLK_CONF_SLOW_CLK_NEXT_EDGE = 0x80000000

	// SDIO_CONF: configure vddsdio register
	// Position of SDIO_TIMER_TARGET field.
	RTC_CNTL_SDIO_CONF_SDIO_TIMER_TARGET_Pos = 0x0
	// Bit mask of SDIO_TIMER_TARGET field.
	RTC_CNTL_SDIO_CONF_SDIO_TIMER_TARGET_Msk = 0xff
	// Position of SDIO_DTHDRV field.
	RTC_CNTL_SDIO_CONF_SDIO_DTHDRV_Pos = 0x9
	// Bit mask of SDIO_DTHDRV field.
	RTC_CNTL_SDIO_CONF_SDIO_DTHDRV_Msk = 0x600
	// Position of SDIO_DCAP field.
	RTC_CNTL_SDIO_CONF_SDIO_DCAP_Pos = 0xb
	// Bit mask of SDIO_DCAP field.
	RTC_CNTL_SDIO_CONF_SDIO_DCAP_Msk = 0x1800
	// Position of SDIO_INITI field.
	RTC_CNTL_SDIO_CONF_SDIO_INITI_Pos = 0xd
	// Bit mask of SDIO_INITI field.
	RTC_CNTL_SDIO_CONF_SDIO_INITI_Msk = 0x6000
	// Position of SDIO_EN_INITI field.
	RTC_CNTL_SDIO_CONF_SDIO_EN_INITI_Pos = 0xf
	// Bit mask of SDIO_EN_INITI field.
	RTC_CNTL_SDIO_CONF_SDIO_EN_INITI_Msk = 0x8000
	// Bit SDIO_EN_INITI.
	RTC_CNTL_SDIO_CONF_SDIO_EN_INITI = 0x8000
	// Position of SDIO_DCURLIM field.
	RTC_CNTL_SDIO_CONF_SDIO_DCURLIM_Pos = 0x10
	// Bit mask of SDIO_DCURLIM field.
	RTC_CNTL_SDIO_CONF_SDIO_DCURLIM_Msk = 0x70000
	// Position of SDIO_MODECURLIM field.
	RTC_CNTL_SDIO_CONF_SDIO_MODECURLIM_Pos = 0x13
	// Bit mask of SDIO_MODECURLIM field.
	RTC_CNTL_SDIO_CONF_SDIO_MODECURLIM_Msk = 0x80000
	// Bit SDIO_MODECURLIM.
	RTC_CNTL_SDIO_CONF_SDIO_MODECURLIM = 0x80000
	// Position of SDIO_ENCURLIM field.
	RTC_CNTL_SDIO_CONF_SDIO_ENCURLIM_Pos = 0x14
	// Bit mask of SDIO_ENCURLIM field.
	RTC_CNTL_SDIO_CONF_SDIO_ENCURLIM_Msk = 0x100000
	// Bit SDIO_ENCURLIM.
	RTC_CNTL_SDIO_CONF_SDIO_ENCURLIM = 0x100000
	// Position of SDIO_REG_PD_EN field.
	RTC_CNTL_SDIO_CONF_SDIO_REG_PD_EN_Pos = 0x15
	// Bit mask of SDIO_REG_PD_EN field.
	RTC_CNTL_SDIO_CONF_SDIO_REG_PD_EN_Msk = 0x200000
	// Bit SDIO_REG_PD_EN.
	RTC_CNTL_SDIO_CONF_SDIO_REG_PD_EN = 0x200000
	// Position of SDIO_FORCE field.
	RTC_CNTL_SDIO_CONF_SDIO_FORCE_Pos = 0x16
	// Bit mask of SDIO_FORCE field.
	RTC_CNTL_SDIO_CONF_SDIO_FORCE_Msk = 0x400000
	// Bit SDIO_FORCE.
	RTC_CNTL_SDIO_CONF_SDIO_FORCE = 0x400000
	// Position of SDIO_TIEH field.
	RTC_CNTL_SDIO_CONF_SDIO_TIEH_Pos = 0x17
	// Bit mask of SDIO_TIEH field.
	RTC_CNTL_SDIO_CONF_SDIO_TIEH_Msk = 0x800000
	// Bit SDIO_TIEH.
	RTC_CNTL_SDIO_CONF_SDIO_TIEH = 0x800000
	// Position of REG1P8_READY field.
	RTC_CNTL_SDIO_CONF_REG1P8_READY_Pos = 0x18
	// Bit mask of REG1P8_READY field.
	RTC_CNTL_SDIO_CONF_REG1P8_READY_Msk = 0x1000000
	// Bit REG1P8_READY.
	RTC_CNTL_SDIO_CONF_REG1P8_READY = 0x1000000
	// Position of DREFL_SDIO field.
	RTC_CNTL_SDIO_CONF_DREFL_SDIO_Pos = 0x19
	// Bit mask of DREFL_SDIO field.
	RTC_CNTL_SDIO_CONF_DREFL_SDIO_Msk = 0x6000000
	// Position of DREFM_SDIO field.
	RTC_CNTL_SDIO_CONF_DREFM_SDIO_Pos = 0x1b
	// Bit mask of DREFM_SDIO field.
	RTC_CNTL_SDIO_CONF_DREFM_SDIO_Msk = 0x18000000
	// Position of DREFH_SDIO field.
	RTC_CNTL_SDIO_CONF_DREFH_SDIO_Pos = 0x1d
	// Bit mask of DREFH_SDIO field.
	RTC_CNTL_SDIO_CONF_DREFH_SDIO_Msk = 0x60000000
	// Position of XPD_SDIO field.
	RTC_CNTL_SDIO_CONF_XPD_SDIO_Pos = 0x1f
	// Bit mask of XPD_SDIO field.
	RTC_CNTL_SDIO_CONF_XPD_SDIO_Msk = 0x80000000
	// Bit XPD_SDIO.
	RTC_CNTL_SDIO_CONF_XPD_SDIO = 0x80000000

	// BIAS_CONF: configure power register
	// Position of BIAS_BUF_IDLE field.
	RTC_CNTL_BIAS_CONF_BIAS_BUF_IDLE_Pos = 0xa
	// Bit mask of BIAS_BUF_IDLE field.
	RTC_CNTL_BIAS_CONF_BIAS_BUF_IDLE_Msk = 0x400
	// Bit BIAS_BUF_IDLE.
	RTC_CNTL_BIAS_CONF_BIAS_BUF_IDLE = 0x400
	// Position of BIAS_BUF_WAKE field.
	RTC_CNTL_BIAS_CONF_BIAS_BUF_WAKE_Pos = 0xb
	// Bit mask of BIAS_BUF_WAKE field.
	RTC_CNTL_BIAS_CONF_BIAS_BUF_WAKE_Msk = 0x800
	// Bit BIAS_BUF_WAKE.
	RTC_CNTL_BIAS_CONF_BIAS_BUF_WAKE = 0x800
	// Position of BIAS_BUF_DEEP_SLP field.
	RTC_CNTL_BIAS_CONF_BIAS_BUF_DEEP_SLP_Pos = 0xc
	// Bit mask of BIAS_BUF_DEEP_SLP field.
	RTC_CNTL_BIAS_CONF_BIAS_BUF_DEEP_SLP_Msk = 0x1000
	// Bit BIAS_BUF_DEEP_SLP.
	RTC_CNTL_BIAS_CONF_BIAS_BUF_DEEP_SLP = 0x1000
	// Position of BIAS_BUF_MONITOR field.
	RTC_CNTL_BIAS_CONF_BIAS_BUF_MONITOR_Pos = 0xd
	// Bit mask of BIAS_BUF_MONITOR field.
	RTC_CNTL_BIAS_CONF_BIAS_BUF_MONITOR_Msk = 0x2000
	// Bit BIAS_BUF_MONITOR.
	RTC_CNTL_BIAS_CONF_BIAS_BUF_MONITOR = 0x2000
	// Position of PD_CUR_DEEP_SLP field.
	RTC_CNTL_BIAS_CONF_PD_CUR_DEEP_SLP_Pos = 0xe
	// Bit mask of PD_CUR_DEEP_SLP field.
	RTC_CNTL_BIAS_CONF_PD_CUR_DEEP_SLP_Msk = 0x4000
	// Bit PD_CUR_DEEP_SLP.
	RTC_CNTL_BIAS_CONF_PD_CUR_DEEP_SLP = 0x4000
	// Position of PD_CUR_MONITOR field.
	RTC_CNTL_BIAS_CONF_PD_CUR_MONITOR_Pos = 0xf
	// Bit mask of PD_CUR_MONITOR field.
	RTC_CNTL_BIAS_CONF_PD_CUR_MONITOR_Msk = 0x8000
	// Bit PD_CUR_MONITOR.
	RTC_CNTL_BIAS_CONF_PD_CUR_MONITOR = 0x8000
	// Position of BIAS_SLEEP_DEEP_SLP field.
	RTC_CNTL_BIAS_CONF_BIAS_SLEEP_DEEP_SLP_Pos = 0x10
	// Bit mask of BIAS_SLEEP_DEEP_SLP field.
	RTC_CNTL_BIAS_CONF_BIAS_SLEEP_DEEP_SLP_Msk = 0x10000
	// Bit BIAS_SLEEP_DEEP_SLP.
	RTC_CNTL_BIAS_CONF_BIAS_SLEEP_DEEP_SLP = 0x10000
	// Position of BIAS_SLEEP_MONITOR field.
	RTC_CNTL_BIAS_CONF_BIAS_SLEEP_MONITOR_Pos = 0x11
	// Bit mask of BIAS_SLEEP_MONITOR field.
	RTC_CNTL_BIAS_CONF_BIAS_SLEEP_MONITOR_Msk = 0x20000
	// Bit BIAS_SLEEP_MONITOR.
	RTC_CNTL_BIAS_CONF_BIAS_SLEEP_MONITOR = 0x20000
	// Position of DBG_ATTEN_DEEP_SLP field.
	RTC_CNTL_BIAS_CONF_DBG_ATTEN_DEEP_SLP_Pos = 0x12
	// Bit mask of DBG_ATTEN_DEEP_SLP field.
	RTC_CNTL_BIAS_CONF_DBG_ATTEN_DEEP_SLP_Msk = 0x3c0000
	// Position of DBG_ATTEN_MONITOR field.
	RTC_CNTL_BIAS_CONF_DBG_ATTEN_MONITOR_Pos = 0x16
	// Bit mask of DBG_ATTEN_MONITOR field.
	RTC_CNTL_BIAS_CONF_DBG_ATTEN_MONITOR_Msk = 0x3c00000
	// Position of ENB_SCK_XTAL field.
	RTC_CNTL_BIAS_CONF_ENB_SCK_XTAL_Pos = 0x1a
	// Bit mask of ENB_SCK_XTAL field.
	RTC_CNTL_BIAS_CONF_ENB_SCK_XTAL_Msk = 0x4000000
	// Bit ENB_SCK_XTAL.
	RTC_CNTL_BIAS_CONF_ENB_SCK_XTAL = 0x4000000
	// Position of INC_HEARTBEAT_REFRESH field.
	RTC_CNTL_BIAS_CONF_INC_HEARTBEAT_REFRESH_Pos = 0x1b
	// Bit mask of INC_HEARTBEAT_REFRESH field.
	RTC_CNTL_BIAS_CONF_INC_HEARTBEAT_REFRESH_Msk = 0x8000000
	// Bit INC_HEARTBEAT_REFRESH.
	RTC_CNTL_BIAS_CONF_INC_HEARTBEAT_REFRESH = 0x8000000
	// Position of DEC_HEARTBEAT_PERIOD field.
	RTC_CNTL_BIAS_CONF_DEC_HEARTBEAT_PERIOD_Pos = 0x1c
	// Bit mask of DEC_HEARTBEAT_PERIOD field.
	RTC_CNTL_BIAS_CONF_DEC_HEARTBEAT_PERIOD_Msk = 0x10000000
	// Bit DEC_HEARTBEAT_PERIOD.
	RTC_CNTL_BIAS_CONF_DEC_HEARTBEAT_PERIOD = 0x10000000
	// Position of INC_HEARTBEAT_PERIOD field.
	RTC_CNTL_BIAS_CONF_INC_HEARTBEAT_PERIOD_Pos = 0x1d
	// Bit mask of INC_HEARTBEAT_PERIOD field.
	RTC_CNTL_BIAS_CONF_INC_HEARTBEAT_PERIOD_Msk = 0x20000000
	// Bit INC_HEARTBEAT_PERIOD.
	RTC_CNTL_BIAS_CONF_INC_HEARTBEAT_PERIOD = 0x20000000
	// Position of DEC_HEARTBEAT_WIDTH field.
	RTC_CNTL_BIAS_CONF_DEC_HEARTBEAT_WIDTH_Pos = 0x1e
	// Bit mask of DEC_HEARTBEAT_WIDTH field.
	RTC_CNTL_BIAS_CONF_DEC_HEARTBEAT_WIDTH_Msk = 0x40000000
	// Bit DEC_HEARTBEAT_WIDTH.
	RTC_CNTL_BIAS_CONF_DEC_HEARTBEAT_WIDTH = 0x40000000
	// Position of RST_BIAS_I2C field.
	RTC_CNTL_BIAS_CONF_RST_BIAS_I2C_Pos = 0x1f
	// Bit mask of RST_BIAS_I2C field.
	RTC_CNTL_BIAS_CONF_RST_BIAS_I2C_Msk = 0x80000000
	// Bit RST_BIAS_I2C.
	RTC_CNTL_BIAS_CONF_RST_BIAS_I2C = 0x80000000

	// BIAS: RTC/DIG regulator configuration register
	// Position of DIG_DBIAS_SLP field.
	RTC_CNTL_BIAS_DIG_DBIAS_SLP_Pos = 0x8
	// Bit mask of DIG_DBIAS_SLP field.
	RTC_CNTL_BIAS_DIG_DBIAS_SLP_Msk = 0x700
	// Position of DIG_DBIAS_WAK field.
	RTC_CNTL_BIAS_DIG_DBIAS_WAK_Pos = 0xb
	// Bit mask of DIG_DBIAS_WAK field.
	RTC_CNTL_BIAS_DIG_DBIAS_WAK_Msk = 0x3800
	// Position of SCK_DCAP field.
	RTC_CNTL_BIAS_SCK_DCAP_Pos = 0xe
	// Bit mask of SCK_DCAP field.
	RTC_CNTL_BIAS_SCK_DCAP_Msk = 0x3fc000
	// Position of DBIAS_SLP field.
	RTC_CNTL_BIAS_DBIAS_SLP_Pos = 0x16
	// Bit mask of DBIAS_SLP field.
	RTC_CNTL_BIAS_DBIAS_SLP_Msk = 0x1c00000
	// Position of DBIAS_WAK field.
	RTC_CNTL_BIAS_DBIAS_WAK_Pos = 0x19
	// Bit mask of DBIAS_WAK field.
	RTC_CNTL_BIAS_DBIAS_WAK_Msk = 0xe000000
	// Position of DBOOST_FORCE_PD field.
	RTC_CNTL_BIAS_DBOOST_FORCE_PD_Pos = 0x1c
	// Bit mask of DBOOST_FORCE_PD field.
	RTC_CNTL_BIAS_DBOOST_FORCE_PD_Msk = 0x10000000
	// Bit DBOOST_FORCE_PD.
	RTC_CNTL_BIAS_DBOOST_FORCE_PD = 0x10000000
	// Position of DBOOST_FORCE_PU field.
	RTC_CNTL_BIAS_DBOOST_FORCE_PU_Pos = 0x1d
	// Bit mask of DBOOST_FORCE_PU field.
	RTC_CNTL_BIAS_DBOOST_FORCE_PU_Msk = 0x20000000
	// Bit DBOOST_FORCE_PU.
	RTC_CNTL_BIAS_DBOOST_FORCE_PU = 0x20000000
	// Position of REGULATOR_FORCE_PD field.
	RTC_CNTL_BIAS_REGULATOR_FORCE_PD_Pos = 0x1e
	// Bit mask of REGULATOR_FORCE_PD field.
	RTC_CNTL_BIAS_REGULATOR_FORCE_PD_Msk = 0x40000000
	// Bit REGULATOR_FORCE_PD.
	RTC_CNTL_BIAS_REGULATOR_FORCE_PD = 0x40000000
	// Position of REGULATOR_FORCE_PU field.
	RTC_CNTL_BIAS_REGULATOR_FORCE_PU_Pos = 0x1f
	// Bit mask of REGULATOR_FORCE_PU field.
	RTC_CNTL_BIAS_REGULATOR_FORCE_PU_Msk = 0x80000000
	// Bit REGULATOR_FORCE_PU.
	RTC_CNTL_BIAS_REGULATOR_FORCE_PU = 0x80000000

	// PWC: RTC power configuraiton register
	// Position of FASTMEM_FORCE_NOISO field.
	RTC_CNTL_PWC_FASTMEM_FORCE_NOISO_Pos = 0x0
	// Bit mask of FASTMEM_FORCE_NOISO field.
	RTC_CNTL_PWC_FASTMEM_FORCE_NOISO_Msk = 0x1
	// Bit FASTMEM_FORCE_NOISO.
	RTC_CNTL_PWC_FASTMEM_FORCE_NOISO = 0x1
	// Position of FASTMEM_FORCE_ISO field.
	RTC_CNTL_PWC_FASTMEM_FORCE_ISO_Pos = 0x1
	// Bit mask of FASTMEM_FORCE_ISO field.
	RTC_CNTL_PWC_FASTMEM_FORCE_ISO_Msk = 0x2
	// Bit FASTMEM_FORCE_ISO.
	RTC_CNTL_PWC_FASTMEM_FORCE_ISO = 0x2
	// Position of SLOWMEM_FORCE_NOISO field.
	RTC_CNTL_PWC_SLOWMEM_FORCE_NOISO_Pos = 0x2
	// Bit mask of SLOWMEM_FORCE_NOISO field.
	RTC_CNTL_PWC_SLOWMEM_FORCE_NOISO_Msk = 0x4
	// Bit SLOWMEM_FORCE_NOISO.
	RTC_CNTL_PWC_SLOWMEM_FORCE_NOISO = 0x4
	// Position of SLOWMEM_FORCE_ISO field.
	RTC_CNTL_PWC_SLOWMEM_FORCE_ISO_Pos = 0x3
	// Bit mask of SLOWMEM_FORCE_ISO field.
	RTC_CNTL_PWC_SLOWMEM_FORCE_ISO_Msk = 0x8
	// Bit SLOWMEM_FORCE_ISO.
	RTC_CNTL_PWC_SLOWMEM_FORCE_ISO = 0x8
	// Position of FORCE_ISO field.
	RTC_CNTL_PWC_FORCE_ISO_Pos = 0x4
	// Bit mask of FORCE_ISO field.
	RTC_CNTL_PWC_FORCE_ISO_Msk = 0x10
	// Bit FORCE_ISO.
	RTC_CNTL_PWC_FORCE_ISO = 0x10
	// Position of FORCE_NOISO field.
	RTC_CNTL_PWC_FORCE_NOISO_Pos = 0x5
	// Bit mask of FORCE_NOISO field.
	RTC_CNTL_PWC_FORCE_NOISO_Msk = 0x20
	// Bit FORCE_NOISO.
	RTC_CNTL_PWC_FORCE_NOISO = 0x20
	// Position of FASTMEM_FOLW_CPU field.
	RTC_CNTL_PWC_FASTMEM_FOLW_CPU_Pos = 0x6
	// Bit mask of FASTMEM_FOLW_CPU field.
	RTC_CNTL_PWC_FASTMEM_FOLW_CPU_Msk = 0x40
	// Bit FASTMEM_FOLW_CPU.
	RTC_CNTL_PWC_FASTMEM_FOLW_CPU = 0x40
	// Position of FASTMEM_FORCE_LPD field.
	RTC_CNTL_PWC_FASTMEM_FORCE_LPD_Pos = 0x7
	// Bit mask of FASTMEM_FORCE_LPD field.
	RTC_CNTL_PWC_FASTMEM_FORCE_LPD_Msk = 0x80
	// Bit FASTMEM_FORCE_LPD.
	RTC_CNTL_PWC_FASTMEM_FORCE_LPD = 0x80
	// Position of FASTMEM_FORCE_LPU field.
	RTC_CNTL_PWC_FASTMEM_FORCE_LPU_Pos = 0x8
	// Bit mask of FASTMEM_FORCE_LPU field.
	RTC_CNTL_PWC_FASTMEM_FORCE_LPU_Msk = 0x100
	// Bit FASTMEM_FORCE_LPU.
	RTC_CNTL_PWC_FASTMEM_FORCE_LPU = 0x100
	// Position of SLOWMEM_FOLW_CPU field.
	RTC_CNTL_PWC_SLOWMEM_FOLW_CPU_Pos = 0x9
	// Bit mask of SLOWMEM_FOLW_CPU field.
	RTC_CNTL_PWC_SLOWMEM_FOLW_CPU_Msk = 0x200
	// Bit SLOWMEM_FOLW_CPU.
	RTC_CNTL_PWC_SLOWMEM_FOLW_CPU = 0x200
	// Position of SLOWMEM_FORCE_LPD field.
	RTC_CNTL_PWC_SLOWMEM_FORCE_LPD_Pos = 0xa
	// Bit mask of SLOWMEM_FORCE_LPD field.
	RTC_CNTL_PWC_SLOWMEM_FORCE_LPD_Msk = 0x400
	// Bit SLOWMEM_FORCE_LPD.
	RTC_CNTL_PWC_SLOWMEM_FORCE_LPD = 0x400
	// Position of SLOWMEM_FORCE_LPU field.
	RTC_CNTL_PWC_SLOWMEM_FORCE_LPU_Pos = 0xb
	// Bit mask of SLOWMEM_FORCE_LPU field.
	RTC_CNTL_PWC_SLOWMEM_FORCE_LPU_Msk = 0x800
	// Bit SLOWMEM_FORCE_LPU.
	RTC_CNTL_PWC_SLOWMEM_FORCE_LPU = 0x800
	// Position of FASTMEM_FORCE_PD field.
	RTC_CNTL_PWC_FASTMEM_FORCE_PD_Pos = 0xc
	// Bit mask of FASTMEM_FORCE_PD field.
	RTC_CNTL_PWC_FASTMEM_FORCE_PD_Msk = 0x1000
	// Bit FASTMEM_FORCE_PD.
	RTC_CNTL_PWC_FASTMEM_FORCE_PD = 0x1000
	// Position of FASTMEM_FORCE_PU field.
	RTC_CNTL_PWC_FASTMEM_FORCE_PU_Pos = 0xd
	// Bit mask of FASTMEM_FORCE_PU field.
	RTC_CNTL_PWC_FASTMEM_FORCE_PU_Msk = 0x2000
	// Bit FASTMEM_FORCE_PU.
	RTC_CNTL_PWC_FASTMEM_FORCE_PU = 0x2000
	// Position of FASTMEM_PD_EN field.
	RTC_CNTL_PWC_FASTMEM_PD_EN_Pos = 0xe
	// Bit mask of FASTMEM_PD_EN field.
	RTC_CNTL_PWC_FASTMEM_PD_EN_Msk = 0x4000
	// Bit FASTMEM_PD_EN.
	RTC_CNTL_PWC_FASTMEM_PD_EN = 0x4000
	// Position of SLOWMEM_FORCE_PD field.
	RTC_CNTL_PWC_SLOWMEM_FORCE_PD_Pos = 0xf
	// Bit mask of SLOWMEM_FORCE_PD field.
	RTC_CNTL_PWC_SLOWMEM_FORCE_PD_Msk = 0x8000
	// Bit SLOWMEM_FORCE_PD.
	RTC_CNTL_PWC_SLOWMEM_FORCE_PD = 0x8000
	// Position of SLOWMEM_FORCE_PU field.
	RTC_CNTL_PWC_SLOWMEM_FORCE_PU_Pos = 0x10
	// Bit mask of SLOWMEM_FORCE_PU field.
	RTC_CNTL_PWC_SLOWMEM_FORCE_PU_Msk = 0x10000
	// Bit SLOWMEM_FORCE_PU.
	RTC_CNTL_PWC_SLOWMEM_FORCE_PU = 0x10000
	// Position of SLOWMEM_PD_EN field.
	RTC_CNTL_PWC_SLOWMEM_PD_EN_Pos = 0x11
	// Bit mask of SLOWMEM_PD_EN field.
	RTC_CNTL_PWC_SLOWMEM_PD_EN_Msk = 0x20000
	// Bit SLOWMEM_PD_EN.
	RTC_CNTL_PWC_SLOWMEM_PD_EN = 0x20000
	// Position of FORCE_PD field.
	RTC_CNTL_PWC_FORCE_PD_Pos = 0x12
	// Bit mask of FORCE_PD field.
	RTC_CNTL_PWC_FORCE_PD_Msk = 0x40000
	// Bit FORCE_PD.
	RTC_CNTL_PWC_FORCE_PD = 0x40000
	// Position of FORCE_PU field.
	RTC_CNTL_PWC_FORCE_PU_Pos = 0x13
	// Bit mask of FORCE_PU field.
	RTC_CNTL_PWC_FORCE_PU_Msk = 0x80000
	// Bit FORCE_PU.
	RTC_CNTL_PWC_FORCE_PU = 0x80000
	// Position of PD_EN field.
	RTC_CNTL_PWC_PD_EN_Pos = 0x14
	// Bit mask of PD_EN field.
	RTC_CNTL_PWC_PD_EN_Msk = 0x100000
	// Bit PD_EN.
	RTC_CNTL_PWC_PD_EN = 0x100000
	// Position of PAD_FORCE_HOLD field.
	RTC_CNTL_PWC_PAD_FORCE_HOLD_Pos = 0x15
	// Bit mask of PAD_FORCE_HOLD field.
	RTC_CNTL_PWC_PAD_FORCE_HOLD_Msk = 0x200000
	// Bit PAD_FORCE_HOLD.
	RTC_CNTL_PWC_PAD_FORCE_HOLD = 0x200000

	// DIG_PWC: Digital system power configuraiton register
	// Position of LSLP_MEM_FORCE_PD field.
	RTC_CNTL_DIG_PWC_LSLP_MEM_FORCE_PD_Pos = 0x3
	// Bit mask of LSLP_MEM_FORCE_PD field.
	RTC_CNTL_DIG_PWC_LSLP_MEM_FORCE_PD_Msk = 0x8
	// Bit LSLP_MEM_FORCE_PD.
	RTC_CNTL_DIG_PWC_LSLP_MEM_FORCE_PD = 0x8
	// Position of LSLP_MEM_FORCE_PU field.
	RTC_CNTL_DIG_PWC_LSLP_MEM_FORCE_PU_Pos = 0x4
	// Bit mask of LSLP_MEM_FORCE_PU field.
	RTC_CNTL_DIG_PWC_LSLP_MEM_FORCE_PU_Msk = 0x10
	// Bit LSLP_MEM_FORCE_PU.
	RTC_CNTL_DIG_PWC_LSLP_MEM_FORCE_PU = 0x10
	// Position of ROM0_FORCE_PD field.
	RTC_CNTL_DIG_PWC_ROM0_FORCE_PD_Pos = 0x5
	// Bit mask of ROM0_FORCE_PD field.
	RTC_CNTL_DIG_PWC_ROM0_FORCE_PD_Msk = 0x20
	// Bit ROM0_FORCE_PD.
	RTC_CNTL_DIG_PWC_ROM0_FORCE_PD = 0x20
	// Position of ROM0_FORCE_PU field.
	RTC_CNTL_DIG_PWC_ROM0_FORCE_PU_Pos = 0x6
	// Bit mask of ROM0_FORCE_PU field.
	RTC_CNTL_DIG_PWC_ROM0_FORCE_PU_Msk = 0x40
	// Bit ROM0_FORCE_PU.
	RTC_CNTL_DIG_PWC_ROM0_FORCE_PU = 0x40
	// Position of INTER_RAM0_FORCE_PD field.
	RTC_CNTL_DIG_PWC_INTER_RAM0_FORCE_PD_Pos = 0x7
	// Bit mask of INTER_RAM0_FORCE_PD field.
	RTC_CNTL_DIG_PWC_INTER_RAM0_FORCE_PD_Msk = 0x80
	// Bit INTER_RAM0_FORCE_PD.
	RTC_CNTL_DIG_PWC_INTER_RAM0_FORCE_PD = 0x80
	// Position of INTER_RAM0_FORCE_PU field.
	RTC_CNTL_DIG_PWC_INTER_RAM0_FORCE_PU_Pos = 0x8
	// Bit mask of INTER_RAM0_FORCE_PU field.
	RTC_CNTL_DIG_PWC_INTER_RAM0_FORCE_PU_Msk = 0x100
	// Bit INTER_RAM0_FORCE_PU.
	RTC_CNTL_DIG_PWC_INTER_RAM0_FORCE_PU = 0x100
	// Position of INTER_RAM1_FORCE_PD field.
	RTC_CNTL_DIG_PWC_INTER_RAM1_FORCE_PD_Pos = 0x9
	// Bit mask of INTER_RAM1_FORCE_PD field.
	RTC_CNTL_DIG_PWC_INTER_RAM1_FORCE_PD_Msk = 0x200
	// Bit INTER_RAM1_FORCE_PD.
	RTC_CNTL_DIG_PWC_INTER_RAM1_FORCE_PD = 0x200
	// Position of INTER_RAM1_FORCE_PU field.
	RTC_CNTL_DIG_PWC_INTER_RAM1_FORCE_PU_Pos = 0xa
	// Bit mask of INTER_RAM1_FORCE_PU field.
	RTC_CNTL_DIG_PWC_INTER_RAM1_FORCE_PU_Msk = 0x400
	// Bit INTER_RAM1_FORCE_PU.
	RTC_CNTL_DIG_PWC_INTER_RAM1_FORCE_PU = 0x400
	// Position of INTER_RAM2_FORCE_PD field.
	RTC_CNTL_DIG_PWC_INTER_RAM2_FORCE_PD_Pos = 0xb
	// Bit mask of INTER_RAM2_FORCE_PD field.
	RTC_CNTL_DIG_PWC_INTER_RAM2_FORCE_PD_Msk = 0x800
	// Bit INTER_RAM2_FORCE_PD.
	RTC_CNTL_DIG_PWC_INTER_RAM2_FORCE_PD = 0x800
	// Position of INTER_RAM2_FORCE_PU field.
	RTC_CNTL_DIG_PWC_INTER_RAM2_FORCE_PU_Pos = 0xc
	// Bit mask of INTER_RAM2_FORCE_PU field.
	RTC_CNTL_DIG_PWC_INTER_RAM2_FORCE_PU_Msk = 0x1000
	// Bit INTER_RAM2_FORCE_PU.
	RTC_CNTL_DIG_PWC_INTER_RAM2_FORCE_PU = 0x1000
	// Position of INTER_RAM3_FORCE_PD field.
	RTC_CNTL_DIG_PWC_INTER_RAM3_FORCE_PD_Pos = 0xd
	// Bit mask of INTER_RAM3_FORCE_PD field.
	RTC_CNTL_DIG_PWC_INTER_RAM3_FORCE_PD_Msk = 0x2000
	// Bit INTER_RAM3_FORCE_PD.
	RTC_CNTL_DIG_PWC_INTER_RAM3_FORCE_PD = 0x2000
	// Position of INTER_RAM3_FORCE_PU field.
	RTC_CNTL_DIG_PWC_INTER_RAM3_FORCE_PU_Pos = 0xe
	// Bit mask of INTER_RAM3_FORCE_PU field.
	RTC_CNTL_DIG_PWC_INTER_RAM3_FORCE_PU_Msk = 0x4000
	// Bit INTER_RAM3_FORCE_PU.
	RTC_CNTL_DIG_PWC_INTER_RAM3_FORCE_PU = 0x4000
	// Position of INTER_RAM4_FORCE_PD field.
	RTC_CNTL_DIG_PWC_INTER_RAM4_FORCE_PD_Pos = 0xf
	// Bit mask of INTER_RAM4_FORCE_PD field.
	RTC_CNTL_DIG_PWC_INTER_RAM4_FORCE_PD_Msk = 0x8000
	// Bit INTER_RAM4_FORCE_PD.
	RTC_CNTL_DIG_PWC_INTER_RAM4_FORCE_PD = 0x8000
	// Position of INTER_RAM4_FORCE_PU field.
	RTC_CNTL_DIG_PWC_INTER_RAM4_FORCE_PU_Pos = 0x10
	// Bit mask of INTER_RAM4_FORCE_PU field.
	RTC_CNTL_DIG_PWC_INTER_RAM4_FORCE_PU_Msk = 0x10000
	// Bit INTER_RAM4_FORCE_PU.
	RTC_CNTL_DIG_PWC_INTER_RAM4_FORCE_PU = 0x10000
	// Position of WIFI_FORCE_PD field.
	RTC_CNTL_DIG_PWC_WIFI_FORCE_PD_Pos = 0x11
	// Bit mask of WIFI_FORCE_PD field.
	RTC_CNTL_DIG_PWC_WIFI_FORCE_PD_Msk = 0x20000
	// Bit WIFI_FORCE_PD.
	RTC_CNTL_DIG_PWC_WIFI_FORCE_PD = 0x20000
	// Position of WIFI_FORCE_PU field.
	RTC_CNTL_DIG_PWC_WIFI_FORCE_PU_Pos = 0x12
	// Bit mask of WIFI_FORCE_PU field.
	RTC_CNTL_DIG_PWC_WIFI_FORCE_PU_Msk = 0x40000
	// Bit WIFI_FORCE_PU.
	RTC_CNTL_DIG_PWC_WIFI_FORCE_PU = 0x40000
	// Position of DG_WRAP_FORCE_PD field.
	RTC_CNTL_DIG_PWC_DG_WRAP_FORCE_PD_Pos = 0x13
	// Bit mask of DG_WRAP_FORCE_PD field.
	RTC_CNTL_DIG_PWC_DG_WRAP_FORCE_PD_Msk = 0x80000
	// Bit DG_WRAP_FORCE_PD.
	RTC_CNTL_DIG_PWC_DG_WRAP_FORCE_PD = 0x80000
	// Position of DG_WRAP_FORCE_PU field.
	RTC_CNTL_DIG_PWC_DG_WRAP_FORCE_PU_Pos = 0x14
	// Bit mask of DG_WRAP_FORCE_PU field.
	RTC_CNTL_DIG_PWC_DG_WRAP_FORCE_PU_Msk = 0x100000
	// Bit DG_WRAP_FORCE_PU.
	RTC_CNTL_DIG_PWC_DG_WRAP_FORCE_PU = 0x100000
	// Position of DG_DCDC_FORCE_PD field.
	RTC_CNTL_DIG_PWC_DG_DCDC_FORCE_PD_Pos = 0x15
	// Bit mask of DG_DCDC_FORCE_PD field.
	RTC_CNTL_DIG_PWC_DG_DCDC_FORCE_PD_Msk = 0x200000
	// Bit DG_DCDC_FORCE_PD.
	RTC_CNTL_DIG_PWC_DG_DCDC_FORCE_PD = 0x200000
	// Position of DG_DCDC_FORCE_PU field.
	RTC_CNTL_DIG_PWC_DG_DCDC_FORCE_PU_Pos = 0x16
	// Bit mask of DG_DCDC_FORCE_PU field.
	RTC_CNTL_DIG_PWC_DG_DCDC_FORCE_PU_Msk = 0x400000
	// Bit DG_DCDC_FORCE_PU.
	RTC_CNTL_DIG_PWC_DG_DCDC_FORCE_PU = 0x400000
	// Position of DG_DCDC_PD_EN field.
	RTC_CNTL_DIG_PWC_DG_DCDC_PD_EN_Pos = 0x17
	// Bit mask of DG_DCDC_PD_EN field.
	RTC_CNTL_DIG_PWC_DG_DCDC_PD_EN_Msk = 0x800000
	// Bit DG_DCDC_PD_EN.
	RTC_CNTL_DIG_PWC_DG_DCDC_PD_EN = 0x800000
	// Position of ROM0_PD_EN field.
	RTC_CNTL_DIG_PWC_ROM0_PD_EN_Pos = 0x18
	// Bit mask of ROM0_PD_EN field.
	RTC_CNTL_DIG_PWC_ROM0_PD_EN_Msk = 0x1000000
	// Bit ROM0_PD_EN.
	RTC_CNTL_DIG_PWC_ROM0_PD_EN = 0x1000000
	// Position of INTER_RAM0_PD_EN field.
	RTC_CNTL_DIG_PWC_INTER_RAM0_PD_EN_Pos = 0x19
	// Bit mask of INTER_RAM0_PD_EN field.
	RTC_CNTL_DIG_PWC_INTER_RAM0_PD_EN_Msk = 0x2000000
	// Bit INTER_RAM0_PD_EN.
	RTC_CNTL_DIG_PWC_INTER_RAM0_PD_EN = 0x2000000
	// Position of INTER_RAM1_PD_EN field.
	RTC_CNTL_DIG_PWC_INTER_RAM1_PD_EN_Pos = 0x1a
	// Bit mask of INTER_RAM1_PD_EN field.
	RTC_CNTL_DIG_PWC_INTER_RAM1_PD_EN_Msk = 0x4000000
	// Bit INTER_RAM1_PD_EN.
	RTC_CNTL_DIG_PWC_INTER_RAM1_PD_EN = 0x4000000
	// Position of INTER_RAM2_PD_EN field.
	RTC_CNTL_DIG_PWC_INTER_RAM2_PD_EN_Pos = 0x1b
	// Bit mask of INTER_RAM2_PD_EN field.
	RTC_CNTL_DIG_PWC_INTER_RAM2_PD_EN_Msk = 0x8000000
	// Bit INTER_RAM2_PD_EN.
	RTC_CNTL_DIG_PWC_INTER_RAM2_PD_EN = 0x8000000
	// Position of INTER_RAM3_PD_EN field.
	RTC_CNTL_DIG_PWC_INTER_RAM3_PD_EN_Pos = 0x1c
	// Bit mask of INTER_RAM3_PD_EN field.
	RTC_CNTL_DIG_PWC_INTER_RAM3_PD_EN_Msk = 0x10000000
	// Bit INTER_RAM3_PD_EN.
	RTC_CNTL_DIG_PWC_INTER_RAM3_PD_EN = 0x10000000
	// Position of INTER_RAM4_PD_EN field.
	RTC_CNTL_DIG_PWC_INTER_RAM4_PD_EN_Pos = 0x1d
	// Bit mask of INTER_RAM4_PD_EN field.
	RTC_CNTL_DIG_PWC_INTER_RAM4_PD_EN_Msk = 0x20000000
	// Bit INTER_RAM4_PD_EN.
	RTC_CNTL_DIG_PWC_INTER_RAM4_PD_EN = 0x20000000
	// Position of WIFI_PD_EN field.
	RTC_CNTL_DIG_PWC_WIFI_PD_EN_Pos = 0x1e
	// Bit mask of WIFI_PD_EN field.
	RTC_CNTL_DIG_PWC_WIFI_PD_EN_Msk = 0x40000000
	// Bit WIFI_PD_EN.
	RTC_CNTL_DIG_PWC_WIFI_PD_EN = 0x40000000
	// Position of DG_WRAP_PD_EN field.
	RTC_CNTL_DIG_PWC_DG_WRAP_PD_EN_Pos = 0x1f
	// Bit mask of DG_WRAP_PD_EN field.
	RTC_CNTL_DIG_PWC_DG_WRAP_PD_EN_Msk = 0x80000000
	// Bit DG_WRAP_PD_EN.
	RTC_CNTL_DIG_PWC_DG_WRAP_PD_EN = 0x80000000

	// DIG_ISO: Digital system ISO configuration register
	// Position of FORCE_OFF field.
	RTC_CNTL_DIG_ISO_FORCE_OFF_Pos = 0x7
	// Bit mask of FORCE_OFF field.
	RTC_CNTL_DIG_ISO_FORCE_OFF_Msk = 0x80
	// Bit FORCE_OFF.
	RTC_CNTL_DIG_ISO_FORCE_OFF = 0x80
	// Position of FORCE_ON field.
	RTC_CNTL_DIG_ISO_FORCE_ON_Pos = 0x8
	// Bit mask of FORCE_ON field.
	RTC_CNTL_DIG_ISO_FORCE_ON_Msk = 0x100
	// Bit FORCE_ON.
	RTC_CNTL_DIG_ISO_FORCE_ON = 0x100
	// Position of DG_PAD_AUTOHOLD field.
	RTC_CNTL_DIG_ISO_DG_PAD_AUTOHOLD_Pos = 0x9
	// Bit mask of DG_PAD_AUTOHOLD field.
	RTC_CNTL_DIG_ISO_DG_PAD_AUTOHOLD_Msk = 0x200
	// Bit DG_PAD_AUTOHOLD.
	RTC_CNTL_DIG_ISO_DG_PAD_AUTOHOLD = 0x200
	// Position of CLR_DG_PAD_AUTOHOLD field.
	RTC_CNTL_DIG_ISO_CLR_DG_PAD_AUTOHOLD_Pos = 0xa
	// Bit mask of CLR_DG_PAD_AUTOHOLD field.
	RTC_CNTL_DIG_ISO_CLR_DG_PAD_AUTOHOLD_Msk = 0x400
	// Bit CLR_DG_PAD_AUTOHOLD.
	RTC_CNTL_DIG_ISO_CLR_DG_PAD_AUTOHOLD = 0x400
	// Position of DG_PAD_AUTOHOLD_EN field.
	RTC_CNTL_DIG_ISO_DG_PAD_AUTOHOLD_EN_Pos = 0xb
	// Bit mask of DG_PAD_AUTOHOLD_EN field.
	RTC_CNTL_DIG_ISO_DG_PAD_AUTOHOLD_EN_Msk = 0x800
	// Bit DG_PAD_AUTOHOLD_EN.
	RTC_CNTL_DIG_ISO_DG_PAD_AUTOHOLD_EN = 0x800
	// Position of DG_PAD_FORCE_NOISO field.
	RTC_CNTL_DIG_ISO_DG_PAD_FORCE_NOISO_Pos = 0xc
	// Bit mask of DG_PAD_FORCE_NOISO field.
	RTC_CNTL_DIG_ISO_DG_PAD_FORCE_NOISO_Msk = 0x1000
	// Bit DG_PAD_FORCE_NOISO.
	RTC_CNTL_DIG_ISO_DG_PAD_FORCE_NOISO = 0x1000
	// Position of DG_PAD_FORCE_ISO field.
	RTC_CNTL_DIG_ISO_DG_PAD_FORCE_ISO_Pos = 0xd
	// Bit mask of DG_PAD_FORCE_ISO field.
	RTC_CNTL_DIG_ISO_DG_PAD_FORCE_ISO_Msk = 0x2000
	// Bit DG_PAD_FORCE_ISO.
	RTC_CNTL_DIG_ISO_DG_PAD_FORCE_ISO = 0x2000
	// Position of DG_PAD_FORCE_UNHOLD field.
	RTC_CNTL_DIG_ISO_DG_PAD_FORCE_UNHOLD_Pos = 0xe
	// Bit mask of DG_PAD_FORCE_UNHOLD field.
	RTC_CNTL_DIG_ISO_DG_PAD_FORCE_UNHOLD_Msk = 0x4000
	// Bit DG_PAD_FORCE_UNHOLD.
	RTC_CNTL_DIG_ISO_DG_PAD_FORCE_UNHOLD = 0x4000
	// Position of DG_PAD_FORCE_HOLD field.
	RTC_CNTL_DIG_ISO_DG_PAD_FORCE_HOLD_Pos = 0xf
	// Bit mask of DG_PAD_FORCE_HOLD field.
	RTC_CNTL_DIG_ISO_DG_PAD_FORCE_HOLD_Msk = 0x8000
	// Bit DG_PAD_FORCE_HOLD.
	RTC_CNTL_DIG_ISO_DG_PAD_FORCE_HOLD = 0x8000
	// Position of ROM0_FORCE_ISO field.
	RTC_CNTL_DIG_ISO_ROM0_FORCE_ISO_Pos = 0x10
	// Bit mask of ROM0_FORCE_ISO field.
	RTC_CNTL_DIG_ISO_ROM0_FORCE_ISO_Msk = 0x10000
	// Bit ROM0_FORCE_ISO.
	RTC_CNTL_DIG_ISO_ROM0_FORCE_ISO = 0x10000
	// Position of ROM0_FORCE_NOISO field.
	RTC_CNTL_DIG_ISO_ROM0_FORCE_NOISO_Pos = 0x11
	// Bit mask of ROM0_FORCE_NOISO field.
	RTC_CNTL_DIG_ISO_ROM0_FORCE_NOISO_Msk = 0x20000
	// Bit ROM0_FORCE_NOISO.
	RTC_CNTL_DIG_ISO_ROM0_FORCE_NOISO = 0x20000
	// Position of INTER_RAM0_FORCE_ISO field.
	RTC_CNTL_DIG_ISO_INTER_RAM0_FORCE_ISO_Pos = 0x12
	// Bit mask of INTER_RAM0_FORCE_ISO field.
	RTC_CNTL_DIG_ISO_INTER_RAM0_FORCE_ISO_Msk = 0x40000
	// Bit INTER_RAM0_FORCE_ISO.
	RTC_CNTL_DIG_ISO_INTER_RAM0_FORCE_ISO = 0x40000
	// Position of INTER_RAM0_FORCE_NOISO field.
	RTC_CNTL_DIG_ISO_INTER_RAM0_FORCE_NOISO_Pos = 0x13
	// Bit mask of INTER_RAM0_FORCE_NOISO field.
	RTC_CNTL_DIG_ISO_INTER_RAM0_FORCE_NOISO_Msk = 0x80000
	// Bit INTER_RAM0_FORCE_NOISO.
	RTC_CNTL_DIG_ISO_INTER_RAM0_FORCE_NOISO = 0x80000
	// Position of INTER_RAM1_FORCE_ISO field.
	RTC_CNTL_DIG_ISO_INTER_RAM1_FORCE_ISO_Pos = 0x14
	// Bit mask of INTER_RAM1_FORCE_ISO field.
	RTC_CNTL_DIG_ISO_INTER_RAM1_FORCE_ISO_Msk = 0x100000
	// Bit INTER_RAM1_FORCE_ISO.
	RTC_CNTL_DIG_ISO_INTER_RAM1_FORCE_ISO = 0x100000
	// Position of INTER_RAM1_FORCE_NOISO field.
	RTC_CNTL_DIG_ISO_INTER_RAM1_FORCE_NOISO_Pos = 0x15
	// Bit mask of INTER_RAM1_FORCE_NOISO field.
	RTC_CNTL_DIG_ISO_INTER_RAM1_FORCE_NOISO_Msk = 0x200000
	// Bit INTER_RAM1_FORCE_NOISO.
	RTC_CNTL_DIG_ISO_INTER_RAM1_FORCE_NOISO = 0x200000
	// Position of INTER_RAM2_FORCE_ISO field.
	RTC_CNTL_DIG_ISO_INTER_RAM2_FORCE_ISO_Pos = 0x16
	// Bit mask of INTER_RAM2_FORCE_ISO field.
	RTC_CNTL_DIG_ISO_INTER_RAM2_FORCE_ISO_Msk = 0x400000
	// Bit INTER_RAM2_FORCE_ISO.
	RTC_CNTL_DIG_ISO_INTER_RAM2_FORCE_ISO = 0x400000
	// Position of INTER_RAM2_FORCE_NOISO field.
	RTC_CNTL_DIG_ISO_INTER_RAM2_FORCE_NOISO_Pos = 0x17
	// Bit mask of INTER_RAM2_FORCE_NOISO field.
	RTC_CNTL_DIG_ISO_INTER_RAM2_FORCE_NOISO_Msk = 0x800000
	// Bit INTER_RAM2_FORCE_NOISO.
	RTC_CNTL_DIG_ISO_INTER_RAM2_FORCE_NOISO = 0x800000
	// Position of INTER_RAM3_FORCE_ISO field.
	RTC_CNTL_DIG_ISO_INTER_RAM3_FORCE_ISO_Pos = 0x18
	// Bit mask of INTER_RAM3_FORCE_ISO field.
	RTC_CNTL_DIG_ISO_INTER_RAM3_FORCE_ISO_Msk = 0x1000000
	// Bit INTER_RAM3_FORCE_ISO.
	RTC_CNTL_DIG_ISO_INTER_RAM3_FORCE_ISO = 0x1000000
	// Position of INTER_RAM3_FORCE_NOISO field.
	RTC_CNTL_DIG_ISO_INTER_RAM3_FORCE_NOISO_Pos = 0x19
	// Bit mask of INTER_RAM3_FORCE_NOISO field.
	RTC_CNTL_DIG_ISO_INTER_RAM3_FORCE_NOISO_Msk = 0x2000000
	// Bit INTER_RAM3_FORCE_NOISO.
	RTC_CNTL_DIG_ISO_INTER_RAM3_FORCE_NOISO = 0x2000000
	// Position of INTER_RAM4_FORCE_ISO field.
	RTC_CNTL_DIG_ISO_INTER_RAM4_FORCE_ISO_Pos = 0x1a
	// Bit mask of INTER_RAM4_FORCE_ISO field.
	RTC_CNTL_DIG_ISO_INTER_RAM4_FORCE_ISO_Msk = 0x4000000
	// Bit INTER_RAM4_FORCE_ISO.
	RTC_CNTL_DIG_ISO_INTER_RAM4_FORCE_ISO = 0x4000000
	// Position of INTER_RAM4_FORCE_NOISO field.
	RTC_CNTL_DIG_ISO_INTER_RAM4_FORCE_NOISO_Pos = 0x1b
	// Bit mask of INTER_RAM4_FORCE_NOISO field.
	RTC_CNTL_DIG_ISO_INTER_RAM4_FORCE_NOISO_Msk = 0x8000000
	// Bit INTER_RAM4_FORCE_NOISO.
	RTC_CNTL_DIG_ISO_INTER_RAM4_FORCE_NOISO = 0x8000000
	// Position of WIFI_FORCE_ISO field.
	RTC_CNTL_DIG_ISO_WIFI_FORCE_ISO_Pos = 0x1c
	// Bit mask of WIFI_FORCE_ISO field.
	RTC_CNTL_DIG_ISO_WIFI_FORCE_ISO_Msk = 0x10000000
	// Bit WIFI_FORCE_ISO.
	RTC_CNTL_DIG_ISO_WIFI_FORCE_ISO = 0x10000000
	// Position of WIFI_FORCE_NOISO field.
	RTC_CNTL_DIG_ISO_WIFI_FORCE_NOISO_Pos = 0x1d
	// Bit mask of WIFI_FORCE_NOISO field.
	RTC_CNTL_DIG_ISO_WIFI_FORCE_NOISO_Msk = 0x20000000
	// Bit WIFI_FORCE_NOISO.
	RTC_CNTL_DIG_ISO_WIFI_FORCE_NOISO = 0x20000000
	// Position of DG_WRAP_FORCE_ISO field.
	RTC_CNTL_DIG_ISO_DG_WRAP_FORCE_ISO_Pos = 0x1e
	// Bit mask of DG_WRAP_FORCE_ISO field.
	RTC_CNTL_DIG_ISO_DG_WRAP_FORCE_ISO_Msk = 0x40000000
	// Bit DG_WRAP_FORCE_ISO.
	RTC_CNTL_DIG_ISO_DG_WRAP_FORCE_ISO = 0x40000000
	// Position of DG_WRAP_FORCE_NOISO field.
	RTC_CNTL_DIG_ISO_DG_WRAP_FORCE_NOISO_Pos = 0x1f
	// Bit mask of DG_WRAP_FORCE_NOISO field.
	RTC_CNTL_DIG_ISO_DG_WRAP_FORCE_NOISO_Msk = 0x80000000
	// Bit DG_WRAP_FORCE_NOISO.
	RTC_CNTL_DIG_ISO_DG_WRAP_FORCE_NOISO = 0x80000000

	// WDTCONFIG0: RTC watchdog configuration register
	// Position of WDT_CHIP_RESET_WIDTH field.
	RTC_CNTL_WDTCONFIG0_WDT_CHIP_RESET_WIDTH_Pos = 0x0
	// Bit mask of WDT_CHIP_RESET_WIDTH field.
	RTC_CNTL_WDTCONFIG0_WDT_CHIP_RESET_WIDTH_Msk = 0xff
	// Position of WDT_CHIP_RESET_EN field.
	RTC_CNTL_WDTCONFIG0_WDT_CHIP_RESET_EN_Pos = 0x8
	// Bit mask of WDT_CHIP_RESET_EN field.
	RTC_CNTL_WDTCONFIG0_WDT_CHIP_RESET_EN_Msk = 0x100
	// Bit WDT_CHIP_RESET_EN.
	RTC_CNTL_WDTCONFIG0_WDT_CHIP_RESET_EN = 0x100
	// Position of WDT_PAUSE_IN_SLP field.
	RTC_CNTL_WDTCONFIG0_WDT_PAUSE_IN_SLP_Pos = 0x9
	// Bit mask of WDT_PAUSE_IN_SLP field.
	RTC_CNTL_WDTCONFIG0_WDT_PAUSE_IN_SLP_Msk = 0x200
	// Bit WDT_PAUSE_IN_SLP.
	RTC_CNTL_WDTCONFIG0_WDT_PAUSE_IN_SLP = 0x200
	// Position of WDT_APPCPU_RESET_EN field.
	RTC_CNTL_WDTCONFIG0_WDT_APPCPU_RESET_EN_Pos = 0xa
	// Bit mask of WDT_APPCPU_RESET_EN field.
	RTC_CNTL_WDTCONFIG0_WDT_APPCPU_RESET_EN_Msk = 0x400
	// Bit WDT_APPCPU_RESET_EN.
	RTC_CNTL_WDTCONFIG0_WDT_APPCPU_RESET_EN = 0x400
	// Position of WDT_PROCPU_RESET_EN field.
	RTC_CNTL_WDTCONFIG0_WDT_PROCPU_RESET_EN_Pos = 0xb
	// Bit mask of WDT_PROCPU_RESET_EN field.
	RTC_CNTL_WDTCONFIG0_WDT_PROCPU_RESET_EN_Msk = 0x800
	// Bit WDT_PROCPU_RESET_EN.
	RTC_CNTL_WDTCONFIG0_WDT_PROCPU_RESET_EN = 0x800
	// Position of WDT_FLASHBOOT_MOD_EN field.
	RTC_CNTL_WDTCONFIG0_WDT_FLASHBOOT_MOD_EN_Pos = 0xc
	// Bit mask of WDT_FLASHBOOT_MOD_EN field.
	RTC_CNTL_WDTCONFIG0_WDT_FLASHBOOT_MOD_EN_Msk = 0x1000
	// Bit WDT_FLASHBOOT_MOD_EN.
	RTC_CNTL_WDTCONFIG0_WDT_FLASHBOOT_MOD_EN = 0x1000
	// Position of WDT_SYS_RESET_LENGTH field.
	RTC_CNTL_WDTCONFIG0_WDT_SYS_RESET_LENGTH_Pos = 0xd
	// Bit mask of WDT_SYS_RESET_LENGTH field.
	RTC_CNTL_WDTCONFIG0_WDT_SYS_RESET_LENGTH_Msk = 0xe000
	// Position of WDT_CPU_RESET_LENGTH field.
	RTC_CNTL_WDTCONFIG0_WDT_CPU_RESET_LENGTH_Pos = 0x10
	// Bit mask of WDT_CPU_RESET_LENGTH field.
	RTC_CNTL_WDTCONFIG0_WDT_CPU_RESET_LENGTH_Msk = 0x70000
	// Position of WDT_STG3 field.
	RTC_CNTL_WDTCONFIG0_WDT_STG3_Pos = 0x13
	// Bit mask of WDT_STG3 field.
	RTC_CNTL_WDTCONFIG0_WDT_STG3_Msk = 0x380000
	// Position of WDT_STG2 field.
	RTC_CNTL_WDTCONFIG0_WDT_STG2_Pos = 0x16
	// Bit mask of WDT_STG2 field.
	RTC_CNTL_WDTCONFIG0_WDT_STG2_Msk = 0x1c00000
	// Position of WDT_STG1 field.
	RTC_CNTL_WDTCONFIG0_WDT_STG1_Pos = 0x19
	// Bit mask of WDT_STG1 field.
	RTC_CNTL_WDTCONFIG0_WDT_STG1_Msk = 0xe000000
	// Position of WDT_STG0 field.
	RTC_CNTL_WDTCONFIG0_WDT_STG0_Pos = 0x1c
	// Bit mask of WDT_STG0 field.
	RTC_CNTL_WDTCONFIG0_WDT_STG0_Msk = 0x70000000
	// Position of WDT_EN field.
	RTC_CNTL_WDTCONFIG0_WDT_EN_Pos = 0x1f
	// Bit mask of WDT_EN field.
	RTC_CNTL_WDTCONFIG0_WDT_EN_Msk = 0x80000000
	// Bit WDT_EN.
	RTC_CNTL_WDTCONFIG0_WDT_EN = 0x80000000

	// WDTCONFIG1: Configures the hold time of RTC watchdog at level 1
	// Position of WDT_STG0_HOLD field.
	RTC_CNTL_WDTCONFIG1_WDT_STG0_HOLD_Pos = 0x0
	// Bit mask of WDT_STG0_HOLD field.
	RTC_CNTL_WDTCONFIG1_WDT_STG0_HOLD_Msk = 0xffffffff

	// WDTCONFIG2: Configures the hold time of RTC watchdog at level 2
	// Position of WDT_STG1_HOLD field.
	RTC_CNTL_WDTCONFIG2_WDT_STG1_HOLD_Pos = 0x0
	// Bit mask of WDT_STG1_HOLD field.
	RTC_CNTL_WDTCONFIG2_WDT_STG1_HOLD_Msk = 0xffffffff

	// WDTCONFIG3: Configures the hold time of RTC watchdog at level 3
	// Position of WDT_STG2_HOLD field.
	RTC_CNTL_WDTCONFIG3_WDT_STG2_HOLD_Pos = 0x0
	// Bit mask of WDT_STG2_HOLD field.
	RTC_CNTL_WDTCONFIG3_WDT_STG2_HOLD_Msk = 0xffffffff

	// WDTCONFIG4: Configures the hold time of RTC watchdog at level 4
	// Position of WDT_STG3_HOLD field.
	RTC_CNTL_WDTCONFIG4_WDT_STG3_HOLD_Pos = 0x0
	// Bit mask of WDT_STG3_HOLD field.
	RTC_CNTL_WDTCONFIG4_WDT_STG3_HOLD_Msk = 0xffffffff

	// WDTFEED: RTC watchdog SW feed configuration register
	// Position of WDT_FEED field.
	RTC_CNTL_WDTFEED_WDT_FEED_Pos = 0x1f
	// Bit mask of WDT_FEED field.
	RTC_CNTL_WDTFEED_WDT_FEED_Msk = 0x80000000
	// Bit WDT_FEED.
	RTC_CNTL_WDTFEED_WDT_FEED = 0x80000000

	// WDTWPROTECT: RTC watchdog write protection configuration register
	// Position of WDT_WKEY field.
	RTC_CNTL_WDTWPROTECT_WDT_WKEY_Pos = 0x0
	// Bit mask of WDT_WKEY field.
	RTC_CNTL_WDTWPROTECT_WDT_WKEY_Msk = 0xffffffff

	// SWD_CONF: Super watchdog configuration register
	// Position of SWD_RESET_FLAG field.
	RTC_CNTL_SWD_CONF_SWD_RESET_FLAG_Pos = 0x0
	// Bit mask of SWD_RESET_FLAG field.
	RTC_CNTL_SWD_CONF_SWD_RESET_FLAG_Msk = 0x1
	// Bit SWD_RESET_FLAG.
	RTC_CNTL_SWD_CONF_SWD_RESET_FLAG = 0x1
	// Position of SWD_FEED_INT field.
	RTC_CNTL_SWD_CONF_SWD_FEED_INT_Pos = 0x1
	// Bit mask of SWD_FEED_INT field.
	RTC_CNTL_SWD_CONF_SWD_FEED_INT_Msk = 0x2
	// Bit SWD_FEED_INT.
	RTC_CNTL_SWD_CONF_SWD_FEED_INT = 0x2
	// Position of SWD_SIGNAL_WIDTH field.
	RTC_CNTL_SWD_CONF_SWD_SIGNAL_WIDTH_Pos = 0x12
	// Bit mask of SWD_SIGNAL_WIDTH field.
	RTC_CNTL_SWD_CONF_SWD_SIGNAL_WIDTH_Msk = 0xffc0000
	// Position of SWD_RST_FLAG_CLR field.
	RTC_CNTL_SWD_CONF_SWD_RST_FLAG_CLR_Pos = 0x1c
	// Bit mask of SWD_RST_FLAG_CLR field.
	RTC_CNTL_SWD_CONF_SWD_RST_FLAG_CLR_Msk = 0x10000000
	// Bit SWD_RST_FLAG_CLR.
	RTC_CNTL_SWD_CONF_SWD_RST_FLAG_CLR = 0x10000000
	// Position of SWD_FEED field.
	RTC_CNTL_SWD_CONF_SWD_FEED_Pos = 0x1d
	// Bit mask of SWD_FEED field.
	RTC_CNTL_SWD_CONF_SWD_FEED_Msk = 0x20000000
	// Bit SWD_FEED.
	RTC_CNTL_SWD_CONF_SWD_FEED = 0x20000000
	// Position of SWD_DISABLE field.
	RTC_CNTL_SWD_CONF_SWD_DISABLE_Pos = 0x1e
	// Bit mask of SWD_DISABLE field.
	RTC_CNTL_SWD_CONF_SWD_DISABLE_Msk = 0x40000000
	// Bit SWD_DISABLE.
	RTC_CNTL_SWD_CONF_SWD_DISABLE = 0x40000000
	// Position of SWD_AUTO_FEED_EN field.
	RTC_CNTL_SWD_CONF_SWD_AUTO_FEED_EN_Pos = 0x1f
	// Bit mask of SWD_AUTO_FEED_EN field.
	RTC_CNTL_SWD_CONF_SWD_AUTO_FEED_EN_Msk = 0x80000000
	// Bit SWD_AUTO_FEED_EN.
	RTC_CNTL_SWD_CONF_SWD_AUTO_FEED_EN = 0x80000000

	// SWD_WPROTECT: Super watchdog write protection configuration register
	// Position of SWD_WKEY field.
	RTC_CNTL_SWD_WPROTECT_SWD_WKEY_Pos = 0x0
	// Bit mask of SWD_WKEY field.
	RTC_CNTL_SWD_WPROTECT_SWD_WKEY_Msk = 0xffffffff

	// SW_CPU_STALL: CPU stall configuration register
	// Position of SW_STALL_APPCPU_C1 field.
	RTC_CNTL_SW_CPU_STALL_SW_STALL_APPCPU_C1_Pos = 0x14
	// Bit mask of SW_STALL_APPCPU_C1 field.
	RTC_CNTL_SW_CPU_STALL_SW_STALL_APPCPU_C1_Msk = 0x3f00000
	// Position of SW_STALL_PROCPU_C1 field.
	RTC_CNTL_SW_CPU_STALL_SW_STALL_PROCPU_C1_Pos = 0x1a
	// Bit mask of SW_STALL_PROCPU_C1 field.
	RTC_CNTL_SW_CPU_STALL_SW_STALL_PROCPU_C1_Msk = 0xfc000000

	// STORE4: Reservation register 4
	// Position of SCRATCH4 field.
	RTC_CNTL_STORE4_SCRATCH4_Pos = 0x0
	// Bit mask of SCRATCH4 field.
	RTC_CNTL_STORE4_SCRATCH4_Msk = 0xffffffff

	// STORE5: Reservation register 5
	// Position of SCRATCH5 field.
	RTC_CNTL_STORE5_SCRATCH5_Pos = 0x0
	// Bit mask of SCRATCH5 field.
	RTC_CNTL_STORE5_SCRATCH5_Msk = 0xffffffff

	// STORE6: Reservation register 6
	// Position of SCRATCH6 field.
	RTC_CNTL_STORE6_SCRATCH6_Pos = 0x0
	// Bit mask of SCRATCH6 field.
	RTC_CNTL_STORE6_SCRATCH6_Msk = 0xffffffff

	// STORE7: Reservation register 7
	// Position of SCRATCH7 field.
	RTC_CNTL_STORE7_SCRATCH7_Pos = 0x0
	// Bit mask of SCRATCH7 field.
	RTC_CNTL_STORE7_SCRATCH7_Msk = 0xffffffff

	// LOW_POWER_ST: RTC main state machine status register
	// Position of XPD_ROM0 field.
	RTC_CNTL_LOW_POWER_ST_XPD_ROM0_Pos = 0x0
	// Bit mask of XPD_ROM0 field.
	RTC_CNTL_LOW_POWER_ST_XPD_ROM0_Msk = 0x1
	// Bit XPD_ROM0.
	RTC_CNTL_LOW_POWER_ST_XPD_ROM0 = 0x1
	// Position of XPD_DIG_DCDC field.
	RTC_CNTL_LOW_POWER_ST_XPD_DIG_DCDC_Pos = 0x2
	// Bit mask of XPD_DIG_DCDC field.
	RTC_CNTL_LOW_POWER_ST_XPD_DIG_DCDC_Msk = 0x4
	// Bit XPD_DIG_DCDC.
	RTC_CNTL_LOW_POWER_ST_XPD_DIG_DCDC = 0x4
	// Position of PERI_ISO field.
	RTC_CNTL_LOW_POWER_ST_PERI_ISO_Pos = 0x3
	// Bit mask of PERI_ISO field.
	RTC_CNTL_LOW_POWER_ST_PERI_ISO_Msk = 0x8
	// Bit PERI_ISO.
	RTC_CNTL_LOW_POWER_ST_PERI_ISO = 0x8
	// Position of XPD_RTC_PERI field.
	RTC_CNTL_LOW_POWER_ST_XPD_RTC_PERI_Pos = 0x4
	// Bit mask of XPD_RTC_PERI field.
	RTC_CNTL_LOW_POWER_ST_XPD_RTC_PERI_Msk = 0x10
	// Bit XPD_RTC_PERI.
	RTC_CNTL_LOW_POWER_ST_XPD_RTC_PERI = 0x10
	// Position of WIFI_ISO field.
	RTC_CNTL_LOW_POWER_ST_WIFI_ISO_Pos = 0x5
	// Bit mask of WIFI_ISO field.
	RTC_CNTL_LOW_POWER_ST_WIFI_ISO_Msk = 0x20
	// Bit WIFI_ISO.
	RTC_CNTL_LOW_POWER_ST_WIFI_ISO = 0x20
	// Position of XPD_WIFI field.
	RTC_CNTL_LOW_POWER_ST_XPD_WIFI_Pos = 0x6
	// Bit mask of XPD_WIFI field.
	RTC_CNTL_LOW_POWER_ST_XPD_WIFI_Msk = 0x40
	// Bit XPD_WIFI.
	RTC_CNTL_LOW_POWER_ST_XPD_WIFI = 0x40
	// Position of DIG_ISO field.
	RTC_CNTL_LOW_POWER_ST_DIG_ISO_Pos = 0x7
	// Bit mask of DIG_ISO field.
	RTC_CNTL_LOW_POWER_ST_DIG_ISO_Msk = 0x80
	// Bit DIG_ISO.
	RTC_CNTL_LOW_POWER_ST_DIG_ISO = 0x80
	// Position of XPD_DIG field.
	RTC_CNTL_LOW_POWER_ST_XPD_DIG_Pos = 0x8
	// Bit mask of XPD_DIG field.
	RTC_CNTL_LOW_POWER_ST_XPD_DIG_Msk = 0x100
	// Bit XPD_DIG.
	RTC_CNTL_LOW_POWER_ST_XPD_DIG = 0x100
	// Position of TOUCH_STATE_START field.
	RTC_CNTL_LOW_POWER_ST_TOUCH_STATE_START_Pos = 0x9
	// Bit mask of TOUCH_STATE_START field.
	RTC_CNTL_LOW_POWER_ST_TOUCH_STATE_START_Msk = 0x200
	// Bit TOUCH_STATE_START.
	RTC_CNTL_LOW_POWER_ST_TOUCH_STATE_START = 0x200
	// Position of TOUCH_STATE_SWITCH field.
	RTC_CNTL_LOW_POWER_ST_TOUCH_STATE_SWITCH_Pos = 0xa
	// Bit mask of TOUCH_STATE_SWITCH field.
	RTC_CNTL_LOW_POWER_ST_TOUCH_STATE_SWITCH_Msk = 0x400
	// Bit TOUCH_STATE_SWITCH.
	RTC_CNTL_LOW_POWER_ST_TOUCH_STATE_SWITCH = 0x400
	// Position of TOUCH_STATE_SLP field.
	RTC_CNTL_LOW_POWER_ST_TOUCH_STATE_SLP_Pos = 0xb
	// Bit mask of TOUCH_STATE_SLP field.
	RTC_CNTL_LOW_POWER_ST_TOUCH_STATE_SLP_Msk = 0x800
	// Bit TOUCH_STATE_SLP.
	RTC_CNTL_LOW_POWER_ST_TOUCH_STATE_SLP = 0x800
	// Position of TOUCH_STATE_DONE field.
	RTC_CNTL_LOW_POWER_ST_TOUCH_STATE_DONE_Pos = 0xc
	// Bit mask of TOUCH_STATE_DONE field.
	RTC_CNTL_LOW_POWER_ST_TOUCH_STATE_DONE_Msk = 0x1000
	// Bit TOUCH_STATE_DONE.
	RTC_CNTL_LOW_POWER_ST_TOUCH_STATE_DONE = 0x1000
	// Position of COCPU_STATE_START field.
	RTC_CNTL_LOW_POWER_ST_COCPU_STATE_START_Pos = 0xd
	// Bit mask of COCPU_STATE_START field.
	RTC_CNTL_LOW_POWER_ST_COCPU_STATE_START_Msk = 0x2000
	// Bit COCPU_STATE_START.
	RTC_CNTL_LOW_POWER_ST_COCPU_STATE_START = 0x2000
	// Position of COCPU_STATE_SWITCH field.
	RTC_CNTL_LOW_POWER_ST_COCPU_STATE_SWITCH_Pos = 0xe
	// Bit mask of COCPU_STATE_SWITCH field.
	RTC_CNTL_LOW_POWER_ST_COCPU_STATE_SWITCH_Msk = 0x4000
	// Bit COCPU_STATE_SWITCH.
	RTC_CNTL_LOW_POWER_ST_COCPU_STATE_SWITCH = 0x4000
	// Position of COCPU_STATE_SLP field.
	RTC_CNTL_LOW_POWER_ST_COCPU_STATE_SLP_Pos = 0xf
	// Bit mask of COCPU_STATE_SLP field.
	RTC_CNTL_LOW_POWER_ST_COCPU_STATE_SLP_Msk = 0x8000
	// Bit COCPU_STATE_SLP.
	RTC_CNTL_LOW_POWER_ST_COCPU_STATE_SLP = 0x8000
	// Position of COCPU_STATE_DONE field.
	RTC_CNTL_LOW_POWER_ST_COCPU_STATE_DONE_Pos = 0x10
	// Bit mask of COCPU_STATE_DONE field.
	RTC_CNTL_LOW_POWER_ST_COCPU_STATE_DONE_Msk = 0x10000
	// Bit COCPU_STATE_DONE.
	RTC_CNTL_LOW_POWER_ST_COCPU_STATE_DONE = 0x10000
	// Position of MAIN_STATE_XTAL_ISO field.
	RTC_CNTL_LOW_POWER_ST_MAIN_STATE_XTAL_ISO_Pos = 0x11
	// Bit mask of MAIN_STATE_XTAL_ISO field.
	RTC_CNTL_LOW_POWER_ST_MAIN_STATE_XTAL_ISO_Msk = 0x20000
	// Bit MAIN_STATE_XTAL_ISO.
	RTC_CNTL_LOW_POWER_ST_MAIN_STATE_XTAL_ISO = 0x20000
	// Position of MAIN_STATE_PLL_ON field.
	RTC_CNTL_LOW_POWER_ST_MAIN_STATE_PLL_ON_Pos = 0x12
	// Bit mask of MAIN_STATE_PLL_ON field.
	RTC_CNTL_LOW_POWER_ST_MAIN_STATE_PLL_ON_Msk = 0x40000
	// Bit MAIN_STATE_PLL_ON.
	RTC_CNTL_LOW_POWER_ST_MAIN_STATE_PLL_ON = 0x40000
	// Position of RDY_FOR_WAKEUP field.
	RTC_CNTL_LOW_POWER_ST_RDY_FOR_WAKEUP_Pos = 0x13
	// Bit mask of RDY_FOR_WAKEUP field.
	RTC_CNTL_LOW_POWER_ST_RDY_FOR_WAKEUP_Msk = 0x80000
	// Bit RDY_FOR_WAKEUP.
	RTC_CNTL_LOW_POWER_ST_RDY_FOR_WAKEUP = 0x80000
	// Position of MAIN_STATE_WAIT_END field.
	RTC_CNTL_LOW_POWER_ST_MAIN_STATE_WAIT_END_Pos = 0x14
	// Bit mask of MAIN_STATE_WAIT_END field.
	RTC_CNTL_LOW_POWER_ST_MAIN_STATE_WAIT_END_Msk = 0x100000
	// Bit MAIN_STATE_WAIT_END.
	RTC_CNTL_LOW_POWER_ST_MAIN_STATE_WAIT_END = 0x100000
	// Position of IN_WAKEUP_STATE field.
	RTC_CNTL_LOW_POWER_ST_IN_WAKEUP_STATE_Pos = 0x15
	// Bit mask of IN_WAKEUP_STATE field.
	RTC_CNTL_LOW_POWER_ST_IN_WAKEUP_STATE_Msk = 0x200000
	// Bit IN_WAKEUP_STATE.
	RTC_CNTL_LOW_POWER_ST_IN_WAKEUP_STATE = 0x200000
	// Position of IN_LOW_POWER_STATE field.
	RTC_CNTL_LOW_POWER_ST_IN_LOW_POWER_STATE_Pos = 0x16
	// Bit mask of IN_LOW_POWER_STATE field.
	RTC_CNTL_LOW_POWER_ST_IN_LOW_POWER_STATE_Msk = 0x400000
	// Bit IN_LOW_POWER_STATE.
	RTC_CNTL_LOW_POWER_ST_IN_LOW_POWER_STATE = 0x400000
	// Position of MAIN_STATE_IN_WAIT_8M field.
	RTC_CNTL_LOW_POWER_ST_MAIN_STATE_IN_WAIT_8M_Pos = 0x17
	// Bit mask of MAIN_STATE_IN_WAIT_8M field.
	RTC_CNTL_LOW_POWER_ST_MAIN_STATE_IN_WAIT_8M_Msk = 0x800000
	// Bit MAIN_STATE_IN_WAIT_8M.
	RTC_CNTL_LOW_POWER_ST_MAIN_STATE_IN_WAIT_8M = 0x800000
	// Position of MAIN_STATE_IN_WAIT_PLL field.
	RTC_CNTL_LOW_POWER_ST_MAIN_STATE_IN_WAIT_PLL_Pos = 0x18
	// Bit mask of MAIN_STATE_IN_WAIT_PLL field.
	RTC_CNTL_LOW_POWER_ST_MAIN_STATE_IN_WAIT_PLL_Msk = 0x1000000
	// Bit MAIN_STATE_IN_WAIT_PLL.
	RTC_CNTL_LOW_POWER_ST_MAIN_STATE_IN_WAIT_PLL = 0x1000000
	// Position of MAIN_STATE_IN_WAIT_XTL field.
	RTC_CNTL_LOW_POWER_ST_MAIN_STATE_IN_WAIT_XTL_Pos = 0x19
	// Bit mask of MAIN_STATE_IN_WAIT_XTL field.
	RTC_CNTL_LOW_POWER_ST_MAIN_STATE_IN_WAIT_XTL_Msk = 0x2000000
	// Bit MAIN_STATE_IN_WAIT_XTL.
	RTC_CNTL_LOW_POWER_ST_MAIN_STATE_IN_WAIT_XTL = 0x2000000
	// Position of MAIN_STATE_IN_SLP field.
	RTC_CNTL_LOW_POWER_ST_MAIN_STATE_IN_SLP_Pos = 0x1a
	// Bit mask of MAIN_STATE_IN_SLP field.
	RTC_CNTL_LOW_POWER_ST_MAIN_STATE_IN_SLP_Msk = 0x4000000
	// Bit MAIN_STATE_IN_SLP.
	RTC_CNTL_LOW_POWER_ST_MAIN_STATE_IN_SLP = 0x4000000
	// Position of MAIN_STATE_IN_IDLE field.
	RTC_CNTL_LOW_POWER_ST_MAIN_STATE_IN_IDLE_Pos = 0x1b
	// Bit mask of MAIN_STATE_IN_IDLE field.
	RTC_CNTL_LOW_POWER_ST_MAIN_STATE_IN_IDLE_Msk = 0x8000000
	// Bit MAIN_STATE_IN_IDLE.
	RTC_CNTL_LOW_POWER_ST_MAIN_STATE_IN_IDLE = 0x8000000
	// Position of MAIN_STATE field.
	RTC_CNTL_LOW_POWER_ST_MAIN_STATE_Pos = 0x1c
	// Bit mask of MAIN_STATE field.
	RTC_CNTL_LOW_POWER_ST_MAIN_STATE_Msk = 0xf0000000

	// DIAG0: debug register
	// Position of LOW_POWER_DIAG1 field.
	RTC_CNTL_DIAG0_LOW_POWER_DIAG1_Pos = 0x0
	// Bit mask of LOW_POWER_DIAG1 field.
	RTC_CNTL_DIAG0_LOW_POWER_DIAG1_Msk = 0xffffffff

	// PAD_HOLD: Configures the hold options for RTC GPIOs
	// Position of TOUCH_PAD0_HOLD field.
	RTC_CNTL_PAD_HOLD_TOUCH_PAD0_HOLD_Pos = 0x0
	// Bit mask of TOUCH_PAD0_HOLD field.
	RTC_CNTL_PAD_HOLD_TOUCH_PAD0_HOLD_Msk = 0x1
	// Bit TOUCH_PAD0_HOLD.
	RTC_CNTL_PAD_HOLD_TOUCH_PAD0_HOLD = 0x1
	// Position of TOUCH_PAD1_HOLD field.
	RTC_CNTL_PAD_HOLD_TOUCH_PAD1_HOLD_Pos = 0x1
	// Bit mask of TOUCH_PAD1_HOLD field.
	RTC_CNTL_PAD_HOLD_TOUCH_PAD1_HOLD_Msk = 0x2
	// Bit TOUCH_PAD1_HOLD.
	RTC_CNTL_PAD_HOLD_TOUCH_PAD1_HOLD = 0x2
	// Position of TOUCH_PAD2_HOLD field.
	RTC_CNTL_PAD_HOLD_TOUCH_PAD2_HOLD_Pos = 0x2
	// Bit mask of TOUCH_PAD2_HOLD field.
	RTC_CNTL_PAD_HOLD_TOUCH_PAD2_HOLD_Msk = 0x4
	// Bit TOUCH_PAD2_HOLD.
	RTC_CNTL_PAD_HOLD_TOUCH_PAD2_HOLD = 0x4
	// Position of TOUCH_PAD3_HOLD field.
	RTC_CNTL_PAD_HOLD_TOUCH_PAD3_HOLD_Pos = 0x3
	// Bit mask of TOUCH_PAD3_HOLD field.
	RTC_CNTL_PAD_HOLD_TOUCH_PAD3_HOLD_Msk = 0x8
	// Bit TOUCH_PAD3_HOLD.
	RTC_CNTL_PAD_HOLD_TOUCH_PAD3_HOLD = 0x8
	// Position of TOUCH_PAD4_HOLD field.
	RTC_CNTL_PAD_HOLD_TOUCH_PAD4_HOLD_Pos = 0x4
	// Bit mask of TOUCH_PAD4_HOLD field.
	RTC_CNTL_PAD_HOLD_TOUCH_PAD4_HOLD_Msk = 0x10
	// Bit TOUCH_PAD4_HOLD.
	RTC_CNTL_PAD_HOLD_TOUCH_PAD4_HOLD = 0x10
	// Position of TOUCH_PAD5_HOLD field.
	RTC_CNTL_PAD_HOLD_TOUCH_PAD5_HOLD_Pos = 0x5
	// Bit mask of TOUCH_PAD5_HOLD field.
	RTC_CNTL_PAD_HOLD_TOUCH_PAD5_HOLD_Msk = 0x20
	// Bit TOUCH_PAD5_HOLD.
	RTC_CNTL_PAD_HOLD_TOUCH_PAD5_HOLD = 0x20
	// Position of TOUCH_PAD6_HOLD field.
	RTC_CNTL_PAD_HOLD_TOUCH_PAD6_HOLD_Pos = 0x6
	// Bit mask of TOUCH_PAD6_HOLD field.
	RTC_CNTL_PAD_HOLD_TOUCH_PAD6_HOLD_Msk = 0x40
	// Bit TOUCH_PAD6_HOLD.
	RTC_CNTL_PAD_HOLD_TOUCH_PAD6_HOLD = 0x40
	// Position of TOUCH_PAD7_HOLD field.
	RTC_CNTL_PAD_HOLD_TOUCH_PAD7_HOLD_Pos = 0x7
	// Bit mask of TOUCH_PAD7_HOLD field.
	RTC_CNTL_PAD_HOLD_TOUCH_PAD7_HOLD_Msk = 0x80
	// Bit TOUCH_PAD7_HOLD.
	RTC_CNTL_PAD_HOLD_TOUCH_PAD7_HOLD = 0x80
	// Position of TOUCH_PAD8_HOLD field.
	RTC_CNTL_PAD_HOLD_TOUCH_PAD8_HOLD_Pos = 0x8
	// Bit mask of TOUCH_PAD8_HOLD field.
	RTC_CNTL_PAD_HOLD_TOUCH_PAD8_HOLD_Msk = 0x100
	// Bit TOUCH_PAD8_HOLD.
	RTC_CNTL_PAD_HOLD_TOUCH_PAD8_HOLD = 0x100
	// Position of TOUCH_PAD9_HOLD field.
	RTC_CNTL_PAD_HOLD_TOUCH_PAD9_HOLD_Pos = 0x9
	// Bit mask of TOUCH_PAD9_HOLD field.
	RTC_CNTL_PAD_HOLD_TOUCH_PAD9_HOLD_Msk = 0x200
	// Bit TOUCH_PAD9_HOLD.
	RTC_CNTL_PAD_HOLD_TOUCH_PAD9_HOLD = 0x200
	// Position of TOUCH_PAD10_HOLD field.
	RTC_CNTL_PAD_HOLD_TOUCH_PAD10_HOLD_Pos = 0xa
	// Bit mask of TOUCH_PAD10_HOLD field.
	RTC_CNTL_PAD_HOLD_TOUCH_PAD10_HOLD_Msk = 0x400
	// Bit TOUCH_PAD10_HOLD.
	RTC_CNTL_PAD_HOLD_TOUCH_PAD10_HOLD = 0x400
	// Position of TOUCH_PAD11_HOLD field.
	RTC_CNTL_PAD_HOLD_TOUCH_PAD11_HOLD_Pos = 0xb
	// Bit mask of TOUCH_PAD11_HOLD field.
	RTC_CNTL_PAD_HOLD_TOUCH_PAD11_HOLD_Msk = 0x800
	// Bit TOUCH_PAD11_HOLD.
	RTC_CNTL_PAD_HOLD_TOUCH_PAD11_HOLD = 0x800
	// Position of TOUCH_PAD12_HOLD field.
	RTC_CNTL_PAD_HOLD_TOUCH_PAD12_HOLD_Pos = 0xc
	// Bit mask of TOUCH_PAD12_HOLD field.
	RTC_CNTL_PAD_HOLD_TOUCH_PAD12_HOLD_Msk = 0x1000
	// Bit TOUCH_PAD12_HOLD.
	RTC_CNTL_PAD_HOLD_TOUCH_PAD12_HOLD = 0x1000
	// Position of TOUCH_PAD13_HOLD field.
	RTC_CNTL_PAD_HOLD_TOUCH_PAD13_HOLD_Pos = 0xd
	// Bit mask of TOUCH_PAD13_HOLD field.
	RTC_CNTL_PAD_HOLD_TOUCH_PAD13_HOLD_Msk = 0x2000
	// Bit TOUCH_PAD13_HOLD.
	RTC_CNTL_PAD_HOLD_TOUCH_PAD13_HOLD = 0x2000
	// Position of TOUCH_PAD14_HOLD field.
	RTC_CNTL_PAD_HOLD_TOUCH_PAD14_HOLD_Pos = 0xe
	// Bit mask of TOUCH_PAD14_HOLD field.
	RTC_CNTL_PAD_HOLD_TOUCH_PAD14_HOLD_Msk = 0x4000
	// Bit TOUCH_PAD14_HOLD.
	RTC_CNTL_PAD_HOLD_TOUCH_PAD14_HOLD = 0x4000
	// Position of X32P_HOLD field.
	RTC_CNTL_PAD_HOLD_X32P_HOLD_Pos = 0xf
	// Bit mask of X32P_HOLD field.
	RTC_CNTL_PAD_HOLD_X32P_HOLD_Msk = 0x8000
	// Bit X32P_HOLD.
	RTC_CNTL_PAD_HOLD_X32P_HOLD = 0x8000
	// Position of X32N_HOLD field.
	RTC_CNTL_PAD_HOLD_X32N_HOLD_Pos = 0x10
	// Bit mask of X32N_HOLD field.
	RTC_CNTL_PAD_HOLD_X32N_HOLD_Msk = 0x10000
	// Bit X32N_HOLD.
	RTC_CNTL_PAD_HOLD_X32N_HOLD = 0x10000
	// Position of PDAC1_HOLD field.
	RTC_CNTL_PAD_HOLD_PDAC1_HOLD_Pos = 0x11
	// Bit mask of PDAC1_HOLD field.
	RTC_CNTL_PAD_HOLD_PDAC1_HOLD_Msk = 0x20000
	// Bit PDAC1_HOLD.
	RTC_CNTL_PAD_HOLD_PDAC1_HOLD = 0x20000
	// Position of PDAC2_HOLD field.
	RTC_CNTL_PAD_HOLD_PDAC2_HOLD_Pos = 0x12
	// Bit mask of PDAC2_HOLD field.
	RTC_CNTL_PAD_HOLD_PDAC2_HOLD_Msk = 0x40000
	// Bit PDAC2_HOLD.
	RTC_CNTL_PAD_HOLD_PDAC2_HOLD = 0x40000
	// Position of PAD19_HOLD field.
	RTC_CNTL_PAD_HOLD_PAD19_HOLD_Pos = 0x13
	// Bit mask of PAD19_HOLD field.
	RTC_CNTL_PAD_HOLD_PAD19_HOLD_Msk = 0x80000
	// Bit PAD19_HOLD.
	RTC_CNTL_PAD_HOLD_PAD19_HOLD = 0x80000
	// Position of PAD20_HOLD field.
	RTC_CNTL_PAD_HOLD_PAD20_HOLD_Pos = 0x14
	// Bit mask of PAD20_HOLD field.
	RTC_CNTL_PAD_HOLD_PAD20_HOLD_Msk = 0x100000
	// Bit PAD20_HOLD.
	RTC_CNTL_PAD_HOLD_PAD20_HOLD = 0x100000
	// Position of PAD21_HOLD field.
	RTC_CNTL_PAD_HOLD_PAD21_HOLD_Pos = 0x15
	// Bit mask of PAD21_HOLD field.
	RTC_CNTL_PAD_HOLD_PAD21_HOLD_Msk = 0x200000
	// Bit PAD21_HOLD.
	RTC_CNTL_PAD_HOLD_PAD21_HOLD = 0x200000

	// DIG_PAD_HOLD: Configures the hold option for digital GPIOs
	// Position of DIG_PAD_HOLD field.
	RTC_CNTL_DIG_PAD_HOLD_DIG_PAD_HOLD_Pos = 0x0
	// Bit mask of DIG_PAD_HOLD field.
	RTC_CNTL_DIG_PAD_HOLD_DIG_PAD_HOLD_Msk = 0xffffffff

	// EXT_WAKEUP1: EXT1 wakeup configuration register
	// Position of SEL field.
	RTC_CNTL_EXT_WAKEUP1_SEL_Pos = 0x0
	// Bit mask of SEL field.
	RTC_CNTL_EXT_WAKEUP1_SEL_Msk = 0x3fffff
	// Position of STATUS_CLR field.
	RTC_CNTL_EXT_WAKEUP1_STATUS_CLR_Pos = 0x16
	// Bit mask of STATUS_CLR field.
	RTC_CNTL_EXT_WAKEUP1_STATUS_CLR_Msk = 0x400000
	// Bit STATUS_CLR.
	RTC_CNTL_EXT_WAKEUP1_STATUS_CLR = 0x400000

	// EXT_WAKEUP1_STATUS: EXT1 wakeup source register
	// Position of EXT_WAKEUP1_STATUS field.
	RTC_CNTL_EXT_WAKEUP1_STATUS_EXT_WAKEUP1_STATUS_Pos = 0x0
	// Bit mask of EXT_WAKEUP1_STATUS field.
	RTC_CNTL_EXT_WAKEUP1_STATUS_EXT_WAKEUP1_STATUS_Msk = 0x3fffff

	// BROWN_OUT: Brownout configuration register
	// Position of BROWN_OUT2_ENA field.
	RTC_CNTL_BROWN_OUT_BROWN_OUT2_ENA_Pos = 0x0
	// Bit mask of BROWN_OUT2_ENA field.
	RTC_CNTL_BROWN_OUT_BROWN_OUT2_ENA_Msk = 0x1
	// Bit BROWN_OUT2_ENA.
	RTC_CNTL_BROWN_OUT_BROWN_OUT2_ENA = 0x1
	// Position of INT_WAIT field.
	RTC_CNTL_BROWN_OUT_INT_WAIT_Pos = 0x4
	// Bit mask of INT_WAIT field.
	RTC_CNTL_BROWN_OUT_INT_WAIT_Msk = 0x3ff0
	// Position of CLOSE_FLASH_ENA field.
	RTC_CNTL_BROWN_OUT_CLOSE_FLASH_ENA_Pos = 0xe
	// Bit mask of CLOSE_FLASH_ENA field.
	RTC_CNTL_BROWN_OUT_CLOSE_FLASH_ENA_Msk = 0x4000
	// Bit CLOSE_FLASH_ENA.
	RTC_CNTL_BROWN_OUT_CLOSE_FLASH_ENA = 0x4000
	// Position of PD_RF_ENA field.
	RTC_CNTL_BROWN_OUT_PD_RF_ENA_Pos = 0xf
	// Bit mask of PD_RF_ENA field.
	RTC_CNTL_BROWN_OUT_PD_RF_ENA_Msk = 0x8000
	// Bit PD_RF_ENA.
	RTC_CNTL_BROWN_OUT_PD_RF_ENA = 0x8000
	// Position of RST_WAIT field.
	RTC_CNTL_BROWN_OUT_RST_WAIT_Pos = 0x10
	// Bit mask of RST_WAIT field.
	RTC_CNTL_BROWN_OUT_RST_WAIT_Msk = 0x3ff0000
	// Position of RST_ENA field.
	RTC_CNTL_BROWN_OUT_RST_ENA_Pos = 0x1a
	// Bit mask of RST_ENA field.
	RTC_CNTL_BROWN_OUT_RST_ENA_Msk = 0x4000000
	// Bit RST_ENA.
	RTC_CNTL_BROWN_OUT_RST_ENA = 0x4000000
	// Position of RST_SEL field.
	RTC_CNTL_BROWN_OUT_RST_SEL_Pos = 0x1b
	// Bit mask of RST_SEL field.
	RTC_CNTL_BROWN_OUT_RST_SEL_Msk = 0x8000000
	// Bit RST_SEL.
	RTC_CNTL_BROWN_OUT_RST_SEL = 0x8000000
	// Position of CNT_CLR field.
	RTC_CNTL_BROWN_OUT_CNT_CLR_Pos = 0x1d
	// Bit mask of CNT_CLR field.
	RTC_CNTL_BROWN_OUT_CNT_CLR_Msk = 0x20000000
	// Bit CNT_CLR.
	RTC_CNTL_BROWN_OUT_CNT_CLR = 0x20000000
	// Position of ENA field.
	RTC_CNTL_BROWN_OUT_ENA_Pos = 0x1e
	// Bit mask of ENA field.
	RTC_CNTL_BROWN_OUT_ENA_Msk = 0x40000000
	// Bit ENA.
	RTC_CNTL_BROWN_OUT_ENA = 0x40000000
	// Position of DET field.
	RTC_CNTL_BROWN_OUT_DET_Pos = 0x1f
	// Bit mask of DET field.
	RTC_CNTL_BROWN_OUT_DET_Msk = 0x80000000
	// Bit DET.
	RTC_CNTL_BROWN_OUT_DET = 0x80000000

	// TIME_LOW1: Stores the lower 32 bits of RTC timer 1
	// Position of TIMER_VALUE1_LOW field.
	RTC_CNTL_TIME_LOW1_TIMER_VALUE1_LOW_Pos = 0x0
	// Bit mask of TIMER_VALUE1_LOW field.
	RTC_CNTL_TIME_LOW1_TIMER_VALUE1_LOW_Msk = 0xffffffff

	// TIME_HIGH1: Stores the higher 16 bits of RTC timer 1
	// Position of TIMER_VALUE1_HIGH field.
	RTC_CNTL_TIME_HIGH1_TIMER_VALUE1_HIGH_Pos = 0x0
	// Bit mask of TIMER_VALUE1_HIGH field.
	RTC_CNTL_TIME_HIGH1_TIMER_VALUE1_HIGH_Msk = 0xffff

	// XTAL32K_CLK_FACTOR: Configures the divider factor for the backup clock of 32 kHz crystal oscillator
	// Position of XTAL32K_CLK_FACTOR field.
	RTC_CNTL_XTAL32K_CLK_FACTOR_XTAL32K_CLK_FACTOR_Pos = 0x0
	// Bit mask of XTAL32K_CLK_FACTOR field.
	RTC_CNTL_XTAL32K_CLK_FACTOR_XTAL32K_CLK_FACTOR_Msk = 0xffffffff

	// XTAL32K_CONF: 32 kHz crystal oscillator configuration register
	// Position of XTAL32K_RETURN_WAIT field.
	RTC_CNTL_XTAL32K_CONF_XTAL32K_RETURN_WAIT_Pos = 0x0
	// Bit mask of XTAL32K_RETURN_WAIT field.
	RTC_CNTL_XTAL32K_CONF_XTAL32K_RETURN_WAIT_Msk = 0xf
	// Position of XTAL32K_RESTART_WAIT field.
	RTC_CNTL_XTAL32K_CONF_XTAL32K_RESTART_WAIT_Pos = 0x4
	// Bit mask of XTAL32K_RESTART_WAIT field.
	RTC_CNTL_XTAL32K_CONF_XTAL32K_RESTART_WAIT_Msk = 0xffff0
	// Position of XTAL32K_WDT_TIMEOUT field.
	RTC_CNTL_XTAL32K_CONF_XTAL32K_WDT_TIMEOUT_Pos = 0x14
	// Bit mask of XTAL32K_WDT_TIMEOUT field.
	RTC_CNTL_XTAL32K_CONF_XTAL32K_WDT_TIMEOUT_Msk = 0xff00000
	// Position of XTAL32K_STABLE_THRES field.
	RTC_CNTL_XTAL32K_CONF_XTAL32K_STABLE_THRES_Pos = 0x1c
	// Bit mask of XTAL32K_STABLE_THRES field.
	RTC_CNTL_XTAL32K_CONF_XTAL32K_STABLE_THRES_Msk = 0xf0000000

	// ULP_CP_TIMER: Configure coprocessor timer
	// Position of ULP_CP_PC_INIT field.
	RTC_CNTL_ULP_CP_TIMER_ULP_CP_PC_INIT_Pos = 0x0
	// Bit mask of ULP_CP_PC_INIT field.
	RTC_CNTL_ULP_CP_TIMER_ULP_CP_PC_INIT_Msk = 0x7ff
	// Position of ULP_CP_GPIO_WAKEUP_ENA field.
	RTC_CNTL_ULP_CP_TIMER_ULP_CP_GPIO_WAKEUP_ENA_Pos = 0x1d
	// Bit mask of ULP_CP_GPIO_WAKEUP_ENA field.
	RTC_CNTL_ULP_CP_TIMER_ULP_CP_GPIO_WAKEUP_ENA_Msk = 0x20000000
	// Bit ULP_CP_GPIO_WAKEUP_ENA.
	RTC_CNTL_ULP_CP_TIMER_ULP_CP_GPIO_WAKEUP_ENA = 0x20000000
	// Position of ULP_CP_GPIO_WAKEUP_CLR field.
	RTC_CNTL_ULP_CP_TIMER_ULP_CP_GPIO_WAKEUP_CLR_Pos = 0x1e
	// Bit mask of ULP_CP_GPIO_WAKEUP_CLR field.
	RTC_CNTL_ULP_CP_TIMER_ULP_CP_GPIO_WAKEUP_CLR_Msk = 0x40000000
	// Bit ULP_CP_GPIO_WAKEUP_CLR.
	RTC_CNTL_ULP_CP_TIMER_ULP_CP_GPIO_WAKEUP_CLR = 0x40000000
	// Position of ULP_CP_SLP_TIMER_EN field.
	RTC_CNTL_ULP_CP_TIMER_ULP_CP_SLP_TIMER_EN_Pos = 0x1f
	// Bit mask of ULP_CP_SLP_TIMER_EN field.
	RTC_CNTL_ULP_CP_TIMER_ULP_CP_SLP_TIMER_EN_Msk = 0x80000000
	// Bit ULP_CP_SLP_TIMER_EN.
	RTC_CNTL_ULP_CP_TIMER_ULP_CP_SLP_TIMER_EN = 0x80000000

	// ULP_CP_CTRL: ULP-FSM configuration register
	// Position of ULP_CP_MEM_ADDR_INIT field.
	RTC_CNTL_ULP_CP_CTRL_ULP_CP_MEM_ADDR_INIT_Pos = 0x0
	// Bit mask of ULP_CP_MEM_ADDR_INIT field.
	RTC_CNTL_ULP_CP_CTRL_ULP_CP_MEM_ADDR_INIT_Msk = 0x7ff
	// Position of ULP_CP_MEM_ADDR_SIZE field.
	RTC_CNTL_ULP_CP_CTRL_ULP_CP_MEM_ADDR_SIZE_Pos = 0xb
	// Bit mask of ULP_CP_MEM_ADDR_SIZE field.
	RTC_CNTL_ULP_CP_CTRL_ULP_CP_MEM_ADDR_SIZE_Msk = 0x3ff800
	// Position of ULP_CP_MEM_OFFSET_CLR field.
	RTC_CNTL_ULP_CP_CTRL_ULP_CP_MEM_OFFSET_CLR_Pos = 0x16
	// Bit mask of ULP_CP_MEM_OFFSET_CLR field.
	RTC_CNTL_ULP_CP_CTRL_ULP_CP_MEM_OFFSET_CLR_Msk = 0x400000
	// Bit ULP_CP_MEM_OFFSET_CLR.
	RTC_CNTL_ULP_CP_CTRL_ULP_CP_MEM_OFFSET_CLR = 0x400000
	// Position of ULP_CP_CLK_FO field.
	RTC_CNTL_ULP_CP_CTRL_ULP_CP_CLK_FO_Pos = 0x1c
	// Bit mask of ULP_CP_CLK_FO field.
	RTC_CNTL_ULP_CP_CTRL_ULP_CP_CLK_FO_Msk = 0x10000000
	// Bit ULP_CP_CLK_FO.
	RTC_CNTL_ULP_CP_CTRL_ULP_CP_CLK_FO = 0x10000000
	// Position of ULP_CP_RESET field.
	RTC_CNTL_ULP_CP_CTRL_ULP_CP_RESET_Pos = 0x1d
	// Bit mask of ULP_CP_RESET field.
	RTC_CNTL_ULP_CP_CTRL_ULP_CP_RESET_Msk = 0x20000000
	// Bit ULP_CP_RESET.
	RTC_CNTL_ULP_CP_CTRL_ULP_CP_RESET = 0x20000000
	// Position of ULP_CP_FORCE_START_TOP field.
	RTC_CNTL_ULP_CP_CTRL_ULP_CP_FORCE_START_TOP_Pos = 0x1e
	// Bit mask of ULP_CP_FORCE_START_TOP field.
	RTC_CNTL_ULP_CP_CTRL_ULP_CP_FORCE_START_TOP_Msk = 0x40000000
	// Bit ULP_CP_FORCE_START_TOP.
	RTC_CNTL_ULP_CP_CTRL_ULP_CP_FORCE_START_TOP = 0x40000000
	// Position of ULP_CP_START_TOP field.
	RTC_CNTL_ULP_CP_CTRL_ULP_CP_START_TOP_Pos = 0x1f
	// Bit mask of ULP_CP_START_TOP field.
	RTC_CNTL_ULP_CP_CTRL_ULP_CP_START_TOP_Msk = 0x80000000
	// Bit ULP_CP_START_TOP.
	RTC_CNTL_ULP_CP_CTRL_ULP_CP_START_TOP = 0x80000000

	// COCPU_CTRL: ULP-RISCV configuration register
	// Position of COCPU_CLK_FO field.
	RTC_CNTL_COCPU_CTRL_COCPU_CLK_FO_Pos = 0x0
	// Bit mask of COCPU_CLK_FO field.
	RTC_CNTL_COCPU_CTRL_COCPU_CLK_FO_Msk = 0x1
	// Bit COCPU_CLK_FO.
	RTC_CNTL_COCPU_CTRL_COCPU_CLK_FO = 0x1
	// Position of COCPU_START_2_RESET_DIS field.
	RTC_CNTL_COCPU_CTRL_COCPU_START_2_RESET_DIS_Pos = 0x1
	// Bit mask of COCPU_START_2_RESET_DIS field.
	RTC_CNTL_COCPU_CTRL_COCPU_START_2_RESET_DIS_Msk = 0x7e
	// Position of COCPU_START_2_INTR_EN field.
	RTC_CNTL_COCPU_CTRL_COCPU_START_2_INTR_EN_Pos = 0x7
	// Bit mask of COCPU_START_2_INTR_EN field.
	RTC_CNTL_COCPU_CTRL_COCPU_START_2_INTR_EN_Msk = 0x1f80
	// Position of COCPU_SHUT field.
	RTC_CNTL_COCPU_CTRL_COCPU_SHUT_Pos = 0xd
	// Bit mask of COCPU_SHUT field.
	RTC_CNTL_COCPU_CTRL_COCPU_SHUT_Msk = 0x2000
	// Bit COCPU_SHUT.
	RTC_CNTL_COCPU_CTRL_COCPU_SHUT = 0x2000
	// Position of COCPU_SHUT_2_CLK_DIS field.
	RTC_CNTL_COCPU_CTRL_COCPU_SHUT_2_CLK_DIS_Pos = 0xe
	// Bit mask of COCPU_SHUT_2_CLK_DIS field.
	RTC_CNTL_COCPU_CTRL_COCPU_SHUT_2_CLK_DIS_Msk = 0x3fc000
	// Position of COCPU_SHUT_RESET_EN field.
	RTC_CNTL_COCPU_CTRL_COCPU_SHUT_RESET_EN_Pos = 0x16
	// Bit mask of COCPU_SHUT_RESET_EN field.
	RTC_CNTL_COCPU_CTRL_COCPU_SHUT_RESET_EN_Msk = 0x400000
	// Bit COCPU_SHUT_RESET_EN.
	RTC_CNTL_COCPU_CTRL_COCPU_SHUT_RESET_EN = 0x400000
	// Position of COCPU_SEL field.
	RTC_CNTL_COCPU_CTRL_COCPU_SEL_Pos = 0x17
	// Bit mask of COCPU_SEL field.
	RTC_CNTL_COCPU_CTRL_COCPU_SEL_Msk = 0x800000
	// Bit COCPU_SEL.
	RTC_CNTL_COCPU_CTRL_COCPU_SEL = 0x800000
	// Position of COCPU_DONE_FORCE field.
	RTC_CNTL_COCPU_CTRL_COCPU_DONE_FORCE_Pos = 0x18
	// Bit mask of COCPU_DONE_FORCE field.
	RTC_CNTL_COCPU_CTRL_COCPU_DONE_FORCE_Msk = 0x1000000
	// Bit COCPU_DONE_FORCE.
	RTC_CNTL_COCPU_CTRL_COCPU_DONE_FORCE = 0x1000000
	// Position of COCPU_DONE field.
	RTC_CNTL_COCPU_CTRL_COCPU_DONE_Pos = 0x19
	// Bit mask of COCPU_DONE field.
	RTC_CNTL_COCPU_CTRL_COCPU_DONE_Msk = 0x2000000
	// Bit COCPU_DONE.
	RTC_CNTL_COCPU_CTRL_COCPU_DONE = 0x2000000
	// Position of COCPU_SW_INT_TRIGGER field.
	RTC_CNTL_COCPU_CTRL_COCPU_SW_INT_TRIGGER_Pos = 0x1a
	// Bit mask of COCPU_SW_INT_TRIGGER field.
	RTC_CNTL_COCPU_CTRL_COCPU_SW_INT_TRIGGER_Msk = 0x4000000
	// Bit COCPU_SW_INT_TRIGGER.
	RTC_CNTL_COCPU_CTRL_COCPU_SW_INT_TRIGGER = 0x4000000

	// TOUCH_CTRL1: Touch control register
	// Position of TOUCH_SLEEP_CYCLES field.
	RTC_CNTL_TOUCH_CTRL1_TOUCH_SLEEP_CYCLES_Pos = 0x0
	// Bit mask of TOUCH_SLEEP_CYCLES field.
	RTC_CNTL_TOUCH_CTRL1_TOUCH_SLEEP_CYCLES_Msk = 0xffff
	// Position of TOUCH_MEAS_NUM field.
	RTC_CNTL_TOUCH_CTRL1_TOUCH_MEAS_NUM_Pos = 0x10
	// Bit mask of TOUCH_MEAS_NUM field.
	RTC_CNTL_TOUCH_CTRL1_TOUCH_MEAS_NUM_Msk = 0xffff0000

	// TOUCH_CTRL2: Touch control register
	// Position of TOUCH_DRANGE field.
	RTC_CNTL_TOUCH_CTRL2_TOUCH_DRANGE_Pos = 0x2
	// Bit mask of TOUCH_DRANGE field.
	RTC_CNTL_TOUCH_CTRL2_TOUCH_DRANGE_Msk = 0xc
	// Position of TOUCH_DREFL field.
	RTC_CNTL_TOUCH_CTRL2_TOUCH_DREFL_Pos = 0x4
	// Bit mask of TOUCH_DREFL field.
	RTC_CNTL_TOUCH_CTRL2_TOUCH_DREFL_Msk = 0x30
	// Position of TOUCH_DREFH field.
	RTC_CNTL_TOUCH_CTRL2_TOUCH_DREFH_Pos = 0x6
	// Bit mask of TOUCH_DREFH field.
	RTC_CNTL_TOUCH_CTRL2_TOUCH_DREFH_Msk = 0xc0
	// Position of TOUCH_XPD_BIAS field.
	RTC_CNTL_TOUCH_CTRL2_TOUCH_XPD_BIAS_Pos = 0x8
	// Bit mask of TOUCH_XPD_BIAS field.
	RTC_CNTL_TOUCH_CTRL2_TOUCH_XPD_BIAS_Msk = 0x100
	// Bit TOUCH_XPD_BIAS.
	RTC_CNTL_TOUCH_CTRL2_TOUCH_XPD_BIAS = 0x100
	// Position of TOUCH_REFC field.
	RTC_CNTL_TOUCH_CTRL2_TOUCH_REFC_Pos = 0x9
	// Bit mask of TOUCH_REFC field.
	RTC_CNTL_TOUCH_CTRL2_TOUCH_REFC_Msk = 0xe00
	// Position of TOUCH_DBIAS field.
	RTC_CNTL_TOUCH_CTRL2_TOUCH_DBIAS_Pos = 0xc
	// Bit mask of TOUCH_DBIAS field.
	RTC_CNTL_TOUCH_CTRL2_TOUCH_DBIAS_Msk = 0x1000
	// Bit TOUCH_DBIAS.
	RTC_CNTL_TOUCH_CTRL2_TOUCH_DBIAS = 0x1000
	// Position of TOUCH_SLP_TIMER_EN field.
	RTC_CNTL_TOUCH_CTRL2_TOUCH_SLP_TIMER_EN_Pos = 0xd
	// Bit mask of TOUCH_SLP_TIMER_EN field.
	RTC_CNTL_TOUCH_CTRL2_TOUCH_SLP_TIMER_EN_Msk = 0x2000
	// Bit TOUCH_SLP_TIMER_EN.
	RTC_CNTL_TOUCH_CTRL2_TOUCH_SLP_TIMER_EN = 0x2000
	// Position of TOUCH_START_FSM_EN field.
	RTC_CNTL_TOUCH_CTRL2_TOUCH_START_FSM_EN_Pos = 0xe
	// Bit mask of TOUCH_START_FSM_EN field.
	RTC_CNTL_TOUCH_CTRL2_TOUCH_START_FSM_EN_Msk = 0x4000
	// Bit TOUCH_START_FSM_EN.
	RTC_CNTL_TOUCH_CTRL2_TOUCH_START_FSM_EN = 0x4000
	// Position of TOUCH_START_EN field.
	RTC_CNTL_TOUCH_CTRL2_TOUCH_START_EN_Pos = 0xf
	// Bit mask of TOUCH_START_EN field.
	RTC_CNTL_TOUCH_CTRL2_TOUCH_START_EN_Msk = 0x8000
	// Bit TOUCH_START_EN.
	RTC_CNTL_TOUCH_CTRL2_TOUCH_START_EN = 0x8000
	// Position of TOUCH_START_FORCE field.
	RTC_CNTL_TOUCH_CTRL2_TOUCH_START_FORCE_Pos = 0x10
	// Bit mask of TOUCH_START_FORCE field.
	RTC_CNTL_TOUCH_CTRL2_TOUCH_START_FORCE_Msk = 0x10000
	// Bit TOUCH_START_FORCE.
	RTC_CNTL_TOUCH_CTRL2_TOUCH_START_FORCE = 0x10000
	// Position of TOUCH_XPD_WAIT field.
	RTC_CNTL_TOUCH_CTRL2_TOUCH_XPD_WAIT_Pos = 0x11
	// Bit mask of TOUCH_XPD_WAIT field.
	RTC_CNTL_TOUCH_CTRL2_TOUCH_XPD_WAIT_Msk = 0x1fe0000
	// Position of TOUCH_SLP_CYC_DIV field.
	RTC_CNTL_TOUCH_CTRL2_TOUCH_SLP_CYC_DIV_Pos = 0x19
	// Bit mask of TOUCH_SLP_CYC_DIV field.
	RTC_CNTL_TOUCH_CTRL2_TOUCH_SLP_CYC_DIV_Msk = 0x6000000
	// Position of TOUCH_TIMER_FORCE_DONE field.
	RTC_CNTL_TOUCH_CTRL2_TOUCH_TIMER_FORCE_DONE_Pos = 0x1b
	// Bit mask of TOUCH_TIMER_FORCE_DONE field.
	RTC_CNTL_TOUCH_CTRL2_TOUCH_TIMER_FORCE_DONE_Msk = 0x18000000
	// Position of TOUCH_RESET field.
	RTC_CNTL_TOUCH_CTRL2_TOUCH_RESET_Pos = 0x1d
	// Bit mask of TOUCH_RESET field.
	RTC_CNTL_TOUCH_CTRL2_TOUCH_RESET_Msk = 0x20000000
	// Bit TOUCH_RESET.
	RTC_CNTL_TOUCH_CTRL2_TOUCH_RESET = 0x20000000
	// Position of TOUCH_CLK_FO field.
	RTC_CNTL_TOUCH_CTRL2_TOUCH_CLK_FO_Pos = 0x1e
	// Bit mask of TOUCH_CLK_FO field.
	RTC_CNTL_TOUCH_CTRL2_TOUCH_CLK_FO_Msk = 0x40000000
	// Bit TOUCH_CLK_FO.
	RTC_CNTL_TOUCH_CTRL2_TOUCH_CLK_FO = 0x40000000
	// Position of TOUCH_CLKGATE_EN field.
	RTC_CNTL_TOUCH_CTRL2_TOUCH_CLKGATE_EN_Pos = 0x1f
	// Bit mask of TOUCH_CLKGATE_EN field.
	RTC_CNTL_TOUCH_CTRL2_TOUCH_CLKGATE_EN_Msk = 0x80000000
	// Bit TOUCH_CLKGATE_EN.
	RTC_CNTL_TOUCH_CTRL2_TOUCH_CLKGATE_EN = 0x80000000

	// TOUCH_SCAN_CTRL: Configure touch scan settings
	// Position of TOUCH_DENOISE_RES field.
	RTC_CNTL_TOUCH_SCAN_CTRL_TOUCH_DENOISE_RES_Pos = 0x0
	// Bit mask of TOUCH_DENOISE_RES field.
	RTC_CNTL_TOUCH_SCAN_CTRL_TOUCH_DENOISE_RES_Msk = 0x3
	// Position of TOUCH_DENOISE_EN field.
	RTC_CNTL_TOUCH_SCAN_CTRL_TOUCH_DENOISE_EN_Pos = 0x2
	// Bit mask of TOUCH_DENOISE_EN field.
	RTC_CNTL_TOUCH_SCAN_CTRL_TOUCH_DENOISE_EN_Msk = 0x4
	// Bit TOUCH_DENOISE_EN.
	RTC_CNTL_TOUCH_SCAN_CTRL_TOUCH_DENOISE_EN = 0x4
	// Position of TOUCH_INACTIVE_CONNECTION field.
	RTC_CNTL_TOUCH_SCAN_CTRL_TOUCH_INACTIVE_CONNECTION_Pos = 0x8
	// Bit mask of TOUCH_INACTIVE_CONNECTION field.
	RTC_CNTL_TOUCH_SCAN_CTRL_TOUCH_INACTIVE_CONNECTION_Msk = 0x100
	// Bit TOUCH_INACTIVE_CONNECTION.
	RTC_CNTL_TOUCH_SCAN_CTRL_TOUCH_INACTIVE_CONNECTION = 0x100
	// Position of TOUCH_SHIELD_PAD_EN field.
	RTC_CNTL_TOUCH_SCAN_CTRL_TOUCH_SHIELD_PAD_EN_Pos = 0x9
	// Bit mask of TOUCH_SHIELD_PAD_EN field.
	RTC_CNTL_TOUCH_SCAN_CTRL_TOUCH_SHIELD_PAD_EN_Msk = 0x200
	// Bit TOUCH_SHIELD_PAD_EN.
	RTC_CNTL_TOUCH_SCAN_CTRL_TOUCH_SHIELD_PAD_EN = 0x200
	// Position of TOUCH_SCAN_PAD_MAP field.
	RTC_CNTL_TOUCH_SCAN_CTRL_TOUCH_SCAN_PAD_MAP_Pos = 0xa
	// Bit mask of TOUCH_SCAN_PAD_MAP field.
	RTC_CNTL_TOUCH_SCAN_CTRL_TOUCH_SCAN_PAD_MAP_Msk = 0x1fffc00
	// Position of TOUCH_BUFDRV field.
	RTC_CNTL_TOUCH_SCAN_CTRL_TOUCH_BUFDRV_Pos = 0x19
	// Bit mask of TOUCH_BUFDRV field.
	RTC_CNTL_TOUCH_SCAN_CTRL_TOUCH_BUFDRV_Msk = 0xe000000
	// Position of TOUCH_OUT_RING field.
	RTC_CNTL_TOUCH_SCAN_CTRL_TOUCH_OUT_RING_Pos = 0x1c
	// Bit mask of TOUCH_OUT_RING field.
	RTC_CNTL_TOUCH_SCAN_CTRL_TOUCH_OUT_RING_Msk = 0xf0000000

	// TOUCH_SLP_THRES: Configure the settings of touch sleep pad
	// Position of TOUCH_SLP_TH field.
	RTC_CNTL_TOUCH_SLP_THRES_TOUCH_SLP_TH_Pos = 0x0
	// Bit mask of TOUCH_SLP_TH field.
	RTC_CNTL_TOUCH_SLP_THRES_TOUCH_SLP_TH_Msk = 0x3fffff
	// Position of TOUCH_SLP_APPROACH_EN field.
	RTC_CNTL_TOUCH_SLP_THRES_TOUCH_SLP_APPROACH_EN_Pos = 0x1a
	// Bit mask of TOUCH_SLP_APPROACH_EN field.
	RTC_CNTL_TOUCH_SLP_THRES_TOUCH_SLP_APPROACH_EN_Msk = 0x4000000
	// Bit TOUCH_SLP_APPROACH_EN.
	RTC_CNTL_TOUCH_SLP_THRES_TOUCH_SLP_APPROACH_EN = 0x4000000
	// Position of TOUCH_SLP_PAD field.
	RTC_CNTL_TOUCH_SLP_THRES_TOUCH_SLP_PAD_Pos = 0x1b
	// Bit mask of TOUCH_SLP_PAD field.
	RTC_CNTL_TOUCH_SLP_THRES_TOUCH_SLP_PAD_Msk = 0xf8000000

	// TOUCH_APPROACH: Configure touch approach settings
	// Position of TOUCH_SLP_CHANNEL_CLR field.
	RTC_CNTL_TOUCH_APPROACH_TOUCH_SLP_CHANNEL_CLR_Pos = 0x17
	// Bit mask of TOUCH_SLP_CHANNEL_CLR field.
	RTC_CNTL_TOUCH_APPROACH_TOUCH_SLP_CHANNEL_CLR_Msk = 0x800000
	// Bit TOUCH_SLP_CHANNEL_CLR.
	RTC_CNTL_TOUCH_APPROACH_TOUCH_SLP_CHANNEL_CLR = 0x800000
	// Position of MEAS_TIME field.
	RTC_CNTL_TOUCH_APPROACH_MEAS_TIME_Pos = 0x18
	// Bit mask of MEAS_TIME field.
	RTC_CNTL_TOUCH_APPROACH_MEAS_TIME_Msk = 0xff000000

	// TOUCH_FILTER_CTRL: Configure touch filter settings
	// Position of TOUCH_SMOOTH_LVL field.
	RTC_CNTL_TOUCH_FILTER_CTRL_TOUCH_SMOOTH_LVL_Pos = 0x9
	// Bit mask of TOUCH_SMOOTH_LVL field.
	RTC_CNTL_TOUCH_FILTER_CTRL_TOUCH_SMOOTH_LVL_Msk = 0x600
	// Position of TOUCH_JITTER_STEP field.
	RTC_CNTL_TOUCH_FILTER_CTRL_TOUCH_JITTER_STEP_Pos = 0xb
	// Bit mask of TOUCH_JITTER_STEP field.
	RTC_CNTL_TOUCH_FILTER_CTRL_TOUCH_JITTER_STEP_Msk = 0x7800
	// Position of TOUCH_NEG_NOISE_LIMIT field.
	RTC_CNTL_TOUCH_FILTER_CTRL_TOUCH_NEG_NOISE_LIMIT_Pos = 0xf
	// Bit mask of TOUCH_NEG_NOISE_LIMIT field.
	RTC_CNTL_TOUCH_FILTER_CTRL_TOUCH_NEG_NOISE_LIMIT_Msk = 0x78000
	// Position of TOUCH_NEG_NOISE_THRES field.
	RTC_CNTL_TOUCH_FILTER_CTRL_TOUCH_NEG_NOISE_THRES_Pos = 0x13
	// Bit mask of TOUCH_NEG_NOISE_THRES field.
	RTC_CNTL_TOUCH_FILTER_CTRL_TOUCH_NEG_NOISE_THRES_Msk = 0x180000
	// Position of TOUCH_NOISE_THRES field.
	RTC_CNTL_TOUCH_FILTER_CTRL_TOUCH_NOISE_THRES_Pos = 0x15
	// Bit mask of TOUCH_NOISE_THRES field.
	RTC_CNTL_TOUCH_FILTER_CTRL_TOUCH_NOISE_THRES_Msk = 0x600000
	// Position of TOUCH_HYSTERESIS field.
	RTC_CNTL_TOUCH_FILTER_CTRL_TOUCH_HYSTERESIS_Pos = 0x17
	// Bit mask of TOUCH_HYSTERESIS field.
	RTC_CNTL_TOUCH_FILTER_CTRL_TOUCH_HYSTERESIS_Msk = 0x1800000
	// Position of TOUCH_DEBOUNCE field.
	RTC_CNTL_TOUCH_FILTER_CTRL_TOUCH_DEBOUNCE_Pos = 0x19
	// Bit mask of TOUCH_DEBOUNCE field.
	RTC_CNTL_TOUCH_FILTER_CTRL_TOUCH_DEBOUNCE_Msk = 0xe000000
	// Position of TOUCH_FILTER_MODE field.
	RTC_CNTL_TOUCH_FILTER_CTRL_TOUCH_FILTER_MODE_Pos = 0x1c
	// Bit mask of TOUCH_FILTER_MODE field.
	RTC_CNTL_TOUCH_FILTER_CTRL_TOUCH_FILTER_MODE_Msk = 0x70000000
	// Position of TOUCH_FILTER_EN field.
	RTC_CNTL_TOUCH_FILTER_CTRL_TOUCH_FILTER_EN_Pos = 0x1f
	// Bit mask of TOUCH_FILTER_EN field.
	RTC_CNTL_TOUCH_FILTER_CTRL_TOUCH_FILTER_EN_Msk = 0x80000000
	// Bit TOUCH_FILTER_EN.
	RTC_CNTL_TOUCH_FILTER_CTRL_TOUCH_FILTER_EN = 0x80000000

	// USB_CONF: configure usb control register
	// Position of USB_VREFH field.
	RTC_CNTL_USB_CONF_USB_VREFH_Pos = 0x0
	// Bit mask of USB_VREFH field.
	RTC_CNTL_USB_CONF_USB_VREFH_Msk = 0x3
	// Position of USB_VREFL field.
	RTC_CNTL_USB_CONF_USB_VREFL_Pos = 0x2
	// Bit mask of USB_VREFL field.
	RTC_CNTL_USB_CONF_USB_VREFL_Msk = 0xc
	// Position of USB_VREF_OVERRIDE field.
	RTC_CNTL_USB_CONF_USB_VREF_OVERRIDE_Pos = 0x4
	// Bit mask of USB_VREF_OVERRIDE field.
	RTC_CNTL_USB_CONF_USB_VREF_OVERRIDE_Msk = 0x10
	// Bit USB_VREF_OVERRIDE.
	RTC_CNTL_USB_CONF_USB_VREF_OVERRIDE = 0x10
	// Position of USB_PAD_PULL_OVERRIDE field.
	RTC_CNTL_USB_CONF_USB_PAD_PULL_OVERRIDE_Pos = 0x5
	// Bit mask of USB_PAD_PULL_OVERRIDE field.
	RTC_CNTL_USB_CONF_USB_PAD_PULL_OVERRIDE_Msk = 0x20
	// Bit USB_PAD_PULL_OVERRIDE.
	RTC_CNTL_USB_CONF_USB_PAD_PULL_OVERRIDE = 0x20
	// Position of USB_DP_PULLUP field.
	RTC_CNTL_USB_CONF_USB_DP_PULLUP_Pos = 0x6
	// Bit mask of USB_DP_PULLUP field.
	RTC_CNTL_USB_CONF_USB_DP_PULLUP_Msk = 0x40
	// Bit USB_DP_PULLUP.
	RTC_CNTL_USB_CONF_USB_DP_PULLUP = 0x40
	// Position of USB_DP_PULLDOWN field.
	RTC_CNTL_USB_CONF_USB_DP_PULLDOWN_Pos = 0x7
	// Bit mask of USB_DP_PULLDOWN field.
	RTC_CNTL_USB_CONF_USB_DP_PULLDOWN_Msk = 0x80
	// Bit USB_DP_PULLDOWN.
	RTC_CNTL_USB_CONF_USB_DP_PULLDOWN = 0x80
	// Position of USB_DM_PULLUP field.
	RTC_CNTL_USB_CONF_USB_DM_PULLUP_Pos = 0x8
	// Bit mask of USB_DM_PULLUP field.
	RTC_CNTL_USB_CONF_USB_DM_PULLUP_Msk = 0x100
	// Bit USB_DM_PULLUP.
	RTC_CNTL_USB_CONF_USB_DM_PULLUP = 0x100
	// Position of USB_DM_PULLDOWN field.
	RTC_CNTL_USB_CONF_USB_DM_PULLDOWN_Pos = 0x9
	// Bit mask of USB_DM_PULLDOWN field.
	RTC_CNTL_USB_CONF_USB_DM_PULLDOWN_Msk = 0x200
	// Bit USB_DM_PULLDOWN.
	RTC_CNTL_USB_CONF_USB_DM_PULLDOWN = 0x200
	// Position of USB_PULLUP_VALUE field.
	RTC_CNTL_USB_CONF_USB_PULLUP_VALUE_Pos = 0xa
	// Bit mask of USB_PULLUP_VALUE field.
	RTC_CNTL_USB_CONF_USB_PULLUP_VALUE_Msk = 0x400
	// Bit USB_PULLUP_VALUE.
	RTC_CNTL_USB_CONF_USB_PULLUP_VALUE = 0x400
	// Position of USB_PAD_ENABLE_OVERRIDE field.
	RTC_CNTL_USB_CONF_USB_PAD_ENABLE_OVERRIDE_Pos = 0xb
	// Bit mask of USB_PAD_ENABLE_OVERRIDE field.
	RTC_CNTL_USB_CONF_USB_PAD_ENABLE_OVERRIDE_Msk = 0x800
	// Bit USB_PAD_ENABLE_OVERRIDE.
	RTC_CNTL_USB_CONF_USB_PAD_ENABLE_OVERRIDE = 0x800
	// Position of USB_PAD_ENABLE field.
	RTC_CNTL_USB_CONF_USB_PAD_ENABLE_Pos = 0xc
	// Bit mask of USB_PAD_ENABLE field.
	RTC_CNTL_USB_CONF_USB_PAD_ENABLE_Msk = 0x1000
	// Bit USB_PAD_ENABLE.
	RTC_CNTL_USB_CONF_USB_PAD_ENABLE = 0x1000
	// Position of USB_TXM field.
	RTC_CNTL_USB_CONF_USB_TXM_Pos = 0xd
	// Bit mask of USB_TXM field.
	RTC_CNTL_USB_CONF_USB_TXM_Msk = 0x2000
	// Bit USB_TXM.
	RTC_CNTL_USB_CONF_USB_TXM = 0x2000
	// Position of USB_TXP field.
	RTC_CNTL_USB_CONF_USB_TXP_Pos = 0xe
	// Bit mask of USB_TXP field.
	RTC_CNTL_USB_CONF_USB_TXP_Msk = 0x4000
	// Bit USB_TXP.
	RTC_CNTL_USB_CONF_USB_TXP = 0x4000
	// Position of USB_TX_EN field.
	RTC_CNTL_USB_CONF_USB_TX_EN_Pos = 0xf
	// Bit mask of USB_TX_EN field.
	RTC_CNTL_USB_CONF_USB_TX_EN_Msk = 0x8000
	// Bit USB_TX_EN.
	RTC_CNTL_USB_CONF_USB_TX_EN = 0x8000
	// Position of USB_TX_EN_OVERRIDE field.
	RTC_CNTL_USB_CONF_USB_TX_EN_OVERRIDE_Pos = 0x10
	// Bit mask of USB_TX_EN_OVERRIDE field.
	RTC_CNTL_USB_CONF_USB_TX_EN_OVERRIDE_Msk = 0x10000
	// Bit USB_TX_EN_OVERRIDE.
	RTC_CNTL_USB_CONF_USB_TX_EN_OVERRIDE = 0x10000
	// Position of USB_RESET_DISABLE field.
	RTC_CNTL_USB_CONF_USB_RESET_DISABLE_Pos = 0x11
	// Bit mask of USB_RESET_DISABLE field.
	RTC_CNTL_USB_CONF_USB_RESET_DISABLE_Msk = 0x20000
	// Bit USB_RESET_DISABLE.
	RTC_CNTL_USB_CONF_USB_RESET_DISABLE = 0x20000
	// Position of IO_MUX_RESET_DISABLE field.
	RTC_CNTL_USB_CONF_IO_MUX_RESET_DISABLE_Pos = 0x12
	// Bit mask of IO_MUX_RESET_DISABLE field.
	RTC_CNTL_USB_CONF_IO_MUX_RESET_DISABLE_Msk = 0x40000
	// Bit IO_MUX_RESET_DISABLE.
	RTC_CNTL_USB_CONF_IO_MUX_RESET_DISABLE = 0x40000

	// TOUCH_TIMEOUT_CTRL: Configure touch timeout settings
	// Position of TOUCH_TIMEOUT_NUM field.
	RTC_CNTL_TOUCH_TIMEOUT_CTRL_TOUCH_TIMEOUT_NUM_Pos = 0x0
	// Bit mask of TOUCH_TIMEOUT_NUM field.
	RTC_CNTL_TOUCH_TIMEOUT_CTRL_TOUCH_TIMEOUT_NUM_Msk = 0x3fffff
	// Position of TOUCH_TIMEOUT_EN field.
	RTC_CNTL_TOUCH_TIMEOUT_CTRL_TOUCH_TIMEOUT_EN_Pos = 0x16
	// Bit mask of TOUCH_TIMEOUT_EN field.
	RTC_CNTL_TOUCH_TIMEOUT_CTRL_TOUCH_TIMEOUT_EN_Msk = 0x400000
	// Bit TOUCH_TIMEOUT_EN.
	RTC_CNTL_TOUCH_TIMEOUT_CTRL_TOUCH_TIMEOUT_EN = 0x400000

	// SLP_REJECT_CAUSE: Stores the reject-to-sleep cause.
	// Position of REJECT_CAUSE field.
	RTC_CNTL_SLP_REJECT_CAUSE_REJECT_CAUSE_Pos = 0x0
	// Bit mask of REJECT_CAUSE field.
	RTC_CNTL_SLP_REJECT_CAUSE_REJECT_CAUSE_Msk = 0x1ffff

	// OPTIONS1: RTC option register
	// Position of FORCE_DOWNLOAD_BOOT field.
	RTC_CNTL_OPTIONS1_FORCE_DOWNLOAD_BOOT_Pos = 0x0
	// Bit mask of FORCE_DOWNLOAD_BOOT field.
	RTC_CNTL_OPTIONS1_FORCE_DOWNLOAD_BOOT_Msk = 0x1
	// Bit FORCE_DOWNLOAD_BOOT.
	RTC_CNTL_OPTIONS1_FORCE_DOWNLOAD_BOOT = 0x1

	// SLP_WAKEUP_CAUSE: Stores the sleep-to-wakeup cause.
	// Position of WAKEUP_CAUSE field.
	RTC_CNTL_SLP_WAKEUP_CAUSE_WAKEUP_CAUSE_Pos = 0x0
	// Bit mask of WAKEUP_CAUSE field.
	RTC_CNTL_SLP_WAKEUP_CAUSE_WAKEUP_CAUSE_Msk = 0x1ffff

	// ULP_CP_TIMER_1: Configure sleep cycle of the timer
	// Position of ULP_CP_TIMER_SLP_CYCLE field.
	RTC_CNTL_ULP_CP_TIMER_1_ULP_CP_TIMER_SLP_CYCLE_Pos = 0x8
	// Bit mask of ULP_CP_TIMER_SLP_CYCLE field.
	RTC_CNTL_ULP_CP_TIMER_1_ULP_CP_TIMER_SLP_CYCLE_Msk = 0xffffff00

	// DATE
	// Position of CNTL_DATE field.
	RTC_CNTL_DATE_CNTL_DATE_Pos = 0x0
	// Bit mask of CNTL_DATE field.
	RTC_CNTL_DATE_CNTL_DATE_Msk = 0xfffffff
)

// Constants for SENS: Peripheral SENS
const (
	// SAR_READER1_CTRL: RTC ADC1 data and sampling control
	// Position of SAR1_CLK_DIV field.
	SENS_SAR_READER1_CTRL_SAR1_CLK_DIV_Pos = 0x0
	// Bit mask of SAR1_CLK_DIV field.
	SENS_SAR_READER1_CTRL_SAR1_CLK_DIV_Msk = 0xff
	// Position of SAR1_CLK_GATED field.
	SENS_SAR_READER1_CTRL_SAR1_CLK_GATED_Pos = 0x12
	// Bit mask of SAR1_CLK_GATED field.
	SENS_SAR_READER1_CTRL_SAR1_CLK_GATED_Msk = 0x40000
	// Bit SAR1_CLK_GATED.
	SENS_SAR_READER1_CTRL_SAR1_CLK_GATED = 0x40000
	// Position of SAR1_SAMPLE_NUM field.
	SENS_SAR_READER1_CTRL_SAR1_SAMPLE_NUM_Pos = 0x13
	// Bit mask of SAR1_SAMPLE_NUM field.
	SENS_SAR_READER1_CTRL_SAR1_SAMPLE_NUM_Msk = 0x7f80000
	// Position of SAR1_DATA_INV field.
	SENS_SAR_READER1_CTRL_SAR1_DATA_INV_Pos = 0x1c
	// Bit mask of SAR1_DATA_INV field.
	SENS_SAR_READER1_CTRL_SAR1_DATA_INV_Msk = 0x10000000
	// Bit SAR1_DATA_INV.
	SENS_SAR_READER1_CTRL_SAR1_DATA_INV = 0x10000000
	// Position of SAR1_INT_EN field.
	SENS_SAR_READER1_CTRL_SAR1_INT_EN_Pos = 0x1d
	// Bit mask of SAR1_INT_EN field.
	SENS_SAR_READER1_CTRL_SAR1_INT_EN_Msk = 0x20000000
	// Bit SAR1_INT_EN.
	SENS_SAR_READER1_CTRL_SAR1_INT_EN = 0x20000000

	// SAR_READER1_STATUS: saradc1 status for debug
	// Position of SAR1_READER_STATUS field.
	SENS_SAR_READER1_STATUS_SAR1_READER_STATUS_Pos = 0x0
	// Bit mask of SAR1_READER_STATUS field.
	SENS_SAR_READER1_STATUS_SAR1_READER_STATUS_Msk = 0xffffffff

	// SAR_MEAS1_CTRL1: Configure RTC ADC1 controller
	// Position of RTC_SARADC_RESET field.
	SENS_SAR_MEAS1_CTRL1_RTC_SARADC_RESET_Pos = 0x16
	// Bit mask of RTC_SARADC_RESET field.
	SENS_SAR_MEAS1_CTRL1_RTC_SARADC_RESET_Msk = 0x400000
	// Bit RTC_SARADC_RESET.
	SENS_SAR_MEAS1_CTRL1_RTC_SARADC_RESET = 0x400000
	// Position of RTC_SARADC_CLKGATE_EN field.
	SENS_SAR_MEAS1_CTRL1_RTC_SARADC_CLKGATE_EN_Pos = 0x17
	// Bit mask of RTC_SARADC_CLKGATE_EN field.
	SENS_SAR_MEAS1_CTRL1_RTC_SARADC_CLKGATE_EN_Msk = 0x800000
	// Bit RTC_SARADC_CLKGATE_EN.
	SENS_SAR_MEAS1_CTRL1_RTC_SARADC_CLKGATE_EN = 0x800000
	// Position of FORCE_XPD_AMP field.
	SENS_SAR_MEAS1_CTRL1_FORCE_XPD_AMP_Pos = 0x18
	// Bit mask of FORCE_XPD_AMP field.
	SENS_SAR_MEAS1_CTRL1_FORCE_XPD_AMP_Msk = 0x3000000
	// Position of AMP_RST_FB_FORCE field.
	SENS_SAR_MEAS1_CTRL1_AMP_RST_FB_FORCE_Pos = 0x1a
	// Bit mask of AMP_RST_FB_FORCE field.
	SENS_SAR_MEAS1_CTRL1_AMP_RST_FB_FORCE_Msk = 0xc000000
	// Position of AMP_SHORT_REF_FORCE field.
	SENS_SAR_MEAS1_CTRL1_AMP_SHORT_REF_FORCE_Pos = 0x1c
	// Bit mask of AMP_SHORT_REF_FORCE field.
	SENS_SAR_MEAS1_CTRL1_AMP_SHORT_REF_FORCE_Msk = 0x30000000
	// Position of AMP_SHORT_REF_GND_FORCE field.
	SENS_SAR_MEAS1_CTRL1_AMP_SHORT_REF_GND_FORCE_Pos = 0x1e
	// Bit mask of AMP_SHORT_REF_GND_FORCE field.
	SENS_SAR_MEAS1_CTRL1_AMP_SHORT_REF_GND_FORCE_Msk = 0xc0000000

	// SAR_MEAS1_CTRL2: Control RTC ADC1 conversion and status
	// Position of MEAS1_DATA_SAR field.
	SENS_SAR_MEAS1_CTRL2_MEAS1_DATA_SAR_Pos = 0x0
	// Bit mask of MEAS1_DATA_SAR field.
	SENS_SAR_MEAS1_CTRL2_MEAS1_DATA_SAR_Msk = 0xffff
	// Position of MEAS1_DONE_SAR field.
	SENS_SAR_MEAS1_CTRL2_MEAS1_DONE_SAR_Pos = 0x10
	// Bit mask of MEAS1_DONE_SAR field.
	SENS_SAR_MEAS1_CTRL2_MEAS1_DONE_SAR_Msk = 0x10000
	// Bit MEAS1_DONE_SAR.
	SENS_SAR_MEAS1_CTRL2_MEAS1_DONE_SAR = 0x10000
	// Position of MEAS1_START_SAR field.
	SENS_SAR_MEAS1_CTRL2_MEAS1_START_SAR_Pos = 0x11
	// Bit mask of MEAS1_START_SAR field.
	SENS_SAR_MEAS1_CTRL2_MEAS1_START_SAR_Msk = 0x20000
	// Bit MEAS1_START_SAR.
	SENS_SAR_MEAS1_CTRL2_MEAS1_START_SAR = 0x20000
	// Position of MEAS1_START_FORCE field.
	SENS_SAR_MEAS1_CTRL2_MEAS1_START_FORCE_Pos = 0x12
	// Bit mask of MEAS1_START_FORCE field.
	SENS_SAR_MEAS1_CTRL2_MEAS1_START_FORCE_Msk = 0x40000
	// Bit MEAS1_START_FORCE.
	SENS_SAR_MEAS1_CTRL2_MEAS1_START_FORCE = 0x40000
	// Position of SAR1_EN_PAD field.
	SENS_SAR_MEAS1_CTRL2_SAR1_EN_PAD_Pos = 0x13
	// Bit mask of SAR1_EN_PAD field.
	SENS_SAR_MEAS1_CTRL2_SAR1_EN_PAD_Msk = 0x7ff80000
	// Position of SAR1_EN_PAD_FORCE field.
	SENS_SAR_MEAS1_CTRL2_SAR1_EN_PAD_FORCE_Pos = 0x1f
	// Bit mask of SAR1_EN_PAD_FORCE field.
	SENS_SAR_MEAS1_CTRL2_SAR1_EN_PAD_FORCE_Msk = 0x80000000
	// Bit SAR1_EN_PAD_FORCE.
	SENS_SAR_MEAS1_CTRL2_SAR1_EN_PAD_FORCE = 0x80000000

	// SAR_MEAS1_MUX: Select the controller for SAR ADC1
	// Position of SAR1_DIG_FORCE field.
	SENS_SAR_MEAS1_MUX_SAR1_DIG_FORCE_Pos = 0x1f
	// Bit mask of SAR1_DIG_FORCE field.
	SENS_SAR_MEAS1_MUX_SAR1_DIG_FORCE_Msk = 0x80000000
	// Bit SAR1_DIG_FORCE.
	SENS_SAR_MEAS1_MUX_SAR1_DIG_FORCE = 0x80000000

	// SAR_ATTEN1: Configure SAR ADC1 attenuation
	// Position of SAR1_ATTEN field.
	SENS_SAR_ATTEN1_SAR1_ATTEN_Pos = 0x0
	// Bit mask of SAR1_ATTEN field.
	SENS_SAR_ATTEN1_SAR1_ATTEN_Msk = 0xffffffff

	// SAR_AMP_CTRL1: AMP control
	// Position of SAR_AMP_WAIT1 field.
	SENS_SAR_AMP_CTRL1_SAR_AMP_WAIT1_Pos = 0x0
	// Bit mask of SAR_AMP_WAIT1 field.
	SENS_SAR_AMP_CTRL1_SAR_AMP_WAIT1_Msk = 0xffff
	// Position of SAR_AMP_WAIT2 field.
	SENS_SAR_AMP_CTRL1_SAR_AMP_WAIT2_Pos = 0x10
	// Bit mask of SAR_AMP_WAIT2 field.
	SENS_SAR_AMP_CTRL1_SAR_AMP_WAIT2_Msk = 0xffff0000

	// SAR_AMP_CTRL2: AMP control
	// Position of SAR1_DAC_XPD_FSM_IDLE field.
	SENS_SAR_AMP_CTRL2_SAR1_DAC_XPD_FSM_IDLE_Pos = 0x0
	// Bit mask of SAR1_DAC_XPD_FSM_IDLE field.
	SENS_SAR_AMP_CTRL2_SAR1_DAC_XPD_FSM_IDLE_Msk = 0x1
	// Bit SAR1_DAC_XPD_FSM_IDLE.
	SENS_SAR_AMP_CTRL2_SAR1_DAC_XPD_FSM_IDLE = 0x1
	// Position of XPD_SAR_AMP_FSM_IDLE field.
	SENS_SAR_AMP_CTRL2_XPD_SAR_AMP_FSM_IDLE_Pos = 0x1
	// Bit mask of XPD_SAR_AMP_FSM_IDLE field.
	SENS_SAR_AMP_CTRL2_XPD_SAR_AMP_FSM_IDLE_Msk = 0x2
	// Bit XPD_SAR_AMP_FSM_IDLE.
	SENS_SAR_AMP_CTRL2_XPD_SAR_AMP_FSM_IDLE = 0x2
	// Position of AMP_RST_FB_FSM_IDLE field.
	SENS_SAR_AMP_CTRL2_AMP_RST_FB_FSM_IDLE_Pos = 0x2
	// Bit mask of AMP_RST_FB_FSM_IDLE field.
	SENS_SAR_AMP_CTRL2_AMP_RST_FB_FSM_IDLE_Msk = 0x4
	// Bit AMP_RST_FB_FSM_IDLE.
	SENS_SAR_AMP_CTRL2_AMP_RST_FB_FSM_IDLE = 0x4
	// Position of AMP_SHORT_REF_FSM_IDLE field.
	SENS_SAR_AMP_CTRL2_AMP_SHORT_REF_FSM_IDLE_Pos = 0x3
	// Bit mask of AMP_SHORT_REF_FSM_IDLE field.
	SENS_SAR_AMP_CTRL2_AMP_SHORT_REF_FSM_IDLE_Msk = 0x8
	// Bit AMP_SHORT_REF_FSM_IDLE.
	SENS_SAR_AMP_CTRL2_AMP_SHORT_REF_FSM_IDLE = 0x8
	// Position of AMP_SHORT_REF_GND_FSM_IDLE field.
	SENS_SAR_AMP_CTRL2_AMP_SHORT_REF_GND_FSM_IDLE_Pos = 0x4
	// Bit mask of AMP_SHORT_REF_GND_FSM_IDLE field.
	SENS_SAR_AMP_CTRL2_AMP_SHORT_REF_GND_FSM_IDLE_Msk = 0x10
	// Bit AMP_SHORT_REF_GND_FSM_IDLE.
	SENS_SAR_AMP_CTRL2_AMP_SHORT_REF_GND_FSM_IDLE = 0x10
	// Position of XPD_SAR_FSM_IDLE field.
	SENS_SAR_AMP_CTRL2_XPD_SAR_FSM_IDLE_Pos = 0x5
	// Bit mask of XPD_SAR_FSM_IDLE field.
	SENS_SAR_AMP_CTRL2_XPD_SAR_FSM_IDLE_Msk = 0x20
	// Bit XPD_SAR_FSM_IDLE.
	SENS_SAR_AMP_CTRL2_XPD_SAR_FSM_IDLE = 0x20
	// Position of SAR_RSTB_FSM_IDLE field.
	SENS_SAR_AMP_CTRL2_SAR_RSTB_FSM_IDLE_Pos = 0x6
	// Bit mask of SAR_RSTB_FSM_IDLE field.
	SENS_SAR_AMP_CTRL2_SAR_RSTB_FSM_IDLE_Msk = 0x40
	// Bit SAR_RSTB_FSM_IDLE.
	SENS_SAR_AMP_CTRL2_SAR_RSTB_FSM_IDLE = 0x40
	// Position of SAR_AMP_WAIT3 field.
	SENS_SAR_AMP_CTRL2_SAR_AMP_WAIT3_Pos = 0x10
	// Bit mask of SAR_AMP_WAIT3 field.
	SENS_SAR_AMP_CTRL2_SAR_AMP_WAIT3_Msk = 0xffff0000

	// SAR_AMP_CTRL3: AMP control register
	// Position of SAR1_DAC_XPD_FSM field.
	SENS_SAR_AMP_CTRL3_SAR1_DAC_XPD_FSM_Pos = 0x0
	// Bit mask of SAR1_DAC_XPD_FSM field.
	SENS_SAR_AMP_CTRL3_SAR1_DAC_XPD_FSM_Msk = 0xf
	// Position of XPD_SAR_AMP_FSM field.
	SENS_SAR_AMP_CTRL3_XPD_SAR_AMP_FSM_Pos = 0x4
	// Bit mask of XPD_SAR_AMP_FSM field.
	SENS_SAR_AMP_CTRL3_XPD_SAR_AMP_FSM_Msk = 0xf0
	// Position of AMP_RST_FB_FSM field.
	SENS_SAR_AMP_CTRL3_AMP_RST_FB_FSM_Pos = 0x8
	// Bit mask of AMP_RST_FB_FSM field.
	SENS_SAR_AMP_CTRL3_AMP_RST_FB_FSM_Msk = 0xf00
	// Position of AMP_SHORT_REF_FSM field.
	SENS_SAR_AMP_CTRL3_AMP_SHORT_REF_FSM_Pos = 0xc
	// Bit mask of AMP_SHORT_REF_FSM field.
	SENS_SAR_AMP_CTRL3_AMP_SHORT_REF_FSM_Msk = 0xf000
	// Position of AMP_SHORT_REF_GND_FSM field.
	SENS_SAR_AMP_CTRL3_AMP_SHORT_REF_GND_FSM_Pos = 0x10
	// Bit mask of AMP_SHORT_REF_GND_FSM field.
	SENS_SAR_AMP_CTRL3_AMP_SHORT_REF_GND_FSM_Msk = 0xf0000
	// Position of XPD_SAR_FSM field.
	SENS_SAR_AMP_CTRL3_XPD_SAR_FSM_Pos = 0x14
	// Bit mask of XPD_SAR_FSM field.
	SENS_SAR_AMP_CTRL3_XPD_SAR_FSM_Msk = 0xf00000
	// Position of SAR_RSTB_FSM field.
	SENS_SAR_AMP_CTRL3_SAR_RSTB_FSM_Pos = 0x18
	// Bit mask of SAR_RSTB_FSM field.
	SENS_SAR_AMP_CTRL3_SAR_RSTB_FSM_Msk = 0xf000000

	// SAR_READER2_CTRL: RTC ADC2 data and sampling control
	// Position of SAR2_CLK_DIV field.
	SENS_SAR_READER2_CTRL_SAR2_CLK_DIV_Pos = 0x0
	// Bit mask of SAR2_CLK_DIV field.
	SENS_SAR_READER2_CTRL_SAR2_CLK_DIV_Msk = 0xff
	// Position of SAR2_WAIT_ARB_CYCLE field.
	SENS_SAR_READER2_CTRL_SAR2_WAIT_ARB_CYCLE_Pos = 0x10
	// Bit mask of SAR2_WAIT_ARB_CYCLE field.
	SENS_SAR_READER2_CTRL_SAR2_WAIT_ARB_CYCLE_Msk = 0x30000
	// Position of SAR2_CLK_GATED field.
	SENS_SAR_READER2_CTRL_SAR2_CLK_GATED_Pos = 0x12
	// Bit mask of SAR2_CLK_GATED field.
	SENS_SAR_READER2_CTRL_SAR2_CLK_GATED_Msk = 0x40000
	// Bit SAR2_CLK_GATED.
	SENS_SAR_READER2_CTRL_SAR2_CLK_GATED = 0x40000
	// Position of SAR2_SAMPLE_NUM field.
	SENS_SAR_READER2_CTRL_SAR2_SAMPLE_NUM_Pos = 0x13
	// Bit mask of SAR2_SAMPLE_NUM field.
	SENS_SAR_READER2_CTRL_SAR2_SAMPLE_NUM_Msk = 0x7f80000
	// Position of SAR2_DATA_INV field.
	SENS_SAR_READER2_CTRL_SAR2_DATA_INV_Pos = 0x1d
	// Bit mask of SAR2_DATA_INV field.
	SENS_SAR_READER2_CTRL_SAR2_DATA_INV_Msk = 0x20000000
	// Bit SAR2_DATA_INV.
	SENS_SAR_READER2_CTRL_SAR2_DATA_INV = 0x20000000
	// Position of SAR2_INT_EN field.
	SENS_SAR_READER2_CTRL_SAR2_INT_EN_Pos = 0x1e
	// Bit mask of SAR2_INT_EN field.
	SENS_SAR_READER2_CTRL_SAR2_INT_EN_Msk = 0x40000000
	// Bit SAR2_INT_EN.
	SENS_SAR_READER2_CTRL_SAR2_INT_EN = 0x40000000

	// SAR_READER2_STATUS: saradc2 status for debug
	// Position of SAR2_READER_STATUS field.
	SENS_SAR_READER2_STATUS_SAR2_READER_STATUS_Pos = 0x0
	// Bit mask of SAR2_READER_STATUS field.
	SENS_SAR_READER2_STATUS_SAR2_READER_STATUS_Msk = 0xffffffff

	// SAR_MEAS2_CTRL1: configure rtc saradc2
	// Position of SAR2_CNTL_STATE field.
	SENS_SAR_MEAS2_CTRL1_SAR2_CNTL_STATE_Pos = 0x0
	// Bit mask of SAR2_CNTL_STATE field.
	SENS_SAR_MEAS2_CTRL1_SAR2_CNTL_STATE_Msk = 0x7
	// Position of SAR2_PWDET_CAL_EN field.
	SENS_SAR_MEAS2_CTRL1_SAR2_PWDET_CAL_EN_Pos = 0x3
	// Bit mask of SAR2_PWDET_CAL_EN field.
	SENS_SAR_MEAS2_CTRL1_SAR2_PWDET_CAL_EN_Msk = 0x8
	// Bit SAR2_PWDET_CAL_EN.
	SENS_SAR_MEAS2_CTRL1_SAR2_PWDET_CAL_EN = 0x8
	// Position of SAR2_PKDET_CAL_EN field.
	SENS_SAR_MEAS2_CTRL1_SAR2_PKDET_CAL_EN_Pos = 0x4
	// Bit mask of SAR2_PKDET_CAL_EN field.
	SENS_SAR_MEAS2_CTRL1_SAR2_PKDET_CAL_EN_Msk = 0x10
	// Bit SAR2_PKDET_CAL_EN.
	SENS_SAR_MEAS2_CTRL1_SAR2_PKDET_CAL_EN = 0x10
	// Position of SAR2_EN_TEST field.
	SENS_SAR_MEAS2_CTRL1_SAR2_EN_TEST_Pos = 0x5
	// Bit mask of SAR2_EN_TEST field.
	SENS_SAR_MEAS2_CTRL1_SAR2_EN_TEST_Msk = 0x20
	// Bit SAR2_EN_TEST.
	SENS_SAR_MEAS2_CTRL1_SAR2_EN_TEST = 0x20
	// Position of SAR2_RSTB_FORCE field.
	SENS_SAR_MEAS2_CTRL1_SAR2_RSTB_FORCE_Pos = 0x6
	// Bit mask of SAR2_RSTB_FORCE field.
	SENS_SAR_MEAS2_CTRL1_SAR2_RSTB_FORCE_Msk = 0xc0
	// Position of SAR2_STANDBY_WAIT field.
	SENS_SAR_MEAS2_CTRL1_SAR2_STANDBY_WAIT_Pos = 0x8
	// Bit mask of SAR2_STANDBY_WAIT field.
	SENS_SAR_MEAS2_CTRL1_SAR2_STANDBY_WAIT_Msk = 0xff00
	// Position of SAR2_RSTB_WAIT field.
	SENS_SAR_MEAS2_CTRL1_SAR2_RSTB_WAIT_Pos = 0x10
	// Bit mask of SAR2_RSTB_WAIT field.
	SENS_SAR_MEAS2_CTRL1_SAR2_RSTB_WAIT_Msk = 0xff0000
	// Position of SAR2_XPD_WAIT field.
	SENS_SAR_MEAS2_CTRL1_SAR2_XPD_WAIT_Pos = 0x18
	// Bit mask of SAR2_XPD_WAIT field.
	SENS_SAR_MEAS2_CTRL1_SAR2_XPD_WAIT_Msk = 0xff000000

	// SAR_MEAS2_CTRL2: Control RTC ADC2 conversion and status
	// Position of MEAS2_DATA_SAR field.
	SENS_SAR_MEAS2_CTRL2_MEAS2_DATA_SAR_Pos = 0x0
	// Bit mask of MEAS2_DATA_SAR field.
	SENS_SAR_MEAS2_CTRL2_MEAS2_DATA_SAR_Msk = 0xffff
	// Position of MEAS2_DONE_SAR field.
	SENS_SAR_MEAS2_CTRL2_MEAS2_DONE_SAR_Pos = 0x10
	// Bit mask of MEAS2_DONE_SAR field.
	SENS_SAR_MEAS2_CTRL2_MEAS2_DONE_SAR_Msk = 0x10000
	// Bit MEAS2_DONE_SAR.
	SENS_SAR_MEAS2_CTRL2_MEAS2_DONE_SAR = 0x10000
	// Position of MEAS2_START_SAR field.
	SENS_SAR_MEAS2_CTRL2_MEAS2_START_SAR_Pos = 0x11
	// Bit mask of MEAS2_START_SAR field.
	SENS_SAR_MEAS2_CTRL2_MEAS2_START_SAR_Msk = 0x20000
	// Bit MEAS2_START_SAR.
	SENS_SAR_MEAS2_CTRL2_MEAS2_START_SAR = 0x20000
	// Position of MEAS2_START_FORCE field.
	SENS_SAR_MEAS2_CTRL2_MEAS2_START_FORCE_Pos = 0x12
	// Bit mask of MEAS2_START_FORCE field.
	SENS_SAR_MEAS2_CTRL2_MEAS2_START_FORCE_Msk = 0x40000
	// Bit MEAS2_START_FORCE.
	SENS_SAR_MEAS2_CTRL2_MEAS2_START_FORCE = 0x40000
	// Position of SAR2_EN_PAD field.
	SENS_SAR_MEAS2_CTRL2_SAR2_EN_PAD_Pos = 0x13
	// Bit mask of SAR2_EN_PAD field.
	SENS_SAR_MEAS2_CTRL2_SAR2_EN_PAD_Msk = 0x7ff80000
	// Position of SAR2_EN_PAD_FORCE field.
	SENS_SAR_MEAS2_CTRL2_SAR2_EN_PAD_FORCE_Pos = 0x1f
	// Bit mask of SAR2_EN_PAD_FORCE field.
	SENS_SAR_MEAS2_CTRL2_SAR2_EN_PAD_FORCE_Msk = 0x80000000
	// Bit SAR2_EN_PAD_FORCE.
	SENS_SAR_MEAS2_CTRL2_SAR2_EN_PAD_FORCE = 0x80000000

	// SAR_MEAS2_MUX: Select the controller for SAR ADC2
	// Position of SAR2_PWDET_CCT field.
	SENS_SAR_MEAS2_MUX_SAR2_PWDET_CCT_Pos = 0x1c
	// Bit mask of SAR2_PWDET_CCT field.
	SENS_SAR_MEAS2_MUX_SAR2_PWDET_CCT_Msk = 0x70000000
	// Position of SAR2_RTC_FORCE field.
	SENS_SAR_MEAS2_MUX_SAR2_RTC_FORCE_Pos = 0x1f
	// Bit mask of SAR2_RTC_FORCE field.
	SENS_SAR_MEAS2_MUX_SAR2_RTC_FORCE_Msk = 0x80000000
	// Bit SAR2_RTC_FORCE.
	SENS_SAR_MEAS2_MUX_SAR2_RTC_FORCE = 0x80000000

	// SAR_ATTEN2: Configure SAR ADC2 attenuation
	// Position of SAR2_ATTEN field.
	SENS_SAR_ATTEN2_SAR2_ATTEN_Pos = 0x0
	// Bit mask of SAR2_ATTEN field.
	SENS_SAR_ATTEN2_SAR2_ATTEN_Msk = 0xffffffff

	// SAR_POWER_XPD_SAR: configure saradc’s power by sw
	// Position of FORCE_XPD_SAR field.
	SENS_SAR_POWER_XPD_SAR_FORCE_XPD_SAR_Pos = 0x1d
	// Bit mask of FORCE_XPD_SAR field.
	SENS_SAR_POWER_XPD_SAR_FORCE_XPD_SAR_Msk = 0x60000000
	// Position of SARCLK_EN field.
	SENS_SAR_POWER_XPD_SAR_SARCLK_EN_Pos = 0x1f
	// Bit mask of SARCLK_EN field.
	SENS_SAR_POWER_XPD_SAR_SARCLK_EN_Msk = 0x80000000
	// Bit SARCLK_EN.
	SENS_SAR_POWER_XPD_SAR_SARCLK_EN = 0x80000000

	// SAR_SLAVE_ADDR1: Configure slave addresses 0-1 of RTC I2C
	// Position of I2C_SLAVE_ADDR1 field.
	SENS_SAR_SLAVE_ADDR1_I2C_SLAVE_ADDR1_Pos = 0x0
	// Bit mask of I2C_SLAVE_ADDR1 field.
	SENS_SAR_SLAVE_ADDR1_I2C_SLAVE_ADDR1_Msk = 0x7ff
	// Position of I2C_SLAVE_ADDR0 field.
	SENS_SAR_SLAVE_ADDR1_I2C_SLAVE_ADDR0_Pos = 0xb
	// Bit mask of I2C_SLAVE_ADDR0 field.
	SENS_SAR_SLAVE_ADDR1_I2C_SLAVE_ADDR0_Msk = 0x3ff800
	// Position of MEAS_STATUS field.
	SENS_SAR_SLAVE_ADDR1_MEAS_STATUS_Pos = 0x16
	// Bit mask of MEAS_STATUS field.
	SENS_SAR_SLAVE_ADDR1_MEAS_STATUS_Msk = 0x3fc00000

	// SAR_SLAVE_ADDR2: Configure slave addresses 2-3 of RTC I2C
	// Position of I2C_SLAVE_ADDR3 field.
	SENS_SAR_SLAVE_ADDR2_I2C_SLAVE_ADDR3_Pos = 0x0
	// Bit mask of I2C_SLAVE_ADDR3 field.
	SENS_SAR_SLAVE_ADDR2_I2C_SLAVE_ADDR3_Msk = 0x7ff
	// Position of I2C_SLAVE_ADDR2 field.
	SENS_SAR_SLAVE_ADDR2_I2C_SLAVE_ADDR2_Pos = 0xb
	// Bit mask of I2C_SLAVE_ADDR2 field.
	SENS_SAR_SLAVE_ADDR2_I2C_SLAVE_ADDR2_Msk = 0x3ff800

	// SAR_SLAVE_ADDR3: Configure slave addresses 4-5 of RTC I2C
	// Position of I2C_SLAVE_ADDR5 field.
	SENS_SAR_SLAVE_ADDR3_I2C_SLAVE_ADDR5_Pos = 0x0
	// Bit mask of I2C_SLAVE_ADDR5 field.
	SENS_SAR_SLAVE_ADDR3_I2C_SLAVE_ADDR5_Msk = 0x7ff
	// Position of I2C_SLAVE_ADDR4 field.
	SENS_SAR_SLAVE_ADDR3_I2C_SLAVE_ADDR4_Pos = 0xb
	// Bit mask of I2C_SLAVE_ADDR4 field.
	SENS_SAR_SLAVE_ADDR3_I2C_SLAVE_ADDR4_Msk = 0x3ff800

	// SAR_SLAVE_ADDR4: Configure slave addresses 6-7 of RTC I2C
	// Position of I2C_SLAVE_ADDR7 field.
	SENS_SAR_SLAVE_ADDR4_I2C_SLAVE_ADDR7_Pos = 0x0
	// Bit mask of I2C_SLAVE_ADDR7 field.
	SENS_SAR_SLAVE_ADDR4_I2C_SLAVE_ADDR7_Msk = 0x7ff
	// Position of I2C_SLAVE_ADDR6 field.
	SENS_SAR_SLAVE_ADDR4_I2C_SLAVE_ADDR6_Pos = 0xb
	// Bit mask of I2C_SLAVE_ADDR6 field.
	SENS_SAR_SLAVE_ADDR4_I2C_SLAVE_ADDR6_Msk = 0x3ff800

	// SAR_TSENS_CTRL: Temperature sensor data control
	// Position of TSENS_OUT field.
	SENS_SAR_TSENS_CTRL_TSENS_OUT_Pos = 0x0
	// Bit mask of TSENS_OUT field.
	SENS_SAR_TSENS_CTRL_TSENS_OUT_Msk = 0xff
	// Position of TSENS_READY field.
	SENS_SAR_TSENS_CTRL_TSENS_READY_Pos = 0x8
	// Bit mask of TSENS_READY field.
	SENS_SAR_TSENS_CTRL_TSENS_READY_Msk = 0x100
	// Bit TSENS_READY.
	SENS_SAR_TSENS_CTRL_TSENS_READY = 0x100
	// Position of TSENS_INT_EN field.
	SENS_SAR_TSENS_CTRL_TSENS_INT_EN_Pos = 0xc
	// Bit mask of TSENS_INT_EN field.
	SENS_SAR_TSENS_CTRL_TSENS_INT_EN_Msk = 0x1000
	// Bit TSENS_INT_EN.
	SENS_SAR_TSENS_CTRL_TSENS_INT_EN = 0x1000
	// Position of TSENS_IN_INV field.
	SENS_SAR_TSENS_CTRL_TSENS_IN_INV_Pos = 0xd
	// Bit mask of TSENS_IN_INV field.
	SENS_SAR_TSENS_CTRL_TSENS_IN_INV_Msk = 0x2000
	// Bit TSENS_IN_INV.
	SENS_SAR_TSENS_CTRL_TSENS_IN_INV = 0x2000
	// Position of TSENS_CLK_DIV field.
	SENS_SAR_TSENS_CTRL_TSENS_CLK_DIV_Pos = 0xe
	// Bit mask of TSENS_CLK_DIV field.
	SENS_SAR_TSENS_CTRL_TSENS_CLK_DIV_Msk = 0x3fc000
	// Position of TSENS_POWER_UP field.
	SENS_SAR_TSENS_CTRL_TSENS_POWER_UP_Pos = 0x16
	// Bit mask of TSENS_POWER_UP field.
	SENS_SAR_TSENS_CTRL_TSENS_POWER_UP_Msk = 0x400000
	// Bit TSENS_POWER_UP.
	SENS_SAR_TSENS_CTRL_TSENS_POWER_UP = 0x400000
	// Position of TSENS_POWER_UP_FORCE field.
	SENS_SAR_TSENS_CTRL_TSENS_POWER_UP_FORCE_Pos = 0x17
	// Bit mask of TSENS_POWER_UP_FORCE field.
	SENS_SAR_TSENS_CTRL_TSENS_POWER_UP_FORCE_Msk = 0x800000
	// Bit TSENS_POWER_UP_FORCE.
	SENS_SAR_TSENS_CTRL_TSENS_POWER_UP_FORCE = 0x800000
	// Position of TSENS_DUMP_OUT field.
	SENS_SAR_TSENS_CTRL_TSENS_DUMP_OUT_Pos = 0x18
	// Bit mask of TSENS_DUMP_OUT field.
	SENS_SAR_TSENS_CTRL_TSENS_DUMP_OUT_Msk = 0x1000000
	// Bit TSENS_DUMP_OUT.
	SENS_SAR_TSENS_CTRL_TSENS_DUMP_OUT = 0x1000000

	// SAR_TSENS_CTRL2: Temperature sensor control
	// Position of TSENS_XPD_WAIT field.
	SENS_SAR_TSENS_CTRL2_TSENS_XPD_WAIT_Pos = 0x0
	// Bit mask of TSENS_XPD_WAIT field.
	SENS_SAR_TSENS_CTRL2_TSENS_XPD_WAIT_Msk = 0xfff
	// Position of TSENS_XPD_FORCE field.
	SENS_SAR_TSENS_CTRL2_TSENS_XPD_FORCE_Pos = 0xc
	// Bit mask of TSENS_XPD_FORCE field.
	SENS_SAR_TSENS_CTRL2_TSENS_XPD_FORCE_Msk = 0x3000
	// Position of TSENS_CLK_INV field.
	SENS_SAR_TSENS_CTRL2_TSENS_CLK_INV_Pos = 0xe
	// Bit mask of TSENS_CLK_INV field.
	SENS_SAR_TSENS_CTRL2_TSENS_CLK_INV_Msk = 0x4000
	// Bit TSENS_CLK_INV.
	SENS_SAR_TSENS_CTRL2_TSENS_CLK_INV = 0x4000
	// Position of TSENS_CLKGATE_EN field.
	SENS_SAR_TSENS_CTRL2_TSENS_CLKGATE_EN_Pos = 0xf
	// Bit mask of TSENS_CLKGATE_EN field.
	SENS_SAR_TSENS_CTRL2_TSENS_CLKGATE_EN_Msk = 0x8000
	// Bit TSENS_CLKGATE_EN.
	SENS_SAR_TSENS_CTRL2_TSENS_CLKGATE_EN = 0x8000
	// Position of TSENS_RESET field.
	SENS_SAR_TSENS_CTRL2_TSENS_RESET_Pos = 0x10
	// Bit mask of TSENS_RESET field.
	SENS_SAR_TSENS_CTRL2_TSENS_RESET_Msk = 0x10000
	// Bit TSENS_RESET.
	SENS_SAR_TSENS_CTRL2_TSENS_RESET = 0x10000

	// SAR_I2C_CTRL: Configure RTC I2C transmission
	// Position of SAR_I2C_CTRL field.
	SENS_SAR_I2C_CTRL_SAR_I2C_CTRL_Pos = 0x0
	// Bit mask of SAR_I2C_CTRL field.
	SENS_SAR_I2C_CTRL_SAR_I2C_CTRL_Msk = 0xfffffff
	// Position of SAR_I2C_START field.
	SENS_SAR_I2C_CTRL_SAR_I2C_START_Pos = 0x1c
	// Bit mask of SAR_I2C_START field.
	SENS_SAR_I2C_CTRL_SAR_I2C_START_Msk = 0x10000000
	// Bit SAR_I2C_START.
	SENS_SAR_I2C_CTRL_SAR_I2C_START = 0x10000000
	// Position of SAR_I2C_START_FORCE field.
	SENS_SAR_I2C_CTRL_SAR_I2C_START_FORCE_Pos = 0x1d
	// Bit mask of SAR_I2C_START_FORCE field.
	SENS_SAR_I2C_CTRL_SAR_I2C_START_FORCE_Msk = 0x20000000
	// Bit SAR_I2C_START_FORCE.
	SENS_SAR_I2C_CTRL_SAR_I2C_START_FORCE = 0x20000000

	// SAR_TOUCH_CONF: Touch sensor configuration register
	// Position of TOUCH_OUTEN field.
	SENS_SAR_TOUCH_CONF_TOUCH_OUTEN_Pos = 0x0
	// Bit mask of TOUCH_OUTEN field.
	SENS_SAR_TOUCH_CONF_TOUCH_OUTEN_Msk = 0x7fff
	// Position of TOUCH_STATUS_CLR field.
	SENS_SAR_TOUCH_CONF_TOUCH_STATUS_CLR_Pos = 0xf
	// Bit mask of TOUCH_STATUS_CLR field.
	SENS_SAR_TOUCH_CONF_TOUCH_STATUS_CLR_Msk = 0x8000
	// Bit TOUCH_STATUS_CLR.
	SENS_SAR_TOUCH_CONF_TOUCH_STATUS_CLR = 0x8000
	// Position of TOUCH_DATA_SEL field.
	SENS_SAR_TOUCH_CONF_TOUCH_DATA_SEL_Pos = 0x10
	// Bit mask of TOUCH_DATA_SEL field.
	SENS_SAR_TOUCH_CONF_TOUCH_DATA_SEL_Msk = 0x30000
	// Position of TOUCH_DENOISE_END field.
	SENS_SAR_TOUCH_CONF_TOUCH_DENOISE_END_Pos = 0x12
	// Bit mask of TOUCH_DENOISE_END field.
	SENS_SAR_TOUCH_CONF_TOUCH_DENOISE_END_Msk = 0x40000
	// Bit TOUCH_DENOISE_END.
	SENS_SAR_TOUCH_CONF_TOUCH_DENOISE_END = 0x40000
	// Position of TOUCH_UNIT_END field.
	SENS_SAR_TOUCH_CONF_TOUCH_UNIT_END_Pos = 0x13
	// Bit mask of TOUCH_UNIT_END field.
	SENS_SAR_TOUCH_CONF_TOUCH_UNIT_END_Msk = 0x80000
	// Bit TOUCH_UNIT_END.
	SENS_SAR_TOUCH_CONF_TOUCH_UNIT_END = 0x80000
	// Position of TOUCH_APPROACH_PAD2 field.
	SENS_SAR_TOUCH_CONF_TOUCH_APPROACH_PAD2_Pos = 0x14
	// Bit mask of TOUCH_APPROACH_PAD2 field.
	SENS_SAR_TOUCH_CONF_TOUCH_APPROACH_PAD2_Msk = 0xf00000
	// Position of TOUCH_APPROACH_PAD1 field.
	SENS_SAR_TOUCH_CONF_TOUCH_APPROACH_PAD1_Pos = 0x18
	// Bit mask of TOUCH_APPROACH_PAD1 field.
	SENS_SAR_TOUCH_CONF_TOUCH_APPROACH_PAD1_Msk = 0xf000000
	// Position of TOUCH_APPROACH_PAD0 field.
	SENS_SAR_TOUCH_CONF_TOUCH_APPROACH_PAD0_Pos = 0x1c
	// Bit mask of TOUCH_APPROACH_PAD0 field.
	SENS_SAR_TOUCH_CONF_TOUCH_APPROACH_PAD0_Msk = 0xf0000000

	// SAR_TOUCH_THRES1: Finger threshold for touch pad 1
	// Position of TOUCH_OUT_TH1 field.
	SENS_SAR_TOUCH_THRES1_TOUCH_OUT_TH1_Pos = 0x0
	// Bit mask of TOUCH_OUT_TH1 field.
	SENS_SAR_TOUCH_THRES1_TOUCH_OUT_TH1_Msk = 0x3fffff

	// SAR_TOUCH_THRES2: Finger threshold for touch pad 2
	// Position of TOUCH_OUT_TH2 field.
	SENS_SAR_TOUCH_THRES2_TOUCH_OUT_TH2_Pos = 0x0
	// Bit mask of TOUCH_OUT_TH2 field.
	SENS_SAR_TOUCH_THRES2_TOUCH_OUT_TH2_Msk = 0x3fffff

	// SAR_TOUCH_THRES3: Finger threshold for touch pad 3
	// Position of TOUCH_OUT_TH3 field.
	SENS_SAR_TOUCH_THRES3_TOUCH_OUT_TH3_Pos = 0x0
	// Bit mask of TOUCH_OUT_TH3 field.
	SENS_SAR_TOUCH_THRES3_TOUCH_OUT_TH3_Msk = 0x3fffff

	// SAR_TOUCH_THRES4: Finger threshold for touch pad 4
	// Position of TOUCH_OUT_TH4 field.
	SENS_SAR_TOUCH_THRES4_TOUCH_OUT_TH4_Pos = 0x0
	// Bit mask of TOUCH_OUT_TH4 field.
	SENS_SAR_TOUCH_THRES4_TOUCH_OUT_TH4_Msk = 0x3fffff

	// SAR_TOUCH_THRES5: Finger threshold for touch pad 5
	// Position of TOUCH_OUT_TH5 field.
	SENS_SAR_TOUCH_THRES5_TOUCH_OUT_TH5_Pos = 0x0
	// Bit mask of TOUCH_OUT_TH5 field.
	SENS_SAR_TOUCH_THRES5_TOUCH_OUT_TH5_Msk = 0x3fffff

	// SAR_TOUCH_THRES6: Finger threshold for touch pad 6
	// Position of TOUCH_OUT_TH6 field.
	SENS_SAR_TOUCH_THRES6_TOUCH_OUT_TH6_Pos = 0x0
	// Bit mask of TOUCH_OUT_TH6 field.
	SENS_SAR_TOUCH_THRES6_TOUCH_OUT_TH6_Msk = 0x3fffff

	// SAR_TOUCH_THRES7: Finger threshold for touch pad 7
	// Position of TOUCH_OUT_TH7 field.
	SENS_SAR_TOUCH_THRES7_TOUCH_OUT_TH7_Pos = 0x0
	// Bit mask of TOUCH_OUT_TH7 field.
	SENS_SAR_TOUCH_THRES7_TOUCH_OUT_TH7_Msk = 0x3fffff

	// SAR_TOUCH_THRES8: Finger threshold for touch pad 8
	// Position of TOUCH_OUT_TH8 field.
	SENS_SAR_TOUCH_THRES8_TOUCH_OUT_TH8_Pos = 0x0
	// Bit mask of TOUCH_OUT_TH8 field.
	SENS_SAR_TOUCH_THRES8_TOUCH_OUT_TH8_Msk = 0x3fffff

	// SAR_TOUCH_THRES9: Finger threshold for touch pad 9
	// Position of TOUCH_OUT_TH9 field.
	SENS_SAR_TOUCH_THRES9_TOUCH_OUT_TH9_Pos = 0x0
	// Bit mask of TOUCH_OUT_TH9 field.
	SENS_SAR_TOUCH_THRES9_TOUCH_OUT_TH9_Msk = 0x3fffff

	// SAR_TOUCH_THRES10: Finger threshold for touch pad 10
	// Position of TOUCH_OUT_TH10 field.
	SENS_SAR_TOUCH_THRES10_TOUCH_OUT_TH10_Pos = 0x0
	// Bit mask of TOUCH_OUT_TH10 field.
	SENS_SAR_TOUCH_THRES10_TOUCH_OUT_TH10_Msk = 0x3fffff

	// SAR_TOUCH_THRES11: Finger threshold for touch pad 11
	// Position of TOUCH_OUT_TH11 field.
	SENS_SAR_TOUCH_THRES11_TOUCH_OUT_TH11_Pos = 0x0
	// Bit mask of TOUCH_OUT_TH11 field.
	SENS_SAR_TOUCH_THRES11_TOUCH_OUT_TH11_Msk = 0x3fffff

	// SAR_TOUCH_THRES12: Finger threshold for touch pad 12
	// Position of TOUCH_OUT_TH12 field.
	SENS_SAR_TOUCH_THRES12_TOUCH_OUT_TH12_Pos = 0x0
	// Bit mask of TOUCH_OUT_TH12 field.
	SENS_SAR_TOUCH_THRES12_TOUCH_OUT_TH12_Msk = 0x3fffff

	// SAR_TOUCH_THRES13: Finger threshold for touch pad 13
	// Position of TOUCH_OUT_TH13 field.
	SENS_SAR_TOUCH_THRES13_TOUCH_OUT_TH13_Pos = 0x0
	// Bit mask of TOUCH_OUT_TH13 field.
	SENS_SAR_TOUCH_THRES13_TOUCH_OUT_TH13_Msk = 0x3fffff

	// SAR_TOUCH_THRES14: Finger threshold for touch pad 14
	// Position of TOUCH_OUT_TH14 field.
	SENS_SAR_TOUCH_THRES14_TOUCH_OUT_TH14_Pos = 0x0
	// Bit mask of TOUCH_OUT_TH14 field.
	SENS_SAR_TOUCH_THRES14_TOUCH_OUT_TH14_Msk = 0x3fffff

	// SAR_TOUCH_CHN_ST: Touch channel status register
	// Position of TOUCH_PAD_ACTIVE field.
	SENS_SAR_TOUCH_CHN_ST_TOUCH_PAD_ACTIVE_Pos = 0x0
	// Bit mask of TOUCH_PAD_ACTIVE field.
	SENS_SAR_TOUCH_CHN_ST_TOUCH_PAD_ACTIVE_Msk = 0x7fff
	// Position of TOUCH_CHANNEL_CLR field.
	SENS_SAR_TOUCH_CHN_ST_TOUCH_CHANNEL_CLR_Pos = 0xf
	// Bit mask of TOUCH_CHANNEL_CLR field.
	SENS_SAR_TOUCH_CHN_ST_TOUCH_CHANNEL_CLR_Msk = 0x3fff8000
	// Position of TOUCH_MEAS_DONE field.
	SENS_SAR_TOUCH_CHN_ST_TOUCH_MEAS_DONE_Pos = 0x1f
	// Bit mask of TOUCH_MEAS_DONE field.
	SENS_SAR_TOUCH_CHN_ST_TOUCH_MEAS_DONE_Msk = 0x80000000
	// Bit TOUCH_MEAS_DONE.
	SENS_SAR_TOUCH_CHN_ST_TOUCH_MEAS_DONE = 0x80000000

	// SAR_TOUCH_STATUS0: Status of touch controller
	// Position of TOUCH_DENOISE_DATA field.
	SENS_SAR_TOUCH_STATUS0_TOUCH_DENOISE_DATA_Pos = 0x0
	// Bit mask of TOUCH_DENOISE_DATA field.
	SENS_SAR_TOUCH_STATUS0_TOUCH_DENOISE_DATA_Msk = 0x3fffff
	// Position of TOUCH_SCAN_CURR field.
	SENS_SAR_TOUCH_STATUS0_TOUCH_SCAN_CURR_Pos = 0x16
	// Bit mask of TOUCH_SCAN_CURR field.
	SENS_SAR_TOUCH_STATUS0_TOUCH_SCAN_CURR_Msk = 0x3c00000

	// SAR_TOUCH_STATUS1: Touch pad 1 status
	// Position of TOUCH_PAD1_DATA field.
	SENS_SAR_TOUCH_STATUS1_TOUCH_PAD1_DATA_Pos = 0x0
	// Bit mask of TOUCH_PAD1_DATA field.
	SENS_SAR_TOUCH_STATUS1_TOUCH_PAD1_DATA_Msk = 0x3fffff
	// Position of TOUCH_PAD1_DEBOUNCE field.
	SENS_SAR_TOUCH_STATUS1_TOUCH_PAD1_DEBOUNCE_Pos = 0x1d
	// Bit mask of TOUCH_PAD1_DEBOUNCE field.
	SENS_SAR_TOUCH_STATUS1_TOUCH_PAD1_DEBOUNCE_Msk = 0xe0000000

	// SAR_TOUCH_STATUS2: Touch pad 2 status
	// Position of TOUCH_PAD2_DATA field.
	SENS_SAR_TOUCH_STATUS2_TOUCH_PAD2_DATA_Pos = 0x0
	// Bit mask of TOUCH_PAD2_DATA field.
	SENS_SAR_TOUCH_STATUS2_TOUCH_PAD2_DATA_Msk = 0x3fffff
	// Position of TOUCH_PAD2_DEBOUNCE field.
	SENS_SAR_TOUCH_STATUS2_TOUCH_PAD2_DEBOUNCE_Pos = 0x1d
	// Bit mask of TOUCH_PAD2_DEBOUNCE field.
	SENS_SAR_TOUCH_STATUS2_TOUCH_PAD2_DEBOUNCE_Msk = 0xe0000000

	// SAR_TOUCH_STATUS3: Touch pad 3 status
	// Position of TOUCH_PAD3_DATA field.
	SENS_SAR_TOUCH_STATUS3_TOUCH_PAD3_DATA_Pos = 0x0
	// Bit mask of TOUCH_PAD3_DATA field.
	SENS_SAR_TOUCH_STATUS3_TOUCH_PAD3_DATA_Msk = 0x3fffff
	// Position of TOUCH_PAD3_DEBOUNCE field.
	SENS_SAR_TOUCH_STATUS3_TOUCH_PAD3_DEBOUNCE_Pos = 0x1d
	// Bit mask of TOUCH_PAD3_DEBOUNCE field.
	SENS_SAR_TOUCH_STATUS3_TOUCH_PAD3_DEBOUNCE_Msk = 0xe0000000

	// SAR_TOUCH_STATUS4: Touch pad 4 status
	// Position of TOUCH_PAD4_DATA field.
	SENS_SAR_TOUCH_STATUS4_TOUCH_PAD4_DATA_Pos = 0x0
	// Bit mask of TOUCH_PAD4_DATA field.
	SENS_SAR_TOUCH_STATUS4_TOUCH_PAD4_DATA_Msk = 0x3fffff
	// Position of TOUCH_PAD4_DEBOUNCE field.
	SENS_SAR_TOUCH_STATUS4_TOUCH_PAD4_DEBOUNCE_Pos = 0x1d
	// Bit mask of TOUCH_PAD4_DEBOUNCE field.
	SENS_SAR_TOUCH_STATUS4_TOUCH_PAD4_DEBOUNCE_Msk = 0xe0000000

	// SAR_TOUCH_STATUS5: Touch pad 5 status
	// Position of TOUCH_PAD5_DATA field.
	SENS_SAR_TOUCH_STATUS5_TOUCH_PAD5_DATA_Pos = 0x0
	// Bit mask of TOUCH_PAD5_DATA field.
	SENS_SAR_TOUCH_STATUS5_TOUCH_PAD5_DATA_Msk = 0x3fffff
	// Position of TOUCH_PAD5_DEBOUNCE field.
	SENS_SAR_TOUCH_STATUS5_TOUCH_PAD5_DEBOUNCE_Pos = 0x1d
	// Bit mask of TOUCH_PAD5_DEBOUNCE field.
	SENS_SAR_TOUCH_STATUS5_TOUCH_PAD5_DEBOUNCE_Msk = 0xe0000000

	// SAR_TOUCH_STATUS6: Touch pad 6 status
	// Position of TOUCH_PAD6_DATA field.
	SENS_SAR_TOUCH_STATUS6_TOUCH_PAD6_DATA_Pos = 0x0
	// Bit mask of TOUCH_PAD6_DATA field.
	SENS_SAR_TOUCH_STATUS6_TOUCH_PAD6_DATA_Msk = 0x3fffff
	// Position of TOUCH_PAD6_DEBOUNCE field.
	SENS_SAR_TOUCH_STATUS6_TOUCH_PAD6_DEBOUNCE_Pos = 0x1d
	// Bit mask of TOUCH_PAD6_DEBOUNCE field.
	SENS_SAR_TOUCH_STATUS6_TOUCH_PAD6_DEBOUNCE_Msk = 0xe0000000

	// SAR_TOUCH_STATUS7: Touch pad 7 status
	// Position of TOUCH_PAD7_DATA field.
	SENS_SAR_TOUCH_STATUS7_TOUCH_PAD7_DATA_Pos = 0x0
	// Bit mask of TOUCH_PAD7_DATA field.
	SENS_SAR_TOUCH_STATUS7_TOUCH_PAD7_DATA_Msk = 0x3fffff
	// Position of TOUCH_PAD7_DEBOUNCE field.
	SENS_SAR_TOUCH_STATUS7_TOUCH_PAD7_DEBOUNCE_Pos = 0x1d
	// Bit mask of TOUCH_PAD7_DEBOUNCE field.
	SENS_SAR_TOUCH_STATUS7_TOUCH_PAD7_DEBOUNCE_Msk = 0xe0000000

	// SAR_TOUCH_STATUS8: Touch pad 8 status
	// Position of TOUCH_PAD8_DATA field.
	SENS_SAR_TOUCH_STATUS8_TOUCH_PAD8_DATA_Pos = 0x0
	// Bit mask of TOUCH_PAD8_DATA field.
	SENS_SAR_TOUCH_STATUS8_TOUCH_PAD8_DATA_Msk = 0x3fffff
	// Position of TOUCH_PAD8_DEBOUNCE field.
	SENS_SAR_TOUCH_STATUS8_TOUCH_PAD8_DEBOUNCE_Pos = 0x1d
	// Bit mask of TOUCH_PAD8_DEBOUNCE field.
	SENS_SAR_TOUCH_STATUS8_TOUCH_PAD8_DEBOUNCE_Msk = 0xe0000000

	// SAR_TOUCH_STATUS9: Touch pad 9 status
	// Position of TOUCH_PAD9_DATA field.
	SENS_SAR_TOUCH_STATUS9_TOUCH_PAD9_DATA_Pos = 0x0
	// Bit mask of TOUCH_PAD9_DATA field.
	SENS_SAR_TOUCH_STATUS9_TOUCH_PAD9_DATA_Msk = 0x3fffff
	// Position of TOUCH_PAD9_DEBOUNCE field.
	SENS_SAR_TOUCH_STATUS9_TOUCH_PAD9_DEBOUNCE_Pos = 0x1d
	// Bit mask of TOUCH_PAD9_DEBOUNCE field.
	SENS_SAR_TOUCH_STATUS9_TOUCH_PAD9_DEBOUNCE_Msk = 0xe0000000

	// SAR_TOUCH_STATUS10: Touch pad 10 status
	// Position of TOUCH_PAD10_DATA field.
	SENS_SAR_TOUCH_STATUS10_TOUCH_PAD10_DATA_Pos = 0x0
	// Bit mask of TOUCH_PAD10_DATA field.
	SENS_SAR_TOUCH_STATUS10_TOUCH_PAD10_DATA_Msk = 0x3fffff
	// Position of TOUCH_PAD10_DEBOUNCE field.
	SENS_SAR_TOUCH_STATUS10_TOUCH_PAD10_DEBOUNCE_Pos = 0x1d
	// Bit mask of TOUCH_PAD10_DEBOUNCE field.
	SENS_SAR_TOUCH_STATUS10_TOUCH_PAD10_DEBOUNCE_Msk = 0xe0000000

	// SAR_TOUCH_STATUS11: Touch pad 11 status
	// Position of TOUCH_PAD11_DATA field.
	SENS_SAR_TOUCH_STATUS11_TOUCH_PAD11_DATA_Pos = 0x0
	// Bit mask of TOUCH_PAD11_DATA field.
	SENS_SAR_TOUCH_STATUS11_TOUCH_PAD11_DATA_Msk = 0x3fffff
	// Position of TOUCH_PAD11_DEBOUNCE field.
	SENS_SAR_TOUCH_STATUS11_TOUCH_PAD11_DEBOUNCE_Pos = 0x1d
	// Bit mask of TOUCH_PAD11_DEBOUNCE field.
	SENS_SAR_TOUCH_STATUS11_TOUCH_PAD11_DEBOUNCE_Msk = 0xe0000000

	// SAR_TOUCH_STATUS12: Touch pad 12 status
	// Position of TOUCH_PAD12_DATA field.
	SENS_SAR_TOUCH_STATUS12_TOUCH_PAD12_DATA_Pos = 0x0
	// Bit mask of TOUCH_PAD12_DATA field.
	SENS_SAR_TOUCH_STATUS12_TOUCH_PAD12_DATA_Msk = 0x3fffff
	// Position of TOUCH_PAD12_DEBOUNCE field.
	SENS_SAR_TOUCH_STATUS12_TOUCH_PAD12_DEBOUNCE_Pos = 0x1d
	// Bit mask of TOUCH_PAD12_DEBOUNCE field.
	SENS_SAR_TOUCH_STATUS12_TOUCH_PAD12_DEBOUNCE_Msk = 0xe0000000

	// SAR_TOUCH_STATUS13: Touch pad 13 status
	// Position of TOUCH_PAD13_DATA field.
	SENS_SAR_TOUCH_STATUS13_TOUCH_PAD13_DATA_Pos = 0x0
	// Bit mask of TOUCH_PAD13_DATA field.
	SENS_SAR_TOUCH_STATUS13_TOUCH_PAD13_DATA_Msk = 0x3fffff
	// Position of TOUCH_PAD13_DEBOUNCE field.
	SENS_SAR_TOUCH_STATUS13_TOUCH_PAD13_DEBOUNCE_Pos = 0x1d
	// Bit mask of TOUCH_PAD13_DEBOUNCE field.
	SENS_SAR_TOUCH_STATUS13_TOUCH_PAD13_DEBOUNCE_Msk = 0xe0000000

	// SAR_TOUCH_STATUS14: Touch pad 14 status
	// Position of TOUCH_PAD14_DATA field.
	SENS_SAR_TOUCH_STATUS14_TOUCH_PAD14_DATA_Pos = 0x0
	// Bit mask of TOUCH_PAD14_DATA field.
	SENS_SAR_TOUCH_STATUS14_TOUCH_PAD14_DATA_Msk = 0x3fffff
	// Position of TOUCH_PAD14_DEBOUNCE field.
	SENS_SAR_TOUCH_STATUS14_TOUCH_PAD14_DEBOUNCE_Pos = 0x1d
	// Bit mask of TOUCH_PAD14_DEBOUNCE field.
	SENS_SAR_TOUCH_STATUS14_TOUCH_PAD14_DEBOUNCE_Msk = 0xe0000000

	// SAR_TOUCH_STATUS15: Touch sleep pad status
	// Position of TOUCH_SLP_DATA field.
	SENS_SAR_TOUCH_STATUS15_TOUCH_SLP_DATA_Pos = 0x0
	// Bit mask of TOUCH_SLP_DATA field.
	SENS_SAR_TOUCH_STATUS15_TOUCH_SLP_DATA_Msk = 0x3fffff
	// Position of TOUCH_SLP_DEBOUNCE field.
	SENS_SAR_TOUCH_STATUS15_TOUCH_SLP_DEBOUNCE_Pos = 0x1d
	// Bit mask of TOUCH_SLP_DEBOUNCE field.
	SENS_SAR_TOUCH_STATUS15_TOUCH_SLP_DEBOUNCE_Msk = 0xe0000000

	// SAR_TOUCH_STATUS16: Touch approach count status
	// Position of TOUCH_APPROACH_PAD2_CNT field.
	SENS_SAR_TOUCH_STATUS16_TOUCH_APPROACH_PAD2_CNT_Pos = 0x0
	// Bit mask of TOUCH_APPROACH_PAD2_CNT field.
	SENS_SAR_TOUCH_STATUS16_TOUCH_APPROACH_PAD2_CNT_Msk = 0xff
	// Position of TOUCH_APPROACH_PAD1_CNT field.
	SENS_SAR_TOUCH_STATUS16_TOUCH_APPROACH_PAD1_CNT_Pos = 0x8
	// Bit mask of TOUCH_APPROACH_PAD1_CNT field.
	SENS_SAR_TOUCH_STATUS16_TOUCH_APPROACH_PAD1_CNT_Msk = 0xff00
	// Position of TOUCH_APPROACH_PAD0_CNT field.
	SENS_SAR_TOUCH_STATUS16_TOUCH_APPROACH_PAD0_CNT_Pos = 0x10
	// Bit mask of TOUCH_APPROACH_PAD0_CNT field.
	SENS_SAR_TOUCH_STATUS16_TOUCH_APPROACH_PAD0_CNT_Msk = 0xff0000
	// Position of TOUCH_SLP_APPROACH_CNT field.
	SENS_SAR_TOUCH_STATUS16_TOUCH_SLP_APPROACH_CNT_Pos = 0x18
	// Bit mask of TOUCH_SLP_APPROACH_CNT field.
	SENS_SAR_TOUCH_STATUS16_TOUCH_SLP_APPROACH_CNT_Msk = 0xff000000

	// SAR_DAC_CTRL1: DAC control
	// Position of SW_FSTEP field.
	SENS_SAR_DAC_CTRL1_SW_FSTEP_Pos = 0x0
	// Bit mask of SW_FSTEP field.
	SENS_SAR_DAC_CTRL1_SW_FSTEP_Msk = 0xffff
	// Position of SW_TONE_EN field.
	SENS_SAR_DAC_CTRL1_SW_TONE_EN_Pos = 0x10
	// Bit mask of SW_TONE_EN field.
	SENS_SAR_DAC_CTRL1_SW_TONE_EN_Msk = 0x10000
	// Bit SW_TONE_EN.
	SENS_SAR_DAC_CTRL1_SW_TONE_EN = 0x10000
	// Position of DEBUG_BIT_SEL field.
	SENS_SAR_DAC_CTRL1_DEBUG_BIT_SEL_Pos = 0x11
	// Bit mask of DEBUG_BIT_SEL field.
	SENS_SAR_DAC_CTRL1_DEBUG_BIT_SEL_Msk = 0x3e0000
	// Position of DAC_DIG_FORCE field.
	SENS_SAR_DAC_CTRL1_DAC_DIG_FORCE_Pos = 0x16
	// Bit mask of DAC_DIG_FORCE field.
	SENS_SAR_DAC_CTRL1_DAC_DIG_FORCE_Msk = 0x400000
	// Bit DAC_DIG_FORCE.
	SENS_SAR_DAC_CTRL1_DAC_DIG_FORCE = 0x400000
	// Position of DAC_CLK_FORCE_LOW field.
	SENS_SAR_DAC_CTRL1_DAC_CLK_FORCE_LOW_Pos = 0x17
	// Bit mask of DAC_CLK_FORCE_LOW field.
	SENS_SAR_DAC_CTRL1_DAC_CLK_FORCE_LOW_Msk = 0x800000
	// Bit DAC_CLK_FORCE_LOW.
	SENS_SAR_DAC_CTRL1_DAC_CLK_FORCE_LOW = 0x800000
	// Position of DAC_CLK_FORCE_HIGH field.
	SENS_SAR_DAC_CTRL1_DAC_CLK_FORCE_HIGH_Pos = 0x18
	// Bit mask of DAC_CLK_FORCE_HIGH field.
	SENS_SAR_DAC_CTRL1_DAC_CLK_FORCE_HIGH_Msk = 0x1000000
	// Bit DAC_CLK_FORCE_HIGH.
	SENS_SAR_DAC_CTRL1_DAC_CLK_FORCE_HIGH = 0x1000000
	// Position of DAC_CLK_INV field.
	SENS_SAR_DAC_CTRL1_DAC_CLK_INV_Pos = 0x19
	// Bit mask of DAC_CLK_INV field.
	SENS_SAR_DAC_CTRL1_DAC_CLK_INV_Msk = 0x2000000
	// Bit DAC_CLK_INV.
	SENS_SAR_DAC_CTRL1_DAC_CLK_INV = 0x2000000
	// Position of DAC_RESET field.
	SENS_SAR_DAC_CTRL1_DAC_RESET_Pos = 0x1a
	// Bit mask of DAC_RESET field.
	SENS_SAR_DAC_CTRL1_DAC_RESET_Msk = 0x4000000
	// Bit DAC_RESET.
	SENS_SAR_DAC_CTRL1_DAC_RESET = 0x4000000
	// Position of DAC_CLKGATE_EN field.
	SENS_SAR_DAC_CTRL1_DAC_CLKGATE_EN_Pos = 0x1b
	// Bit mask of DAC_CLKGATE_EN field.
	SENS_SAR_DAC_CTRL1_DAC_CLKGATE_EN_Msk = 0x8000000
	// Bit DAC_CLKGATE_EN.
	SENS_SAR_DAC_CTRL1_DAC_CLKGATE_EN = 0x8000000

	// SAR_DAC_CTRL2: DAC output control
	// Position of DAC_DC1 field.
	SENS_SAR_DAC_CTRL2_DAC_DC1_Pos = 0x0
	// Bit mask of DAC_DC1 field.
	SENS_SAR_DAC_CTRL2_DAC_DC1_Msk = 0xff
	// Position of DAC_DC2 field.
	SENS_SAR_DAC_CTRL2_DAC_DC2_Pos = 0x8
	// Bit mask of DAC_DC2 field.
	SENS_SAR_DAC_CTRL2_DAC_DC2_Msk = 0xff00
	// Position of DAC_SCALE1 field.
	SENS_SAR_DAC_CTRL2_DAC_SCALE1_Pos = 0x10
	// Bit mask of DAC_SCALE1 field.
	SENS_SAR_DAC_CTRL2_DAC_SCALE1_Msk = 0x30000
	// Position of DAC_SCALE2 field.
	SENS_SAR_DAC_CTRL2_DAC_SCALE2_Pos = 0x12
	// Bit mask of DAC_SCALE2 field.
	SENS_SAR_DAC_CTRL2_DAC_SCALE2_Msk = 0xc0000
	// Position of DAC_INV1 field.
	SENS_SAR_DAC_CTRL2_DAC_INV1_Pos = 0x14
	// Bit mask of DAC_INV1 field.
	SENS_SAR_DAC_CTRL2_DAC_INV1_Msk = 0x300000
	// Position of DAC_INV2 field.
	SENS_SAR_DAC_CTRL2_DAC_INV2_Pos = 0x16
	// Bit mask of DAC_INV2 field.
	SENS_SAR_DAC_CTRL2_DAC_INV2_Msk = 0xc00000
	// Position of DAC_CW_EN1 field.
	SENS_SAR_DAC_CTRL2_DAC_CW_EN1_Pos = 0x18
	// Bit mask of DAC_CW_EN1 field.
	SENS_SAR_DAC_CTRL2_DAC_CW_EN1_Msk = 0x1000000
	// Bit DAC_CW_EN1.
	SENS_SAR_DAC_CTRL2_DAC_CW_EN1 = 0x1000000
	// Position of DAC_CW_EN2 field.
	SENS_SAR_DAC_CTRL2_DAC_CW_EN2_Pos = 0x19
	// Bit mask of DAC_CW_EN2 field.
	SENS_SAR_DAC_CTRL2_DAC_CW_EN2_Msk = 0x2000000
	// Bit DAC_CW_EN2.
	SENS_SAR_DAC_CTRL2_DAC_CW_EN2 = 0x2000000

	// SAR_COCPU_STATE: ULP-RISCV status
	// Position of COCPU_DBG_TRIGGER field.
	SENS_SAR_COCPU_STATE_COCPU_DBG_TRIGGER_Pos = 0x19
	// Bit mask of COCPU_DBG_TRIGGER field.
	SENS_SAR_COCPU_STATE_COCPU_DBG_TRIGGER_Msk = 0x2000000
	// Bit COCPU_DBG_TRIGGER.
	SENS_SAR_COCPU_STATE_COCPU_DBG_TRIGGER = 0x2000000
	// Position of COCPU_CLK_EN field.
	SENS_SAR_COCPU_STATE_COCPU_CLK_EN_Pos = 0x1a
	// Bit mask of COCPU_CLK_EN field.
	SENS_SAR_COCPU_STATE_COCPU_CLK_EN_Msk = 0x4000000
	// Bit COCPU_CLK_EN.
	SENS_SAR_COCPU_STATE_COCPU_CLK_EN = 0x4000000
	// Position of COCPU_RESET_N field.
	SENS_SAR_COCPU_STATE_COCPU_RESET_N_Pos = 0x1b
	// Bit mask of COCPU_RESET_N field.
	SENS_SAR_COCPU_STATE_COCPU_RESET_N_Msk = 0x8000000
	// Bit COCPU_RESET_N.
	SENS_SAR_COCPU_STATE_COCPU_RESET_N = 0x8000000
	// Position of COCPU_EOI field.
	SENS_SAR_COCPU_STATE_COCPU_EOI_Pos = 0x1c
	// Bit mask of COCPU_EOI field.
	SENS_SAR_COCPU_STATE_COCPU_EOI_Msk = 0x10000000
	// Bit COCPU_EOI.
	SENS_SAR_COCPU_STATE_COCPU_EOI = 0x10000000
	// Position of COCPU_TRAP field.
	SENS_SAR_COCPU_STATE_COCPU_TRAP_Pos = 0x1d
	// Bit mask of COCPU_TRAP field.
	SENS_SAR_COCPU_STATE_COCPU_TRAP_Msk = 0x20000000
	// Bit COCPU_TRAP.
	SENS_SAR_COCPU_STATE_COCPU_TRAP = 0x20000000
	// Position of COCPU_EBREAK field.
	SENS_SAR_COCPU_STATE_COCPU_EBREAK_Pos = 0x1e
	// Bit mask of COCPU_EBREAK field.
	SENS_SAR_COCPU_STATE_COCPU_EBREAK_Msk = 0x40000000
	// Bit COCPU_EBREAK.
	SENS_SAR_COCPU_STATE_COCPU_EBREAK = 0x40000000

	// SAR_COCPU_INT_RAW: Interrupt raw bit of ULP-RISCV
	// Position of COCPU_TOUCH_DONE_INT_RAW field.
	SENS_SAR_COCPU_INT_RAW_COCPU_TOUCH_DONE_INT_RAW_Pos = 0x0
	// Bit mask of COCPU_TOUCH_DONE_INT_RAW field.
	SENS_SAR_COCPU_INT_RAW_COCPU_TOUCH_DONE_INT_RAW_Msk = 0x1
	// Bit COCPU_TOUCH_DONE_INT_RAW.
	SENS_SAR_COCPU_INT_RAW_COCPU_TOUCH_DONE_INT_RAW = 0x1
	// Position of COCPU_TOUCH_INACTIVE_INT_RAW field.
	SENS_SAR_COCPU_INT_RAW_COCPU_TOUCH_INACTIVE_INT_RAW_Pos = 0x1
	// Bit mask of COCPU_TOUCH_INACTIVE_INT_RAW field.
	SENS_SAR_COCPU_INT_RAW_COCPU_TOUCH_INACTIVE_INT_RAW_Msk = 0x2
	// Bit COCPU_TOUCH_INACTIVE_INT_RAW.
	SENS_SAR_COCPU_INT_RAW_COCPU_TOUCH_INACTIVE_INT_RAW = 0x2
	// Position of COCPU_TOUCH_ACTIVE_INT_RAW field.
	SENS_SAR_COCPU_INT_RAW_COCPU_TOUCH_ACTIVE_INT_RAW_Pos = 0x2
	// Bit mask of COCPU_TOUCH_ACTIVE_INT_RAW field.
	SENS_SAR_COCPU_INT_RAW_COCPU_TOUCH_ACTIVE_INT_RAW_Msk = 0x4
	// Bit COCPU_TOUCH_ACTIVE_INT_RAW.
	SENS_SAR_COCPU_INT_RAW_COCPU_TOUCH_ACTIVE_INT_RAW = 0x4
	// Position of COCPU_SARADC1_INT_RAW field.
	SENS_SAR_COCPU_INT_RAW_COCPU_SARADC1_INT_RAW_Pos = 0x3
	// Bit mask of COCPU_SARADC1_INT_RAW field.
	SENS_SAR_COCPU_INT_RAW_COCPU_SARADC1_INT_RAW_Msk = 0x8
	// Bit COCPU_SARADC1_INT_RAW.
	SENS_SAR_COCPU_INT_RAW_COCPU_SARADC1_INT_RAW = 0x8
	// Position of COCPU_SARADC2_INT_RAW field.
	SENS_SAR_COCPU_INT_RAW_COCPU_SARADC2_INT_RAW_Pos = 0x4
	// Bit mask of COCPU_SARADC2_INT_RAW field.
	SENS_SAR_COCPU_INT_RAW_COCPU_SARADC2_INT_RAW_Msk = 0x10
	// Bit COCPU_SARADC2_INT_RAW.
	SENS_SAR_COCPU_INT_RAW_COCPU_SARADC2_INT_RAW = 0x10
	// Position of COCPU_TSENS_INT_RAW field.
	SENS_SAR_COCPU_INT_RAW_COCPU_TSENS_INT_RAW_Pos = 0x5
	// Bit mask of COCPU_TSENS_INT_RAW field.
	SENS_SAR_COCPU_INT_RAW_COCPU_TSENS_INT_RAW_Msk = 0x20
	// Bit COCPU_TSENS_INT_RAW.
	SENS_SAR_COCPU_INT_RAW_COCPU_TSENS_INT_RAW = 0x20
	// Position of COCPU_START_INT_RAW field.
	SENS_SAR_COCPU_INT_RAW_COCPU_START_INT_RAW_Pos = 0x6
	// Bit mask of COCPU_START_INT_RAW field.
	SENS_SAR_COCPU_INT_RAW_COCPU_START_INT_RAW_Msk = 0x40
	// Bit COCPU_START_INT_RAW.
	SENS_SAR_COCPU_INT_RAW_COCPU_START_INT_RAW = 0x40
	// Position of COCPU_SW_INT_RAW field.
	SENS_SAR_COCPU_INT_RAW_COCPU_SW_INT_RAW_Pos = 0x7
	// Bit mask of COCPU_SW_INT_RAW field.
	SENS_SAR_COCPU_INT_RAW_COCPU_SW_INT_RAW_Msk = 0x80
	// Bit COCPU_SW_INT_RAW.
	SENS_SAR_COCPU_INT_RAW_COCPU_SW_INT_RAW = 0x80
	// Position of COCPU_SWD_INT_RAW field.
	SENS_SAR_COCPU_INT_RAW_COCPU_SWD_INT_RAW_Pos = 0x8
	// Bit mask of COCPU_SWD_INT_RAW field.
	SENS_SAR_COCPU_INT_RAW_COCPU_SWD_INT_RAW_Msk = 0x100
	// Bit COCPU_SWD_INT_RAW.
	SENS_SAR_COCPU_INT_RAW_COCPU_SWD_INT_RAW = 0x100

	// SAR_COCPU_INT_ENA: Interrupt enable bit of ULP-RISCV
	// Position of COCPU_TOUCH_DONE_INT_ENA field.
	SENS_SAR_COCPU_INT_ENA_COCPU_TOUCH_DONE_INT_ENA_Pos = 0x0
	// Bit mask of COCPU_TOUCH_DONE_INT_ENA field.
	SENS_SAR_COCPU_INT_ENA_COCPU_TOUCH_DONE_INT_ENA_Msk = 0x1
	// Bit COCPU_TOUCH_DONE_INT_ENA.
	SENS_SAR_COCPU_INT_ENA_COCPU_TOUCH_DONE_INT_ENA = 0x1
	// Position of COCPU_TOUCH_INACTIVE_INT_ENA field.
	SENS_SAR_COCPU_INT_ENA_COCPU_TOUCH_INACTIVE_INT_ENA_Pos = 0x1
	// Bit mask of COCPU_TOUCH_INACTIVE_INT_ENA field.
	SENS_SAR_COCPU_INT_ENA_COCPU_TOUCH_INACTIVE_INT_ENA_Msk = 0x2
	// Bit COCPU_TOUCH_INACTIVE_INT_ENA.
	SENS_SAR_COCPU_INT_ENA_COCPU_TOUCH_INACTIVE_INT_ENA = 0x2
	// Position of COCPU_TOUCH_ACTIVE_INT_ENA field.
	SENS_SAR_COCPU_INT_ENA_COCPU_TOUCH_ACTIVE_INT_ENA_Pos = 0x2
	// Bit mask of COCPU_TOUCH_ACTIVE_INT_ENA field.
	SENS_SAR_COCPU_INT_ENA_COCPU_TOUCH_ACTIVE_INT_ENA_Msk = 0x4
	// Bit COCPU_TOUCH_ACTIVE_INT_ENA.
	SENS_SAR_COCPU_INT_ENA_COCPU_TOUCH_ACTIVE_INT_ENA = 0x4
	// Position of COCPU_SARADC1_INT_ENA field.
	SENS_SAR_COCPU_INT_ENA_COCPU_SARADC1_INT_ENA_Pos = 0x3
	// Bit mask of COCPU_SARADC1_INT_ENA field.
	SENS_SAR_COCPU_INT_ENA_COCPU_SARADC1_INT_ENA_Msk = 0x8
	// Bit COCPU_SARADC1_INT_ENA.
	SENS_SAR_COCPU_INT_ENA_COCPU_SARADC1_INT_ENA = 0x8
	// Position of COCPU_SARADC2_INT_ENA field.
	SENS_SAR_COCPU_INT_ENA_COCPU_SARADC2_INT_ENA_Pos = 0x4
	// Bit mask of COCPU_SARADC2_INT_ENA field.
	SENS_SAR_COCPU_INT_ENA_COCPU_SARADC2_INT_ENA_Msk = 0x10
	// Bit COCPU_SARADC2_INT_ENA.
	SENS_SAR_COCPU_INT_ENA_COCPU_SARADC2_INT_ENA = 0x10
	// Position of COCPU_TSENS_INT_ENA field.
	SENS_SAR_COCPU_INT_ENA_COCPU_TSENS_INT_ENA_Pos = 0x5
	// Bit mask of COCPU_TSENS_INT_ENA field.
	SENS_SAR_COCPU_INT_ENA_COCPU_TSENS_INT_ENA_Msk = 0x20
	// Bit COCPU_TSENS_INT_ENA.
	SENS_SAR_COCPU_INT_ENA_COCPU_TSENS_INT_ENA = 0x20
	// Position of COCPU_START_INT_ENA field.
	SENS_SAR_COCPU_INT_ENA_COCPU_START_INT_ENA_Pos = 0x6
	// Bit mask of COCPU_START_INT_ENA field.
	SENS_SAR_COCPU_INT_ENA_COCPU_START_INT_ENA_Msk = 0x40
	// Bit COCPU_START_INT_ENA.
	SENS_SAR_COCPU_INT_ENA_COCPU_START_INT_ENA = 0x40
	// Position of COCPU_SW_INT_ENA field.
	SENS_SAR_COCPU_INT_ENA_COCPU_SW_INT_ENA_Pos = 0x7
	// Bit mask of COCPU_SW_INT_ENA field.
	SENS_SAR_COCPU_INT_ENA_COCPU_SW_INT_ENA_Msk = 0x80
	// Bit COCPU_SW_INT_ENA.
	SENS_SAR_COCPU_INT_ENA_COCPU_SW_INT_ENA = 0x80
	// Position of COCPU_SWD_INT_ENA field.
	SENS_SAR_COCPU_INT_ENA_COCPU_SWD_INT_ENA_Pos = 0x8
	// Bit mask of COCPU_SWD_INT_ENA field.
	SENS_SAR_COCPU_INT_ENA_COCPU_SWD_INT_ENA_Msk = 0x100
	// Bit COCPU_SWD_INT_ENA.
	SENS_SAR_COCPU_INT_ENA_COCPU_SWD_INT_ENA = 0x100

	// SAR_COCPU_INT_ST: Interrupt status bit of ULP-RISCV
	// Position of COCPU_TOUCH_DONE_INT_ST field.
	SENS_SAR_COCPU_INT_ST_COCPU_TOUCH_DONE_INT_ST_Pos = 0x0
	// Bit mask of COCPU_TOUCH_DONE_INT_ST field.
	SENS_SAR_COCPU_INT_ST_COCPU_TOUCH_DONE_INT_ST_Msk = 0x1
	// Bit COCPU_TOUCH_DONE_INT_ST.
	SENS_SAR_COCPU_INT_ST_COCPU_TOUCH_DONE_INT_ST = 0x1
	// Position of COCPU_TOUCH_INACTIVE_INT_ST field.
	SENS_SAR_COCPU_INT_ST_COCPU_TOUCH_INACTIVE_INT_ST_Pos = 0x1
	// Bit mask of COCPU_TOUCH_INACTIVE_INT_ST field.
	SENS_SAR_COCPU_INT_ST_COCPU_TOUCH_INACTIVE_INT_ST_Msk = 0x2
	// Bit COCPU_TOUCH_INACTIVE_INT_ST.
	SENS_SAR_COCPU_INT_ST_COCPU_TOUCH_INACTIVE_INT_ST = 0x2
	// Position of COCPU_TOUCH_ACTIVE_INT_ST field.
	SENS_SAR_COCPU_INT_ST_COCPU_TOUCH_ACTIVE_INT_ST_Pos = 0x2
	// Bit mask of COCPU_TOUCH_ACTIVE_INT_ST field.
	SENS_SAR_COCPU_INT_ST_COCPU_TOUCH_ACTIVE_INT_ST_Msk = 0x4
	// Bit COCPU_TOUCH_ACTIVE_INT_ST.
	SENS_SAR_COCPU_INT_ST_COCPU_TOUCH_ACTIVE_INT_ST = 0x4
	// Position of COCPU_SARADC1_INT_ST field.
	SENS_SAR_COCPU_INT_ST_COCPU_SARADC1_INT_ST_Pos = 0x3
	// Bit mask of COCPU_SARADC1_INT_ST field.
	SENS_SAR_COCPU_INT_ST_COCPU_SARADC1_INT_ST_Msk = 0x8
	// Bit COCPU_SARADC1_INT_ST.
	SENS_SAR_COCPU_INT_ST_COCPU_SARADC1_INT_ST = 0x8
	// Position of COCPU_SARADC2_INT_ST field.
	SENS_SAR_COCPU_INT_ST_COCPU_SARADC2_INT_ST_Pos = 0x4
	// Bit mask of COCPU_SARADC2_INT_ST field.
	SENS_SAR_COCPU_INT_ST_COCPU_SARADC2_INT_ST_Msk = 0x10
	// Bit COCPU_SARADC2_INT_ST.
	SENS_SAR_COCPU_INT_ST_COCPU_SARADC2_INT_ST = 0x10
	// Position of COCPU_TSENS_INT_ST field.
	SENS_SAR_COCPU_INT_ST_COCPU_TSENS_INT_ST_Pos = 0x5
	// Bit mask of COCPU_TSENS_INT_ST field.
	SENS_SAR_COCPU_INT_ST_COCPU_TSENS_INT_ST_Msk = 0x20
	// Bit COCPU_TSENS_INT_ST.
	SENS_SAR_COCPU_INT_ST_COCPU_TSENS_INT_ST = 0x20
	// Position of COCPU_START_INT_ST field.
	SENS_SAR_COCPU_INT_ST_COCPU_START_INT_ST_Pos = 0x6
	// Bit mask of COCPU_START_INT_ST field.
	SENS_SAR_COCPU_INT_ST_COCPU_START_INT_ST_Msk = 0x40
	// Bit COCPU_START_INT_ST.
	SENS_SAR_COCPU_INT_ST_COCPU_START_INT_ST = 0x40
	// Position of COCPU_SW_INT_ST field.
	SENS_SAR_COCPU_INT_ST_COCPU_SW_INT_ST_Pos = 0x7
	// Bit mask of COCPU_SW_INT_ST field.
	SENS_SAR_COCPU_INT_ST_COCPU_SW_INT_ST_Msk = 0x80
	// Bit COCPU_SW_INT_ST.
	SENS_SAR_COCPU_INT_ST_COCPU_SW_INT_ST = 0x80
	// Position of COCPU_SWD_INT_ST field.
	SENS_SAR_COCPU_INT_ST_COCPU_SWD_INT_ST_Pos = 0x8
	// Bit mask of COCPU_SWD_INT_ST field.
	SENS_SAR_COCPU_INT_ST_COCPU_SWD_INT_ST_Msk = 0x100
	// Bit COCPU_SWD_INT_ST.
	SENS_SAR_COCPU_INT_ST_COCPU_SWD_INT_ST = 0x100

	// SAR_COCPU_INT_CLR: Interrupt clear bit of ULP-RISCV
	// Position of COCPU_TOUCH_DONE_INT_CLR field.
	SENS_SAR_COCPU_INT_CLR_COCPU_TOUCH_DONE_INT_CLR_Pos = 0x0
	// Bit mask of COCPU_TOUCH_DONE_INT_CLR field.
	SENS_SAR_COCPU_INT_CLR_COCPU_TOUCH_DONE_INT_CLR_Msk = 0x1
	// Bit COCPU_TOUCH_DONE_INT_CLR.
	SENS_SAR_COCPU_INT_CLR_COCPU_TOUCH_DONE_INT_CLR = 0x1
	// Position of COCPU_TOUCH_INACTIVE_INT_CLR field.
	SENS_SAR_COCPU_INT_CLR_COCPU_TOUCH_INACTIVE_INT_CLR_Pos = 0x1
	// Bit mask of COCPU_TOUCH_INACTIVE_INT_CLR field.
	SENS_SAR_COCPU_INT_CLR_COCPU_TOUCH_INACTIVE_INT_CLR_Msk = 0x2
	// Bit COCPU_TOUCH_INACTIVE_INT_CLR.
	SENS_SAR_COCPU_INT_CLR_COCPU_TOUCH_INACTIVE_INT_CLR = 0x2
	// Position of COCPU_TOUCH_ACTIVE_INT_CLR field.
	SENS_SAR_COCPU_INT_CLR_COCPU_TOUCH_ACTIVE_INT_CLR_Pos = 0x2
	// Bit mask of COCPU_TOUCH_ACTIVE_INT_CLR field.
	SENS_SAR_COCPU_INT_CLR_COCPU_TOUCH_ACTIVE_INT_CLR_Msk = 0x4
	// Bit COCPU_TOUCH_ACTIVE_INT_CLR.
	SENS_SAR_COCPU_INT_CLR_COCPU_TOUCH_ACTIVE_INT_CLR = 0x4
	// Position of COCPU_SARADC1_INT_CLR field.
	SENS_SAR_COCPU_INT_CLR_COCPU_SARADC1_INT_CLR_Pos = 0x3
	// Bit mask of COCPU_SARADC1_INT_CLR field.
	SENS_SAR_COCPU_INT_CLR_COCPU_SARADC1_INT_CLR_Msk = 0x8
	// Bit COCPU_SARADC1_INT_CLR.
	SENS_SAR_COCPU_INT_CLR_COCPU_SARADC1_INT_CLR = 0x8
	// Position of COCPU_SARADC2_INT_CLR field.
	SENS_SAR_COCPU_INT_CLR_COCPU_SARADC2_INT_CLR_Pos = 0x4
	// Bit mask of COCPU_SARADC2_INT_CLR field.
	SENS_SAR_COCPU_INT_CLR_COCPU_SARADC2_INT_CLR_Msk = 0x10
	// Bit COCPU_SARADC2_INT_CLR.
	SENS_SAR_COCPU_INT_CLR_COCPU_SARADC2_INT_CLR = 0x10
	// Position of COCPU_TSENS_INT_CLR field.
	SENS_SAR_COCPU_INT_CLR_COCPU_TSENS_INT_CLR_Pos = 0x5
	// Bit mask of COCPU_TSENS_INT_CLR field.
	SENS_SAR_COCPU_INT_CLR_COCPU_TSENS_INT_CLR_Msk = 0x20
	// Bit COCPU_TSENS_INT_CLR.
	SENS_SAR_COCPU_INT_CLR_COCPU_TSENS_INT_CLR = 0x20
	// Position of COCPU_START_INT_CLR field.
	SENS_SAR_COCPU_INT_CLR_COCPU_START_INT_CLR_Pos = 0x6
	// Bit mask of COCPU_START_INT_CLR field.
	SENS_SAR_COCPU_INT_CLR_COCPU_START_INT_CLR_Msk = 0x40
	// Bit COCPU_START_INT_CLR.
	SENS_SAR_COCPU_INT_CLR_COCPU_START_INT_CLR = 0x40
	// Position of COCPU_SW_INT_CLR field.
	SENS_SAR_COCPU_INT_CLR_COCPU_SW_INT_CLR_Pos = 0x7
	// Bit mask of COCPU_SW_INT_CLR field.
	SENS_SAR_COCPU_INT_CLR_COCPU_SW_INT_CLR_Msk = 0x80
	// Bit COCPU_SW_INT_CLR.
	SENS_SAR_COCPU_INT_CLR_COCPU_SW_INT_CLR = 0x80
	// Position of COCPU_SWD_INT_CLR field.
	SENS_SAR_COCPU_INT_CLR_COCPU_SWD_INT_CLR_Pos = 0x8
	// Bit mask of COCPU_SWD_INT_CLR field.
	SENS_SAR_COCPU_INT_CLR_COCPU_SWD_INT_CLR_Msk = 0x100
	// Bit COCPU_SWD_INT_CLR.
	SENS_SAR_COCPU_INT_CLR_COCPU_SWD_INT_CLR = 0x100

	// SAR_COCPU_DEBUG: ULP-RISCV debug register
	// Position of COCPU_PC field.
	SENS_SAR_COCPU_DEBUG_COCPU_PC_Pos = 0x0
	// Bit mask of COCPU_PC field.
	SENS_SAR_COCPU_DEBUG_COCPU_PC_Msk = 0x1fff
	// Position of COCPU_MEM_VLD field.
	SENS_SAR_COCPU_DEBUG_COCPU_MEM_VLD_Pos = 0xd
	// Bit mask of COCPU_MEM_VLD field.
	SENS_SAR_COCPU_DEBUG_COCPU_MEM_VLD_Msk = 0x2000
	// Bit COCPU_MEM_VLD.
	SENS_SAR_COCPU_DEBUG_COCPU_MEM_VLD = 0x2000
	// Position of COCPU_MEM_RDY field.
	SENS_SAR_COCPU_DEBUG_COCPU_MEM_RDY_Pos = 0xe
	// Bit mask of COCPU_MEM_RDY field.
	SENS_SAR_COCPU_DEBUG_COCPU_MEM_RDY_Msk = 0x4000
	// Bit COCPU_MEM_RDY.
	SENS_SAR_COCPU_DEBUG_COCPU_MEM_RDY = 0x4000
	// Position of COCPU_MEM_WEN field.
	SENS_SAR_COCPU_DEBUG_COCPU_MEM_WEN_Pos = 0xf
	// Bit mask of COCPU_MEM_WEN field.
	SENS_SAR_COCPU_DEBUG_COCPU_MEM_WEN_Msk = 0x78000
	// Position of COCPU_MEM_ADDR field.
	SENS_SAR_COCPU_DEBUG_COCPU_MEM_ADDR_Pos = 0x13
	// Bit mask of COCPU_MEM_ADDR field.
	SENS_SAR_COCPU_DEBUG_COCPU_MEM_ADDR_Msk = 0xfff80000

	// SAR_HALL_CTRL: hall control
	// Position of XPD_HALL field.
	SENS_SAR_HALL_CTRL_XPD_HALL_Pos = 0x1c
	// Bit mask of XPD_HALL field.
	SENS_SAR_HALL_CTRL_XPD_HALL_Msk = 0x10000000
	// Bit XPD_HALL.
	SENS_SAR_HALL_CTRL_XPD_HALL = 0x10000000
	// Position of XPD_HALL_FORCE field.
	SENS_SAR_HALL_CTRL_XPD_HALL_FORCE_Pos = 0x1d
	// Bit mask of XPD_HALL_FORCE field.
	SENS_SAR_HALL_CTRL_XPD_HALL_FORCE_Msk = 0x20000000
	// Bit XPD_HALL_FORCE.
	SENS_SAR_HALL_CTRL_XPD_HALL_FORCE = 0x20000000
	// Position of HALL_PHASE field.
	SENS_SAR_HALL_CTRL_HALL_PHASE_Pos = 0x1e
	// Bit mask of HALL_PHASE field.
	SENS_SAR_HALL_CTRL_HALL_PHASE_Msk = 0x40000000
	// Bit HALL_PHASE.
	SENS_SAR_HALL_CTRL_HALL_PHASE = 0x40000000
	// Position of HALL_PHASE_FORCE field.
	SENS_SAR_HALL_CTRL_HALL_PHASE_FORCE_Pos = 0x1f
	// Bit mask of HALL_PHASE_FORCE field.
	SENS_SAR_HALL_CTRL_HALL_PHASE_FORCE_Msk = 0x80000000
	// Bit HALL_PHASE_FORCE.
	SENS_SAR_HALL_CTRL_HALL_PHASE_FORCE = 0x80000000

	// SAR_NOUSE: sar nouse
	// Position of SAR_NOUSE field.
	SENS_SAR_NOUSE_SAR_NOUSE_Pos = 0x0
	// Bit mask of SAR_NOUSE field.
	SENS_SAR_NOUSE_SAR_NOUSE_Msk = 0xffffffff

	// SAR_IO_MUX_CONF: Configure and reset IO MUX
	// Position of IOMUX_RESET field.
	SENS_SAR_IO_MUX_CONF_IOMUX_RESET_Pos = 0x1e
	// Bit mask of IOMUX_RESET field.
	SENS_SAR_IO_MUX_CONF_IOMUX_RESET_Msk = 0x40000000
	// Bit IOMUX_RESET.
	SENS_SAR_IO_MUX_CONF_IOMUX_RESET = 0x40000000
	// Position of IOMUX_CLK_GATE_EN field.
	SENS_SAR_IO_MUX_CONF_IOMUX_CLK_GATE_EN_Pos = 0x1f
	// Bit mask of IOMUX_CLK_GATE_EN field.
	SENS_SAR_IO_MUX_CONF_IOMUX_CLK_GATE_EN_Msk = 0x80000000
	// Bit IOMUX_CLK_GATE_EN.
	SENS_SAR_IO_MUX_CONF_IOMUX_CLK_GATE_EN = 0x80000000

	// SARDATE: Version Control Register
	// Position of SAR_DATE field.
	SENS_SARDATE_SAR_DATE_Pos = 0x0
	// Bit mask of SAR_DATE field.
	SENS_SARDATE_SAR_DATE_Msk = 0xfffffff
)

// Constants for SHA: Peripheral SHA
const (
	// MODE: Defines the algorithm of SHA accelerator
	// Position of MODE field.
	SHA_MODE_MODE_Pos = 0x0
	// Bit mask of MODE field.
	SHA_MODE_MODE_Msk = 0x7

	// T_STRING: String content register for calculating initial Hash Value (only effective for SHA-512/t)
	// Position of T_STRING field.
	SHA_T_STRING_T_STRING_Pos = 0x0
	// Bit mask of T_STRING field.
	SHA_T_STRING_T_STRING_Msk = 0xffffffff

	// T_LENGTH: String length register for calculating initial Hash Value (only effective for SHA-512/t)
	// Position of T_LENGTH field.
	SHA_T_LENGTH_T_LENGTH_Pos = 0x0
	// Bit mask of T_LENGTH field.
	SHA_T_LENGTH_T_LENGTH_Msk = 0x3f

	// DMA_BLOCK_NUM: Block number register (only effective for DMA-SHA)
	// Position of DMA_BLOCK_NUM field.
	SHA_DMA_BLOCK_NUM_DMA_BLOCK_NUM_Pos = 0x0
	// Bit mask of DMA_BLOCK_NUM field.
	SHA_DMA_BLOCK_NUM_DMA_BLOCK_NUM_Msk = 0x3f

	// START: Starts the SHA accelerator for Typical SHA operation
	// Position of START field.
	SHA_START_START_Pos = 0x0
	// Bit mask of START field.
	SHA_START_START_Msk = 0x1
	// Bit START.
	SHA_START_START = 0x1

	// CONTINUE_OP: Continues SHA operation (only effective in Typical SHA mode)
	// Position of CONTINUE_OP field.
	SHA_CONTINUE_OP_CONTINUE_OP_Pos = 0x0
	// Bit mask of CONTINUE_OP field.
	SHA_CONTINUE_OP_CONTINUE_OP_Msk = 0x1
	// Bit CONTINUE_OP.
	SHA_CONTINUE_OP_CONTINUE_OP = 0x1

	// BUSY: Indicates if SHA Accelerator is busy or not
	// Position of STATE field.
	SHA_BUSY_STATE_Pos = 0x0
	// Bit mask of STATE field.
	SHA_BUSY_STATE_Msk = 0x1
	// Bit STATE.
	SHA_BUSY_STATE = 0x1

	// DMA_START: Starts the SHA accelerator for DMA-SHA operation
	// Position of DMA_START field.
	SHA_DMA_START_DMA_START_Pos = 0x0
	// Bit mask of DMA_START field.
	SHA_DMA_START_DMA_START_Msk = 0x1
	// Bit DMA_START.
	SHA_DMA_START_DMA_START = 0x1

	// DMA_CONTINUE: Continues SHA operation (only effective in DMA-SHA mode)
	// Position of DMA_CONTINUE field.
	SHA_DMA_CONTINUE_DMA_CONTINUE_Pos = 0x0
	// Bit mask of DMA_CONTINUE field.
	SHA_DMA_CONTINUE_DMA_CONTINUE_Msk = 0x1
	// Bit DMA_CONTINUE.
	SHA_DMA_CONTINUE_DMA_CONTINUE = 0x1

	// INT_CLEAR: DMA-SHA interrupt clear register
	// Position of CLEAR_INTERRUPT field.
	SHA_INT_CLEAR_CLEAR_INTERRUPT_Pos = 0x0
	// Bit mask of CLEAR_INTERRUPT field.
	SHA_INT_CLEAR_CLEAR_INTERRUPT_Msk = 0x1
	// Bit CLEAR_INTERRUPT.
	SHA_INT_CLEAR_CLEAR_INTERRUPT = 0x1

	// INT_ENA: DMA-SHA interrupt enable register
	// Position of INTERRUPT_ENA field.
	SHA_INT_ENA_INTERRUPT_ENA_Pos = 0x0
	// Bit mask of INTERRUPT_ENA field.
	SHA_INT_ENA_INTERRUPT_ENA_Msk = 0x1
	// Bit INTERRUPT_ENA.
	SHA_INT_ENA_INTERRUPT_ENA = 0x1

	// DATE: Version control register.
	// Position of DATE field.
	SHA_DATE_DATE_Pos = 0x0
	// Bit mask of DATE field.
	SHA_DATE_DATE_Msk = 0x3fffffff

	// H_0: Hash value
	// Position of H_0 field.
	SHA_H_H_0_Pos = 0x0
	// Bit mask of H_0 field.
	SHA_H_H_0_Msk = 0xffffffff

	// M_0: Message
	// Position of M_0 field.
	SHA_M_M_0_Pos = 0x0
	// Bit mask of M_0 field.
	SHA_M_M_0_Msk = 0xffffffff
)

// Constants for SYSTEM: Peripheral SYSTEM
const (
	// ROM_CTRL_0: System ROM configuration register 0
	// Position of ROM_FO field.
	SYSTEM_ROM_CTRL_0_ROM_FO_Pos = 0x0
	// Bit mask of ROM_FO field.
	SYSTEM_ROM_CTRL_0_ROM_FO_Msk = 0x3

	// ROM_CTRL_1: System ROM configuration register 1
	// Position of ROM_FORCE_PD field.
	SYSTEM_ROM_CTRL_1_ROM_FORCE_PD_Pos = 0x0
	// Bit mask of ROM_FORCE_PD field.
	SYSTEM_ROM_CTRL_1_ROM_FORCE_PD_Msk = 0x3
	// Position of ROM_FORCE_PU field.
	SYSTEM_ROM_CTRL_1_ROM_FORCE_PU_Pos = 0x2
	// Bit mask of ROM_FORCE_PU field.
	SYSTEM_ROM_CTRL_1_ROM_FORCE_PU_Msk = 0xc

	// SRAM_CTRL_0: System SRAM configuration register 0
	// Position of SRAM_FO field.
	SYSTEM_SRAM_CTRL_0_SRAM_FO_Pos = 0x0
	// Bit mask of SRAM_FO field.
	SYSTEM_SRAM_CTRL_0_SRAM_FO_Msk = 0x3fffff

	// SRAM_CTRL_1: System SRAM configuration register 1
	// Position of SRAM_FORCE_PD field.
	SYSTEM_SRAM_CTRL_1_SRAM_FORCE_PD_Pos = 0x0
	// Bit mask of SRAM_FORCE_PD field.
	SYSTEM_SRAM_CTRL_1_SRAM_FORCE_PD_Msk = 0x3fffff

	// CPU_PERI_CLK_EN: CPU peripheral clock enable register
	// Position of CLK_EN_DEDICATED_GPIO field.
	SYSTEM_CPU_PERI_CLK_EN_CLK_EN_DEDICATED_GPIO_Pos = 0x7
	// Bit mask of CLK_EN_DEDICATED_GPIO field.
	SYSTEM_CPU_PERI_CLK_EN_CLK_EN_DEDICATED_GPIO_Msk = 0x80
	// Bit CLK_EN_DEDICATED_GPIO.
	SYSTEM_CPU_PERI_CLK_EN_CLK_EN_DEDICATED_GPIO = 0x80

	// CPU_PERI_RST_EN: CPU peripheral reset register
	// Position of RST_EN_DEDICATED_GPIO field.
	SYSTEM_CPU_PERI_RST_EN_RST_EN_DEDICATED_GPIO_Pos = 0x7
	// Bit mask of RST_EN_DEDICATED_GPIO field.
	SYSTEM_CPU_PERI_RST_EN_RST_EN_DEDICATED_GPIO_Msk = 0x80
	// Bit RST_EN_DEDICATED_GPIO.
	SYSTEM_CPU_PERI_RST_EN_RST_EN_DEDICATED_GPIO = 0x80

	// CPU_PER_CONF: CPU peripheral clock configuration register
	// Position of CPUPERIOD_SEL field.
	SYSTEM_CPU_PER_CONF_CPUPERIOD_SEL_Pos = 0x0
	// Bit mask of CPUPERIOD_SEL field.
	SYSTEM_CPU_PER_CONF_CPUPERIOD_SEL_Msk = 0x3
	// Position of PLL_FREQ_SEL field.
	SYSTEM_CPU_PER_CONF_PLL_FREQ_SEL_Pos = 0x2
	// Bit mask of PLL_FREQ_SEL field.
	SYSTEM_CPU_PER_CONF_PLL_FREQ_SEL_Msk = 0x4
	// Bit PLL_FREQ_SEL.
	SYSTEM_CPU_PER_CONF_PLL_FREQ_SEL = 0x4
	// Position of CPU_WAIT_MODE_FORCE_ON field.
	SYSTEM_CPU_PER_CONF_CPU_WAIT_MODE_FORCE_ON_Pos = 0x3
	// Bit mask of CPU_WAIT_MODE_FORCE_ON field.
	SYSTEM_CPU_PER_CONF_CPU_WAIT_MODE_FORCE_ON_Msk = 0x8
	// Bit CPU_WAIT_MODE_FORCE_ON.
	SYSTEM_CPU_PER_CONF_CPU_WAIT_MODE_FORCE_ON = 0x8
	// Position of CPU_WAITI_DELAY_NUM field.
	SYSTEM_CPU_PER_CONF_CPU_WAITI_DELAY_NUM_Pos = 0x4
	// Bit mask of CPU_WAITI_DELAY_NUM field.
	SYSTEM_CPU_PER_CONF_CPU_WAITI_DELAY_NUM_Msk = 0xf0

	// JTAG_CTRL_0: JTAG configuration register 0
	// Position of CANCEL_EFUSE_DISABLE_JTAG_TEMPORARY_0 field.
	SYSTEM_JTAG_CTRL_0_CANCEL_EFUSE_DISABLE_JTAG_TEMPORARY_0_Pos = 0x0
	// Bit mask of CANCEL_EFUSE_DISABLE_JTAG_TEMPORARY_0 field.
	SYSTEM_JTAG_CTRL_0_CANCEL_EFUSE_DISABLE_JTAG_TEMPORARY_0_Msk = 0xffffffff

	// JTAG_CTRL_1: JTAG configuration register 1
	// Position of CANCEL_EFUSE_DISABLE_JTAG_TEMPORARY_1 field.
	SYSTEM_JTAG_CTRL_1_CANCEL_EFUSE_DISABLE_JTAG_TEMPORARY_1_Pos = 0x0
	// Bit mask of CANCEL_EFUSE_DISABLE_JTAG_TEMPORARY_1 field.
	SYSTEM_JTAG_CTRL_1_CANCEL_EFUSE_DISABLE_JTAG_TEMPORARY_1_Msk = 0xffffffff

	// JTAG_CTRL_2: JTAG configuration register 2
	// Position of CANCEL_EFUSE_DISABLE_JTAG_TEMPORARY_2 field.
	SYSTEM_JTAG_CTRL_2_CANCEL_EFUSE_DISABLE_JTAG_TEMPORARY_2_Pos = 0x0
	// Bit mask of CANCEL_EFUSE_DISABLE_JTAG_TEMPORARY_2 field.
	SYSTEM_JTAG_CTRL_2_CANCEL_EFUSE_DISABLE_JTAG_TEMPORARY_2_Msk = 0xffffffff

	// JTAG_CTRL_3: JTAG configuration register 3
	// Position of CANCEL_EFUSE_DISABLE_JTAG_TEMPORARY_3 field.
	SYSTEM_JTAG_CTRL_3_CANCEL_EFUSE_DISABLE_JTAG_TEMPORARY_3_Pos = 0x0
	// Bit mask of CANCEL_EFUSE_DISABLE_JTAG_TEMPORARY_3 field.
	SYSTEM_JTAG_CTRL_3_CANCEL_EFUSE_DISABLE_JTAG_TEMPORARY_3_Msk = 0xffffffff

	// JTAG_CTRL_4: JTAG configuration register 4
	// Position of CANCEL_EFUSE_DISABLE_JTAG_TEMPORARY_4 field.
	SYSTEM_JTAG_CTRL_4_CANCEL_EFUSE_DISABLE_JTAG_TEMPORARY_4_Pos = 0x0
	// Bit mask of CANCEL_EFUSE_DISABLE_JTAG_TEMPORARY_4 field.
	SYSTEM_JTAG_CTRL_4_CANCEL_EFUSE_DISABLE_JTAG_TEMPORARY_4_Msk = 0xffffffff

	// JTAG_CTRL_5: JTAG configuration register 5
	// Position of CANCEL_EFUSE_DISABLE_JTAG_TEMPORARY_5 field.
	SYSTEM_JTAG_CTRL_5_CANCEL_EFUSE_DISABLE_JTAG_TEMPORARY_5_Pos = 0x0
	// Bit mask of CANCEL_EFUSE_DISABLE_JTAG_TEMPORARY_5 field.
	SYSTEM_JTAG_CTRL_5_CANCEL_EFUSE_DISABLE_JTAG_TEMPORARY_5_Msk = 0xffffffff

	// JTAG_CTRL_6: JTAG configuration register 6
	// Position of CANCEL_EFUSE_DISABLE_JTAG_TEMPORARY_6 field.
	SYSTEM_JTAG_CTRL_6_CANCEL_EFUSE_DISABLE_JTAG_TEMPORARY_6_Pos = 0x0
	// Bit mask of CANCEL_EFUSE_DISABLE_JTAG_TEMPORARY_6 field.
	SYSTEM_JTAG_CTRL_6_CANCEL_EFUSE_DISABLE_JTAG_TEMPORARY_6_Msk = 0xffffffff

	// JTAG_CTRL_7: JTAG configuration register 7
	// Position of CANCEL_EFUSE_DISABLE_JTAG_TEMPORARY_7 field.
	SYSTEM_JTAG_CTRL_7_CANCEL_EFUSE_DISABLE_JTAG_TEMPORARY_7_Pos = 0x0
	// Bit mask of CANCEL_EFUSE_DISABLE_JTAG_TEMPORARY_7 field.
	SYSTEM_JTAG_CTRL_7_CANCEL_EFUSE_DISABLE_JTAG_TEMPORARY_7_Msk = 0xffffffff

	// MEM_PD_MASK: Memory power-related controlling register (under low-sleep)
	// Position of LSLP_MEM_PD_MASK field.
	SYSTEM_MEM_PD_MASK_LSLP_MEM_PD_MASK_Pos = 0x0
	// Bit mask of LSLP_MEM_PD_MASK field.
	SYSTEM_MEM_PD_MASK_LSLP_MEM_PD_MASK_Msk = 0x1
	// Bit LSLP_MEM_PD_MASK.
	SYSTEM_MEM_PD_MASK_LSLP_MEM_PD_MASK = 0x1

	// PERIP_CLK_EN0: System peripheral clock (for hardware accelerators) enable register
	// Position of TIMERS_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_TIMERS_CLK_EN_Pos = 0x0
	// Bit mask of TIMERS_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_TIMERS_CLK_EN_Msk = 0x1
	// Bit TIMERS_CLK_EN.
	SYSTEM_PERIP_CLK_EN0_TIMERS_CLK_EN = 0x1
	// Position of SPI01_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_SPI01_CLK_EN_Pos = 0x1
	// Bit mask of SPI01_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_SPI01_CLK_EN_Msk = 0x2
	// Bit SPI01_CLK_EN.
	SYSTEM_PERIP_CLK_EN0_SPI01_CLK_EN = 0x2
	// Position of UART_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_UART_CLK_EN_Pos = 0x2
	// Bit mask of UART_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_UART_CLK_EN_Msk = 0x4
	// Bit UART_CLK_EN.
	SYSTEM_PERIP_CLK_EN0_UART_CLK_EN = 0x4
	// Position of WDG_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_WDG_CLK_EN_Pos = 0x3
	// Bit mask of WDG_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_WDG_CLK_EN_Msk = 0x8
	// Bit WDG_CLK_EN.
	SYSTEM_PERIP_CLK_EN0_WDG_CLK_EN = 0x8
	// Position of I2S0_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_I2S0_CLK_EN_Pos = 0x4
	// Bit mask of I2S0_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_I2S0_CLK_EN_Msk = 0x10
	// Bit I2S0_CLK_EN.
	SYSTEM_PERIP_CLK_EN0_I2S0_CLK_EN = 0x10
	// Position of UART1_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_UART1_CLK_EN_Pos = 0x5
	// Bit mask of UART1_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_UART1_CLK_EN_Msk = 0x20
	// Bit UART1_CLK_EN.
	SYSTEM_PERIP_CLK_EN0_UART1_CLK_EN = 0x20
	// Position of SPI2_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_SPI2_CLK_EN_Pos = 0x6
	// Bit mask of SPI2_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_SPI2_CLK_EN_Msk = 0x40
	// Bit SPI2_CLK_EN.
	SYSTEM_PERIP_CLK_EN0_SPI2_CLK_EN = 0x40
	// Position of I2C_EXT0_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_I2C_EXT0_CLK_EN_Pos = 0x7
	// Bit mask of I2C_EXT0_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_I2C_EXT0_CLK_EN_Msk = 0x80
	// Bit I2C_EXT0_CLK_EN.
	SYSTEM_PERIP_CLK_EN0_I2C_EXT0_CLK_EN = 0x80
	// Position of UHCI0_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_UHCI0_CLK_EN_Pos = 0x8
	// Bit mask of UHCI0_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_UHCI0_CLK_EN_Msk = 0x100
	// Bit UHCI0_CLK_EN.
	SYSTEM_PERIP_CLK_EN0_UHCI0_CLK_EN = 0x100
	// Position of RMT_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_RMT_CLK_EN_Pos = 0x9
	// Bit mask of RMT_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_RMT_CLK_EN_Msk = 0x200
	// Bit RMT_CLK_EN.
	SYSTEM_PERIP_CLK_EN0_RMT_CLK_EN = 0x200
	// Position of PCNT_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_PCNT_CLK_EN_Pos = 0xa
	// Bit mask of PCNT_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_PCNT_CLK_EN_Msk = 0x400
	// Bit PCNT_CLK_EN.
	SYSTEM_PERIP_CLK_EN0_PCNT_CLK_EN = 0x400
	// Position of LEDC_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_LEDC_CLK_EN_Pos = 0xb
	// Bit mask of LEDC_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_LEDC_CLK_EN_Msk = 0x800
	// Bit LEDC_CLK_EN.
	SYSTEM_PERIP_CLK_EN0_LEDC_CLK_EN = 0x800
	// Position of UHCI1_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_UHCI1_CLK_EN_Pos = 0xc
	// Bit mask of UHCI1_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_UHCI1_CLK_EN_Msk = 0x1000
	// Bit UHCI1_CLK_EN.
	SYSTEM_PERIP_CLK_EN0_UHCI1_CLK_EN = 0x1000
	// Position of TIMERGROUP_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_TIMERGROUP_CLK_EN_Pos = 0xd
	// Bit mask of TIMERGROUP_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_TIMERGROUP_CLK_EN_Msk = 0x2000
	// Bit TIMERGROUP_CLK_EN.
	SYSTEM_PERIP_CLK_EN0_TIMERGROUP_CLK_EN = 0x2000
	// Position of EFUSE_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_EFUSE_CLK_EN_Pos = 0xe
	// Bit mask of EFUSE_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_EFUSE_CLK_EN_Msk = 0x4000
	// Bit EFUSE_CLK_EN.
	SYSTEM_PERIP_CLK_EN0_EFUSE_CLK_EN = 0x4000
	// Position of TIMERGROUP1_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_TIMERGROUP1_CLK_EN_Pos = 0xf
	// Bit mask of TIMERGROUP1_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_TIMERGROUP1_CLK_EN_Msk = 0x8000
	// Bit TIMERGROUP1_CLK_EN.
	SYSTEM_PERIP_CLK_EN0_TIMERGROUP1_CLK_EN = 0x8000
	// Position of SPI3_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_SPI3_CLK_EN_Pos = 0x10
	// Bit mask of SPI3_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_SPI3_CLK_EN_Msk = 0x10000
	// Bit SPI3_CLK_EN.
	SYSTEM_PERIP_CLK_EN0_SPI3_CLK_EN = 0x10000
	// Position of PWM0_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_PWM0_CLK_EN_Pos = 0x11
	// Bit mask of PWM0_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_PWM0_CLK_EN_Msk = 0x20000
	// Bit PWM0_CLK_EN.
	SYSTEM_PERIP_CLK_EN0_PWM0_CLK_EN = 0x20000
	// Position of I2C_EXT1_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_I2C_EXT1_CLK_EN_Pos = 0x12
	// Bit mask of I2C_EXT1_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_I2C_EXT1_CLK_EN_Msk = 0x40000
	// Bit I2C_EXT1_CLK_EN.
	SYSTEM_PERIP_CLK_EN0_I2C_EXT1_CLK_EN = 0x40000
	// Position of CAN_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_CAN_CLK_EN_Pos = 0x13
	// Bit mask of CAN_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_CAN_CLK_EN_Msk = 0x80000
	// Bit CAN_CLK_EN.
	SYSTEM_PERIP_CLK_EN0_CAN_CLK_EN = 0x80000
	// Position of PWM1_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_PWM1_CLK_EN_Pos = 0x14
	// Bit mask of PWM1_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_PWM1_CLK_EN_Msk = 0x100000
	// Bit PWM1_CLK_EN.
	SYSTEM_PERIP_CLK_EN0_PWM1_CLK_EN = 0x100000
	// Position of I2S1_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_I2S1_CLK_EN_Pos = 0x15
	// Bit mask of I2S1_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_I2S1_CLK_EN_Msk = 0x200000
	// Bit I2S1_CLK_EN.
	SYSTEM_PERIP_CLK_EN0_I2S1_CLK_EN = 0x200000
	// Position of SPI2_DMA_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_SPI2_DMA_CLK_EN_Pos = 0x16
	// Bit mask of SPI2_DMA_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_SPI2_DMA_CLK_EN_Msk = 0x400000
	// Bit SPI2_DMA_CLK_EN.
	SYSTEM_PERIP_CLK_EN0_SPI2_DMA_CLK_EN = 0x400000
	// Position of USB_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_USB_CLK_EN_Pos = 0x17
	// Bit mask of USB_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_USB_CLK_EN_Msk = 0x800000
	// Bit USB_CLK_EN.
	SYSTEM_PERIP_CLK_EN0_USB_CLK_EN = 0x800000
	// Position of UART_MEM_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_UART_MEM_CLK_EN_Pos = 0x18
	// Bit mask of UART_MEM_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_UART_MEM_CLK_EN_Msk = 0x1000000
	// Bit UART_MEM_CLK_EN.
	SYSTEM_PERIP_CLK_EN0_UART_MEM_CLK_EN = 0x1000000
	// Position of PWM2_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_PWM2_CLK_EN_Pos = 0x19
	// Bit mask of PWM2_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_PWM2_CLK_EN_Msk = 0x2000000
	// Bit PWM2_CLK_EN.
	SYSTEM_PERIP_CLK_EN0_PWM2_CLK_EN = 0x2000000
	// Position of PWM3_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_PWM3_CLK_EN_Pos = 0x1a
	// Bit mask of PWM3_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_PWM3_CLK_EN_Msk = 0x4000000
	// Bit PWM3_CLK_EN.
	SYSTEM_PERIP_CLK_EN0_PWM3_CLK_EN = 0x4000000
	// Position of SPI3_DMA_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_SPI3_DMA_CLK_EN_Pos = 0x1b
	// Bit mask of SPI3_DMA_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_SPI3_DMA_CLK_EN_Msk = 0x8000000
	// Bit SPI3_DMA_CLK_EN.
	SYSTEM_PERIP_CLK_EN0_SPI3_DMA_CLK_EN = 0x8000000
	// Position of APB_SARADC_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_APB_SARADC_CLK_EN_Pos = 0x1c
	// Bit mask of APB_SARADC_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_APB_SARADC_CLK_EN_Msk = 0x10000000
	// Bit APB_SARADC_CLK_EN.
	SYSTEM_PERIP_CLK_EN0_APB_SARADC_CLK_EN = 0x10000000
	// Position of SYSTIMER_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_SYSTIMER_CLK_EN_Pos = 0x1d
	// Bit mask of SYSTIMER_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_SYSTIMER_CLK_EN_Msk = 0x20000000
	// Bit SYSTIMER_CLK_EN.
	SYSTEM_PERIP_CLK_EN0_SYSTIMER_CLK_EN = 0x20000000
	// Position of ADC2_ARB_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_ADC2_ARB_CLK_EN_Pos = 0x1e
	// Bit mask of ADC2_ARB_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_ADC2_ARB_CLK_EN_Msk = 0x40000000
	// Bit ADC2_ARB_CLK_EN.
	SYSTEM_PERIP_CLK_EN0_ADC2_ARB_CLK_EN = 0x40000000
	// Position of SPI4_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_SPI4_CLK_EN_Pos = 0x1f
	// Bit mask of SPI4_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_SPI4_CLK_EN_Msk = 0x80000000
	// Bit SPI4_CLK_EN.
	SYSTEM_PERIP_CLK_EN0_SPI4_CLK_EN = 0x80000000

	// PERIP_CLK_EN1: System peripheral clock (for hardware accelerators) enable register 1
	// Position of CRYPTO_AES_CLK_EN field.
	SYSTEM_PERIP_CLK_EN1_CRYPTO_AES_CLK_EN_Pos = 0x1
	// Bit mask of CRYPTO_AES_CLK_EN field.
	SYSTEM_PERIP_CLK_EN1_CRYPTO_AES_CLK_EN_Msk = 0x2
	// Bit CRYPTO_AES_CLK_EN.
	SYSTEM_PERIP_CLK_EN1_CRYPTO_AES_CLK_EN = 0x2
	// Position of CRYPTO_SHA_CLK_EN field.
	SYSTEM_PERIP_CLK_EN1_CRYPTO_SHA_CLK_EN_Pos = 0x2
	// Bit mask of CRYPTO_SHA_CLK_EN field.
	SYSTEM_PERIP_CLK_EN1_CRYPTO_SHA_CLK_EN_Msk = 0x4
	// Bit CRYPTO_SHA_CLK_EN.
	SYSTEM_PERIP_CLK_EN1_CRYPTO_SHA_CLK_EN = 0x4
	// Position of CRYPTO_RSA_CLK_EN field.
	SYSTEM_PERIP_CLK_EN1_CRYPTO_RSA_CLK_EN_Pos = 0x3
	// Bit mask of CRYPTO_RSA_CLK_EN field.
	SYSTEM_PERIP_CLK_EN1_CRYPTO_RSA_CLK_EN_Msk = 0x8
	// Bit CRYPTO_RSA_CLK_EN.
	SYSTEM_PERIP_CLK_EN1_CRYPTO_RSA_CLK_EN = 0x8
	// Position of CRYPTO_DS_CLK_EN field.
	SYSTEM_PERIP_CLK_EN1_CRYPTO_DS_CLK_EN_Pos = 0x4
	// Bit mask of CRYPTO_DS_CLK_EN field.
	SYSTEM_PERIP_CLK_EN1_CRYPTO_DS_CLK_EN_Msk = 0x10
	// Bit CRYPTO_DS_CLK_EN.
	SYSTEM_PERIP_CLK_EN1_CRYPTO_DS_CLK_EN = 0x10
	// Position of CRYPTO_HMAC_CLK_EN field.
	SYSTEM_PERIP_CLK_EN1_CRYPTO_HMAC_CLK_EN_Pos = 0x5
	// Bit mask of CRYPTO_HMAC_CLK_EN field.
	SYSTEM_PERIP_CLK_EN1_CRYPTO_HMAC_CLK_EN_Msk = 0x20
	// Bit CRYPTO_HMAC_CLK_EN.
	SYSTEM_PERIP_CLK_EN1_CRYPTO_HMAC_CLK_EN = 0x20
	// Position of CRYPTO_DMA_CLK_EN field.
	SYSTEM_PERIP_CLK_EN1_CRYPTO_DMA_CLK_EN_Pos = 0x6
	// Bit mask of CRYPTO_DMA_CLK_EN field.
	SYSTEM_PERIP_CLK_EN1_CRYPTO_DMA_CLK_EN_Msk = 0x40
	// Bit CRYPTO_DMA_CLK_EN.
	SYSTEM_PERIP_CLK_EN1_CRYPTO_DMA_CLK_EN = 0x40

	// PERIP_RST_EN0: System peripheral (hardware accelerators) reset register 0
	// Position of TIMERS_RST field.
	SYSTEM_PERIP_RST_EN0_TIMERS_RST_Pos = 0x0
	// Bit mask of TIMERS_RST field.
	SYSTEM_PERIP_RST_EN0_TIMERS_RST_Msk = 0x1
	// Bit TIMERS_RST.
	SYSTEM_PERIP_RST_EN0_TIMERS_RST = 0x1
	// Position of SPI01_RST field.
	SYSTEM_PERIP_RST_EN0_SPI01_RST_Pos = 0x1
	// Bit mask of SPI01_RST field.
	SYSTEM_PERIP_RST_EN0_SPI01_RST_Msk = 0x2
	// Bit SPI01_RST.
	SYSTEM_PERIP_RST_EN0_SPI01_RST = 0x2
	// Position of UART_RST field.
	SYSTEM_PERIP_RST_EN0_UART_RST_Pos = 0x2
	// Bit mask of UART_RST field.
	SYSTEM_PERIP_RST_EN0_UART_RST_Msk = 0x4
	// Bit UART_RST.
	SYSTEM_PERIP_RST_EN0_UART_RST = 0x4
	// Position of WDG_RST field.
	SYSTEM_PERIP_RST_EN0_WDG_RST_Pos = 0x3
	// Bit mask of WDG_RST field.
	SYSTEM_PERIP_RST_EN0_WDG_RST_Msk = 0x8
	// Bit WDG_RST.
	SYSTEM_PERIP_RST_EN0_WDG_RST = 0x8
	// Position of I2S0_RST field.
	SYSTEM_PERIP_RST_EN0_I2S0_RST_Pos = 0x4
	// Bit mask of I2S0_RST field.
	SYSTEM_PERIP_RST_EN0_I2S0_RST_Msk = 0x10
	// Bit I2S0_RST.
	SYSTEM_PERIP_RST_EN0_I2S0_RST = 0x10
	// Position of UART1_RST field.
	SYSTEM_PERIP_RST_EN0_UART1_RST_Pos = 0x5
	// Bit mask of UART1_RST field.
	SYSTEM_PERIP_RST_EN0_UART1_RST_Msk = 0x20
	// Bit UART1_RST.
	SYSTEM_PERIP_RST_EN0_UART1_RST = 0x20
	// Position of SPI2_RST field.
	SYSTEM_PERIP_RST_EN0_SPI2_RST_Pos = 0x6
	// Bit mask of SPI2_RST field.
	SYSTEM_PERIP_RST_EN0_SPI2_RST_Msk = 0x40
	// Bit SPI2_RST.
	SYSTEM_PERIP_RST_EN0_SPI2_RST = 0x40
	// Position of I2C_EXT0_RST field.
	SYSTEM_PERIP_RST_EN0_I2C_EXT0_RST_Pos = 0x7
	// Bit mask of I2C_EXT0_RST field.
	SYSTEM_PERIP_RST_EN0_I2C_EXT0_RST_Msk = 0x80
	// Bit I2C_EXT0_RST.
	SYSTEM_PERIP_RST_EN0_I2C_EXT0_RST = 0x80
	// Position of UHCI0_RST field.
	SYSTEM_PERIP_RST_EN0_UHCI0_RST_Pos = 0x8
	// Bit mask of UHCI0_RST field.
	SYSTEM_PERIP_RST_EN0_UHCI0_RST_Msk = 0x100
	// Bit UHCI0_RST.
	SYSTEM_PERIP_RST_EN0_UHCI0_RST = 0x100
	// Position of RMT_RST field.
	SYSTEM_PERIP_RST_EN0_RMT_RST_Pos = 0x9
	// Bit mask of RMT_RST field.
	SYSTEM_PERIP_RST_EN0_RMT_RST_Msk = 0x200
	// Bit RMT_RST.
	SYSTEM_PERIP_RST_EN0_RMT_RST = 0x200
	// Position of PCNT_RST field.
	SYSTEM_PERIP_RST_EN0_PCNT_RST_Pos = 0xa
	// Bit mask of PCNT_RST field.
	SYSTEM_PERIP_RST_EN0_PCNT_RST_Msk = 0x400
	// Bit PCNT_RST.
	SYSTEM_PERIP_RST_EN0_PCNT_RST = 0x400
	// Position of LEDC_RST field.
	SYSTEM_PERIP_RST_EN0_LEDC_RST_Pos = 0xb
	// Bit mask of LEDC_RST field.
	SYSTEM_PERIP_RST_EN0_LEDC_RST_Msk = 0x800
	// Bit LEDC_RST.
	SYSTEM_PERIP_RST_EN0_LEDC_RST = 0x800
	// Position of UHCI1_RST field.
	SYSTEM_PERIP_RST_EN0_UHCI1_RST_Pos = 0xc
	// Bit mask of UHCI1_RST field.
	SYSTEM_PERIP_RST_EN0_UHCI1_RST_Msk = 0x1000
	// Bit UHCI1_RST.
	SYSTEM_PERIP_RST_EN0_UHCI1_RST = 0x1000
	// Position of TIMERGROUP_RST field.
	SYSTEM_PERIP_RST_EN0_TIMERGROUP_RST_Pos = 0xd
	// Bit mask of TIMERGROUP_RST field.
	SYSTEM_PERIP_RST_EN0_TIMERGROUP_RST_Msk = 0x2000
	// Bit TIMERGROUP_RST.
	SYSTEM_PERIP_RST_EN0_TIMERGROUP_RST = 0x2000
	// Position of EFUSE_RST field.
	SYSTEM_PERIP_RST_EN0_EFUSE_RST_Pos = 0xe
	// Bit mask of EFUSE_RST field.
	SYSTEM_PERIP_RST_EN0_EFUSE_RST_Msk = 0x4000
	// Bit EFUSE_RST.
	SYSTEM_PERIP_RST_EN0_EFUSE_RST = 0x4000
	// Position of TIMERGROUP1_RST field.
	SYSTEM_PERIP_RST_EN0_TIMERGROUP1_RST_Pos = 0xf
	// Bit mask of TIMERGROUP1_RST field.
	SYSTEM_PERIP_RST_EN0_TIMERGROUP1_RST_Msk = 0x8000
	// Bit TIMERGROUP1_RST.
	SYSTEM_PERIP_RST_EN0_TIMERGROUP1_RST = 0x8000
	// Position of SPI3_RST field.
	SYSTEM_PERIP_RST_EN0_SPI3_RST_Pos = 0x10
	// Bit mask of SPI3_RST field.
	SYSTEM_PERIP_RST_EN0_SPI3_RST_Msk = 0x10000
	// Bit SPI3_RST.
	SYSTEM_PERIP_RST_EN0_SPI3_RST = 0x10000
	// Position of PWM0_RST field.
	SYSTEM_PERIP_RST_EN0_PWM0_RST_Pos = 0x11
	// Bit mask of PWM0_RST field.
	SYSTEM_PERIP_RST_EN0_PWM0_RST_Msk = 0x20000
	// Bit PWM0_RST.
	SYSTEM_PERIP_RST_EN0_PWM0_RST = 0x20000
	// Position of I2C_EXT1_RST field.
	SYSTEM_PERIP_RST_EN0_I2C_EXT1_RST_Pos = 0x12
	// Bit mask of I2C_EXT1_RST field.
	SYSTEM_PERIP_RST_EN0_I2C_EXT1_RST_Msk = 0x40000
	// Bit I2C_EXT1_RST.
	SYSTEM_PERIP_RST_EN0_I2C_EXT1_RST = 0x40000
	// Position of CAN_RST field.
	SYSTEM_PERIP_RST_EN0_CAN_RST_Pos = 0x13
	// Bit mask of CAN_RST field.
	SYSTEM_PERIP_RST_EN0_CAN_RST_Msk = 0x80000
	// Bit CAN_RST.
	SYSTEM_PERIP_RST_EN0_CAN_RST = 0x80000
	// Position of PWM1_RST field.
	SYSTEM_PERIP_RST_EN0_PWM1_RST_Pos = 0x14
	// Bit mask of PWM1_RST field.
	SYSTEM_PERIP_RST_EN0_PWM1_RST_Msk = 0x100000
	// Bit PWM1_RST.
	SYSTEM_PERIP_RST_EN0_PWM1_RST = 0x100000
	// Position of I2S1_RST field.
	SYSTEM_PERIP_RST_EN0_I2S1_RST_Pos = 0x15
	// Bit mask of I2S1_RST field.
	SYSTEM_PERIP_RST_EN0_I2S1_RST_Msk = 0x200000
	// Bit I2S1_RST.
	SYSTEM_PERIP_RST_EN0_I2S1_RST = 0x200000
	// Position of SPI2_DMA_RST field.
	SYSTEM_PERIP_RST_EN0_SPI2_DMA_RST_Pos = 0x16
	// Bit mask of SPI2_DMA_RST field.
	SYSTEM_PERIP_RST_EN0_SPI2_DMA_RST_Msk = 0x400000
	// Bit SPI2_DMA_RST.
	SYSTEM_PERIP_RST_EN0_SPI2_DMA_RST = 0x400000
	// Position of USB_RST field.
	SYSTEM_PERIP_RST_EN0_USB_RST_Pos = 0x17
	// Bit mask of USB_RST field.
	SYSTEM_PERIP_RST_EN0_USB_RST_Msk = 0x800000
	// Bit USB_RST.
	SYSTEM_PERIP_RST_EN0_USB_RST = 0x800000
	// Position of UART_MEM_RST field.
	SYSTEM_PERIP_RST_EN0_UART_MEM_RST_Pos = 0x18
	// Bit mask of UART_MEM_RST field.
	SYSTEM_PERIP_RST_EN0_UART_MEM_RST_Msk = 0x1000000
	// Bit UART_MEM_RST.
	SYSTEM_PERIP_RST_EN0_UART_MEM_RST = 0x1000000
	// Position of PWM2_RST field.
	SYSTEM_PERIP_RST_EN0_PWM2_RST_Pos = 0x19
	// Bit mask of PWM2_RST field.
	SYSTEM_PERIP_RST_EN0_PWM2_RST_Msk = 0x2000000
	// Bit PWM2_RST.
	SYSTEM_PERIP_RST_EN0_PWM2_RST = 0x2000000
	// Position of PWM3_RST field.
	SYSTEM_PERIP_RST_EN0_PWM3_RST_Pos = 0x1a
	// Bit mask of PWM3_RST field.
	SYSTEM_PERIP_RST_EN0_PWM3_RST_Msk = 0x4000000
	// Bit PWM3_RST.
	SYSTEM_PERIP_RST_EN0_PWM3_RST = 0x4000000
	// Position of SPI3_DMA_RST field.
	SYSTEM_PERIP_RST_EN0_SPI3_DMA_RST_Pos = 0x1b
	// Bit mask of SPI3_DMA_RST field.
	SYSTEM_PERIP_RST_EN0_SPI3_DMA_RST_Msk = 0x8000000
	// Bit SPI3_DMA_RST.
	SYSTEM_PERIP_RST_EN0_SPI3_DMA_RST = 0x8000000
	// Position of APB_SARADC_RST field.
	SYSTEM_PERIP_RST_EN0_APB_SARADC_RST_Pos = 0x1c
	// Bit mask of APB_SARADC_RST field.
	SYSTEM_PERIP_RST_EN0_APB_SARADC_RST_Msk = 0x10000000
	// Bit APB_SARADC_RST.
	SYSTEM_PERIP_RST_EN0_APB_SARADC_RST = 0x10000000
	// Position of SYSTIMER_RST field.
	SYSTEM_PERIP_RST_EN0_SYSTIMER_RST_Pos = 0x1d
	// Bit mask of SYSTIMER_RST field.
	SYSTEM_PERIP_RST_EN0_SYSTIMER_RST_Msk = 0x20000000
	// Bit SYSTIMER_RST.
	SYSTEM_PERIP_RST_EN0_SYSTIMER_RST = 0x20000000
	// Position of ADC2_ARB_RST field.
	SYSTEM_PERIP_RST_EN0_ADC2_ARB_RST_Pos = 0x1e
	// Bit mask of ADC2_ARB_RST field.
	SYSTEM_PERIP_RST_EN0_ADC2_ARB_RST_Msk = 0x40000000
	// Bit ADC2_ARB_RST.
	SYSTEM_PERIP_RST_EN0_ADC2_ARB_RST = 0x40000000
	// Position of SPI4_RST field.
	SYSTEM_PERIP_RST_EN0_SPI4_RST_Pos = 0x1f
	// Bit mask of SPI4_RST field.
	SYSTEM_PERIP_RST_EN0_SPI4_RST_Msk = 0x80000000
	// Bit SPI4_RST.
	SYSTEM_PERIP_RST_EN0_SPI4_RST = 0x80000000

	// PERIP_RST_EN1: System peripheral (hardware accelerators) reset register 1
	// Position of CRYPTO_AES_RST field.
	SYSTEM_PERIP_RST_EN1_CRYPTO_AES_RST_Pos = 0x1
	// Bit mask of CRYPTO_AES_RST field.
	SYSTEM_PERIP_RST_EN1_CRYPTO_AES_RST_Msk = 0x2
	// Bit CRYPTO_AES_RST.
	SYSTEM_PERIP_RST_EN1_CRYPTO_AES_RST = 0x2
	// Position of CRYPTO_SHA_RST field.
	SYSTEM_PERIP_RST_EN1_CRYPTO_SHA_RST_Pos = 0x2
	// Bit mask of CRYPTO_SHA_RST field.
	SYSTEM_PERIP_RST_EN1_CRYPTO_SHA_RST_Msk = 0x4
	// Bit CRYPTO_SHA_RST.
	SYSTEM_PERIP_RST_EN1_CRYPTO_SHA_RST = 0x4
	// Position of CRYPTO_RSA_RST field.
	SYSTEM_PERIP_RST_EN1_CRYPTO_RSA_RST_Pos = 0x3
	// Bit mask of CRYPTO_RSA_RST field.
	SYSTEM_PERIP_RST_EN1_CRYPTO_RSA_RST_Msk = 0x8
	// Bit CRYPTO_RSA_RST.
	SYSTEM_PERIP_RST_EN1_CRYPTO_RSA_RST = 0x8
	// Position of CRYPTO_DS_RST field.
	SYSTEM_PERIP_RST_EN1_CRYPTO_DS_RST_Pos = 0x4
	// Bit mask of CRYPTO_DS_RST field.
	SYSTEM_PERIP_RST_EN1_CRYPTO_DS_RST_Msk = 0x10
	// Bit CRYPTO_DS_RST.
	SYSTEM_PERIP_RST_EN1_CRYPTO_DS_RST = 0x10
	// Position of CRYPTO_HMAC_RST field.
	SYSTEM_PERIP_RST_EN1_CRYPTO_HMAC_RST_Pos = 0x5
	// Bit mask of CRYPTO_HMAC_RST field.
	SYSTEM_PERIP_RST_EN1_CRYPTO_HMAC_RST_Msk = 0x20
	// Bit CRYPTO_HMAC_RST.
	SYSTEM_PERIP_RST_EN1_CRYPTO_HMAC_RST = 0x20
	// Position of CRYPTO_DMA_RST field.
	SYSTEM_PERIP_RST_EN1_CRYPTO_DMA_RST_Pos = 0x6
	// Bit mask of CRYPTO_DMA_RST field.
	SYSTEM_PERIP_RST_EN1_CRYPTO_DMA_RST_Msk = 0x40
	// Bit CRYPTO_DMA_RST.
	SYSTEM_PERIP_RST_EN1_CRYPTO_DMA_RST = 0x40

	// LPCK_DIV_INT: Low power clock divider integer register
	// Position of LPCK_DIV_NUM field.
	SYSTEM_LPCK_DIV_INT_LPCK_DIV_NUM_Pos = 0x0
	// Bit mask of LPCK_DIV_NUM field.
	SYSTEM_LPCK_DIV_INT_LPCK_DIV_NUM_Msk = 0xfff

	// BT_LPCK_DIV_FRAC: Divider fraction configuration register for low-power clock
	// Position of LPCLK_SEL_RTC_SLOW field.
	SYSTEM_BT_LPCK_DIV_FRAC_LPCLK_SEL_RTC_SLOW_Pos = 0x18
	// Bit mask of LPCLK_SEL_RTC_SLOW field.
	SYSTEM_BT_LPCK_DIV_FRAC_LPCLK_SEL_RTC_SLOW_Msk = 0x1000000
	// Bit LPCLK_SEL_RTC_SLOW.
	SYSTEM_BT_LPCK_DIV_FRAC_LPCLK_SEL_RTC_SLOW = 0x1000000
	// Position of LPCLK_SEL_8M field.
	SYSTEM_BT_LPCK_DIV_FRAC_LPCLK_SEL_8M_Pos = 0x19
	// Bit mask of LPCLK_SEL_8M field.
	SYSTEM_BT_LPCK_DIV_FRAC_LPCLK_SEL_8M_Msk = 0x2000000
	// Bit LPCLK_SEL_8M.
	SYSTEM_BT_LPCK_DIV_FRAC_LPCLK_SEL_8M = 0x2000000
	// Position of LPCLK_SEL_XTAL field.
	SYSTEM_BT_LPCK_DIV_FRAC_LPCLK_SEL_XTAL_Pos = 0x1a
	// Bit mask of LPCLK_SEL_XTAL field.
	SYSTEM_BT_LPCK_DIV_FRAC_LPCLK_SEL_XTAL_Msk = 0x4000000
	// Bit LPCLK_SEL_XTAL.
	SYSTEM_BT_LPCK_DIV_FRAC_LPCLK_SEL_XTAL = 0x4000000
	// Position of LPCLK_SEL_XTAL32K field.
	SYSTEM_BT_LPCK_DIV_FRAC_LPCLK_SEL_XTAL32K_Pos = 0x1b
	// Bit mask of LPCLK_SEL_XTAL32K field.
	SYSTEM_BT_LPCK_DIV_FRAC_LPCLK_SEL_XTAL32K_Msk = 0x8000000
	// Bit LPCLK_SEL_XTAL32K.
	SYSTEM_BT_LPCK_DIV_FRAC_LPCLK_SEL_XTAL32K = 0x8000000
	// Position of LPCLK_RTC_EN field.
	SYSTEM_BT_LPCK_DIV_FRAC_LPCLK_RTC_EN_Pos = 0x1c
	// Bit mask of LPCLK_RTC_EN field.
	SYSTEM_BT_LPCK_DIV_FRAC_LPCLK_RTC_EN_Msk = 0x10000000
	// Bit LPCLK_RTC_EN.
	SYSTEM_BT_LPCK_DIV_FRAC_LPCLK_RTC_EN = 0x10000000

	// CPU_INTR_FROM_CPU_0: CPU interrupt controlling register 0
	// Position of CPU_INTR_FROM_CPU_0 field.
	SYSTEM_CPU_INTR_FROM_CPU_0_CPU_INTR_FROM_CPU_0_Pos = 0x0
	// Bit mask of CPU_INTR_FROM_CPU_0 field.
	SYSTEM_CPU_INTR_FROM_CPU_0_CPU_INTR_FROM_CPU_0_Msk = 0x1
	// Bit CPU_INTR_FROM_CPU_0.
	SYSTEM_CPU_INTR_FROM_CPU_0_CPU_INTR_FROM_CPU_0 = 0x1

	// CPU_INTR_FROM_CPU_1: CPU interrupt controlling register 1
	// Position of CPU_INTR_FROM_CPU_1 field.
	SYSTEM_CPU_INTR_FROM_CPU_1_CPU_INTR_FROM_CPU_1_Pos = 0x0
	// Bit mask of CPU_INTR_FROM_CPU_1 field.
	SYSTEM_CPU_INTR_FROM_CPU_1_CPU_INTR_FROM_CPU_1_Msk = 0x1
	// Bit CPU_INTR_FROM_CPU_1.
	SYSTEM_CPU_INTR_FROM_CPU_1_CPU_INTR_FROM_CPU_1 = 0x1

	// CPU_INTR_FROM_CPU_2: CPU interrupt controlling register 2
	// Position of CPU_INTR_FROM_CPU_2 field.
	SYSTEM_CPU_INTR_FROM_CPU_2_CPU_INTR_FROM_CPU_2_Pos = 0x0
	// Bit mask of CPU_INTR_FROM_CPU_2 field.
	SYSTEM_CPU_INTR_FROM_CPU_2_CPU_INTR_FROM_CPU_2_Msk = 0x1
	// Bit CPU_INTR_FROM_CPU_2.
	SYSTEM_CPU_INTR_FROM_CPU_2_CPU_INTR_FROM_CPU_2 = 0x1

	// CPU_INTR_FROM_CPU_3: CPU interrupt controlling register 3
	// Position of CPU_INTR_FROM_CPU_3 field.
	SYSTEM_CPU_INTR_FROM_CPU_3_CPU_INTR_FROM_CPU_3_Pos = 0x0
	// Bit mask of CPU_INTR_FROM_CPU_3 field.
	SYSTEM_CPU_INTR_FROM_CPU_3_CPU_INTR_FROM_CPU_3_Msk = 0x1
	// Bit CPU_INTR_FROM_CPU_3.
	SYSTEM_CPU_INTR_FROM_CPU_3_CPU_INTR_FROM_CPU_3 = 0x1

	// RSA_PD_CTRL: RSA memory remapping register
	// Position of RSA_MEM_PD field.
	SYSTEM_RSA_PD_CTRL_RSA_MEM_PD_Pos = 0x0
	// Bit mask of RSA_MEM_PD field.
	SYSTEM_RSA_PD_CTRL_RSA_MEM_PD_Msk = 0x1
	// Bit RSA_MEM_PD.
	SYSTEM_RSA_PD_CTRL_RSA_MEM_PD = 0x1
	// Position of RSA_MEM_FORCE_PU field.
	SYSTEM_RSA_PD_CTRL_RSA_MEM_FORCE_PU_Pos = 0x1
	// Bit mask of RSA_MEM_FORCE_PU field.
	SYSTEM_RSA_PD_CTRL_RSA_MEM_FORCE_PU_Msk = 0x2
	// Bit RSA_MEM_FORCE_PU.
	SYSTEM_RSA_PD_CTRL_RSA_MEM_FORCE_PU = 0x2
	// Position of RSA_MEM_FORCE_PD field.
	SYSTEM_RSA_PD_CTRL_RSA_MEM_FORCE_PD_Pos = 0x2
	// Bit mask of RSA_MEM_FORCE_PD field.
	SYSTEM_RSA_PD_CTRL_RSA_MEM_FORCE_PD_Msk = 0x4
	// Bit RSA_MEM_FORCE_PD.
	SYSTEM_RSA_PD_CTRL_RSA_MEM_FORCE_PD = 0x4

	// BUSTOEXTMEM_ENA: EDMA enable register
	// Position of BUSTOEXTMEM_ENA field.
	SYSTEM_BUSTOEXTMEM_ENA_BUSTOEXTMEM_ENA_Pos = 0x0
	// Bit mask of BUSTOEXTMEM_ENA field.
	SYSTEM_BUSTOEXTMEM_ENA_BUSTOEXTMEM_ENA_Msk = 0x1
	// Bit BUSTOEXTMEM_ENA.
	SYSTEM_BUSTOEXTMEM_ENA_BUSTOEXTMEM_ENA = 0x1

	// CACHE_CONTROL: Cache control register
	// Position of PRO_ICACHE_CLK_ON field.
	SYSTEM_CACHE_CONTROL_PRO_ICACHE_CLK_ON_Pos = 0x0
	// Bit mask of PRO_ICACHE_CLK_ON field.
	SYSTEM_CACHE_CONTROL_PRO_ICACHE_CLK_ON_Msk = 0x1
	// Bit PRO_ICACHE_CLK_ON.
	SYSTEM_CACHE_CONTROL_PRO_ICACHE_CLK_ON = 0x1
	// Position of PRO_DCACHE_CLK_ON field.
	SYSTEM_CACHE_CONTROL_PRO_DCACHE_CLK_ON_Pos = 0x1
	// Bit mask of PRO_DCACHE_CLK_ON field.
	SYSTEM_CACHE_CONTROL_PRO_DCACHE_CLK_ON_Msk = 0x2
	// Bit PRO_DCACHE_CLK_ON.
	SYSTEM_CACHE_CONTROL_PRO_DCACHE_CLK_ON = 0x2
	// Position of PRO_CACHE_RESET field.
	SYSTEM_CACHE_CONTROL_PRO_CACHE_RESET_Pos = 0x2
	// Bit mask of PRO_CACHE_RESET field.
	SYSTEM_CACHE_CONTROL_PRO_CACHE_RESET_Msk = 0x4
	// Bit PRO_CACHE_RESET.
	SYSTEM_CACHE_CONTROL_PRO_CACHE_RESET = 0x4

	// EXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL: External memory encrypt and decrypt controlling register
	// Position of ENABLE_SPI_MANUAL_ENCRYPT field.
	SYSTEM_EXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL_ENABLE_SPI_MANUAL_ENCRYPT_Pos = 0x0
	// Bit mask of ENABLE_SPI_MANUAL_ENCRYPT field.
	SYSTEM_EXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL_ENABLE_SPI_MANUAL_ENCRYPT_Msk = 0x1
	// Bit ENABLE_SPI_MANUAL_ENCRYPT.
	SYSTEM_EXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL_ENABLE_SPI_MANUAL_ENCRYPT = 0x1
	// Position of ENABLE_DOWNLOAD_DB_ENCRYPT field.
	SYSTEM_EXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL_ENABLE_DOWNLOAD_DB_ENCRYPT_Pos = 0x1
	// Bit mask of ENABLE_DOWNLOAD_DB_ENCRYPT field.
	SYSTEM_EXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL_ENABLE_DOWNLOAD_DB_ENCRYPT_Msk = 0x2
	// Bit ENABLE_DOWNLOAD_DB_ENCRYPT.
	SYSTEM_EXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL_ENABLE_DOWNLOAD_DB_ENCRYPT = 0x2
	// Position of ENABLE_DOWNLOAD_G0CB_DECRYPT field.
	SYSTEM_EXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL_ENABLE_DOWNLOAD_G0CB_DECRYPT_Pos = 0x2
	// Bit mask of ENABLE_DOWNLOAD_G0CB_DECRYPT field.
	SYSTEM_EXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL_ENABLE_DOWNLOAD_G0CB_DECRYPT_Msk = 0x4
	// Bit ENABLE_DOWNLOAD_G0CB_DECRYPT.
	SYSTEM_EXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL_ENABLE_DOWNLOAD_G0CB_DECRYPT = 0x4
	// Position of ENABLE_DOWNLOAD_MANUAL_ENCRYPT field.
	SYSTEM_EXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL_ENABLE_DOWNLOAD_MANUAL_ENCRYPT_Pos = 0x3
	// Bit mask of ENABLE_DOWNLOAD_MANUAL_ENCRYPT field.
	SYSTEM_EXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL_ENABLE_DOWNLOAD_MANUAL_ENCRYPT_Msk = 0x8
	// Bit ENABLE_DOWNLOAD_MANUAL_ENCRYPT.
	SYSTEM_EXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL_ENABLE_DOWNLOAD_MANUAL_ENCRYPT = 0x8

	// RTC_FASTMEM_CONFIG: RTC fast memory configuration register
	// Position of RTC_MEM_CRC_START field.
	SYSTEM_RTC_FASTMEM_CONFIG_RTC_MEM_CRC_START_Pos = 0x8
	// Bit mask of RTC_MEM_CRC_START field.
	SYSTEM_RTC_FASTMEM_CONFIG_RTC_MEM_CRC_START_Msk = 0x100
	// Bit RTC_MEM_CRC_START.
	SYSTEM_RTC_FASTMEM_CONFIG_RTC_MEM_CRC_START = 0x100
	// Position of RTC_MEM_CRC_ADDR field.
	SYSTEM_RTC_FASTMEM_CONFIG_RTC_MEM_CRC_ADDR_Pos = 0x9
	// Bit mask of RTC_MEM_CRC_ADDR field.
	SYSTEM_RTC_FASTMEM_CONFIG_RTC_MEM_CRC_ADDR_Msk = 0xffe00
	// Position of RTC_MEM_CRC_LEN field.
	SYSTEM_RTC_FASTMEM_CONFIG_RTC_MEM_CRC_LEN_Pos = 0x14
	// Bit mask of RTC_MEM_CRC_LEN field.
	SYSTEM_RTC_FASTMEM_CONFIG_RTC_MEM_CRC_LEN_Msk = 0x7ff00000
	// Position of RTC_MEM_CRC_FINISH field.
	SYSTEM_RTC_FASTMEM_CONFIG_RTC_MEM_CRC_FINISH_Pos = 0x1f
	// Bit mask of RTC_MEM_CRC_FINISH field.
	SYSTEM_RTC_FASTMEM_CONFIG_RTC_MEM_CRC_FINISH_Msk = 0x80000000
	// Bit RTC_MEM_CRC_FINISH.
	SYSTEM_RTC_FASTMEM_CONFIG_RTC_MEM_CRC_FINISH = 0x80000000

	// RTC_FASTMEM_CRC: RTC fast memory CRC controlling register
	// Position of RTC_MEM_CRC_RES field.
	SYSTEM_RTC_FASTMEM_CRC_RTC_MEM_CRC_RES_Pos = 0x0
	// Bit mask of RTC_MEM_CRC_RES field.
	SYSTEM_RTC_FASTMEM_CRC_RTC_MEM_CRC_RES_Msk = 0xffffffff

	// Redundant_ECO_Ctrl: Redundant ECO control register
	// Position of REDUNDANT_ECO_DRIVE field.
	SYSTEM_Redundant_ECO_Ctrl_REDUNDANT_ECO_DRIVE_Pos = 0x0
	// Bit mask of REDUNDANT_ECO_DRIVE field.
	SYSTEM_Redundant_ECO_Ctrl_REDUNDANT_ECO_DRIVE_Msk = 0x1
	// Bit REDUNDANT_ECO_DRIVE.
	SYSTEM_Redundant_ECO_Ctrl_REDUNDANT_ECO_DRIVE = 0x1
	// Position of REDUNDANT_ECO_RESULT field.
	SYSTEM_Redundant_ECO_Ctrl_REDUNDANT_ECO_RESULT_Pos = 0x1
	// Bit mask of REDUNDANT_ECO_RESULT field.
	SYSTEM_Redundant_ECO_Ctrl_REDUNDANT_ECO_RESULT_Msk = 0x2
	// Bit REDUNDANT_ECO_RESULT.
	SYSTEM_Redundant_ECO_Ctrl_REDUNDANT_ECO_RESULT = 0x2

	// CLOCK_GATE: Clock gate control register
	// Position of CLK_EN field.
	SYSTEM_CLOCK_GATE_CLK_EN_Pos = 0x0
	// Bit mask of CLK_EN field.
	SYSTEM_CLOCK_GATE_CLK_EN_Msk = 0x1
	// Bit CLK_EN.
	SYSTEM_CLOCK_GATE_CLK_EN = 0x1

	// SRAM_CTRL_2: System SRAM configuration register 2
	// Position of SRAM_FORCE_PU field.
	SYSTEM_SRAM_CTRL_2_SRAM_FORCE_PU_Pos = 0x0
	// Bit mask of SRAM_FORCE_PU field.
	SYSTEM_SRAM_CTRL_2_SRAM_FORCE_PU_Msk = 0x3fffff

	// SYSCLK_CONF: SoC clock configuration register
	// Position of PRE_DIV_CNT field.
	SYSTEM_SYSCLK_CONF_PRE_DIV_CNT_Pos = 0x0
	// Bit mask of PRE_DIV_CNT field.
	SYSTEM_SYSCLK_CONF_PRE_DIV_CNT_Msk = 0x3ff
	// Position of SOC_CLK_SEL field.
	SYSTEM_SYSCLK_CONF_SOC_CLK_SEL_Pos = 0xa
	// Bit mask of SOC_CLK_SEL field.
	SYSTEM_SYSCLK_CONF_SOC_CLK_SEL_Msk = 0xc00
	// Position of CLK_XTAL_FREQ field.
	SYSTEM_SYSCLK_CONF_CLK_XTAL_FREQ_Pos = 0xc
	// Bit mask of CLK_XTAL_FREQ field.
	SYSTEM_SYSCLK_CONF_CLK_XTAL_FREQ_Msk = 0x7f000
	// Position of CLK_DIV_EN field.
	SYSTEM_SYSCLK_CONF_CLK_DIV_EN_Pos = 0x13
	// Bit mask of CLK_DIV_EN field.
	SYSTEM_SYSCLK_CONF_CLK_DIV_EN_Msk = 0x80000
	// Bit CLK_DIV_EN.
	SYSTEM_SYSCLK_CONF_CLK_DIV_EN = 0x80000

	// REG_DATE: Version control register
	// Position of SYSTEM_REG_DATE field.
	SYSTEM_REG_DATE_SYSTEM_REG_DATE_Pos = 0x0
	// Bit mask of SYSTEM_REG_DATE field.
	SYSTEM_REG_DATE_SYSTEM_REG_DATE_Msk = 0xfffffff
)

// Constants for SYSTIMER: Peripheral SYSTIMER
const (
	// CONF: Configure system timer clock
	// Position of CLK_FO field.
	SYSTIMER_CONF_CLK_FO_Pos = 0x0
	// Bit mask of CLK_FO field.
	SYSTIMER_CONF_CLK_FO_Msk = 0x1
	// Bit CLK_FO.
	SYSTIMER_CONF_CLK_FO = 0x1
	// Position of CLK_EN field.
	SYSTIMER_CONF_CLK_EN_Pos = 0x1f
	// Bit mask of CLK_EN field.
	SYSTIMER_CONF_CLK_EN_Msk = 0x80000000
	// Bit CLK_EN.
	SYSTIMER_CONF_CLK_EN = 0x80000000

	// LOAD: Load value to system timer
	// Position of TIMER_LOAD field.
	SYSTIMER_LOAD_TIMER_LOAD_Pos = 0x1f
	// Bit mask of TIMER_LOAD field.
	SYSTIMER_LOAD_TIMER_LOAD_Msk = 0x80000000
	// Bit TIMER_LOAD.
	SYSTIMER_LOAD_TIMER_LOAD = 0x80000000

	// LOAD_HI: High 32 bits to be loaded to system timer
	// Position of TIMER_LOAD_HI field.
	SYSTIMER_LOAD_HI_TIMER_LOAD_HI_Pos = 0x0
	// Bit mask of TIMER_LOAD_HI field.
	SYSTIMER_LOAD_HI_TIMER_LOAD_HI_Msk = 0xffffffff

	// LOAD_LO: Low 32 bits to be loaded to system timer
	// Position of TIMER_LOAD_LO field.
	SYSTIMER_LOAD_LO_TIMER_LOAD_LO_Pos = 0x0
	// Bit mask of TIMER_LOAD_LO field.
	SYSTIMER_LOAD_LO_TIMER_LOAD_LO_Msk = 0xffffffff

	// STEP: System timer accumulation step
	// Position of TIMER_XTAL_STEP field.
	SYSTIMER_STEP_TIMER_XTAL_STEP_Pos = 0x0
	// Bit mask of TIMER_XTAL_STEP field.
	SYSTIMER_STEP_TIMER_XTAL_STEP_Msk = 0x3ff
	// Position of TIMER_PLL_STEP field.
	SYSTIMER_STEP_TIMER_PLL_STEP_Pos = 0xa
	// Bit mask of TIMER_PLL_STEP field.
	SYSTIMER_STEP_TIMER_PLL_STEP_Msk = 0xffc00

	// TARGET0_HI: System timer target 0, high 32 bits
	// Position of TIMER_TARGET0_HI field.
	SYSTIMER_TARGET0_HI_TIMER_TARGET0_HI_Pos = 0x0
	// Bit mask of TIMER_TARGET0_HI field.
	SYSTIMER_TARGET0_HI_TIMER_TARGET0_HI_Msk = 0xffffffff

	// TARGET0_LO: System timer target 0, low 32 bits
	// Position of TIMER_TARGET0_LO field.
	SYSTIMER_TARGET0_LO_TIMER_TARGET0_LO_Pos = 0x0
	// Bit mask of TIMER_TARGET0_LO field.
	SYSTIMER_TARGET0_LO_TIMER_TARGET0_LO_Msk = 0xffffffff

	// TARGET1_HI: System timer target 1, high 32 bits
	// Position of TIMER_TARGET1_HI field.
	SYSTIMER_TARGET1_HI_TIMER_TARGET1_HI_Pos = 0x0
	// Bit mask of TIMER_TARGET1_HI field.
	SYSTIMER_TARGET1_HI_TIMER_TARGET1_HI_Msk = 0xffffffff

	// TARGET1_LO: System timer target 1, low 32 bits
	// Position of TIMER_TARGET1_LO field.
	SYSTIMER_TARGET1_LO_TIMER_TARGET1_LO_Pos = 0x0
	// Bit mask of TIMER_TARGET1_LO field.
	SYSTIMER_TARGET1_LO_TIMER_TARGET1_LO_Msk = 0xffffffff

	// TARGET2_HI: System timer target 2, high 32 bits
	// Position of TIMER_TARGET2_HI field.
	SYSTIMER_TARGET2_HI_TIMER_TARGET2_HI_Pos = 0x0
	// Bit mask of TIMER_TARGET2_HI field.
	SYSTIMER_TARGET2_HI_TIMER_TARGET2_HI_Msk = 0xffffffff

	// TARGET2_LO: System timer target 2, low 32 bits
	// Position of TIMER_TARGET2_LO field.
	SYSTIMER_TARGET2_LO_TIMER_TARGET2_LO_Pos = 0x0
	// Bit mask of TIMER_TARGET2_LO field.
	SYSTIMER_TARGET2_LO_TIMER_TARGET2_LO_Msk = 0xffffffff

	// TARGET0_CONF: Configure work mode for system timer target 0
	// Position of TARGET0_PERIOD field.
	SYSTIMER_TARGET0_CONF_TARGET0_PERIOD_Pos = 0x0
	// Bit mask of TARGET0_PERIOD field.
	SYSTIMER_TARGET0_CONF_TARGET0_PERIOD_Msk = 0x3fffffff
	// Position of TARGET0_PERIOD_MODE field.
	SYSTIMER_TARGET0_CONF_TARGET0_PERIOD_MODE_Pos = 0x1e
	// Bit mask of TARGET0_PERIOD_MODE field.
	SYSTIMER_TARGET0_CONF_TARGET0_PERIOD_MODE_Msk = 0x40000000
	// Bit TARGET0_PERIOD_MODE.
	SYSTIMER_TARGET0_CONF_TARGET0_PERIOD_MODE = 0x40000000
	// Position of TARGET0_WORK_EN field.
	SYSTIMER_TARGET0_CONF_TARGET0_WORK_EN_Pos = 0x1f
	// Bit mask of TARGET0_WORK_EN field.
	SYSTIMER_TARGET0_CONF_TARGET0_WORK_EN_Msk = 0x80000000
	// Bit TARGET0_WORK_EN.
	SYSTIMER_TARGET0_CONF_TARGET0_WORK_EN = 0x80000000

	// TARGET1_CONF: Configure work mode for system timer target 1
	// Position of TARGET1_PERIOD field.
	SYSTIMER_TARGET1_CONF_TARGET1_PERIOD_Pos = 0x0
	// Bit mask of TARGET1_PERIOD field.
	SYSTIMER_TARGET1_CONF_TARGET1_PERIOD_Msk = 0x3fffffff
	// Position of TARGET1_PERIOD_MODE field.
	SYSTIMER_TARGET1_CONF_TARGET1_PERIOD_MODE_Pos = 0x1e
	// Bit mask of TARGET1_PERIOD_MODE field.
	SYSTIMER_TARGET1_CONF_TARGET1_PERIOD_MODE_Msk = 0x40000000
	// Bit TARGET1_PERIOD_MODE.
	SYSTIMER_TARGET1_CONF_TARGET1_PERIOD_MODE = 0x40000000
	// Position of TARGET1_WORK_EN field.
	SYSTIMER_TARGET1_CONF_TARGET1_WORK_EN_Pos = 0x1f
	// Bit mask of TARGET1_WORK_EN field.
	SYSTIMER_TARGET1_CONF_TARGET1_WORK_EN_Msk = 0x80000000
	// Bit TARGET1_WORK_EN.
	SYSTIMER_TARGET1_CONF_TARGET1_WORK_EN = 0x80000000

	// TARGET2_CONF: Configure work mode for system timer target 2
	// Position of TARGET2_PERIOD field.
	SYSTIMER_TARGET2_CONF_TARGET2_PERIOD_Pos = 0x0
	// Bit mask of TARGET2_PERIOD field.
	SYSTIMER_TARGET2_CONF_TARGET2_PERIOD_Msk = 0x3fffffff
	// Position of TARGET2_PERIOD_MODE field.
	SYSTIMER_TARGET2_CONF_TARGET2_PERIOD_MODE_Pos = 0x1e
	// Bit mask of TARGET2_PERIOD_MODE field.
	SYSTIMER_TARGET2_CONF_TARGET2_PERIOD_MODE_Msk = 0x40000000
	// Bit TARGET2_PERIOD_MODE.
	SYSTIMER_TARGET2_CONF_TARGET2_PERIOD_MODE = 0x40000000
	// Position of TARGET2_WORK_EN field.
	SYSTIMER_TARGET2_CONF_TARGET2_WORK_EN_Pos = 0x1f
	// Bit mask of TARGET2_WORK_EN field.
	SYSTIMER_TARGET2_CONF_TARGET2_WORK_EN_Msk = 0x80000000
	// Bit TARGET2_WORK_EN.
	SYSTIMER_TARGET2_CONF_TARGET2_WORK_EN = 0x80000000

	// UPDATE: Read out system timer value
	// Position of TIMER_VALUE_VALID field.
	SYSTIMER_UPDATE_TIMER_VALUE_VALID_Pos = 0x1e
	// Bit mask of TIMER_VALUE_VALID field.
	SYSTIMER_UPDATE_TIMER_VALUE_VALID_Msk = 0x40000000
	// Bit TIMER_VALUE_VALID.
	SYSTIMER_UPDATE_TIMER_VALUE_VALID = 0x40000000
	// Position of TIMER_UPDATE field.
	SYSTIMER_UPDATE_TIMER_UPDATE_Pos = 0x1f
	// Bit mask of TIMER_UPDATE field.
	SYSTIMER_UPDATE_TIMER_UPDATE_Msk = 0x80000000
	// Bit TIMER_UPDATE.
	SYSTIMER_UPDATE_TIMER_UPDATE = 0x80000000

	// VALUE_HI: System timer value, high 32 bits
	// Position of TIMER_VALUE_HI field.
	SYSTIMER_VALUE_HI_TIMER_VALUE_HI_Pos = 0x0
	// Bit mask of TIMER_VALUE_HI field.
	SYSTIMER_VALUE_HI_TIMER_VALUE_HI_Msk = 0xffffffff

	// VALUE_LO: System timer value, low 32 bits
	// Position of TIMER_VALUE_LO field.
	SYSTIMER_VALUE_LO_TIMER_VALUE_LO_Pos = 0x0
	// Bit mask of TIMER_VALUE_LO field.
	SYSTIMER_VALUE_LO_TIMER_VALUE_LO_Msk = 0xffffffff

	// INT_ENA: System timer interrupt enable
	// Position of INT0_ENA field.
	SYSTIMER_INT_ENA_INT0_ENA_Pos = 0x0
	// Bit mask of INT0_ENA field.
	SYSTIMER_INT_ENA_INT0_ENA_Msk = 0x1
	// Bit INT0_ENA.
	SYSTIMER_INT_ENA_INT0_ENA = 0x1
	// Position of INT1_ENA field.
	SYSTIMER_INT_ENA_INT1_ENA_Pos = 0x1
	// Bit mask of INT1_ENA field.
	SYSTIMER_INT_ENA_INT1_ENA_Msk = 0x2
	// Bit INT1_ENA.
	SYSTIMER_INT_ENA_INT1_ENA = 0x2
	// Position of INT2_ENA field.
	SYSTIMER_INT_ENA_INT2_ENA_Pos = 0x2
	// Bit mask of INT2_ENA field.
	SYSTIMER_INT_ENA_INT2_ENA_Msk = 0x4
	// Bit INT2_ENA.
	SYSTIMER_INT_ENA_INT2_ENA = 0x4

	// INT_RAW: System timer interrupt raw
	// Position of INT0_RAW field.
	SYSTIMER_INT_RAW_INT0_RAW_Pos = 0x0
	// Bit mask of INT0_RAW field.
	SYSTIMER_INT_RAW_INT0_RAW_Msk = 0x1
	// Bit INT0_RAW.
	SYSTIMER_INT_RAW_INT0_RAW = 0x1
	// Position of INT1_RAW field.
	SYSTIMER_INT_RAW_INT1_RAW_Pos = 0x1
	// Bit mask of INT1_RAW field.
	SYSTIMER_INT_RAW_INT1_RAW_Msk = 0x2
	// Bit INT1_RAW.
	SYSTIMER_INT_RAW_INT1_RAW = 0x2
	// Position of INT2_RAW field.
	SYSTIMER_INT_RAW_INT2_RAW_Pos = 0x2
	// Bit mask of INT2_RAW field.
	SYSTIMER_INT_RAW_INT2_RAW_Msk = 0x4
	// Bit INT2_RAW.
	SYSTIMER_INT_RAW_INT2_RAW = 0x4

	// INT_CLR: System timer interrupt clear
	// Position of INT0_CLR field.
	SYSTIMER_INT_CLR_INT0_CLR_Pos = 0x0
	// Bit mask of INT0_CLR field.
	SYSTIMER_INT_CLR_INT0_CLR_Msk = 0x1
	// Bit INT0_CLR.
	SYSTIMER_INT_CLR_INT0_CLR = 0x1
	// Position of INT1_CLR field.
	SYSTIMER_INT_CLR_INT1_CLR_Pos = 0x1
	// Bit mask of INT1_CLR field.
	SYSTIMER_INT_CLR_INT1_CLR_Msk = 0x2
	// Bit INT1_CLR.
	SYSTIMER_INT_CLR_INT1_CLR = 0x2
	// Position of INT2_CLR field.
	SYSTIMER_INT_CLR_INT2_CLR_Pos = 0x2
	// Bit mask of INT2_CLR field.
	SYSTIMER_INT_CLR_INT2_CLR_Msk = 0x4
	// Bit INT2_CLR.
	SYSTIMER_INT_CLR_INT2_CLR = 0x4

	// DATE: Version control register
	// Position of DATE field.
	SYSTIMER_DATE_DATE_Pos = 0x0
	// Bit mask of DATE field.
	SYSTIMER_DATE_DATE_Msk = 0xffffffff
)

// Constants for TIMG0: Peripheral TIMG
const (
	// T0CONFIG: Timer %s configuration register
	// Position of T0_USE_XTAL field.
	TIMG0_TCONFIG_T0_USE_XTAL_Pos = 0x9
	// Bit mask of T0_USE_XTAL field.
	TIMG0_TCONFIG_T0_USE_XTAL_Msk = 0x200
	// Bit T0_USE_XTAL.
	TIMG0_TCONFIG_T0_USE_XTAL = 0x200
	// Position of T0_ALARM_EN field.
	TIMG0_TCONFIG_T0_ALARM_EN_Pos = 0xa
	// Bit mask of T0_ALARM_EN field.
	TIMG0_TCONFIG_T0_ALARM_EN_Msk = 0x400
	// Bit T0_ALARM_EN.
	TIMG0_TCONFIG_T0_ALARM_EN = 0x400
	// Position of T0_LEVEL_INT_EN field.
	TIMG0_TCONFIG_T0_LEVEL_INT_EN_Pos = 0xb
	// Bit mask of T0_LEVEL_INT_EN field.
	TIMG0_TCONFIG_T0_LEVEL_INT_EN_Msk = 0x800
	// Bit T0_LEVEL_INT_EN.
	TIMG0_TCONFIG_T0_LEVEL_INT_EN = 0x800
	// Position of T0_EDGE_INT_EN field.
	TIMG0_TCONFIG_T0_EDGE_INT_EN_Pos = 0xc
	// Bit mask of T0_EDGE_INT_EN field.
	TIMG0_TCONFIG_T0_EDGE_INT_EN_Msk = 0x1000
	// Bit T0_EDGE_INT_EN.
	TIMG0_TCONFIG_T0_EDGE_INT_EN = 0x1000
	// Position of T0_DIVIDER field.
	TIMG0_TCONFIG_T0_DIVIDER_Pos = 0xd
	// Bit mask of T0_DIVIDER field.
	TIMG0_TCONFIG_T0_DIVIDER_Msk = 0x1fffe000
	// Position of T0_AUTORELOAD field.
	TIMG0_TCONFIG_T0_AUTORELOAD_Pos = 0x1d
	// Bit mask of T0_AUTORELOAD field.
	TIMG0_TCONFIG_T0_AUTORELOAD_Msk = 0x20000000
	// Bit T0_AUTORELOAD.
	TIMG0_TCONFIG_T0_AUTORELOAD = 0x20000000
	// Position of T0_INCREASE field.
	TIMG0_TCONFIG_T0_INCREASE_Pos = 0x1e
	// Bit mask of T0_INCREASE field.
	TIMG0_TCONFIG_T0_INCREASE_Msk = 0x40000000
	// Bit T0_INCREASE.
	TIMG0_TCONFIG_T0_INCREASE = 0x40000000
	// Position of T0_EN field.
	TIMG0_TCONFIG_T0_EN_Pos = 0x1f
	// Bit mask of T0_EN field.
	TIMG0_TCONFIG_T0_EN_Msk = 0x80000000
	// Bit T0_EN.
	TIMG0_TCONFIG_T0_EN = 0x80000000

	// T0LO: Timer %s current value, low 32 bits
	// Position of T0_LO field.
	TIMG0_TLO_T0_LO_Pos = 0x0
	// Bit mask of T0_LO field.
	TIMG0_TLO_T0_LO_Msk = 0xffffffff

	// T0HI: Timer %s current value, high 32 bits
	// Position of T0_HI field.
	TIMG0_THI_T0_HI_Pos = 0x0
	// Bit mask of T0_HI field.
	TIMG0_THI_T0_HI_Msk = 0xffffffff

	// T0UPDATE: Write to copy current timer value to TIMGn_T%s_(LO/HI)_REG
	// Position of T0_UPDATE field.
	TIMG0_TUPDATE_T0_UPDATE_Pos = 0x1f
	// Bit mask of T0_UPDATE field.
	TIMG0_TUPDATE_T0_UPDATE_Msk = 0x80000000
	// Bit T0_UPDATE.
	TIMG0_TUPDATE_T0_UPDATE = 0x80000000

	// T0ALARMLO: Timer %s alarm value, low 32 bits
	// Position of T0_ALARM_LO field.
	TIMG0_TALARMLO_T0_ALARM_LO_Pos = 0x0
	// Bit mask of T0_ALARM_LO field.
	TIMG0_TALARMLO_T0_ALARM_LO_Msk = 0xffffffff

	// T0ALARMHI: Timer %s alarm value, high bits
	// Position of T0_ALARM_HI field.
	TIMG0_TALARMHI_T0_ALARM_HI_Pos = 0x0
	// Bit mask of T0_ALARM_HI field.
	TIMG0_TALARMHI_T0_ALARM_HI_Msk = 0xffffffff

	// T0LOADLO: Timer %s reload value, low 32 bits
	// Position of T0_LOAD_LO field.
	TIMG0_TLOADLO_T0_LOAD_LO_Pos = 0x0
	// Bit mask of T0_LOAD_LO field.
	TIMG0_TLOADLO_T0_LOAD_LO_Msk = 0xffffffff

	// T0LOADHI: Timer %s reload value, high 32 bits
	// Position of T0_LOAD_HI field.
	TIMG0_TLOADHI_T0_LOAD_HI_Pos = 0x0
	// Bit mask of T0_LOAD_HI field.
	TIMG0_TLOADHI_T0_LOAD_HI_Msk = 0xffffffff

	// T0LOAD: Write to reload timer from TIMG_T0_(LOADLOLOADHI)_REG
	// Position of T0_LOAD field.
	TIMG0_TLOAD_T0_LOAD_Pos = 0x0
	// Bit mask of T0_LOAD field.
	TIMG0_TLOAD_T0_LOAD_Msk = 0xffffffff

	// WDTCONFIG0: Watchdog timer configuration register
	// Position of WDT_APPCPU_RESET_EN field.
	TIMG0_WDTCONFIG0_WDT_APPCPU_RESET_EN_Pos = 0xc
	// Bit mask of WDT_APPCPU_RESET_EN field.
	TIMG0_WDTCONFIG0_WDT_APPCPU_RESET_EN_Msk = 0x1000
	// Bit WDT_APPCPU_RESET_EN.
	TIMG0_WDTCONFIG0_WDT_APPCPU_RESET_EN = 0x1000
	// Position of WDT_PROCPU_RESET_EN field.
	TIMG0_WDTCONFIG0_WDT_PROCPU_RESET_EN_Pos = 0xd
	// Bit mask of WDT_PROCPU_RESET_EN field.
	TIMG0_WDTCONFIG0_WDT_PROCPU_RESET_EN_Msk = 0x2000
	// Bit WDT_PROCPU_RESET_EN.
	TIMG0_WDTCONFIG0_WDT_PROCPU_RESET_EN = 0x2000
	// Position of WDT_FLASHBOOT_MOD_EN field.
	TIMG0_WDTCONFIG0_WDT_FLASHBOOT_MOD_EN_Pos = 0xe
	// Bit mask of WDT_FLASHBOOT_MOD_EN field.
	TIMG0_WDTCONFIG0_WDT_FLASHBOOT_MOD_EN_Msk = 0x4000
	// Bit WDT_FLASHBOOT_MOD_EN.
	TIMG0_WDTCONFIG0_WDT_FLASHBOOT_MOD_EN = 0x4000
	// Position of WDT_SYS_RESET_LENGTH field.
	TIMG0_WDTCONFIG0_WDT_SYS_RESET_LENGTH_Pos = 0xf
	// Bit mask of WDT_SYS_RESET_LENGTH field.
	TIMG0_WDTCONFIG0_WDT_SYS_RESET_LENGTH_Msk = 0x38000
	// Position of WDT_CPU_RESET_LENGTH field.
	TIMG0_WDTCONFIG0_WDT_CPU_RESET_LENGTH_Pos = 0x12
	// Bit mask of WDT_CPU_RESET_LENGTH field.
	TIMG0_WDTCONFIG0_WDT_CPU_RESET_LENGTH_Msk = 0x1c0000
	// Position of WDT_LEVEL_INT_EN field.
	TIMG0_WDTCONFIG0_WDT_LEVEL_INT_EN_Pos = 0x15
	// Bit mask of WDT_LEVEL_INT_EN field.
	TIMG0_WDTCONFIG0_WDT_LEVEL_INT_EN_Msk = 0x200000
	// Bit WDT_LEVEL_INT_EN.
	TIMG0_WDTCONFIG0_WDT_LEVEL_INT_EN = 0x200000
	// Position of WDT_EDGE_INT_EN field.
	TIMG0_WDTCONFIG0_WDT_EDGE_INT_EN_Pos = 0x16
	// Bit mask of WDT_EDGE_INT_EN field.
	TIMG0_WDTCONFIG0_WDT_EDGE_INT_EN_Msk = 0x400000
	// Bit WDT_EDGE_INT_EN.
	TIMG0_WDTCONFIG0_WDT_EDGE_INT_EN = 0x400000
	// Position of WDT_STG3 field.
	TIMG0_WDTCONFIG0_WDT_STG3_Pos = 0x17
	// Bit mask of WDT_STG3 field.
	TIMG0_WDTCONFIG0_WDT_STG3_Msk = 0x1800000
	// Position of WDT_STG2 field.
	TIMG0_WDTCONFIG0_WDT_STG2_Pos = 0x19
	// Bit mask of WDT_STG2 field.
	TIMG0_WDTCONFIG0_WDT_STG2_Msk = 0x6000000
	// Position of WDT_STG1 field.
	TIMG0_WDTCONFIG0_WDT_STG1_Pos = 0x1b
	// Bit mask of WDT_STG1 field.
	TIMG0_WDTCONFIG0_WDT_STG1_Msk = 0x18000000
	// Position of WDT_STG0 field.
	TIMG0_WDTCONFIG0_WDT_STG0_Pos = 0x1d
	// Bit mask of WDT_STG0 field.
	TIMG0_WDTCONFIG0_WDT_STG0_Msk = 0x60000000
	// Position of WDT_EN field.
	TIMG0_WDTCONFIG0_WDT_EN_Pos = 0x1f
	// Bit mask of WDT_EN field.
	TIMG0_WDTCONFIG0_WDT_EN_Msk = 0x80000000
	// Bit WDT_EN.
	TIMG0_WDTCONFIG0_WDT_EN = 0x80000000

	// WDTCONFIG1: Watchdog timer prescaler register
	// Position of WDT_CLK_PRESCALER field.
	TIMG0_WDTCONFIG1_WDT_CLK_PRESCALER_Pos = 0x10
	// Bit mask of WDT_CLK_PRESCALER field.
	TIMG0_WDTCONFIG1_WDT_CLK_PRESCALER_Msk = 0xffff0000

	// WDTCONFIG2: Watchdog timer stage 0 timeout value
	// Position of WDT_STG0_HOLD field.
	TIMG0_WDTCONFIG2_WDT_STG0_HOLD_Pos = 0x0
	// Bit mask of WDT_STG0_HOLD field.
	TIMG0_WDTCONFIG2_WDT_STG0_HOLD_Msk = 0xffffffff

	// WDTCONFIG3: Watchdog timer stage 1 timeout value
	// Position of WDT_STG1_HOLD field.
	TIMG0_WDTCONFIG3_WDT_STG1_HOLD_Pos = 0x0
	// Bit mask of WDT_STG1_HOLD field.
	TIMG0_WDTCONFIG3_WDT_STG1_HOLD_Msk = 0xffffffff

	// WDTCONFIG4: Watchdog timer stage 2 timeout value
	// Position of WDT_STG2_HOLD field.
	TIMG0_WDTCONFIG4_WDT_STG2_HOLD_Pos = 0x0
	// Bit mask of WDT_STG2_HOLD field.
	TIMG0_WDTCONFIG4_WDT_STG2_HOLD_Msk = 0xffffffff

	// WDTCONFIG5: Watchdog timer stage 3 timeout value
	// Position of WDT_STG3_HOLD field.
	TIMG0_WDTCONFIG5_WDT_STG3_HOLD_Pos = 0x0
	// Bit mask of WDT_STG3_HOLD field.
	TIMG0_WDTCONFIG5_WDT_STG3_HOLD_Msk = 0xffffffff

	// WDTFEED: Write to feed the watchdog timer
	// Position of WDT_FEED field.
	TIMG0_WDTFEED_WDT_FEED_Pos = 0x0
	// Bit mask of WDT_FEED field.
	TIMG0_WDTFEED_WDT_FEED_Msk = 0xffffffff

	// WDTWPROTECT: Watchdog write protect register
	// Position of WDT_WKEY field.
	TIMG0_WDTWPROTECT_WDT_WKEY_Pos = 0x0
	// Bit mask of WDT_WKEY field.
	TIMG0_WDTWPROTECT_WDT_WKEY_Msk = 0xffffffff

	// RTCCALICFG: RTC calibration configuration register
	// Position of RTC_CALI_START_CYCLING field.
	TIMG0_RTCCALICFG_RTC_CALI_START_CYCLING_Pos = 0xc
	// Bit mask of RTC_CALI_START_CYCLING field.
	TIMG0_RTCCALICFG_RTC_CALI_START_CYCLING_Msk = 0x1000
	// Bit RTC_CALI_START_CYCLING.
	TIMG0_RTCCALICFG_RTC_CALI_START_CYCLING = 0x1000
	// Position of RTC_CALI_CLK_SEL field.
	TIMG0_RTCCALICFG_RTC_CALI_CLK_SEL_Pos = 0xd
	// Bit mask of RTC_CALI_CLK_SEL field.
	TIMG0_RTCCALICFG_RTC_CALI_CLK_SEL_Msk = 0x6000
	// Position of RTC_CALI_RDY field.
	TIMG0_RTCCALICFG_RTC_CALI_RDY_Pos = 0xf
	// Bit mask of RTC_CALI_RDY field.
	TIMG0_RTCCALICFG_RTC_CALI_RDY_Msk = 0x8000
	// Bit RTC_CALI_RDY.
	TIMG0_RTCCALICFG_RTC_CALI_RDY = 0x8000
	// Position of RTC_CALI_MAX field.
	TIMG0_RTCCALICFG_RTC_CALI_MAX_Pos = 0x10
	// Bit mask of RTC_CALI_MAX field.
	TIMG0_RTCCALICFG_RTC_CALI_MAX_Msk = 0x7fff0000
	// Position of RTC_CALI_START field.
	TIMG0_RTCCALICFG_RTC_CALI_START_Pos = 0x1f
	// Bit mask of RTC_CALI_START field.
	TIMG0_RTCCALICFG_RTC_CALI_START_Msk = 0x80000000
	// Bit RTC_CALI_START.
	TIMG0_RTCCALICFG_RTC_CALI_START = 0x80000000

	// RTCCALICFG1: RTC calibration configuration1 register
	// Position of RTC_CALI_CYCLING_DATA_VLD field.
	TIMG0_RTCCALICFG1_RTC_CALI_CYCLING_DATA_VLD_Pos = 0x0
	// Bit mask of RTC_CALI_CYCLING_DATA_VLD field.
	TIMG0_RTCCALICFG1_RTC_CALI_CYCLING_DATA_VLD_Msk = 0x1
	// Bit RTC_CALI_CYCLING_DATA_VLD.
	TIMG0_RTCCALICFG1_RTC_CALI_CYCLING_DATA_VLD = 0x1
	// Position of RTC_CALI_VALUE field.
	TIMG0_RTCCALICFG1_RTC_CALI_VALUE_Pos = 0x7
	// Bit mask of RTC_CALI_VALUE field.
	TIMG0_RTCCALICFG1_RTC_CALI_VALUE_Msk = 0xffffff80

	// LACTCONFIG: LACT configuration register
	// Position of LACT_USE_REFTICK field.
	TIMG0_LACTCONFIG_LACT_USE_REFTICK_Pos = 0x6
	// Bit mask of LACT_USE_REFTICK field.
	TIMG0_LACTCONFIG_LACT_USE_REFTICK_Msk = 0x40
	// Bit LACT_USE_REFTICK.
	TIMG0_LACTCONFIG_LACT_USE_REFTICK = 0x40
	// Position of LACT_RTC_ONLY field.
	TIMG0_LACTCONFIG_LACT_RTC_ONLY_Pos = 0x7
	// Bit mask of LACT_RTC_ONLY field.
	TIMG0_LACTCONFIG_LACT_RTC_ONLY_Msk = 0x80
	// Bit LACT_RTC_ONLY.
	TIMG0_LACTCONFIG_LACT_RTC_ONLY = 0x80
	// Position of LACT_CPST_EN field.
	TIMG0_LACTCONFIG_LACT_CPST_EN_Pos = 0x8
	// Bit mask of LACT_CPST_EN field.
	TIMG0_LACTCONFIG_LACT_CPST_EN_Msk = 0x100
	// Bit LACT_CPST_EN.
	TIMG0_LACTCONFIG_LACT_CPST_EN = 0x100
	// Position of LACT_LAC_EN field.
	TIMG0_LACTCONFIG_LACT_LAC_EN_Pos = 0x9
	// Bit mask of LACT_LAC_EN field.
	TIMG0_LACTCONFIG_LACT_LAC_EN_Msk = 0x200
	// Bit LACT_LAC_EN.
	TIMG0_LACTCONFIG_LACT_LAC_EN = 0x200
	// Position of LACT_ALARM_EN field.
	TIMG0_LACTCONFIG_LACT_ALARM_EN_Pos = 0xa
	// Bit mask of LACT_ALARM_EN field.
	TIMG0_LACTCONFIG_LACT_ALARM_EN_Msk = 0x400
	// Bit LACT_ALARM_EN.
	TIMG0_LACTCONFIG_LACT_ALARM_EN = 0x400
	// Position of LACT_LEVEL_INT_EN field.
	TIMG0_LACTCONFIG_LACT_LEVEL_INT_EN_Pos = 0xb
	// Bit mask of LACT_LEVEL_INT_EN field.
	TIMG0_LACTCONFIG_LACT_LEVEL_INT_EN_Msk = 0x800
	// Bit LACT_LEVEL_INT_EN.
	TIMG0_LACTCONFIG_LACT_LEVEL_INT_EN = 0x800
	// Position of LACT_EDGE_INT_EN field.
	TIMG0_LACTCONFIG_LACT_EDGE_INT_EN_Pos = 0xc
	// Bit mask of LACT_EDGE_INT_EN field.
	TIMG0_LACTCONFIG_LACT_EDGE_INT_EN_Msk = 0x1000
	// Bit LACT_EDGE_INT_EN.
	TIMG0_LACTCONFIG_LACT_EDGE_INT_EN = 0x1000
	// Position of LACT_DIVIDER field.
	TIMG0_LACTCONFIG_LACT_DIVIDER_Pos = 0xd
	// Bit mask of LACT_DIVIDER field.
	TIMG0_LACTCONFIG_LACT_DIVIDER_Msk = 0x1fffe000
	// Position of LACT_AUTORELOAD field.
	TIMG0_LACTCONFIG_LACT_AUTORELOAD_Pos = 0x1d
	// Bit mask of LACT_AUTORELOAD field.
	TIMG0_LACTCONFIG_LACT_AUTORELOAD_Msk = 0x20000000
	// Bit LACT_AUTORELOAD.
	TIMG0_LACTCONFIG_LACT_AUTORELOAD = 0x20000000
	// Position of LACT_INCREASE field.
	TIMG0_LACTCONFIG_LACT_INCREASE_Pos = 0x1e
	// Bit mask of LACT_INCREASE field.
	TIMG0_LACTCONFIG_LACT_INCREASE_Msk = 0x40000000
	// Bit LACT_INCREASE.
	TIMG0_LACTCONFIG_LACT_INCREASE = 0x40000000
	// Position of LACT_EN field.
	TIMG0_LACTCONFIG_LACT_EN_Pos = 0x1f
	// Bit mask of LACT_EN field.
	TIMG0_LACTCONFIG_LACT_EN_Msk = 0x80000000
	// Bit LACT_EN.
	TIMG0_LACTCONFIG_LACT_EN = 0x80000000

	// LACTRTC: LACT RTC register
	// Position of LACT_RTC_STEP_LEN field.
	TIMG0_LACTRTC_LACT_RTC_STEP_LEN_Pos = 0x6
	// Bit mask of LACT_RTC_STEP_LEN field.
	TIMG0_LACTRTC_LACT_RTC_STEP_LEN_Msk = 0xffffffc0

	// LACTLO: LACT low register
	// Position of LACT_LO field.
	TIMG0_LACTLO_LACT_LO_Pos = 0x0
	// Bit mask of LACT_LO field.
	TIMG0_LACTLO_LACT_LO_Msk = 0xffffffff

	// LACTHI: LACT high register
	// Position of LACT_HI field.
	TIMG0_LACTHI_LACT_HI_Pos = 0x0
	// Bit mask of LACT_HI field.
	TIMG0_LACTHI_LACT_HI_Msk = 0xffffffff

	// LACTUPDATE: LACT update register
	// Position of LACT_UPDATE field.
	TIMG0_LACTUPDATE_LACT_UPDATE_Pos = 0x0
	// Bit mask of LACT_UPDATE field.
	TIMG0_LACTUPDATE_LACT_UPDATE_Msk = 0xffffffff

	// LACTALARMLO: LACT alarm low register
	// Position of LACT_ALARM_LO field.
	TIMG0_LACTALARMLO_LACT_ALARM_LO_Pos = 0x0
	// Bit mask of LACT_ALARM_LO field.
	TIMG0_LACTALARMLO_LACT_ALARM_LO_Msk = 0xffffffff

	// LACTALARMHI: LACT alarm high register
	// Position of LACT_ALARM_HI field.
	TIMG0_LACTALARMHI_LACT_ALARM_HI_Pos = 0x0
	// Bit mask of LACT_ALARM_HI field.
	TIMG0_LACTALARMHI_LACT_ALARM_HI_Msk = 0xffffffff

	// LACTLOADLO: LACT load low register
	// Position of LACT_LOAD_LO field.
	TIMG0_LACTLOADLO_LACT_LOAD_LO_Pos = 0x0
	// Bit mask of LACT_LOAD_LO field.
	TIMG0_LACTLOADLO_LACT_LOAD_LO_Msk = 0xffffffff

	// LACTLOADHI: Timer LACT load high register
	// Position of LACT_LOAD_HI field.
	TIMG0_LACTLOADHI_LACT_LOAD_HI_Pos = 0x0
	// Bit mask of LACT_LOAD_HI field.
	TIMG0_LACTLOADHI_LACT_LOAD_HI_Msk = 0xffffffff

	// LACTLOAD: Timer LACT load register
	// Position of LACT_LOAD field.
	TIMG0_LACTLOAD_LACT_LOAD_Pos = 0x0
	// Bit mask of LACT_LOAD field.
	TIMG0_LACTLOAD_LACT_LOAD_Msk = 0xffffffff

	// INT_ENA_TIMERS: Interrupt enable bits
	// Position of T0_INT_ENA field.
	TIMG0_INT_ENA_TIMERS_T0_INT_ENA_Pos = 0x0
	// Bit mask of T0_INT_ENA field.
	TIMG0_INT_ENA_TIMERS_T0_INT_ENA_Msk = 0x1
	// Bit T0_INT_ENA.
	TIMG0_INT_ENA_TIMERS_T0_INT_ENA = 0x1
	// Position of T1_INT_ENA field.
	TIMG0_INT_ENA_TIMERS_T1_INT_ENA_Pos = 0x1
	// Bit mask of T1_INT_ENA field.
	TIMG0_INT_ENA_TIMERS_T1_INT_ENA_Msk = 0x2
	// Bit T1_INT_ENA.
	TIMG0_INT_ENA_TIMERS_T1_INT_ENA = 0x2
	// Position of WDT_INT_ENA field.
	TIMG0_INT_ENA_TIMERS_WDT_INT_ENA_Pos = 0x2
	// Bit mask of WDT_INT_ENA field.
	TIMG0_INT_ENA_TIMERS_WDT_INT_ENA_Msk = 0x4
	// Bit WDT_INT_ENA.
	TIMG0_INT_ENA_TIMERS_WDT_INT_ENA = 0x4
	// Position of LACT_INT_ENA field.
	TIMG0_INT_ENA_TIMERS_LACT_INT_ENA_Pos = 0x3
	// Bit mask of LACT_INT_ENA field.
	TIMG0_INT_ENA_TIMERS_LACT_INT_ENA_Msk = 0x8
	// Bit LACT_INT_ENA.
	TIMG0_INT_ENA_TIMERS_LACT_INT_ENA = 0x8

	// INT_RAW_TIMERS: Raw interrupt status
	// Position of T0_INT_RAW field.
	TIMG0_INT_RAW_TIMERS_T0_INT_RAW_Pos = 0x0
	// Bit mask of T0_INT_RAW field.
	TIMG0_INT_RAW_TIMERS_T0_INT_RAW_Msk = 0x1
	// Bit T0_INT_RAW.
	TIMG0_INT_RAW_TIMERS_T0_INT_RAW = 0x1
	// Position of T1_INT_RAW field.
	TIMG0_INT_RAW_TIMERS_T1_INT_RAW_Pos = 0x1
	// Bit mask of T1_INT_RAW field.
	TIMG0_INT_RAW_TIMERS_T1_INT_RAW_Msk = 0x2
	// Bit T1_INT_RAW.
	TIMG0_INT_RAW_TIMERS_T1_INT_RAW = 0x2
	// Position of WDT_INT_RAW field.
	TIMG0_INT_RAW_TIMERS_WDT_INT_RAW_Pos = 0x2
	// Bit mask of WDT_INT_RAW field.
	TIMG0_INT_RAW_TIMERS_WDT_INT_RAW_Msk = 0x4
	// Bit WDT_INT_RAW.
	TIMG0_INT_RAW_TIMERS_WDT_INT_RAW = 0x4
	// Position of LACT_INT_RAW field.
	TIMG0_INT_RAW_TIMERS_LACT_INT_RAW_Pos = 0x3
	// Bit mask of LACT_INT_RAW field.
	TIMG0_INT_RAW_TIMERS_LACT_INT_RAW_Msk = 0x8
	// Bit LACT_INT_RAW.
	TIMG0_INT_RAW_TIMERS_LACT_INT_RAW = 0x8

	// INT_ST_TIMERS: Masked interrupt status
	// Position of T0_INT_ST field.
	TIMG0_INT_ST_TIMERS_T0_INT_ST_Pos = 0x0
	// Bit mask of T0_INT_ST field.
	TIMG0_INT_ST_TIMERS_T0_INT_ST_Msk = 0x1
	// Bit T0_INT_ST.
	TIMG0_INT_ST_TIMERS_T0_INT_ST = 0x1
	// Position of T1_INT_ST field.
	TIMG0_INT_ST_TIMERS_T1_INT_ST_Pos = 0x1
	// Bit mask of T1_INT_ST field.
	TIMG0_INT_ST_TIMERS_T1_INT_ST_Msk = 0x2
	// Bit T1_INT_ST.
	TIMG0_INT_ST_TIMERS_T1_INT_ST = 0x2
	// Position of WDT_INT_ST field.
	TIMG0_INT_ST_TIMERS_WDT_INT_ST_Pos = 0x2
	// Bit mask of WDT_INT_ST field.
	TIMG0_INT_ST_TIMERS_WDT_INT_ST_Msk = 0x4
	// Bit WDT_INT_ST.
	TIMG0_INT_ST_TIMERS_WDT_INT_ST = 0x4
	// Position of LACT_INT_ST field.
	TIMG0_INT_ST_TIMERS_LACT_INT_ST_Pos = 0x3
	// Bit mask of LACT_INT_ST field.
	TIMG0_INT_ST_TIMERS_LACT_INT_ST_Msk = 0x8
	// Bit LACT_INT_ST.
	TIMG0_INT_ST_TIMERS_LACT_INT_ST = 0x8

	// INT_CLR_TIMERS: Interrupt clear bits
	// Position of T0_INT_CLR field.
	TIMG0_INT_CLR_TIMERS_T0_INT_CLR_Pos = 0x0
	// Bit mask of T0_INT_CLR field.
	TIMG0_INT_CLR_TIMERS_T0_INT_CLR_Msk = 0x1
	// Bit T0_INT_CLR.
	TIMG0_INT_CLR_TIMERS_T0_INT_CLR = 0x1
	// Position of T1_INT_CLR field.
	TIMG0_INT_CLR_TIMERS_T1_INT_CLR_Pos = 0x1
	// Bit mask of T1_INT_CLR field.
	TIMG0_INT_CLR_TIMERS_T1_INT_CLR_Msk = 0x2
	// Bit T1_INT_CLR.
	TIMG0_INT_CLR_TIMERS_T1_INT_CLR = 0x2
	// Position of WDT_INT_CLR field.
	TIMG0_INT_CLR_TIMERS_WDT_INT_CLR_Pos = 0x2
	// Bit mask of WDT_INT_CLR field.
	TIMG0_INT_CLR_TIMERS_WDT_INT_CLR_Msk = 0x4
	// Bit WDT_INT_CLR.
	TIMG0_INT_CLR_TIMERS_WDT_INT_CLR = 0x4
	// Position of LACT_INT_CLR field.
	TIMG0_INT_CLR_TIMERS_LACT_INT_CLR_Pos = 0x3
	// Bit mask of LACT_INT_CLR field.
	TIMG0_INT_CLR_TIMERS_LACT_INT_CLR_Msk = 0x8
	// Bit LACT_INT_CLR.
	TIMG0_INT_CLR_TIMERS_LACT_INT_CLR = 0x8

	// RTCCALICFG2: Timer group calibration register
	// Position of RTC_CALI_TIMEOUT field.
	TIMG0_RTCCALICFG2_RTC_CALI_TIMEOUT_Pos = 0x0
	// Bit mask of RTC_CALI_TIMEOUT field.
	TIMG0_RTCCALICFG2_RTC_CALI_TIMEOUT_Msk = 0x1
	// Bit RTC_CALI_TIMEOUT.
	TIMG0_RTCCALICFG2_RTC_CALI_TIMEOUT = 0x1
	// Position of RTC_CALI_TIMEOUT_RST_CNT field.
	TIMG0_RTCCALICFG2_RTC_CALI_TIMEOUT_RST_CNT_Pos = 0x3
	// Bit mask of RTC_CALI_TIMEOUT_RST_CNT field.
	TIMG0_RTCCALICFG2_RTC_CALI_TIMEOUT_RST_CNT_Msk = 0x78
	// Position of RTC_CALI_TIMEOUT_THRES field.
	TIMG0_RTCCALICFG2_RTC_CALI_TIMEOUT_THRES_Pos = 0x7
	// Bit mask of RTC_CALI_TIMEOUT_THRES field.
	TIMG0_RTCCALICFG2_RTC_CALI_TIMEOUT_THRES_Msk = 0xffffff80

	// TIMERS_DATE: Version control register
	// Position of TIMERS_DATE field.
	TIMG0_TIMERS_DATE_TIMERS_DATE_Pos = 0x0
	// Bit mask of TIMERS_DATE field.
	TIMG0_TIMERS_DATE_TIMERS_DATE_Msk = 0xfffffff

	// REGCLK: Timer group clock gate register
	// Position of CLK_EN field.
	TIMG0_REGCLK_CLK_EN_Pos = 0x1f
	// Bit mask of CLK_EN field.
	TIMG0_REGCLK_CLK_EN_Msk = 0x80000000
	// Bit CLK_EN.
	TIMG0_REGCLK_CLK_EN = 0x80000000
)

// Constants for UART0: Peripheral UART
const (
	// FIFO: FIFO data register
	// Position of RXFIFO_RD_BYTE field.
	UART0_FIFO_RXFIFO_RD_BYTE_Pos = 0x0
	// Bit mask of RXFIFO_RD_BYTE field.
	UART0_FIFO_RXFIFO_RD_BYTE_Msk = 0xff

	// INT_RAW: Raw interrupt status
	// Position of RXFIFO_FULL_INT_RAW field.
	UART0_INT_RAW_RXFIFO_FULL_INT_RAW_Pos = 0x0
	// Bit mask of RXFIFO_FULL_INT_RAW field.
	UART0_INT_RAW_RXFIFO_FULL_INT_RAW_Msk = 0x1
	// Bit RXFIFO_FULL_INT_RAW.
	UART0_INT_RAW_RXFIFO_FULL_INT_RAW = 0x1
	// Position of TXFIFO_EMPTY_INT_RAW field.
	UART0_INT_RAW_TXFIFO_EMPTY_INT_RAW_Pos = 0x1
	// Bit mask of TXFIFO_EMPTY_INT_RAW field.
	UART0_INT_RAW_TXFIFO_EMPTY_INT_RAW_Msk = 0x2
	// Bit TXFIFO_EMPTY_INT_RAW.
	UART0_INT_RAW_TXFIFO_EMPTY_INT_RAW = 0x2
	// Position of PARITY_ERR_INT_RAW field.
	UART0_INT_RAW_PARITY_ERR_INT_RAW_Pos = 0x2
	// Bit mask of PARITY_ERR_INT_RAW field.
	UART0_INT_RAW_PARITY_ERR_INT_RAW_Msk = 0x4
	// Bit PARITY_ERR_INT_RAW.
	UART0_INT_RAW_PARITY_ERR_INT_RAW = 0x4
	// Position of FRM_ERR_INT_RAW field.
	UART0_INT_RAW_FRM_ERR_INT_RAW_Pos = 0x3
	// Bit mask of FRM_ERR_INT_RAW field.
	UART0_INT_RAW_FRM_ERR_INT_RAW_Msk = 0x8
	// Bit FRM_ERR_INT_RAW.
	UART0_INT_RAW_FRM_ERR_INT_RAW = 0x8
	// Position of RXFIFO_OVF_INT_RAW field.
	UART0_INT_RAW_RXFIFO_OVF_INT_RAW_Pos = 0x4
	// Bit mask of RXFIFO_OVF_INT_RAW field.
	UART0_INT_RAW_RXFIFO_OVF_INT_RAW_Msk = 0x10
	// Bit RXFIFO_OVF_INT_RAW.
	UART0_INT_RAW_RXFIFO_OVF_INT_RAW = 0x10
	// Position of DSR_CHG_INT_RAW field.
	UART0_INT_RAW_DSR_CHG_INT_RAW_Pos = 0x5
	// Bit mask of DSR_CHG_INT_RAW field.
	UART0_INT_RAW_DSR_CHG_INT_RAW_Msk = 0x20
	// Bit DSR_CHG_INT_RAW.
	UART0_INT_RAW_DSR_CHG_INT_RAW = 0x20
	// Position of CTS_CHG_INT_RAW field.
	UART0_INT_RAW_CTS_CHG_INT_RAW_Pos = 0x6
	// Bit mask of CTS_CHG_INT_RAW field.
	UART0_INT_RAW_CTS_CHG_INT_RAW_Msk = 0x40
	// Bit CTS_CHG_INT_RAW.
	UART0_INT_RAW_CTS_CHG_INT_RAW = 0x40
	// Position of BRK_DET_INT_RAW field.
	UART0_INT_RAW_BRK_DET_INT_RAW_Pos = 0x7
	// Bit mask of BRK_DET_INT_RAW field.
	UART0_INT_RAW_BRK_DET_INT_RAW_Msk = 0x80
	// Bit BRK_DET_INT_RAW.
	UART0_INT_RAW_BRK_DET_INT_RAW = 0x80
	// Position of RXFIFO_TOUT_INT_RAW field.
	UART0_INT_RAW_RXFIFO_TOUT_INT_RAW_Pos = 0x8
	// Bit mask of RXFIFO_TOUT_INT_RAW field.
	UART0_INT_RAW_RXFIFO_TOUT_INT_RAW_Msk = 0x100
	// Bit RXFIFO_TOUT_INT_RAW.
	UART0_INT_RAW_RXFIFO_TOUT_INT_RAW = 0x100
	// Position of SW_XON_INT_RAW field.
	UART0_INT_RAW_SW_XON_INT_RAW_Pos = 0x9
	// Bit mask of SW_XON_INT_RAW field.
	UART0_INT_RAW_SW_XON_INT_RAW_Msk = 0x200
	// Bit SW_XON_INT_RAW.
	UART0_INT_RAW_SW_XON_INT_RAW = 0x200
	// Position of SW_XOFF_INT_RAW field.
	UART0_INT_RAW_SW_XOFF_INT_RAW_Pos = 0xa
	// Bit mask of SW_XOFF_INT_RAW field.
	UART0_INT_RAW_SW_XOFF_INT_RAW_Msk = 0x400
	// Bit SW_XOFF_INT_RAW.
	UART0_INT_RAW_SW_XOFF_INT_RAW = 0x400
	// Position of GLITCH_DET_INT_RAW field.
	UART0_INT_RAW_GLITCH_DET_INT_RAW_Pos = 0xb
	// Bit mask of GLITCH_DET_INT_RAW field.
	UART0_INT_RAW_GLITCH_DET_INT_RAW_Msk = 0x800
	// Bit GLITCH_DET_INT_RAW.
	UART0_INT_RAW_GLITCH_DET_INT_RAW = 0x800
	// Position of TX_BRK_DONE_INT_RAW field.
	UART0_INT_RAW_TX_BRK_DONE_INT_RAW_Pos = 0xc
	// Bit mask of TX_BRK_DONE_INT_RAW field.
	UART0_INT_RAW_TX_BRK_DONE_INT_RAW_Msk = 0x1000
	// Bit TX_BRK_DONE_INT_RAW.
	UART0_INT_RAW_TX_BRK_DONE_INT_RAW = 0x1000
	// Position of TX_BRK_IDLE_DONE_INT_RAW field.
	UART0_INT_RAW_TX_BRK_IDLE_DONE_INT_RAW_Pos = 0xd
	// Bit mask of TX_BRK_IDLE_DONE_INT_RAW field.
	UART0_INT_RAW_TX_BRK_IDLE_DONE_INT_RAW_Msk = 0x2000
	// Bit TX_BRK_IDLE_DONE_INT_RAW.
	UART0_INT_RAW_TX_BRK_IDLE_DONE_INT_RAW = 0x2000
	// Position of TX_DONE_INT_RAW field.
	UART0_INT_RAW_TX_DONE_INT_RAW_Pos = 0xe
	// Bit mask of TX_DONE_INT_RAW field.
	UART0_INT_RAW_TX_DONE_INT_RAW_Msk = 0x4000
	// Bit TX_DONE_INT_RAW.
	UART0_INT_RAW_TX_DONE_INT_RAW = 0x4000
	// Position of RS485_PARITY_ERR_INT_RAW field.
	UART0_INT_RAW_RS485_PARITY_ERR_INT_RAW_Pos = 0xf
	// Bit mask of RS485_PARITY_ERR_INT_RAW field.
	UART0_INT_RAW_RS485_PARITY_ERR_INT_RAW_Msk = 0x8000
	// Bit RS485_PARITY_ERR_INT_RAW.
	UART0_INT_RAW_RS485_PARITY_ERR_INT_RAW = 0x8000
	// Position of RS485_FRM_ERR_INT_RAW field.
	UART0_INT_RAW_RS485_FRM_ERR_INT_RAW_Pos = 0x10
	// Bit mask of RS485_FRM_ERR_INT_RAW field.
	UART0_INT_RAW_RS485_FRM_ERR_INT_RAW_Msk = 0x10000
	// Bit RS485_FRM_ERR_INT_RAW.
	UART0_INT_RAW_RS485_FRM_ERR_INT_RAW = 0x10000
	// Position of RS485_CLASH_INT_RAW field.
	UART0_INT_RAW_RS485_CLASH_INT_RAW_Pos = 0x11
	// Bit mask of RS485_CLASH_INT_RAW field.
	UART0_INT_RAW_RS485_CLASH_INT_RAW_Msk = 0x20000
	// Bit RS485_CLASH_INT_RAW.
	UART0_INT_RAW_RS485_CLASH_INT_RAW = 0x20000
	// Position of AT_CMD_CHAR_DET_INT_RAW field.
	UART0_INT_RAW_AT_CMD_CHAR_DET_INT_RAW_Pos = 0x12
	// Bit mask of AT_CMD_CHAR_DET_INT_RAW field.
	UART0_INT_RAW_AT_CMD_CHAR_DET_INT_RAW_Msk = 0x40000
	// Bit AT_CMD_CHAR_DET_INT_RAW.
	UART0_INT_RAW_AT_CMD_CHAR_DET_INT_RAW = 0x40000
	// Position of WAKEUP_INT_RAW field.
	UART0_INT_RAW_WAKEUP_INT_RAW_Pos = 0x13
	// Bit mask of WAKEUP_INT_RAW field.
	UART0_INT_RAW_WAKEUP_INT_RAW_Msk = 0x80000
	// Bit WAKEUP_INT_RAW.
	UART0_INT_RAW_WAKEUP_INT_RAW = 0x80000

	// INT_ST: Masked interrupt status
	// Position of RXFIFO_FULL_INT_ST field.
	UART0_INT_ST_RXFIFO_FULL_INT_ST_Pos = 0x0
	// Bit mask of RXFIFO_FULL_INT_ST field.
	UART0_INT_ST_RXFIFO_FULL_INT_ST_Msk = 0x1
	// Bit RXFIFO_FULL_INT_ST.
	UART0_INT_ST_RXFIFO_FULL_INT_ST = 0x1
	// Position of TXFIFO_EMPTY_INT_ST field.
	UART0_INT_ST_TXFIFO_EMPTY_INT_ST_Pos = 0x1
	// Bit mask of TXFIFO_EMPTY_INT_ST field.
	UART0_INT_ST_TXFIFO_EMPTY_INT_ST_Msk = 0x2
	// Bit TXFIFO_EMPTY_INT_ST.
	UART0_INT_ST_TXFIFO_EMPTY_INT_ST = 0x2
	// Position of PARITY_ERR_INT_ST field.
	UART0_INT_ST_PARITY_ERR_INT_ST_Pos = 0x2
	// Bit mask of PARITY_ERR_INT_ST field.
	UART0_INT_ST_PARITY_ERR_INT_ST_Msk = 0x4
	// Bit PARITY_ERR_INT_ST.
	UART0_INT_ST_PARITY_ERR_INT_ST = 0x4
	// Position of FRM_ERR_INT_ST field.
	UART0_INT_ST_FRM_ERR_INT_ST_Pos = 0x3
	// Bit mask of FRM_ERR_INT_ST field.
	UART0_INT_ST_FRM_ERR_INT_ST_Msk = 0x8
	// Bit FRM_ERR_INT_ST.
	UART0_INT_ST_FRM_ERR_INT_ST = 0x8
	// Position of RXFIFO_OVF_INT_ST field.
	UART0_INT_ST_RXFIFO_OVF_INT_ST_Pos = 0x4
	// Bit mask of RXFIFO_OVF_INT_ST field.
	UART0_INT_ST_RXFIFO_OVF_INT_ST_Msk = 0x10
	// Bit RXFIFO_OVF_INT_ST.
	UART0_INT_ST_RXFIFO_OVF_INT_ST = 0x10
	// Position of DSR_CHG_INT_ST field.
	UART0_INT_ST_DSR_CHG_INT_ST_Pos = 0x5
	// Bit mask of DSR_CHG_INT_ST field.
	UART0_INT_ST_DSR_CHG_INT_ST_Msk = 0x20
	// Bit DSR_CHG_INT_ST.
	UART0_INT_ST_DSR_CHG_INT_ST = 0x20
	// Position of CTS_CHG_INT_ST field.
	UART0_INT_ST_CTS_CHG_INT_ST_Pos = 0x6
	// Bit mask of CTS_CHG_INT_ST field.
	UART0_INT_ST_CTS_CHG_INT_ST_Msk = 0x40
	// Bit CTS_CHG_INT_ST.
	UART0_INT_ST_CTS_CHG_INT_ST = 0x40
	// Position of BRK_DET_INT_ST field.
	UART0_INT_ST_BRK_DET_INT_ST_Pos = 0x7
	// Bit mask of BRK_DET_INT_ST field.
	UART0_INT_ST_BRK_DET_INT_ST_Msk = 0x80
	// Bit BRK_DET_INT_ST.
	UART0_INT_ST_BRK_DET_INT_ST = 0x80
	// Position of RXFIFO_TOUT_INT_ST field.
	UART0_INT_ST_RXFIFO_TOUT_INT_ST_Pos = 0x8
	// Bit mask of RXFIFO_TOUT_INT_ST field.
	UART0_INT_ST_RXFIFO_TOUT_INT_ST_Msk = 0x100
	// Bit RXFIFO_TOUT_INT_ST.
	UART0_INT_ST_RXFIFO_TOUT_INT_ST = 0x100
	// Position of SW_XON_INT_ST field.
	UART0_INT_ST_SW_XON_INT_ST_Pos = 0x9
	// Bit mask of SW_XON_INT_ST field.
	UART0_INT_ST_SW_XON_INT_ST_Msk = 0x200
	// Bit SW_XON_INT_ST.
	UART0_INT_ST_SW_XON_INT_ST = 0x200
	// Position of SW_XOFF_INT_ST field.
	UART0_INT_ST_SW_XOFF_INT_ST_Pos = 0xa
	// Bit mask of SW_XOFF_INT_ST field.
	UART0_INT_ST_SW_XOFF_INT_ST_Msk = 0x400
	// Bit SW_XOFF_INT_ST.
	UART0_INT_ST_SW_XOFF_INT_ST = 0x400
	// Position of GLITCH_DET_INT_ST field.
	UART0_INT_ST_GLITCH_DET_INT_ST_Pos = 0xb
	// Bit mask of GLITCH_DET_INT_ST field.
	UART0_INT_ST_GLITCH_DET_INT_ST_Msk = 0x800
	// Bit GLITCH_DET_INT_ST.
	UART0_INT_ST_GLITCH_DET_INT_ST = 0x800
	// Position of TX_BRK_DONE_INT_ST field.
	UART0_INT_ST_TX_BRK_DONE_INT_ST_Pos = 0xc
	// Bit mask of TX_BRK_DONE_INT_ST field.
	UART0_INT_ST_TX_BRK_DONE_INT_ST_Msk = 0x1000
	// Bit TX_BRK_DONE_INT_ST.
	UART0_INT_ST_TX_BRK_DONE_INT_ST = 0x1000
	// Position of TX_BRK_IDLE_DONE_INT_ST field.
	UART0_INT_ST_TX_BRK_IDLE_DONE_INT_ST_Pos = 0xd
	// Bit mask of TX_BRK_IDLE_DONE_INT_ST field.
	UART0_INT_ST_TX_BRK_IDLE_DONE_INT_ST_Msk = 0x2000
	// Bit TX_BRK_IDLE_DONE_INT_ST.
	UART0_INT_ST_TX_BRK_IDLE_DONE_INT_ST = 0x2000
	// Position of TX_DONE_INT_ST field.
	UART0_INT_ST_TX_DONE_INT_ST_Pos = 0xe
	// Bit mask of TX_DONE_INT_ST field.
	UART0_INT_ST_TX_DONE_INT_ST_Msk = 0x4000
	// Bit TX_DONE_INT_ST.
	UART0_INT_ST_TX_DONE_INT_ST = 0x4000
	// Position of RS485_PARITY_ERR_INT_ST field.
	UART0_INT_ST_RS485_PARITY_ERR_INT_ST_Pos = 0xf
	// Bit mask of RS485_PARITY_ERR_INT_ST field.
	UART0_INT_ST_RS485_PARITY_ERR_INT_ST_Msk = 0x8000
	// Bit RS485_PARITY_ERR_INT_ST.
	UART0_INT_ST_RS485_PARITY_ERR_INT_ST = 0x8000
	// Position of RS485_FRM_ERR_INT_ST field.
	UART0_INT_ST_RS485_FRM_ERR_INT_ST_Pos = 0x10
	// Bit mask of RS485_FRM_ERR_INT_ST field.
	UART0_INT_ST_RS485_FRM_ERR_INT_ST_Msk = 0x10000
	// Bit RS485_FRM_ERR_INT_ST.
	UART0_INT_ST_RS485_FRM_ERR_INT_ST = 0x10000
	// Position of RS485_CLASH_INT_ST field.
	UART0_INT_ST_RS485_CLASH_INT_ST_Pos = 0x11
	// Bit mask of RS485_CLASH_INT_ST field.
	UART0_INT_ST_RS485_CLASH_INT_ST_Msk = 0x20000
	// Bit RS485_CLASH_INT_ST.
	UART0_INT_ST_RS485_CLASH_INT_ST = 0x20000
	// Position of AT_CMD_CHAR_DET_INT_ST field.
	UART0_INT_ST_AT_CMD_CHAR_DET_INT_ST_Pos = 0x12
	// Bit mask of AT_CMD_CHAR_DET_INT_ST field.
	UART0_INT_ST_AT_CMD_CHAR_DET_INT_ST_Msk = 0x40000
	// Bit AT_CMD_CHAR_DET_INT_ST.
	UART0_INT_ST_AT_CMD_CHAR_DET_INT_ST = 0x40000
	// Position of WAKEUP_INT_ST field.
	UART0_INT_ST_WAKEUP_INT_ST_Pos = 0x13
	// Bit mask of WAKEUP_INT_ST field.
	UART0_INT_ST_WAKEUP_INT_ST_Msk = 0x80000
	// Bit WAKEUP_INT_ST.
	UART0_INT_ST_WAKEUP_INT_ST = 0x80000

	// INT_ENA: Interrupt enable bits
	// Position of RXFIFO_FULL_INT_ENA field.
	UART0_INT_ENA_RXFIFO_FULL_INT_ENA_Pos = 0x0
	// Bit mask of RXFIFO_FULL_INT_ENA field.
	UART0_INT_ENA_RXFIFO_FULL_INT_ENA_Msk = 0x1
	// Bit RXFIFO_FULL_INT_ENA.
	UART0_INT_ENA_RXFIFO_FULL_INT_ENA = 0x1
	// Position of TXFIFO_EMPTY_INT_ENA field.
	UART0_INT_ENA_TXFIFO_EMPTY_INT_ENA_Pos = 0x1
	// Bit mask of TXFIFO_EMPTY_INT_ENA field.
	UART0_INT_ENA_TXFIFO_EMPTY_INT_ENA_Msk = 0x2
	// Bit TXFIFO_EMPTY_INT_ENA.
	UART0_INT_ENA_TXFIFO_EMPTY_INT_ENA = 0x2
	// Position of PARITY_ERR_INT_ENA field.
	UART0_INT_ENA_PARITY_ERR_INT_ENA_Pos = 0x2
	// Bit mask of PARITY_ERR_INT_ENA field.
	UART0_INT_ENA_PARITY_ERR_INT_ENA_Msk = 0x4
	// Bit PARITY_ERR_INT_ENA.
	UART0_INT_ENA_PARITY_ERR_INT_ENA = 0x4
	// Position of FRM_ERR_INT_ENA field.
	UART0_INT_ENA_FRM_ERR_INT_ENA_Pos = 0x3
	// Bit mask of FRM_ERR_INT_ENA field.
	UART0_INT_ENA_FRM_ERR_INT_ENA_Msk = 0x8
	// Bit FRM_ERR_INT_ENA.
	UART0_INT_ENA_FRM_ERR_INT_ENA = 0x8
	// Position of RXFIFO_OVF_INT_ENA field.
	UART0_INT_ENA_RXFIFO_OVF_INT_ENA_Pos = 0x4
	// Bit mask of RXFIFO_OVF_INT_ENA field.
	UART0_INT_ENA_RXFIFO_OVF_INT_ENA_Msk = 0x10
	// Bit RXFIFO_OVF_INT_ENA.
	UART0_INT_ENA_RXFIFO_OVF_INT_ENA = 0x10
	// Position of DSR_CHG_INT_ENA field.
	UART0_INT_ENA_DSR_CHG_INT_ENA_Pos = 0x5
	// Bit mask of DSR_CHG_INT_ENA field.
	UART0_INT_ENA_DSR_CHG_INT_ENA_Msk = 0x20
	// Bit DSR_CHG_INT_ENA.
	UART0_INT_ENA_DSR_CHG_INT_ENA = 0x20
	// Position of CTS_CHG_INT_ENA field.
	UART0_INT_ENA_CTS_CHG_INT_ENA_Pos = 0x6
	// Bit mask of CTS_CHG_INT_ENA field.
	UART0_INT_ENA_CTS_CHG_INT_ENA_Msk = 0x40
	// Bit CTS_CHG_INT_ENA.
	UART0_INT_ENA_CTS_CHG_INT_ENA = 0x40
	// Position of BRK_DET_INT_ENA field.
	UART0_INT_ENA_BRK_DET_INT_ENA_Pos = 0x7
	// Bit mask of BRK_DET_INT_ENA field.
	UART0_INT_ENA_BRK_DET_INT_ENA_Msk = 0x80
	// Bit BRK_DET_INT_ENA.
	UART0_INT_ENA_BRK_DET_INT_ENA = 0x80
	// Position of RXFIFO_TOUT_INT_ENA field.
	UART0_INT_ENA_RXFIFO_TOUT_INT_ENA_Pos = 0x8
	// Bit mask of RXFIFO_TOUT_INT_ENA field.
	UART0_INT_ENA_RXFIFO_TOUT_INT_ENA_Msk = 0x100
	// Bit RXFIFO_TOUT_INT_ENA.
	UART0_INT_ENA_RXFIFO_TOUT_INT_ENA = 0x100
	// Position of SW_XON_INT_ENA field.
	UART0_INT_ENA_SW_XON_INT_ENA_Pos = 0x9
	// Bit mask of SW_XON_INT_ENA field.
	UART0_INT_ENA_SW_XON_INT_ENA_Msk = 0x200
	// Bit SW_XON_INT_ENA.
	UART0_INT_ENA_SW_XON_INT_ENA = 0x200
	// Position of SW_XOFF_INT_ENA field.
	UART0_INT_ENA_SW_XOFF_INT_ENA_Pos = 0xa
	// Bit mask of SW_XOFF_INT_ENA field.
	UART0_INT_ENA_SW_XOFF_INT_ENA_Msk = 0x400
	// Bit SW_XOFF_INT_ENA.
	UART0_INT_ENA_SW_XOFF_INT_ENA = 0x400
	// Position of GLITCH_DET_INT_ENA field.
	UART0_INT_ENA_GLITCH_DET_INT_ENA_Pos = 0xb
	// Bit mask of GLITCH_DET_INT_ENA field.
	UART0_INT_ENA_GLITCH_DET_INT_ENA_Msk = 0x800
	// Bit GLITCH_DET_INT_ENA.
	UART0_INT_ENA_GLITCH_DET_INT_ENA = 0x800
	// Position of TX_BRK_DONE_INT_ENA field.
	UART0_INT_ENA_TX_BRK_DONE_INT_ENA_Pos = 0xc
	// Bit mask of TX_BRK_DONE_INT_ENA field.
	UART0_INT_ENA_TX_BRK_DONE_INT_ENA_Msk = 0x1000
	// Bit TX_BRK_DONE_INT_ENA.
	UART0_INT_ENA_TX_BRK_DONE_INT_ENA = 0x1000
	// Position of TX_BRK_IDLE_DONE_INT_ENA field.
	UART0_INT_ENA_TX_BRK_IDLE_DONE_INT_ENA_Pos = 0xd
	// Bit mask of TX_BRK_IDLE_DONE_INT_ENA field.
	UART0_INT_ENA_TX_BRK_IDLE_DONE_INT_ENA_Msk = 0x2000
	// Bit TX_BRK_IDLE_DONE_INT_ENA.
	UART0_INT_ENA_TX_BRK_IDLE_DONE_INT_ENA = 0x2000
	// Position of TX_DONE_INT_ENA field.
	UART0_INT_ENA_TX_DONE_INT_ENA_Pos = 0xe
	// Bit mask of TX_DONE_INT_ENA field.
	UART0_INT_ENA_TX_DONE_INT_ENA_Msk = 0x4000
	// Bit TX_DONE_INT_ENA.
	UART0_INT_ENA_TX_DONE_INT_ENA = 0x4000
	// Position of RS485_PARITY_ERR_INT_ENA field.
	UART0_INT_ENA_RS485_PARITY_ERR_INT_ENA_Pos = 0xf
	// Bit mask of RS485_PARITY_ERR_INT_ENA field.
	UART0_INT_ENA_RS485_PARITY_ERR_INT_ENA_Msk = 0x8000
	// Bit RS485_PARITY_ERR_INT_ENA.
	UART0_INT_ENA_RS485_PARITY_ERR_INT_ENA = 0x8000
	// Position of RS485_FRM_ERR_INT_ENA field.
	UART0_INT_ENA_RS485_FRM_ERR_INT_ENA_Pos = 0x10
	// Bit mask of RS485_FRM_ERR_INT_ENA field.
	UART0_INT_ENA_RS485_FRM_ERR_INT_ENA_Msk = 0x10000
	// Bit RS485_FRM_ERR_INT_ENA.
	UART0_INT_ENA_RS485_FRM_ERR_INT_ENA = 0x10000
	// Position of RS485_CLASH_INT_ENA field.
	UART0_INT_ENA_RS485_CLASH_INT_ENA_Pos = 0x11
	// Bit mask of RS485_CLASH_INT_ENA field.
	UART0_INT_ENA_RS485_CLASH_INT_ENA_Msk = 0x20000
	// Bit RS485_CLASH_INT_ENA.
	UART0_INT_ENA_RS485_CLASH_INT_ENA = 0x20000
	// Position of AT_CMD_CHAR_DET_INT_ENA field.
	UART0_INT_ENA_AT_CMD_CHAR_DET_INT_ENA_Pos = 0x12
	// Bit mask of AT_CMD_CHAR_DET_INT_ENA field.
	UART0_INT_ENA_AT_CMD_CHAR_DET_INT_ENA_Msk = 0x40000
	// Bit AT_CMD_CHAR_DET_INT_ENA.
	UART0_INT_ENA_AT_CMD_CHAR_DET_INT_ENA = 0x40000
	// Position of WAKEUP_INT_ENA field.
	UART0_INT_ENA_WAKEUP_INT_ENA_Pos = 0x13
	// Bit mask of WAKEUP_INT_ENA field.
	UART0_INT_ENA_WAKEUP_INT_ENA_Msk = 0x80000
	// Bit WAKEUP_INT_ENA.
	UART0_INT_ENA_WAKEUP_INT_ENA = 0x80000

	// INT_CLR: Interrupt clear bits
	// Position of RXFIFO_FULL_INT_CLR field.
	UART0_INT_CLR_RXFIFO_FULL_INT_CLR_Pos = 0x0
	// Bit mask of RXFIFO_FULL_INT_CLR field.
	UART0_INT_CLR_RXFIFO_FULL_INT_CLR_Msk = 0x1
	// Bit RXFIFO_FULL_INT_CLR.
	UART0_INT_CLR_RXFIFO_FULL_INT_CLR = 0x1
	// Position of TXFIFO_EMPTY_INT_CLR field.
	UART0_INT_CLR_TXFIFO_EMPTY_INT_CLR_Pos = 0x1
	// Bit mask of TXFIFO_EMPTY_INT_CLR field.
	UART0_INT_CLR_TXFIFO_EMPTY_INT_CLR_Msk = 0x2
	// Bit TXFIFO_EMPTY_INT_CLR.
	UART0_INT_CLR_TXFIFO_EMPTY_INT_CLR = 0x2
	// Position of PARITY_ERR_INT_CLR field.
	UART0_INT_CLR_PARITY_ERR_INT_CLR_Pos = 0x2
	// Bit mask of PARITY_ERR_INT_CLR field.
	UART0_INT_CLR_PARITY_ERR_INT_CLR_Msk = 0x4
	// Bit PARITY_ERR_INT_CLR.
	UART0_INT_CLR_PARITY_ERR_INT_CLR = 0x4
	// Position of FRM_ERR_INT_CLR field.
	UART0_INT_CLR_FRM_ERR_INT_CLR_Pos = 0x3
	// Bit mask of FRM_ERR_INT_CLR field.
	UART0_INT_CLR_FRM_ERR_INT_CLR_Msk = 0x8
	// Bit FRM_ERR_INT_CLR.
	UART0_INT_CLR_FRM_ERR_INT_CLR = 0x8
	// Position of RXFIFO_OVF_INT_CLR field.
	UART0_INT_CLR_RXFIFO_OVF_INT_CLR_Pos = 0x4
	// Bit mask of RXFIFO_OVF_INT_CLR field.
	UART0_INT_CLR_RXFIFO_OVF_INT_CLR_Msk = 0x10
	// Bit RXFIFO_OVF_INT_CLR.
	UART0_INT_CLR_RXFIFO_OVF_INT_CLR = 0x10
	// Position of DSR_CHG_INT_CLR field.
	UART0_INT_CLR_DSR_CHG_INT_CLR_Pos = 0x5
	// Bit mask of DSR_CHG_INT_CLR field.
	UART0_INT_CLR_DSR_CHG_INT_CLR_Msk = 0x20
	// Bit DSR_CHG_INT_CLR.
	UART0_INT_CLR_DSR_CHG_INT_CLR = 0x20
	// Position of CTS_CHG_INT_CLR field.
	UART0_INT_CLR_CTS_CHG_INT_CLR_Pos = 0x6
	// Bit mask of CTS_CHG_INT_CLR field.
	UART0_INT_CLR_CTS_CHG_INT_CLR_Msk = 0x40
	// Bit CTS_CHG_INT_CLR.
	UART0_INT_CLR_CTS_CHG_INT_CLR = 0x40
	// Position of BRK_DET_INT_CLR field.
	UART0_INT_CLR_BRK_DET_INT_CLR_Pos = 0x7
	// Bit mask of BRK_DET_INT_CLR field.
	UART0_INT_CLR_BRK_DET_INT_CLR_Msk = 0x80
	// Bit BRK_DET_INT_CLR.
	UART0_INT_CLR_BRK_DET_INT_CLR = 0x80
	// Position of RXFIFO_TOUT_INT_CLR field.
	UART0_INT_CLR_RXFIFO_TOUT_INT_CLR_Pos = 0x8
	// Bit mask of RXFIFO_TOUT_INT_CLR field.
	UART0_INT_CLR_RXFIFO_TOUT_INT_CLR_Msk = 0x100
	// Bit RXFIFO_TOUT_INT_CLR.
	UART0_INT_CLR_RXFIFO_TOUT_INT_CLR = 0x100
	// Position of SW_XON_INT_CLR field.
	UART0_INT_CLR_SW_XON_INT_CLR_Pos = 0x9
	// Bit mask of SW_XON_INT_CLR field.
	UART0_INT_CLR_SW_XON_INT_CLR_Msk = 0x200
	// Bit SW_XON_INT_CLR.
	UART0_INT_CLR_SW_XON_INT_CLR = 0x200
	// Position of SW_XOFF_INT_CLR field.
	UART0_INT_CLR_SW_XOFF_INT_CLR_Pos = 0xa
	// Bit mask of SW_XOFF_INT_CLR field.
	UART0_INT_CLR_SW_XOFF_INT_CLR_Msk = 0x400
	// Bit SW_XOFF_INT_CLR.
	UART0_INT_CLR_SW_XOFF_INT_CLR = 0x400
	// Position of GLITCH_DET_INT_CLR field.
	UART0_INT_CLR_GLITCH_DET_INT_CLR_Pos = 0xb
	// Bit mask of GLITCH_DET_INT_CLR field.
	UART0_INT_CLR_GLITCH_DET_INT_CLR_Msk = 0x800
	// Bit GLITCH_DET_INT_CLR.
	UART0_INT_CLR_GLITCH_DET_INT_CLR = 0x800
	// Position of TX_BRK_DONE_INT_CLR field.
	UART0_INT_CLR_TX_BRK_DONE_INT_CLR_Pos = 0xc
	// Bit mask of TX_BRK_DONE_INT_CLR field.
	UART0_INT_CLR_TX_BRK_DONE_INT_CLR_Msk = 0x1000
	// Bit TX_BRK_DONE_INT_CLR.
	UART0_INT_CLR_TX_BRK_DONE_INT_CLR = 0x1000
	// Position of TX_BRK_IDLE_DONE_INT_CLR field.
	UART0_INT_CLR_TX_BRK_IDLE_DONE_INT_CLR_Pos = 0xd
	// Bit mask of TX_BRK_IDLE_DONE_INT_CLR field.
	UART0_INT_CLR_TX_BRK_IDLE_DONE_INT_CLR_Msk = 0x2000
	// Bit TX_BRK_IDLE_DONE_INT_CLR.
	UART0_INT_CLR_TX_BRK_IDLE_DONE_INT_CLR = 0x2000
	// Position of TX_DONE_INT_CLR field.
	UART0_INT_CLR_TX_DONE_INT_CLR_Pos = 0xe
	// Bit mask of TX_DONE_INT_CLR field.
	UART0_INT_CLR_TX_DONE_INT_CLR_Msk = 0x4000
	// Bit TX_DONE_INT_CLR.
	UART0_INT_CLR_TX_DONE_INT_CLR = 0x4000
	// Position of RS485_PARITY_ERR_INT_CLR field.
	UART0_INT_CLR_RS485_PARITY_ERR_INT_CLR_Pos = 0xf
	// Bit mask of RS485_PARITY_ERR_INT_CLR field.
	UART0_INT_CLR_RS485_PARITY_ERR_INT_CLR_Msk = 0x8000
	// Bit RS485_PARITY_ERR_INT_CLR.
	UART0_INT_CLR_RS485_PARITY_ERR_INT_CLR = 0x8000
	// Position of RS485_FRM_ERR_INT_CLR field.
	UART0_INT_CLR_RS485_FRM_ERR_INT_CLR_Pos = 0x10
	// Bit mask of RS485_FRM_ERR_INT_CLR field.
	UART0_INT_CLR_RS485_FRM_ERR_INT_CLR_Msk = 0x10000
	// Bit RS485_FRM_ERR_INT_CLR.
	UART0_INT_CLR_RS485_FRM_ERR_INT_CLR = 0x10000
	// Position of RS485_CLASH_INT_CLR field.
	UART0_INT_CLR_RS485_CLASH_INT_CLR_Pos = 0x11
	// Bit mask of RS485_CLASH_INT_CLR field.
	UART0_INT_CLR_RS485_CLASH_INT_CLR_Msk = 0x20000
	// Bit RS485_CLASH_INT_CLR.
	UART0_INT_CLR_RS485_CLASH_INT_CLR = 0x20000
	// Position of AT_CMD_CHAR_DET_INT_CLR field.
	UART0_INT_CLR_AT_CMD_CHAR_DET_INT_CLR_Pos = 0x12
	// Bit mask of AT_CMD_CHAR_DET_INT_CLR field.
	UART0_INT_CLR_AT_CMD_CHAR_DET_INT_CLR_Msk = 0x40000
	// Bit AT_CMD_CHAR_DET_INT_CLR.
	UART0_INT_CLR_AT_CMD_CHAR_DET_INT_CLR = 0x40000
	// Position of WAKEUP_INT_CLR field.
	UART0_INT_CLR_WAKEUP_INT_CLR_Pos = 0x13
	// Bit mask of WAKEUP_INT_CLR field.
	UART0_INT_CLR_WAKEUP_INT_CLR_Msk = 0x80000
	// Bit WAKEUP_INT_CLR.
	UART0_INT_CLR_WAKEUP_INT_CLR = 0x80000

	// CLKDIV: Clock divider configuration
	// Position of CLKDIV field.
	UART0_CLKDIV_CLKDIV_Pos = 0x0
	// Bit mask of CLKDIV field.
	UART0_CLKDIV_CLKDIV_Msk = 0xfffff
	// Position of FRAG field.
	UART0_CLKDIV_FRAG_Pos = 0x14
	// Bit mask of FRAG field.
	UART0_CLKDIV_FRAG_Msk = 0xf00000

	// AUTOBAUD: Autobaud configuration register
	// Position of EN field.
	UART0_AUTOBAUD_EN_Pos = 0x0
	// Bit mask of EN field.
	UART0_AUTOBAUD_EN_Msk = 0x1
	// Bit EN.
	UART0_AUTOBAUD_EN = 0x1
	// Position of GLITCH_FILT field.
	UART0_AUTOBAUD_GLITCH_FILT_Pos = 0x8
	// Bit mask of GLITCH_FILT field.
	UART0_AUTOBAUD_GLITCH_FILT_Msk = 0xff00

	// STATUS: UART status register
	// Position of RXFIFO_CNT field.
	UART0_STATUS_RXFIFO_CNT_Pos = 0x0
	// Bit mask of RXFIFO_CNT field.
	UART0_STATUS_RXFIFO_CNT_Msk = 0x3ff
	// Position of DSRN field.
	UART0_STATUS_DSRN_Pos = 0xd
	// Bit mask of DSRN field.
	UART0_STATUS_DSRN_Msk = 0x2000
	// Bit DSRN.
	UART0_STATUS_DSRN = 0x2000
	// Position of CTSN field.
	UART0_STATUS_CTSN_Pos = 0xe
	// Bit mask of CTSN field.
	UART0_STATUS_CTSN_Msk = 0x4000
	// Bit CTSN.
	UART0_STATUS_CTSN = 0x4000
	// Position of RXD field.
	UART0_STATUS_RXD_Pos = 0xf
	// Bit mask of RXD field.
	UART0_STATUS_RXD_Msk = 0x8000
	// Bit RXD.
	UART0_STATUS_RXD = 0x8000
	// Position of TXFIFO_CNT field.
	UART0_STATUS_TXFIFO_CNT_Pos = 0x10
	// Bit mask of TXFIFO_CNT field.
	UART0_STATUS_TXFIFO_CNT_Msk = 0x3ff0000
	// Position of DTRN field.
	UART0_STATUS_DTRN_Pos = 0x1d
	// Bit mask of DTRN field.
	UART0_STATUS_DTRN_Msk = 0x20000000
	// Bit DTRN.
	UART0_STATUS_DTRN = 0x20000000
	// Position of RTSN field.
	UART0_STATUS_RTSN_Pos = 0x1e
	// Bit mask of RTSN field.
	UART0_STATUS_RTSN_Msk = 0x40000000
	// Bit RTSN.
	UART0_STATUS_RTSN = 0x40000000
	// Position of TXD field.
	UART0_STATUS_TXD_Pos = 0x1f
	// Bit mask of TXD field.
	UART0_STATUS_TXD_Msk = 0x80000000
	// Bit TXD.
	UART0_STATUS_TXD = 0x80000000

	// CONF0: Configuration register 0
	// Position of PARITY field.
	UART0_CONF0_PARITY_Pos = 0x0
	// Bit mask of PARITY field.
	UART0_CONF0_PARITY_Msk = 0x1
	// Bit PARITY.
	UART0_CONF0_PARITY = 0x1
	// Position of PARITY_EN field.
	UART0_CONF0_PARITY_EN_Pos = 0x1
	// Bit mask of PARITY_EN field.
	UART0_CONF0_PARITY_EN_Msk = 0x2
	// Bit PARITY_EN.
	UART0_CONF0_PARITY_EN = 0x2
	// Position of BIT_NUM field.
	UART0_CONF0_BIT_NUM_Pos = 0x2
	// Bit mask of BIT_NUM field.
	UART0_CONF0_BIT_NUM_Msk = 0xc
	// Position of STOP_BIT_NUM field.
	UART0_CONF0_STOP_BIT_NUM_Pos = 0x4
	// Bit mask of STOP_BIT_NUM field.
	UART0_CONF0_STOP_BIT_NUM_Msk = 0x30
	// Position of SW_RTS field.
	UART0_CONF0_SW_RTS_Pos = 0x6
	// Bit mask of SW_RTS field.
	UART0_CONF0_SW_RTS_Msk = 0x40
	// Bit SW_RTS.
	UART0_CONF0_SW_RTS = 0x40
	// Position of SW_DTR field.
	UART0_CONF0_SW_DTR_Pos = 0x7
	// Bit mask of SW_DTR field.
	UART0_CONF0_SW_DTR_Msk = 0x80
	// Bit SW_DTR.
	UART0_CONF0_SW_DTR = 0x80
	// Position of TXD_BRK field.
	UART0_CONF0_TXD_BRK_Pos = 0x8
	// Bit mask of TXD_BRK field.
	UART0_CONF0_TXD_BRK_Msk = 0x100
	// Bit TXD_BRK.
	UART0_CONF0_TXD_BRK = 0x100
	// Position of IRDA_DPLX field.
	UART0_CONF0_IRDA_DPLX_Pos = 0x9
	// Bit mask of IRDA_DPLX field.
	UART0_CONF0_IRDA_DPLX_Msk = 0x200
	// Bit IRDA_DPLX.
	UART0_CONF0_IRDA_DPLX = 0x200
	// Position of IRDA_TX_EN field.
	UART0_CONF0_IRDA_TX_EN_Pos = 0xa
	// Bit mask of IRDA_TX_EN field.
	UART0_CONF0_IRDA_TX_EN_Msk = 0x400
	// Bit IRDA_TX_EN.
	UART0_CONF0_IRDA_TX_EN = 0x400
	// Position of IRDA_WCTL field.
	UART0_CONF0_IRDA_WCTL_Pos = 0xb
	// Bit mask of IRDA_WCTL field.
	UART0_CONF0_IRDA_WCTL_Msk = 0x800
	// Bit IRDA_WCTL.
	UART0_CONF0_IRDA_WCTL = 0x800
	// Position of IRDA_TX_INV field.
	UART0_CONF0_IRDA_TX_INV_Pos = 0xc
	// Bit mask of IRDA_TX_INV field.
	UART0_CONF0_IRDA_TX_INV_Msk = 0x1000
	// Bit IRDA_TX_INV.
	UART0_CONF0_IRDA_TX_INV = 0x1000
	// Position of IRDA_RX_INV field.
	UART0_CONF0_IRDA_RX_INV_Pos = 0xd
	// Bit mask of IRDA_RX_INV field.
	UART0_CONF0_IRDA_RX_INV_Msk = 0x2000
	// Bit IRDA_RX_INV.
	UART0_CONF0_IRDA_RX_INV = 0x2000
	// Position of LOOPBACK field.
	UART0_CONF0_LOOPBACK_Pos = 0xe
	// Bit mask of LOOPBACK field.
	UART0_CONF0_LOOPBACK_Msk = 0x4000
	// Bit LOOPBACK.
	UART0_CONF0_LOOPBACK = 0x4000
	// Position of TX_FLOW_EN field.
	UART0_CONF0_TX_FLOW_EN_Pos = 0xf
	// Bit mask of TX_FLOW_EN field.
	UART0_CONF0_TX_FLOW_EN_Msk = 0x8000
	// Bit TX_FLOW_EN.
	UART0_CONF0_TX_FLOW_EN = 0x8000
	// Position of IRDA_EN field.
	UART0_CONF0_IRDA_EN_Pos = 0x10
	// Bit mask of IRDA_EN field.
	UART0_CONF0_IRDA_EN_Msk = 0x10000
	// Bit IRDA_EN.
	UART0_CONF0_IRDA_EN = 0x10000
	// Position of RXFIFO_RST field.
	UART0_CONF0_RXFIFO_RST_Pos = 0x11
	// Bit mask of RXFIFO_RST field.
	UART0_CONF0_RXFIFO_RST_Msk = 0x20000
	// Bit RXFIFO_RST.
	UART0_CONF0_RXFIFO_RST = 0x20000
	// Position of TXFIFO_RST field.
	UART0_CONF0_TXFIFO_RST_Pos = 0x12
	// Bit mask of TXFIFO_RST field.
	UART0_CONF0_TXFIFO_RST_Msk = 0x40000
	// Bit TXFIFO_RST.
	UART0_CONF0_TXFIFO_RST = 0x40000
	// Position of RXD_INV field.
	UART0_CONF0_RXD_INV_Pos = 0x13
	// Bit mask of RXD_INV field.
	UART0_CONF0_RXD_INV_Msk = 0x80000
	// Bit RXD_INV.
	UART0_CONF0_RXD_INV = 0x80000
	// Position of CTS_INV field.
	UART0_CONF0_CTS_INV_Pos = 0x14
	// Bit mask of CTS_INV field.
	UART0_CONF0_CTS_INV_Msk = 0x100000
	// Bit CTS_INV.
	UART0_CONF0_CTS_INV = 0x100000
	// Position of DSR_INV field.
	UART0_CONF0_DSR_INV_Pos = 0x15
	// Bit mask of DSR_INV field.
	UART0_CONF0_DSR_INV_Msk = 0x200000
	// Bit DSR_INV.
	UART0_CONF0_DSR_INV = 0x200000
	// Position of TXD_INV field.
	UART0_CONF0_TXD_INV_Pos = 0x16
	// Bit mask of TXD_INV field.
	UART0_CONF0_TXD_INV_Msk = 0x400000
	// Bit TXD_INV.
	UART0_CONF0_TXD_INV = 0x400000
	// Position of RTS_INV field.
	UART0_CONF0_RTS_INV_Pos = 0x17
	// Bit mask of RTS_INV field.
	UART0_CONF0_RTS_INV_Msk = 0x800000
	// Bit RTS_INV.
	UART0_CONF0_RTS_INV = 0x800000
	// Position of DTR_INV field.
	UART0_CONF0_DTR_INV_Pos = 0x18
	// Bit mask of DTR_INV field.
	UART0_CONF0_DTR_INV_Msk = 0x1000000
	// Bit DTR_INV.
	UART0_CONF0_DTR_INV = 0x1000000
	// Position of CLK_EN field.
	UART0_CONF0_CLK_EN_Pos = 0x19
	// Bit mask of CLK_EN field.
	UART0_CONF0_CLK_EN_Msk = 0x2000000
	// Bit CLK_EN.
	UART0_CONF0_CLK_EN = 0x2000000
	// Position of ERR_WR_MASK field.
	UART0_CONF0_ERR_WR_MASK_Pos = 0x1a
	// Bit mask of ERR_WR_MASK field.
	UART0_CONF0_ERR_WR_MASK_Msk = 0x4000000
	// Bit ERR_WR_MASK.
	UART0_CONF0_ERR_WR_MASK = 0x4000000
	// Position of TICK_REF_ALWAYS_ON field.
	UART0_CONF0_TICK_REF_ALWAYS_ON_Pos = 0x1b
	// Bit mask of TICK_REF_ALWAYS_ON field.
	UART0_CONF0_TICK_REF_ALWAYS_ON_Msk = 0x8000000
	// Bit TICK_REF_ALWAYS_ON.
	UART0_CONF0_TICK_REF_ALWAYS_ON = 0x8000000
	// Position of MEM_CLK_EN field.
	UART0_CONF0_MEM_CLK_EN_Pos = 0x1c
	// Bit mask of MEM_CLK_EN field.
	UART0_CONF0_MEM_CLK_EN_Msk = 0x10000000
	// Bit MEM_CLK_EN.
	UART0_CONF0_MEM_CLK_EN = 0x10000000

	// CONF1: Configuration register 1
	// Position of RXFIFO_FULL_THRHD field.
	UART0_CONF1_RXFIFO_FULL_THRHD_Pos = 0x0
	// Bit mask of RXFIFO_FULL_THRHD field.
	UART0_CONF1_RXFIFO_FULL_THRHD_Msk = 0x1ff
	// Position of TXFIFO_EMPTY_THRHD field.
	UART0_CONF1_TXFIFO_EMPTY_THRHD_Pos = 0x9
	// Bit mask of TXFIFO_EMPTY_THRHD field.
	UART0_CONF1_TXFIFO_EMPTY_THRHD_Msk = 0x3fe00
	// Position of RX_TOUT_FLOW_DIS field.
	UART0_CONF1_RX_TOUT_FLOW_DIS_Pos = 0x1d
	// Bit mask of RX_TOUT_FLOW_DIS field.
	UART0_CONF1_RX_TOUT_FLOW_DIS_Msk = 0x20000000
	// Bit RX_TOUT_FLOW_DIS.
	UART0_CONF1_RX_TOUT_FLOW_DIS = 0x20000000
	// Position of RX_FLOW_EN field.
	UART0_CONF1_RX_FLOW_EN_Pos = 0x1e
	// Bit mask of RX_FLOW_EN field.
	UART0_CONF1_RX_FLOW_EN_Msk = 0x40000000
	// Bit RX_FLOW_EN.
	UART0_CONF1_RX_FLOW_EN = 0x40000000
	// Position of RX_TOUT_EN field.
	UART0_CONF1_RX_TOUT_EN_Pos = 0x1f
	// Bit mask of RX_TOUT_EN field.
	UART0_CONF1_RX_TOUT_EN_Msk = 0x80000000
	// Bit RX_TOUT_EN.
	UART0_CONF1_RX_TOUT_EN = 0x80000000

	// LOWPULSE: Autobaud minimum low pulse duration register
	// Position of MIN_CNT field.
	UART0_LOWPULSE_MIN_CNT_Pos = 0x0
	// Bit mask of MIN_CNT field.
	UART0_LOWPULSE_MIN_CNT_Msk = 0xfffff

	// HIGHPULSE: Autobaud minimum high pulse duration register
	// Position of MIN_CNT field.
	UART0_HIGHPULSE_MIN_CNT_Pos = 0x0
	// Bit mask of MIN_CNT field.
	UART0_HIGHPULSE_MIN_CNT_Msk = 0xfffff

	// RXD_CNT: Autobaud edge change count register
	// Position of RXD_EDGE_CNT field.
	UART0_RXD_CNT_RXD_EDGE_CNT_Pos = 0x0
	// Bit mask of RXD_EDGE_CNT field.
	UART0_RXD_CNT_RXD_EDGE_CNT_Msk = 0x3ff

	// FLOW_CONF: Software flow control configuration
	// Position of SW_FLOW_CON_EN field.
	UART0_FLOW_CONF_SW_FLOW_CON_EN_Pos = 0x0
	// Bit mask of SW_FLOW_CON_EN field.
	UART0_FLOW_CONF_SW_FLOW_CON_EN_Msk = 0x1
	// Bit SW_FLOW_CON_EN.
	UART0_FLOW_CONF_SW_FLOW_CON_EN = 0x1
	// Position of XONOFF_DEL field.
	UART0_FLOW_CONF_XONOFF_DEL_Pos = 0x1
	// Bit mask of XONOFF_DEL field.
	UART0_FLOW_CONF_XONOFF_DEL_Msk = 0x2
	// Bit XONOFF_DEL.
	UART0_FLOW_CONF_XONOFF_DEL = 0x2
	// Position of FORCE_XON field.
	UART0_FLOW_CONF_FORCE_XON_Pos = 0x2
	// Bit mask of FORCE_XON field.
	UART0_FLOW_CONF_FORCE_XON_Msk = 0x4
	// Bit FORCE_XON.
	UART0_FLOW_CONF_FORCE_XON = 0x4
	// Position of FORCE_XOFF field.
	UART0_FLOW_CONF_FORCE_XOFF_Pos = 0x3
	// Bit mask of FORCE_XOFF field.
	UART0_FLOW_CONF_FORCE_XOFF_Msk = 0x8
	// Bit FORCE_XOFF.
	UART0_FLOW_CONF_FORCE_XOFF = 0x8
	// Position of SEND_XON field.
	UART0_FLOW_CONF_SEND_XON_Pos = 0x4
	// Bit mask of SEND_XON field.
	UART0_FLOW_CONF_SEND_XON_Msk = 0x10
	// Bit SEND_XON.
	UART0_FLOW_CONF_SEND_XON = 0x10
	// Position of SEND_XOFF field.
	UART0_FLOW_CONF_SEND_XOFF_Pos = 0x5
	// Bit mask of SEND_XOFF field.
	UART0_FLOW_CONF_SEND_XOFF_Msk = 0x20
	// Bit SEND_XOFF.
	UART0_FLOW_CONF_SEND_XOFF = 0x20

	// SLEEP_CONF: Sleeping mode configuration
	// Position of ACTIVE_THRESHOLD field.
	UART0_SLEEP_CONF_ACTIVE_THRESHOLD_Pos = 0x0
	// Bit mask of ACTIVE_THRESHOLD field.
	UART0_SLEEP_CONF_ACTIVE_THRESHOLD_Msk = 0x3ff

	// SWFC_CONF0: Software flow control character configuration
	// Position of XOFF_THRESHOLD field.
	UART0_SWFC_CONF0_XOFF_THRESHOLD_Pos = 0x0
	// Bit mask of XOFF_THRESHOLD field.
	UART0_SWFC_CONF0_XOFF_THRESHOLD_Msk = 0x1ff
	// Position of XOFF_CHAR field.
	UART0_SWFC_CONF0_XOFF_CHAR_Pos = 0x9
	// Bit mask of XOFF_CHAR field.
	UART0_SWFC_CONF0_XOFF_CHAR_Msk = 0x1fe00

	// SWFC_CONF1: Software flow-control character configuration
	// Position of XON_THRESHOLD field.
	UART0_SWFC_CONF1_XON_THRESHOLD_Pos = 0x0
	// Bit mask of XON_THRESHOLD field.
	UART0_SWFC_CONF1_XON_THRESHOLD_Msk = 0x1ff
	// Position of XON_CHAR field.
	UART0_SWFC_CONF1_XON_CHAR_Pos = 0x9
	// Bit mask of XON_CHAR field.
	UART0_SWFC_CONF1_XON_CHAR_Msk = 0x1fe00

	// IDLE_CONF: Frame-end idle configuration
	// Position of RX_IDLE_THRHD field.
	UART0_IDLE_CONF_RX_IDLE_THRHD_Pos = 0x0
	// Bit mask of RX_IDLE_THRHD field.
	UART0_IDLE_CONF_RX_IDLE_THRHD_Msk = 0x3ff
	// Position of TX_IDLE_NUM field.
	UART0_IDLE_CONF_TX_IDLE_NUM_Pos = 0xa
	// Bit mask of TX_IDLE_NUM field.
	UART0_IDLE_CONF_TX_IDLE_NUM_Msk = 0xffc00
	// Position of TX_BRK_NUM field.
	UART0_IDLE_CONF_TX_BRK_NUM_Pos = 0x14
	// Bit mask of TX_BRK_NUM field.
	UART0_IDLE_CONF_TX_BRK_NUM_Msk = 0xff00000

	// RS485_CONF: RS485 mode configuration
	// Position of RS485_EN field.
	UART0_RS485_CONF_RS485_EN_Pos = 0x0
	// Bit mask of RS485_EN field.
	UART0_RS485_CONF_RS485_EN_Msk = 0x1
	// Bit RS485_EN.
	UART0_RS485_CONF_RS485_EN = 0x1
	// Position of DL0_EN field.
	UART0_RS485_CONF_DL0_EN_Pos = 0x1
	// Bit mask of DL0_EN field.
	UART0_RS485_CONF_DL0_EN_Msk = 0x2
	// Bit DL0_EN.
	UART0_RS485_CONF_DL0_EN = 0x2
	// Position of DL1_EN field.
	UART0_RS485_CONF_DL1_EN_Pos = 0x2
	// Bit mask of DL1_EN field.
	UART0_RS485_CONF_DL1_EN_Msk = 0x4
	// Bit DL1_EN.
	UART0_RS485_CONF_DL1_EN = 0x4
	// Position of RS485TX_RX_EN field.
	UART0_RS485_CONF_RS485TX_RX_EN_Pos = 0x3
	// Bit mask of RS485TX_RX_EN field.
	UART0_RS485_CONF_RS485TX_RX_EN_Msk = 0x8
	// Bit RS485TX_RX_EN.
	UART0_RS485_CONF_RS485TX_RX_EN = 0x8
	// Position of RS485RXBY_TX_EN field.
	UART0_RS485_CONF_RS485RXBY_TX_EN_Pos = 0x4
	// Bit mask of RS485RXBY_TX_EN field.
	UART0_RS485_CONF_RS485RXBY_TX_EN_Msk = 0x10
	// Bit RS485RXBY_TX_EN.
	UART0_RS485_CONF_RS485RXBY_TX_EN = 0x10
	// Position of RS485_RX_DLY_NUM field.
	UART0_RS485_CONF_RS485_RX_DLY_NUM_Pos = 0x5
	// Bit mask of RS485_RX_DLY_NUM field.
	UART0_RS485_CONF_RS485_RX_DLY_NUM_Msk = 0x20
	// Bit RS485_RX_DLY_NUM.
	UART0_RS485_CONF_RS485_RX_DLY_NUM = 0x20
	// Position of RS485_TX_DLY_NUM field.
	UART0_RS485_CONF_RS485_TX_DLY_NUM_Pos = 0x6
	// Bit mask of RS485_TX_DLY_NUM field.
	UART0_RS485_CONF_RS485_TX_DLY_NUM_Msk = 0x3c0

	// AT_CMD_PRECNT: Pre-sequence timing configuration
	// Position of PRE_IDLE_NUM field.
	UART0_AT_CMD_PRECNT_PRE_IDLE_NUM_Pos = 0x0
	// Bit mask of PRE_IDLE_NUM field.
	UART0_AT_CMD_PRECNT_PRE_IDLE_NUM_Msk = 0xffff

	// AT_CMD_POSTCNT: Post-sequence timing configuration
	// Position of POST_IDLE_NUM field.
	UART0_AT_CMD_POSTCNT_POST_IDLE_NUM_Pos = 0x0
	// Bit mask of POST_IDLE_NUM field.
	UART0_AT_CMD_POSTCNT_POST_IDLE_NUM_Msk = 0xffff

	// AT_CMD_GAPTOUT: Timeout configuration
	// Position of RX_GAP_TOUT field.
	UART0_AT_CMD_GAPTOUT_RX_GAP_TOUT_Pos = 0x0
	// Bit mask of RX_GAP_TOUT field.
	UART0_AT_CMD_GAPTOUT_RX_GAP_TOUT_Msk = 0xffff

	// AT_CMD_CHAR: AT Escape Sequence Selection Configuration
	// Position of AT_CMD_CHAR field.
	UART0_AT_CMD_CHAR_AT_CMD_CHAR_Pos = 0x0
	// Bit mask of AT_CMD_CHAR field.
	UART0_AT_CMD_CHAR_AT_CMD_CHAR_Msk = 0xff
	// Position of CHAR_NUM field.
	UART0_AT_CMD_CHAR_CHAR_NUM_Pos = 0x8
	// Bit mask of CHAR_NUM field.
	UART0_AT_CMD_CHAR_CHAR_NUM_Msk = 0xff00

	// MEM_CONF: UART threshold and allocation configuration
	// Position of RX_SIZE field.
	UART0_MEM_CONF_RX_SIZE_Pos = 0x1
	// Bit mask of RX_SIZE field.
	UART0_MEM_CONF_RX_SIZE_Msk = 0xe
	// Position of TX_SIZE field.
	UART0_MEM_CONF_TX_SIZE_Pos = 0x4
	// Bit mask of TX_SIZE field.
	UART0_MEM_CONF_TX_SIZE_Msk = 0x70
	// Position of RX_FLOW_THRHD field.
	UART0_MEM_CONF_RX_FLOW_THRHD_Pos = 0x7
	// Bit mask of RX_FLOW_THRHD field.
	UART0_MEM_CONF_RX_FLOW_THRHD_Msk = 0xff80
	// Position of RX_TOUT_THRHD field.
	UART0_MEM_CONF_RX_TOUT_THRHD_Pos = 0x10
	// Bit mask of RX_TOUT_THRHD field.
	UART0_MEM_CONF_RX_TOUT_THRHD_Msk = 0x3ff0000
	// Position of MEM_FORCE_PD field.
	UART0_MEM_CONF_MEM_FORCE_PD_Pos = 0x1a
	// Bit mask of MEM_FORCE_PD field.
	UART0_MEM_CONF_MEM_FORCE_PD_Msk = 0x4000000
	// Bit MEM_FORCE_PD.
	UART0_MEM_CONF_MEM_FORCE_PD = 0x4000000
	// Position of MEM_FORCE_PU field.
	UART0_MEM_CONF_MEM_FORCE_PU_Pos = 0x1b
	// Bit mask of MEM_FORCE_PU field.
	UART0_MEM_CONF_MEM_FORCE_PU_Msk = 0x8000000
	// Bit MEM_FORCE_PU.
	UART0_MEM_CONF_MEM_FORCE_PU = 0x8000000

	// MEM_TX_STATUS: TX FIFO write and read offset address
	// Position of APB_TX_WADDR field.
	UART0_MEM_TX_STATUS_APB_TX_WADDR_Pos = 0x0
	// Bit mask of APB_TX_WADDR field.
	UART0_MEM_TX_STATUS_APB_TX_WADDR_Msk = 0x3ff
	// Position of TX_RADDR field.
	UART0_MEM_TX_STATUS_TX_RADDR_Pos = 0xb
	// Bit mask of TX_RADDR field.
	UART0_MEM_TX_STATUS_TX_RADDR_Msk = 0x1ff800

	// MEM_RX_STATUS: RX FIFO write and read offset address
	// Position of APB_RX_RADDR field.
	UART0_MEM_RX_STATUS_APB_RX_RADDR_Pos = 0x0
	// Bit mask of APB_RX_RADDR field.
	UART0_MEM_RX_STATUS_APB_RX_RADDR_Msk = 0x3ff
	// Position of RX_WADDR field.
	UART0_MEM_RX_STATUS_RX_WADDR_Pos = 0xb
	// Bit mask of RX_WADDR field.
	UART0_MEM_RX_STATUS_RX_WADDR_Msk = 0x1ff800

	// FSM_STATUS: UART transmit and receive status
	// Position of ST_URX_OUT field.
	UART0_FSM_STATUS_ST_URX_OUT_Pos = 0x0
	// Bit mask of ST_URX_OUT field.
	UART0_FSM_STATUS_ST_URX_OUT_Msk = 0xf
	// Position of ST_UTX_OUT field.
	UART0_FSM_STATUS_ST_UTX_OUT_Pos = 0x4
	// Bit mask of ST_UTX_OUT field.
	UART0_FSM_STATUS_ST_UTX_OUT_Msk = 0xf0

	// POSPULSE: Autobaud high pulse register
	// Position of POSEDGE_MIN_CNT field.
	UART0_POSPULSE_POSEDGE_MIN_CNT_Pos = 0x0
	// Bit mask of POSEDGE_MIN_CNT field.
	UART0_POSPULSE_POSEDGE_MIN_CNT_Msk = 0xfffff

	// NEGPULSE: Autobaud low pulse register
	// Position of NEGEDGE_MIN_CNT field.
	UART0_NEGPULSE_NEGEDGE_MIN_CNT_Pos = 0x0
	// Bit mask of NEGEDGE_MIN_CNT field.
	UART0_NEGPULSE_NEGEDGE_MIN_CNT_Msk = 0xfffff

	// DATE: UART version control register
	// Position of DATE field.
	UART0_DATE_DATE_Pos = 0x0
	// Bit mask of DATE field.
	UART0_DATE_DATE_Msk = 0xffffffff

	// ID: UART ID register
	// Position of ID field.
	UART0_ID_ID_Pos = 0x0
	// Bit mask of ID field.
	UART0_ID_ID_Msk = 0xffffffff
)

// Constants for UHCI0: Peripheral UHCI0
const (
	// CONF0: UHCI configuration register
	// Position of IN_RST field.
	UHCI0_CONF0_IN_RST_Pos = 0x0
	// Bit mask of IN_RST field.
	UHCI0_CONF0_IN_RST_Msk = 0x1
	// Bit IN_RST.
	UHCI0_CONF0_IN_RST = 0x1
	// Position of OUT_RST field.
	UHCI0_CONF0_OUT_RST_Pos = 0x1
	// Bit mask of OUT_RST field.
	UHCI0_CONF0_OUT_RST_Msk = 0x2
	// Bit OUT_RST.
	UHCI0_CONF0_OUT_RST = 0x2
	// Position of AHBM_FIFO_RST field.
	UHCI0_CONF0_AHBM_FIFO_RST_Pos = 0x2
	// Bit mask of AHBM_FIFO_RST field.
	UHCI0_CONF0_AHBM_FIFO_RST_Msk = 0x4
	// Bit AHBM_FIFO_RST.
	UHCI0_CONF0_AHBM_FIFO_RST = 0x4
	// Position of AHBM_RST field.
	UHCI0_CONF0_AHBM_RST_Pos = 0x3
	// Bit mask of AHBM_RST field.
	UHCI0_CONF0_AHBM_RST_Msk = 0x8
	// Bit AHBM_RST.
	UHCI0_CONF0_AHBM_RST = 0x8
	// Position of IN_LOOP_TEST field.
	UHCI0_CONF0_IN_LOOP_TEST_Pos = 0x4
	// Bit mask of IN_LOOP_TEST field.
	UHCI0_CONF0_IN_LOOP_TEST_Msk = 0x10
	// Bit IN_LOOP_TEST.
	UHCI0_CONF0_IN_LOOP_TEST = 0x10
	// Position of OUT_LOOP_TEST field.
	UHCI0_CONF0_OUT_LOOP_TEST_Pos = 0x5
	// Bit mask of OUT_LOOP_TEST field.
	UHCI0_CONF0_OUT_LOOP_TEST_Msk = 0x20
	// Bit OUT_LOOP_TEST.
	UHCI0_CONF0_OUT_LOOP_TEST = 0x20
	// Position of OUT_AUTO_WRBACK field.
	UHCI0_CONF0_OUT_AUTO_WRBACK_Pos = 0x6
	// Bit mask of OUT_AUTO_WRBACK field.
	UHCI0_CONF0_OUT_AUTO_WRBACK_Msk = 0x40
	// Bit OUT_AUTO_WRBACK.
	UHCI0_CONF0_OUT_AUTO_WRBACK = 0x40
	// Position of OUT_NO_RESTART_CLR field.
	UHCI0_CONF0_OUT_NO_RESTART_CLR_Pos = 0x7
	// Bit mask of OUT_NO_RESTART_CLR field.
	UHCI0_CONF0_OUT_NO_RESTART_CLR_Msk = 0x80
	// Bit OUT_NO_RESTART_CLR.
	UHCI0_CONF0_OUT_NO_RESTART_CLR = 0x80
	// Position of OUT_EOF_MODE field.
	UHCI0_CONF0_OUT_EOF_MODE_Pos = 0x8
	// Bit mask of OUT_EOF_MODE field.
	UHCI0_CONF0_OUT_EOF_MODE_Msk = 0x100
	// Bit OUT_EOF_MODE.
	UHCI0_CONF0_OUT_EOF_MODE = 0x100
	// Position of UART0_CE field.
	UHCI0_CONF0_UART0_CE_Pos = 0x9
	// Bit mask of UART0_CE field.
	UHCI0_CONF0_UART0_CE_Msk = 0x200
	// Bit UART0_CE.
	UHCI0_CONF0_UART0_CE = 0x200
	// Position of UART1_CE field.
	UHCI0_CONF0_UART1_CE_Pos = 0xa
	// Bit mask of UART1_CE field.
	UHCI0_CONF0_UART1_CE_Msk = 0x400
	// Bit UART1_CE.
	UHCI0_CONF0_UART1_CE = 0x400
	// Position of OUTDSCR_BURST_EN field.
	UHCI0_CONF0_OUTDSCR_BURST_EN_Pos = 0xc
	// Bit mask of OUTDSCR_BURST_EN field.
	UHCI0_CONF0_OUTDSCR_BURST_EN_Msk = 0x1000
	// Bit OUTDSCR_BURST_EN.
	UHCI0_CONF0_OUTDSCR_BURST_EN = 0x1000
	// Position of INDSCR_BURST_EN field.
	UHCI0_CONF0_INDSCR_BURST_EN_Pos = 0xd
	// Bit mask of INDSCR_BURST_EN field.
	UHCI0_CONF0_INDSCR_BURST_EN_Msk = 0x2000
	// Bit INDSCR_BURST_EN.
	UHCI0_CONF0_INDSCR_BURST_EN = 0x2000
	// Position of OUT_DATA_BURST_EN field.
	UHCI0_CONF0_OUT_DATA_BURST_EN_Pos = 0xe
	// Bit mask of OUT_DATA_BURST_EN field.
	UHCI0_CONF0_OUT_DATA_BURST_EN_Msk = 0x4000
	// Bit OUT_DATA_BURST_EN.
	UHCI0_CONF0_OUT_DATA_BURST_EN = 0x4000
	// Position of MEM_TRANS_EN field.
	UHCI0_CONF0_MEM_TRANS_EN_Pos = 0xf
	// Bit mask of MEM_TRANS_EN field.
	UHCI0_CONF0_MEM_TRANS_EN_Msk = 0x8000
	// Bit MEM_TRANS_EN.
	UHCI0_CONF0_MEM_TRANS_EN = 0x8000
	// Position of SEPER_EN field.
	UHCI0_CONF0_SEPER_EN_Pos = 0x10
	// Bit mask of SEPER_EN field.
	UHCI0_CONF0_SEPER_EN_Msk = 0x10000
	// Bit SEPER_EN.
	UHCI0_CONF0_SEPER_EN = 0x10000
	// Position of HEAD_EN field.
	UHCI0_CONF0_HEAD_EN_Pos = 0x11
	// Bit mask of HEAD_EN field.
	UHCI0_CONF0_HEAD_EN_Msk = 0x20000
	// Bit HEAD_EN.
	UHCI0_CONF0_HEAD_EN = 0x20000
	// Position of CRC_REC_EN field.
	UHCI0_CONF0_CRC_REC_EN_Pos = 0x12
	// Bit mask of CRC_REC_EN field.
	UHCI0_CONF0_CRC_REC_EN_Msk = 0x40000
	// Bit CRC_REC_EN.
	UHCI0_CONF0_CRC_REC_EN = 0x40000
	// Position of UART_IDLE_EOF_EN field.
	UHCI0_CONF0_UART_IDLE_EOF_EN_Pos = 0x13
	// Bit mask of UART_IDLE_EOF_EN field.
	UHCI0_CONF0_UART_IDLE_EOF_EN_Msk = 0x80000
	// Bit UART_IDLE_EOF_EN.
	UHCI0_CONF0_UART_IDLE_EOF_EN = 0x80000
	// Position of LEN_EOF_EN field.
	UHCI0_CONF0_LEN_EOF_EN_Pos = 0x14
	// Bit mask of LEN_EOF_EN field.
	UHCI0_CONF0_LEN_EOF_EN_Msk = 0x100000
	// Bit LEN_EOF_EN.
	UHCI0_CONF0_LEN_EOF_EN = 0x100000
	// Position of ENCODE_CRC_EN field.
	UHCI0_CONF0_ENCODE_CRC_EN_Pos = 0x15
	// Bit mask of ENCODE_CRC_EN field.
	UHCI0_CONF0_ENCODE_CRC_EN_Msk = 0x200000
	// Bit ENCODE_CRC_EN.
	UHCI0_CONF0_ENCODE_CRC_EN = 0x200000
	// Position of CLK_EN field.
	UHCI0_CONF0_CLK_EN_Pos = 0x16
	// Bit mask of CLK_EN field.
	UHCI0_CONF0_CLK_EN_Msk = 0x400000
	// Bit CLK_EN.
	UHCI0_CONF0_CLK_EN = 0x400000
	// Position of UART_RX_BRK_EOF_EN field.
	UHCI0_CONF0_UART_RX_BRK_EOF_EN_Pos = 0x17
	// Bit mask of UART_RX_BRK_EOF_EN field.
	UHCI0_CONF0_UART_RX_BRK_EOF_EN_Msk = 0x800000
	// Bit UART_RX_BRK_EOF_EN.
	UHCI0_CONF0_UART_RX_BRK_EOF_EN = 0x800000

	// INT_RAW: Raw interrupt status
	// Position of RX_START_INT_RAW field.
	UHCI0_INT_RAW_RX_START_INT_RAW_Pos = 0x0
	// Bit mask of RX_START_INT_RAW field.
	UHCI0_INT_RAW_RX_START_INT_RAW_Msk = 0x1
	// Bit RX_START_INT_RAW.
	UHCI0_INT_RAW_RX_START_INT_RAW = 0x1
	// Position of TX_START_INT_RAW field.
	UHCI0_INT_RAW_TX_START_INT_RAW_Pos = 0x1
	// Bit mask of TX_START_INT_RAW field.
	UHCI0_INT_RAW_TX_START_INT_RAW_Msk = 0x2
	// Bit TX_START_INT_RAW.
	UHCI0_INT_RAW_TX_START_INT_RAW = 0x2
	// Position of RX_HUNG_INT_RAW field.
	UHCI0_INT_RAW_RX_HUNG_INT_RAW_Pos = 0x2
	// Bit mask of RX_HUNG_INT_RAW field.
	UHCI0_INT_RAW_RX_HUNG_INT_RAW_Msk = 0x4
	// Bit RX_HUNG_INT_RAW.
	UHCI0_INT_RAW_RX_HUNG_INT_RAW = 0x4
	// Position of TX_HUNG_INT_RAW field.
	UHCI0_INT_RAW_TX_HUNG_INT_RAW_Pos = 0x3
	// Bit mask of TX_HUNG_INT_RAW field.
	UHCI0_INT_RAW_TX_HUNG_INT_RAW_Msk = 0x8
	// Bit TX_HUNG_INT_RAW.
	UHCI0_INT_RAW_TX_HUNG_INT_RAW = 0x8
	// Position of IN_DONE_INT_RAW field.
	UHCI0_INT_RAW_IN_DONE_INT_RAW_Pos = 0x4
	// Bit mask of IN_DONE_INT_RAW field.
	UHCI0_INT_RAW_IN_DONE_INT_RAW_Msk = 0x10
	// Bit IN_DONE_INT_RAW.
	UHCI0_INT_RAW_IN_DONE_INT_RAW = 0x10
	// Position of IN_SUC_EOF_INT_RAW field.
	UHCI0_INT_RAW_IN_SUC_EOF_INT_RAW_Pos = 0x5
	// Bit mask of IN_SUC_EOF_INT_RAW field.
	UHCI0_INT_RAW_IN_SUC_EOF_INT_RAW_Msk = 0x20
	// Bit IN_SUC_EOF_INT_RAW.
	UHCI0_INT_RAW_IN_SUC_EOF_INT_RAW = 0x20
	// Position of IN_ERR_EOF_INT_RAW field.
	UHCI0_INT_RAW_IN_ERR_EOF_INT_RAW_Pos = 0x6
	// Bit mask of IN_ERR_EOF_INT_RAW field.
	UHCI0_INT_RAW_IN_ERR_EOF_INT_RAW_Msk = 0x40
	// Bit IN_ERR_EOF_INT_RAW.
	UHCI0_INT_RAW_IN_ERR_EOF_INT_RAW = 0x40
	// Position of OUT_DONE_INT_RAW field.
	UHCI0_INT_RAW_OUT_DONE_INT_RAW_Pos = 0x7
	// Bit mask of OUT_DONE_INT_RAW field.
	UHCI0_INT_RAW_OUT_DONE_INT_RAW_Msk = 0x80
	// Bit OUT_DONE_INT_RAW.
	UHCI0_INT_RAW_OUT_DONE_INT_RAW = 0x80
	// Position of OUT_EOF_INT_RAW field.
	UHCI0_INT_RAW_OUT_EOF_INT_RAW_Pos = 0x8
	// Bit mask of OUT_EOF_INT_RAW field.
	UHCI0_INT_RAW_OUT_EOF_INT_RAW_Msk = 0x100
	// Bit OUT_EOF_INT_RAW.
	UHCI0_INT_RAW_OUT_EOF_INT_RAW = 0x100
	// Position of IN_DSCR_ERR_INT_RAW field.
	UHCI0_INT_RAW_IN_DSCR_ERR_INT_RAW_Pos = 0x9
	// Bit mask of IN_DSCR_ERR_INT_RAW field.
	UHCI0_INT_RAW_IN_DSCR_ERR_INT_RAW_Msk = 0x200
	// Bit IN_DSCR_ERR_INT_RAW.
	UHCI0_INT_RAW_IN_DSCR_ERR_INT_RAW = 0x200
	// Position of OUT_DSCR_ERR_INT_RAW field.
	UHCI0_INT_RAW_OUT_DSCR_ERR_INT_RAW_Pos = 0xa
	// Bit mask of OUT_DSCR_ERR_INT_RAW field.
	UHCI0_INT_RAW_OUT_DSCR_ERR_INT_RAW_Msk = 0x400
	// Bit OUT_DSCR_ERR_INT_RAW.
	UHCI0_INT_RAW_OUT_DSCR_ERR_INT_RAW = 0x400
	// Position of IN_DSCR_EMPTY_INT_RAW field.
	UHCI0_INT_RAW_IN_DSCR_EMPTY_INT_RAW_Pos = 0xb
	// Bit mask of IN_DSCR_EMPTY_INT_RAW field.
	UHCI0_INT_RAW_IN_DSCR_EMPTY_INT_RAW_Msk = 0x800
	// Bit IN_DSCR_EMPTY_INT_RAW.
	UHCI0_INT_RAW_IN_DSCR_EMPTY_INT_RAW = 0x800
	// Position of OUTLINK_EOF_ERR_INT_RAW field.
	UHCI0_INT_RAW_OUTLINK_EOF_ERR_INT_RAW_Pos = 0xc
	// Bit mask of OUTLINK_EOF_ERR_INT_RAW field.
	UHCI0_INT_RAW_OUTLINK_EOF_ERR_INT_RAW_Msk = 0x1000
	// Bit OUTLINK_EOF_ERR_INT_RAW.
	UHCI0_INT_RAW_OUTLINK_EOF_ERR_INT_RAW = 0x1000
	// Position of OUT_TOTAL_EOF_INT_RAW field.
	UHCI0_INT_RAW_OUT_TOTAL_EOF_INT_RAW_Pos = 0xd
	// Bit mask of OUT_TOTAL_EOF_INT_RAW field.
	UHCI0_INT_RAW_OUT_TOTAL_EOF_INT_RAW_Msk = 0x2000
	// Bit OUT_TOTAL_EOF_INT_RAW.
	UHCI0_INT_RAW_OUT_TOTAL_EOF_INT_RAW = 0x2000
	// Position of SEND_S_REG_Q_INT_RAW field.
	UHCI0_INT_RAW_SEND_S_REG_Q_INT_RAW_Pos = 0xe
	// Bit mask of SEND_S_REG_Q_INT_RAW field.
	UHCI0_INT_RAW_SEND_S_REG_Q_INT_RAW_Msk = 0x4000
	// Bit SEND_S_REG_Q_INT_RAW.
	UHCI0_INT_RAW_SEND_S_REG_Q_INT_RAW = 0x4000
	// Position of SEND_A_REG_Q_INT_RAW field.
	UHCI0_INT_RAW_SEND_A_REG_Q_INT_RAW_Pos = 0xf
	// Bit mask of SEND_A_REG_Q_INT_RAW field.
	UHCI0_INT_RAW_SEND_A_REG_Q_INT_RAW_Msk = 0x8000
	// Bit SEND_A_REG_Q_INT_RAW.
	UHCI0_INT_RAW_SEND_A_REG_Q_INT_RAW = 0x8000
	// Position of DMA_INFIFO_FULL_WM_INT_RAW field.
	UHCI0_INT_RAW_DMA_INFIFO_FULL_WM_INT_RAW_Pos = 0x10
	// Bit mask of DMA_INFIFO_FULL_WM_INT_RAW field.
	UHCI0_INT_RAW_DMA_INFIFO_FULL_WM_INT_RAW_Msk = 0x10000
	// Bit DMA_INFIFO_FULL_WM_INT_RAW.
	UHCI0_INT_RAW_DMA_INFIFO_FULL_WM_INT_RAW = 0x10000

	// INT_ST: Masked interrupt status
	// Position of RX_START_INT_ST field.
	UHCI0_INT_ST_RX_START_INT_ST_Pos = 0x0
	// Bit mask of RX_START_INT_ST field.
	UHCI0_INT_ST_RX_START_INT_ST_Msk = 0x1
	// Bit RX_START_INT_ST.
	UHCI0_INT_ST_RX_START_INT_ST = 0x1
	// Position of TX_START_INT_ST field.
	UHCI0_INT_ST_TX_START_INT_ST_Pos = 0x1
	// Bit mask of TX_START_INT_ST field.
	UHCI0_INT_ST_TX_START_INT_ST_Msk = 0x2
	// Bit TX_START_INT_ST.
	UHCI0_INT_ST_TX_START_INT_ST = 0x2
	// Position of RX_HUNG_INT_ST field.
	UHCI0_INT_ST_RX_HUNG_INT_ST_Pos = 0x2
	// Bit mask of RX_HUNG_INT_ST field.
	UHCI0_INT_ST_RX_HUNG_INT_ST_Msk = 0x4
	// Bit RX_HUNG_INT_ST.
	UHCI0_INT_ST_RX_HUNG_INT_ST = 0x4
	// Position of TX_HUNG_INT_ST field.
	UHCI0_INT_ST_TX_HUNG_INT_ST_Pos = 0x3
	// Bit mask of TX_HUNG_INT_ST field.
	UHCI0_INT_ST_TX_HUNG_INT_ST_Msk = 0x8
	// Bit TX_HUNG_INT_ST.
	UHCI0_INT_ST_TX_HUNG_INT_ST = 0x8
	// Position of IN_DONE_INT_ST field.
	UHCI0_INT_ST_IN_DONE_INT_ST_Pos = 0x4
	// Bit mask of IN_DONE_INT_ST field.
	UHCI0_INT_ST_IN_DONE_INT_ST_Msk = 0x10
	// Bit IN_DONE_INT_ST.
	UHCI0_INT_ST_IN_DONE_INT_ST = 0x10
	// Position of IN_SUC_EOF_INT_ST field.
	UHCI0_INT_ST_IN_SUC_EOF_INT_ST_Pos = 0x5
	// Bit mask of IN_SUC_EOF_INT_ST field.
	UHCI0_INT_ST_IN_SUC_EOF_INT_ST_Msk = 0x20
	// Bit IN_SUC_EOF_INT_ST.
	UHCI0_INT_ST_IN_SUC_EOF_INT_ST = 0x20
	// Position of IN_ERR_EOF_INT_ST field.
	UHCI0_INT_ST_IN_ERR_EOF_INT_ST_Pos = 0x6
	// Bit mask of IN_ERR_EOF_INT_ST field.
	UHCI0_INT_ST_IN_ERR_EOF_INT_ST_Msk = 0x40
	// Bit IN_ERR_EOF_INT_ST.
	UHCI0_INT_ST_IN_ERR_EOF_INT_ST = 0x40
	// Position of OUT_DONE_INT_ST field.
	UHCI0_INT_ST_OUT_DONE_INT_ST_Pos = 0x7
	// Bit mask of OUT_DONE_INT_ST field.
	UHCI0_INT_ST_OUT_DONE_INT_ST_Msk = 0x80
	// Bit OUT_DONE_INT_ST.
	UHCI0_INT_ST_OUT_DONE_INT_ST = 0x80
	// Position of OUT_EOF_INT_ST field.
	UHCI0_INT_ST_OUT_EOF_INT_ST_Pos = 0x8
	// Bit mask of OUT_EOF_INT_ST field.
	UHCI0_INT_ST_OUT_EOF_INT_ST_Msk = 0x100
	// Bit OUT_EOF_INT_ST.
	UHCI0_INT_ST_OUT_EOF_INT_ST = 0x100
	// Position of IN_DSCR_ERR_INT_ST field.
	UHCI0_INT_ST_IN_DSCR_ERR_INT_ST_Pos = 0x9
	// Bit mask of IN_DSCR_ERR_INT_ST field.
	UHCI0_INT_ST_IN_DSCR_ERR_INT_ST_Msk = 0x200
	// Bit IN_DSCR_ERR_INT_ST.
	UHCI0_INT_ST_IN_DSCR_ERR_INT_ST = 0x200
	// Position of OUT_DSCR_ERR_INT_ST field.
	UHCI0_INT_ST_OUT_DSCR_ERR_INT_ST_Pos = 0xa
	// Bit mask of OUT_DSCR_ERR_INT_ST field.
	UHCI0_INT_ST_OUT_DSCR_ERR_INT_ST_Msk = 0x400
	// Bit OUT_DSCR_ERR_INT_ST.
	UHCI0_INT_ST_OUT_DSCR_ERR_INT_ST = 0x400
	// Position of IN_DSCR_EMPTY_INT_ST field.
	UHCI0_INT_ST_IN_DSCR_EMPTY_INT_ST_Pos = 0xb
	// Bit mask of IN_DSCR_EMPTY_INT_ST field.
	UHCI0_INT_ST_IN_DSCR_EMPTY_INT_ST_Msk = 0x800
	// Bit IN_DSCR_EMPTY_INT_ST.
	UHCI0_INT_ST_IN_DSCR_EMPTY_INT_ST = 0x800
	// Position of OUTLINK_EOF_ERR_INT_ST field.
	UHCI0_INT_ST_OUTLINK_EOF_ERR_INT_ST_Pos = 0xc
	// Bit mask of OUTLINK_EOF_ERR_INT_ST field.
	UHCI0_INT_ST_OUTLINK_EOF_ERR_INT_ST_Msk = 0x1000
	// Bit OUTLINK_EOF_ERR_INT_ST.
	UHCI0_INT_ST_OUTLINK_EOF_ERR_INT_ST = 0x1000
	// Position of OUT_TOTAL_EOF_INT_ST field.
	UHCI0_INT_ST_OUT_TOTAL_EOF_INT_ST_Pos = 0xd
	// Bit mask of OUT_TOTAL_EOF_INT_ST field.
	UHCI0_INT_ST_OUT_TOTAL_EOF_INT_ST_Msk = 0x2000
	// Bit OUT_TOTAL_EOF_INT_ST.
	UHCI0_INT_ST_OUT_TOTAL_EOF_INT_ST = 0x2000
	// Position of SEND_S_REG_Q_INT_ST field.
	UHCI0_INT_ST_SEND_S_REG_Q_INT_ST_Pos = 0xe
	// Bit mask of SEND_S_REG_Q_INT_ST field.
	UHCI0_INT_ST_SEND_S_REG_Q_INT_ST_Msk = 0x4000
	// Bit SEND_S_REG_Q_INT_ST.
	UHCI0_INT_ST_SEND_S_REG_Q_INT_ST = 0x4000
	// Position of SEND_A_REG_Q_INT_ST field.
	UHCI0_INT_ST_SEND_A_REG_Q_INT_ST_Pos = 0xf
	// Bit mask of SEND_A_REG_Q_INT_ST field.
	UHCI0_INT_ST_SEND_A_REG_Q_INT_ST_Msk = 0x8000
	// Bit SEND_A_REG_Q_INT_ST.
	UHCI0_INT_ST_SEND_A_REG_Q_INT_ST = 0x8000
	// Position of DMA_INFIFO_FULL_WM_INT_ST field.
	UHCI0_INT_ST_DMA_INFIFO_FULL_WM_INT_ST_Pos = 0x10
	// Bit mask of DMA_INFIFO_FULL_WM_INT_ST field.
	UHCI0_INT_ST_DMA_INFIFO_FULL_WM_INT_ST_Msk = 0x10000
	// Bit DMA_INFIFO_FULL_WM_INT_ST.
	UHCI0_INT_ST_DMA_INFIFO_FULL_WM_INT_ST = 0x10000

	// INT_ENA: Interrupt enable bits
	// Position of RX_START_INT_ENA field.
	UHCI0_INT_ENA_RX_START_INT_ENA_Pos = 0x0
	// Bit mask of RX_START_INT_ENA field.
	UHCI0_INT_ENA_RX_START_INT_ENA_Msk = 0x1
	// Bit RX_START_INT_ENA.
	UHCI0_INT_ENA_RX_START_INT_ENA = 0x1
	// Position of TX_START_INT_ENA field.
	UHCI0_INT_ENA_TX_START_INT_ENA_Pos = 0x1
	// Bit mask of TX_START_INT_ENA field.
	UHCI0_INT_ENA_TX_START_INT_ENA_Msk = 0x2
	// Bit TX_START_INT_ENA.
	UHCI0_INT_ENA_TX_START_INT_ENA = 0x2
	// Position of RX_HUNG_INT_ENA field.
	UHCI0_INT_ENA_RX_HUNG_INT_ENA_Pos = 0x2
	// Bit mask of RX_HUNG_INT_ENA field.
	UHCI0_INT_ENA_RX_HUNG_INT_ENA_Msk = 0x4
	// Bit RX_HUNG_INT_ENA.
	UHCI0_INT_ENA_RX_HUNG_INT_ENA = 0x4
	// Position of TX_HUNG_INT_ENA field.
	UHCI0_INT_ENA_TX_HUNG_INT_ENA_Pos = 0x3
	// Bit mask of TX_HUNG_INT_ENA field.
	UHCI0_INT_ENA_TX_HUNG_INT_ENA_Msk = 0x8
	// Bit TX_HUNG_INT_ENA.
	UHCI0_INT_ENA_TX_HUNG_INT_ENA = 0x8
	// Position of IN_DONE_INT_ENA field.
	UHCI0_INT_ENA_IN_DONE_INT_ENA_Pos = 0x4
	// Bit mask of IN_DONE_INT_ENA field.
	UHCI0_INT_ENA_IN_DONE_INT_ENA_Msk = 0x10
	// Bit IN_DONE_INT_ENA.
	UHCI0_INT_ENA_IN_DONE_INT_ENA = 0x10
	// Position of IN_SUC_EOF_INT_ENA field.
	UHCI0_INT_ENA_IN_SUC_EOF_INT_ENA_Pos = 0x5
	// Bit mask of IN_SUC_EOF_INT_ENA field.
	UHCI0_INT_ENA_IN_SUC_EOF_INT_ENA_Msk = 0x20
	// Bit IN_SUC_EOF_INT_ENA.
	UHCI0_INT_ENA_IN_SUC_EOF_INT_ENA = 0x20
	// Position of IN_ERR_EOF_INT_ENA field.
	UHCI0_INT_ENA_IN_ERR_EOF_INT_ENA_Pos = 0x6
	// Bit mask of IN_ERR_EOF_INT_ENA field.
	UHCI0_INT_ENA_IN_ERR_EOF_INT_ENA_Msk = 0x40
	// Bit IN_ERR_EOF_INT_ENA.
	UHCI0_INT_ENA_IN_ERR_EOF_INT_ENA = 0x40
	// Position of OUT_DONE_INT_ENA field.
	UHCI0_INT_ENA_OUT_DONE_INT_ENA_Pos = 0x7
	// Bit mask of OUT_DONE_INT_ENA field.
	UHCI0_INT_ENA_OUT_DONE_INT_ENA_Msk = 0x80
	// Bit OUT_DONE_INT_ENA.
	UHCI0_INT_ENA_OUT_DONE_INT_ENA = 0x80
	// Position of OUT_EOF_INT_ENA field.
	UHCI0_INT_ENA_OUT_EOF_INT_ENA_Pos = 0x8
	// Bit mask of OUT_EOF_INT_ENA field.
	UHCI0_INT_ENA_OUT_EOF_INT_ENA_Msk = 0x100
	// Bit OUT_EOF_INT_ENA.
	UHCI0_INT_ENA_OUT_EOF_INT_ENA = 0x100
	// Position of IN_DSCR_ERR_INT_ENA field.
	UHCI0_INT_ENA_IN_DSCR_ERR_INT_ENA_Pos = 0x9
	// Bit mask of IN_DSCR_ERR_INT_ENA field.
	UHCI0_INT_ENA_IN_DSCR_ERR_INT_ENA_Msk = 0x200
	// Bit IN_DSCR_ERR_INT_ENA.
	UHCI0_INT_ENA_IN_DSCR_ERR_INT_ENA = 0x200
	// Position of OUT_DSCR_ERR_INT_ENA field.
	UHCI0_INT_ENA_OUT_DSCR_ERR_INT_ENA_Pos = 0xa
	// Bit mask of OUT_DSCR_ERR_INT_ENA field.
	UHCI0_INT_ENA_OUT_DSCR_ERR_INT_ENA_Msk = 0x400
	// Bit OUT_DSCR_ERR_INT_ENA.
	UHCI0_INT_ENA_OUT_DSCR_ERR_INT_ENA = 0x400
	// Position of IN_DSCR_EMPTY_INT_ENA field.
	UHCI0_INT_ENA_IN_DSCR_EMPTY_INT_ENA_Pos = 0xb
	// Bit mask of IN_DSCR_EMPTY_INT_ENA field.
	UHCI0_INT_ENA_IN_DSCR_EMPTY_INT_ENA_Msk = 0x800
	// Bit IN_DSCR_EMPTY_INT_ENA.
	UHCI0_INT_ENA_IN_DSCR_EMPTY_INT_ENA = 0x800
	// Position of OUTLINK_EOF_ERR_INT_ENA field.
	UHCI0_INT_ENA_OUTLINK_EOF_ERR_INT_ENA_Pos = 0xc
	// Bit mask of OUTLINK_EOF_ERR_INT_ENA field.
	UHCI0_INT_ENA_OUTLINK_EOF_ERR_INT_ENA_Msk = 0x1000
	// Bit OUTLINK_EOF_ERR_INT_ENA.
	UHCI0_INT_ENA_OUTLINK_EOF_ERR_INT_ENA = 0x1000
	// Position of OUT_TOTAL_EOF_INT_ENA field.
	UHCI0_INT_ENA_OUT_TOTAL_EOF_INT_ENA_Pos = 0xd
	// Bit mask of OUT_TOTAL_EOF_INT_ENA field.
	UHCI0_INT_ENA_OUT_TOTAL_EOF_INT_ENA_Msk = 0x2000
	// Bit OUT_TOTAL_EOF_INT_ENA.
	UHCI0_INT_ENA_OUT_TOTAL_EOF_INT_ENA = 0x2000
	// Position of SEND_S_REG_Q_INT_ENA field.
	UHCI0_INT_ENA_SEND_S_REG_Q_INT_ENA_Pos = 0xe
	// Bit mask of SEND_S_REG_Q_INT_ENA field.
	UHCI0_INT_ENA_SEND_S_REG_Q_INT_ENA_Msk = 0x4000
	// Bit SEND_S_REG_Q_INT_ENA.
	UHCI0_INT_ENA_SEND_S_REG_Q_INT_ENA = 0x4000
	// Position of SEND_A_REG_Q_INT_ENA field.
	UHCI0_INT_ENA_SEND_A_REG_Q_INT_ENA_Pos = 0xf
	// Bit mask of SEND_A_REG_Q_INT_ENA field.
	UHCI0_INT_ENA_SEND_A_REG_Q_INT_ENA_Msk = 0x8000
	// Bit SEND_A_REG_Q_INT_ENA.
	UHCI0_INT_ENA_SEND_A_REG_Q_INT_ENA = 0x8000
	// Position of DMA_INFIFO_FULL_WM_INT_ENA field.
	UHCI0_INT_ENA_DMA_INFIFO_FULL_WM_INT_ENA_Pos = 0x10
	// Bit mask of DMA_INFIFO_FULL_WM_INT_ENA field.
	UHCI0_INT_ENA_DMA_INFIFO_FULL_WM_INT_ENA_Msk = 0x10000
	// Bit DMA_INFIFO_FULL_WM_INT_ENA.
	UHCI0_INT_ENA_DMA_INFIFO_FULL_WM_INT_ENA = 0x10000

	// INT_CLR: Interrupt clear bits
	// Position of RX_START_INT_CLR field.
	UHCI0_INT_CLR_RX_START_INT_CLR_Pos = 0x0
	// Bit mask of RX_START_INT_CLR field.
	UHCI0_INT_CLR_RX_START_INT_CLR_Msk = 0x1
	// Bit RX_START_INT_CLR.
	UHCI0_INT_CLR_RX_START_INT_CLR = 0x1
	// Position of TX_START_INT_CLR field.
	UHCI0_INT_CLR_TX_START_INT_CLR_Pos = 0x1
	// Bit mask of TX_START_INT_CLR field.
	UHCI0_INT_CLR_TX_START_INT_CLR_Msk = 0x2
	// Bit TX_START_INT_CLR.
	UHCI0_INT_CLR_TX_START_INT_CLR = 0x2
	// Position of RX_HUNG_INT_CLR field.
	UHCI0_INT_CLR_RX_HUNG_INT_CLR_Pos = 0x2
	// Bit mask of RX_HUNG_INT_CLR field.
	UHCI0_INT_CLR_RX_HUNG_INT_CLR_Msk = 0x4
	// Bit RX_HUNG_INT_CLR.
	UHCI0_INT_CLR_RX_HUNG_INT_CLR = 0x4
	// Position of TX_HUNG_INT_CLR field.
	UHCI0_INT_CLR_TX_HUNG_INT_CLR_Pos = 0x3
	// Bit mask of TX_HUNG_INT_CLR field.
	UHCI0_INT_CLR_TX_HUNG_INT_CLR_Msk = 0x8
	// Bit TX_HUNG_INT_CLR.
	UHCI0_INT_CLR_TX_HUNG_INT_CLR = 0x8
	// Position of IN_DONE_INT_CLR field.
	UHCI0_INT_CLR_IN_DONE_INT_CLR_Pos = 0x4
	// Bit mask of IN_DONE_INT_CLR field.
	UHCI0_INT_CLR_IN_DONE_INT_CLR_Msk = 0x10
	// Bit IN_DONE_INT_CLR.
	UHCI0_INT_CLR_IN_DONE_INT_CLR = 0x10
	// Position of IN_SUC_EOF_INT_CLR field.
	UHCI0_INT_CLR_IN_SUC_EOF_INT_CLR_Pos = 0x5
	// Bit mask of IN_SUC_EOF_INT_CLR field.
	UHCI0_INT_CLR_IN_SUC_EOF_INT_CLR_Msk = 0x20
	// Bit IN_SUC_EOF_INT_CLR.
	UHCI0_INT_CLR_IN_SUC_EOF_INT_CLR = 0x20
	// Position of IN_ERR_EOF_INT_CLR field.
	UHCI0_INT_CLR_IN_ERR_EOF_INT_CLR_Pos = 0x6
	// Bit mask of IN_ERR_EOF_INT_CLR field.
	UHCI0_INT_CLR_IN_ERR_EOF_INT_CLR_Msk = 0x40
	// Bit IN_ERR_EOF_INT_CLR.
	UHCI0_INT_CLR_IN_ERR_EOF_INT_CLR = 0x40
	// Position of OUT_DONE_INT_CLR field.
	UHCI0_INT_CLR_OUT_DONE_INT_CLR_Pos = 0x7
	// Bit mask of OUT_DONE_INT_CLR field.
	UHCI0_INT_CLR_OUT_DONE_INT_CLR_Msk = 0x80
	// Bit OUT_DONE_INT_CLR.
	UHCI0_INT_CLR_OUT_DONE_INT_CLR = 0x80
	// Position of OUT_EOF_INT_CLR field.
	UHCI0_INT_CLR_OUT_EOF_INT_CLR_Pos = 0x8
	// Bit mask of OUT_EOF_INT_CLR field.
	UHCI0_INT_CLR_OUT_EOF_INT_CLR_Msk = 0x100
	// Bit OUT_EOF_INT_CLR.
	UHCI0_INT_CLR_OUT_EOF_INT_CLR = 0x100
	// Position of IN_DSCR_ERR_INT_CLR field.
	UHCI0_INT_CLR_IN_DSCR_ERR_INT_CLR_Pos = 0x9
	// Bit mask of IN_DSCR_ERR_INT_CLR field.
	UHCI0_INT_CLR_IN_DSCR_ERR_INT_CLR_Msk = 0x200
	// Bit IN_DSCR_ERR_INT_CLR.
	UHCI0_INT_CLR_IN_DSCR_ERR_INT_CLR = 0x200
	// Position of OUT_DSCR_ERR_INT_CLR field.
	UHCI0_INT_CLR_OUT_DSCR_ERR_INT_CLR_Pos = 0xa
	// Bit mask of OUT_DSCR_ERR_INT_CLR field.
	UHCI0_INT_CLR_OUT_DSCR_ERR_INT_CLR_Msk = 0x400
	// Bit OUT_DSCR_ERR_INT_CLR.
	UHCI0_INT_CLR_OUT_DSCR_ERR_INT_CLR = 0x400
	// Position of IN_DSCR_EMPTY_INT_CLR field.
	UHCI0_INT_CLR_IN_DSCR_EMPTY_INT_CLR_Pos = 0xb
	// Bit mask of IN_DSCR_EMPTY_INT_CLR field.
	UHCI0_INT_CLR_IN_DSCR_EMPTY_INT_CLR_Msk = 0x800
	// Bit IN_DSCR_EMPTY_INT_CLR.
	UHCI0_INT_CLR_IN_DSCR_EMPTY_INT_CLR = 0x800
	// Position of OUTLINK_EOF_ERR_INT_CLR field.
	UHCI0_INT_CLR_OUTLINK_EOF_ERR_INT_CLR_Pos = 0xc
	// Bit mask of OUTLINK_EOF_ERR_INT_CLR field.
	UHCI0_INT_CLR_OUTLINK_EOF_ERR_INT_CLR_Msk = 0x1000
	// Bit OUTLINK_EOF_ERR_INT_CLR.
	UHCI0_INT_CLR_OUTLINK_EOF_ERR_INT_CLR = 0x1000
	// Position of OUT_TOTAL_EOF_INT_CLR field.
	UHCI0_INT_CLR_OUT_TOTAL_EOF_INT_CLR_Pos = 0xd
	// Bit mask of OUT_TOTAL_EOF_INT_CLR field.
	UHCI0_INT_CLR_OUT_TOTAL_EOF_INT_CLR_Msk = 0x2000
	// Bit OUT_TOTAL_EOF_INT_CLR.
	UHCI0_INT_CLR_OUT_TOTAL_EOF_INT_CLR = 0x2000
	// Position of SEND_S_REG_Q_INT_CLR field.
	UHCI0_INT_CLR_SEND_S_REG_Q_INT_CLR_Pos = 0xe
	// Bit mask of SEND_S_REG_Q_INT_CLR field.
	UHCI0_INT_CLR_SEND_S_REG_Q_INT_CLR_Msk = 0x4000
	// Bit SEND_S_REG_Q_INT_CLR.
	UHCI0_INT_CLR_SEND_S_REG_Q_INT_CLR = 0x4000
	// Position of SEND_A_REG_Q_INT_CLR field.
	UHCI0_INT_CLR_SEND_A_REG_Q_INT_CLR_Pos = 0xf
	// Bit mask of SEND_A_REG_Q_INT_CLR field.
	UHCI0_INT_CLR_SEND_A_REG_Q_INT_CLR_Msk = 0x8000
	// Bit SEND_A_REG_Q_INT_CLR.
	UHCI0_INT_CLR_SEND_A_REG_Q_INT_CLR = 0x8000
	// Position of DMA_INFIFO_FULL_WM_INT_CLR field.
	UHCI0_INT_CLR_DMA_INFIFO_FULL_WM_INT_CLR_Pos = 0x10
	// Bit mask of DMA_INFIFO_FULL_WM_INT_CLR field.
	UHCI0_INT_CLR_DMA_INFIFO_FULL_WM_INT_CLR_Msk = 0x10000
	// Bit DMA_INFIFO_FULL_WM_INT_CLR.
	UHCI0_INT_CLR_DMA_INFIFO_FULL_WM_INT_CLR = 0x10000

	// DMA_OUT_STATUS: DMA data-output status register
	// Position of OUT_FULL field.
	UHCI0_DMA_OUT_STATUS_OUT_FULL_Pos = 0x0
	// Bit mask of OUT_FULL field.
	UHCI0_DMA_OUT_STATUS_OUT_FULL_Msk = 0x1
	// Bit OUT_FULL.
	UHCI0_DMA_OUT_STATUS_OUT_FULL = 0x1
	// Position of OUT_EMPTY field.
	UHCI0_DMA_OUT_STATUS_OUT_EMPTY_Pos = 0x1
	// Bit mask of OUT_EMPTY field.
	UHCI0_DMA_OUT_STATUS_OUT_EMPTY_Msk = 0x2
	// Bit OUT_EMPTY.
	UHCI0_DMA_OUT_STATUS_OUT_EMPTY = 0x2

	// DMA_OUT_PUSH: Push control register of data-output FIFO
	// Position of OUTFIFO_WDATA field.
	UHCI0_DMA_OUT_PUSH_OUTFIFO_WDATA_Pos = 0x0
	// Bit mask of OUTFIFO_WDATA field.
	UHCI0_DMA_OUT_PUSH_OUTFIFO_WDATA_Msk = 0x1ff
	// Position of OUTFIFO_PUSH field.
	UHCI0_DMA_OUT_PUSH_OUTFIFO_PUSH_Pos = 0x10
	// Bit mask of OUTFIFO_PUSH field.
	UHCI0_DMA_OUT_PUSH_OUTFIFO_PUSH_Msk = 0x10000
	// Bit OUTFIFO_PUSH.
	UHCI0_DMA_OUT_PUSH_OUTFIFO_PUSH = 0x10000

	// DMA_IN_STATUS: UHCI data-input status register
	// Position of IN_FULL field.
	UHCI0_DMA_IN_STATUS_IN_FULL_Pos = 0x0
	// Bit mask of IN_FULL field.
	UHCI0_DMA_IN_STATUS_IN_FULL_Msk = 0x1
	// Bit IN_FULL.
	UHCI0_DMA_IN_STATUS_IN_FULL = 0x1
	// Position of IN_EMPTY field.
	UHCI0_DMA_IN_STATUS_IN_EMPTY_Pos = 0x1
	// Bit mask of IN_EMPTY field.
	UHCI0_DMA_IN_STATUS_IN_EMPTY_Msk = 0x2
	// Bit IN_EMPTY.
	UHCI0_DMA_IN_STATUS_IN_EMPTY = 0x2
	// Position of RX_ERR_CAUSE field.
	UHCI0_DMA_IN_STATUS_RX_ERR_CAUSE_Pos = 0x4
	// Bit mask of RX_ERR_CAUSE field.
	UHCI0_DMA_IN_STATUS_RX_ERR_CAUSE_Msk = 0x70

	// DMA_IN_POP: Pop control register of data-input FIFO
	// Position of INFIFO_RDATA field.
	UHCI0_DMA_IN_POP_INFIFO_RDATA_Pos = 0x0
	// Bit mask of INFIFO_RDATA field.
	UHCI0_DMA_IN_POP_INFIFO_RDATA_Msk = 0xfff
	// Position of INFIFO_POP field.
	UHCI0_DMA_IN_POP_INFIFO_POP_Pos = 0x10
	// Bit mask of INFIFO_POP field.
	UHCI0_DMA_IN_POP_INFIFO_POP_Msk = 0x10000
	// Bit INFIFO_POP.
	UHCI0_DMA_IN_POP_INFIFO_POP = 0x10000

	// DMA_OUT_LINK: Link descriptor address and control
	// Position of OUTLINK_ADDR field.
	UHCI0_DMA_OUT_LINK_OUTLINK_ADDR_Pos = 0x0
	// Bit mask of OUTLINK_ADDR field.
	UHCI0_DMA_OUT_LINK_OUTLINK_ADDR_Msk = 0xfffff
	// Position of OUTLINK_STOP field.
	UHCI0_DMA_OUT_LINK_OUTLINK_STOP_Pos = 0x1c
	// Bit mask of OUTLINK_STOP field.
	UHCI0_DMA_OUT_LINK_OUTLINK_STOP_Msk = 0x10000000
	// Bit OUTLINK_STOP.
	UHCI0_DMA_OUT_LINK_OUTLINK_STOP = 0x10000000
	// Position of OUTLINK_START field.
	UHCI0_DMA_OUT_LINK_OUTLINK_START_Pos = 0x1d
	// Bit mask of OUTLINK_START field.
	UHCI0_DMA_OUT_LINK_OUTLINK_START_Msk = 0x20000000
	// Bit OUTLINK_START.
	UHCI0_DMA_OUT_LINK_OUTLINK_START = 0x20000000
	// Position of OUTLINK_RESTART field.
	UHCI0_DMA_OUT_LINK_OUTLINK_RESTART_Pos = 0x1e
	// Bit mask of OUTLINK_RESTART field.
	UHCI0_DMA_OUT_LINK_OUTLINK_RESTART_Msk = 0x40000000
	// Bit OUTLINK_RESTART.
	UHCI0_DMA_OUT_LINK_OUTLINK_RESTART = 0x40000000
	// Position of OUTLINK_PARK field.
	UHCI0_DMA_OUT_LINK_OUTLINK_PARK_Pos = 0x1f
	// Bit mask of OUTLINK_PARK field.
	UHCI0_DMA_OUT_LINK_OUTLINK_PARK_Msk = 0x80000000
	// Bit OUTLINK_PARK.
	UHCI0_DMA_OUT_LINK_OUTLINK_PARK = 0x80000000

	// DMA_IN_LINK: Link descriptor address and control
	// Position of INLINK_ADDR field.
	UHCI0_DMA_IN_LINK_INLINK_ADDR_Pos = 0x0
	// Bit mask of INLINK_ADDR field.
	UHCI0_DMA_IN_LINK_INLINK_ADDR_Msk = 0xfffff
	// Position of INLINK_AUTO_RET field.
	UHCI0_DMA_IN_LINK_INLINK_AUTO_RET_Pos = 0x14
	// Bit mask of INLINK_AUTO_RET field.
	UHCI0_DMA_IN_LINK_INLINK_AUTO_RET_Msk = 0x100000
	// Bit INLINK_AUTO_RET.
	UHCI0_DMA_IN_LINK_INLINK_AUTO_RET = 0x100000
	// Position of INLINK_STOP field.
	UHCI0_DMA_IN_LINK_INLINK_STOP_Pos = 0x1c
	// Bit mask of INLINK_STOP field.
	UHCI0_DMA_IN_LINK_INLINK_STOP_Msk = 0x10000000
	// Bit INLINK_STOP.
	UHCI0_DMA_IN_LINK_INLINK_STOP = 0x10000000
	// Position of INLINK_START field.
	UHCI0_DMA_IN_LINK_INLINK_START_Pos = 0x1d
	// Bit mask of INLINK_START field.
	UHCI0_DMA_IN_LINK_INLINK_START_Msk = 0x20000000
	// Bit INLINK_START.
	UHCI0_DMA_IN_LINK_INLINK_START = 0x20000000
	// Position of INLINK_RESTART field.
	UHCI0_DMA_IN_LINK_INLINK_RESTART_Pos = 0x1e
	// Bit mask of INLINK_RESTART field.
	UHCI0_DMA_IN_LINK_INLINK_RESTART_Msk = 0x40000000
	// Bit INLINK_RESTART.
	UHCI0_DMA_IN_LINK_INLINK_RESTART = 0x40000000
	// Position of INLINK_PARK field.
	UHCI0_DMA_IN_LINK_INLINK_PARK_Pos = 0x1f
	// Bit mask of INLINK_PARK field.
	UHCI0_DMA_IN_LINK_INLINK_PARK_Msk = 0x80000000
	// Bit INLINK_PARK.
	UHCI0_DMA_IN_LINK_INLINK_PARK = 0x80000000

	// CONF1: UHCI configuration register
	// Position of CHECK_SUM_EN field.
	UHCI0_CONF1_CHECK_SUM_EN_Pos = 0x0
	// Bit mask of CHECK_SUM_EN field.
	UHCI0_CONF1_CHECK_SUM_EN_Msk = 0x1
	// Bit CHECK_SUM_EN.
	UHCI0_CONF1_CHECK_SUM_EN = 0x1
	// Position of CHECK_SEQ_EN field.
	UHCI0_CONF1_CHECK_SEQ_EN_Pos = 0x1
	// Bit mask of CHECK_SEQ_EN field.
	UHCI0_CONF1_CHECK_SEQ_EN_Msk = 0x2
	// Bit CHECK_SEQ_EN.
	UHCI0_CONF1_CHECK_SEQ_EN = 0x2
	// Position of CRC_DISABLE field.
	UHCI0_CONF1_CRC_DISABLE_Pos = 0x2
	// Bit mask of CRC_DISABLE field.
	UHCI0_CONF1_CRC_DISABLE_Msk = 0x4
	// Bit CRC_DISABLE.
	UHCI0_CONF1_CRC_DISABLE = 0x4
	// Position of SAVE_HEAD field.
	UHCI0_CONF1_SAVE_HEAD_Pos = 0x3
	// Bit mask of SAVE_HEAD field.
	UHCI0_CONF1_SAVE_HEAD_Msk = 0x8
	// Bit SAVE_HEAD.
	UHCI0_CONF1_SAVE_HEAD = 0x8
	// Position of TX_CHECK_SUM_RE field.
	UHCI0_CONF1_TX_CHECK_SUM_RE_Pos = 0x4
	// Bit mask of TX_CHECK_SUM_RE field.
	UHCI0_CONF1_TX_CHECK_SUM_RE_Msk = 0x10
	// Bit TX_CHECK_SUM_RE.
	UHCI0_CONF1_TX_CHECK_SUM_RE = 0x10
	// Position of TX_ACK_NUM_RE field.
	UHCI0_CONF1_TX_ACK_NUM_RE_Pos = 0x5
	// Bit mask of TX_ACK_NUM_RE field.
	UHCI0_CONF1_TX_ACK_NUM_RE_Msk = 0x20
	// Bit TX_ACK_NUM_RE.
	UHCI0_CONF1_TX_ACK_NUM_RE = 0x20
	// Position of CHECK_OWNER field.
	UHCI0_CONF1_CHECK_OWNER_Pos = 0x6
	// Bit mask of CHECK_OWNER field.
	UHCI0_CONF1_CHECK_OWNER_Msk = 0x40
	// Bit CHECK_OWNER.
	UHCI0_CONF1_CHECK_OWNER = 0x40
	// Position of WAIT_SW_START field.
	UHCI0_CONF1_WAIT_SW_START_Pos = 0x7
	// Bit mask of WAIT_SW_START field.
	UHCI0_CONF1_WAIT_SW_START_Msk = 0x80
	// Bit WAIT_SW_START.
	UHCI0_CONF1_WAIT_SW_START = 0x80
	// Position of SW_START field.
	UHCI0_CONF1_SW_START_Pos = 0x8
	// Bit mask of SW_START field.
	UHCI0_CONF1_SW_START_Msk = 0x100
	// Bit SW_START.
	UHCI0_CONF1_SW_START = 0x100
	// Position of DMA_INFIFO_FULL_THRS field.
	UHCI0_CONF1_DMA_INFIFO_FULL_THRS_Pos = 0x9
	// Bit mask of DMA_INFIFO_FULL_THRS field.
	UHCI0_CONF1_DMA_INFIFO_FULL_THRS_Msk = 0x1ffe00

	// STATE0: UHCI decoder status register
	// Position of INLINK_DSCR_ADDR field.
	UHCI0_STATE0_INLINK_DSCR_ADDR_Pos = 0x0
	// Bit mask of INLINK_DSCR_ADDR field.
	UHCI0_STATE0_INLINK_DSCR_ADDR_Msk = 0x3ffff
	// Position of IN_DSCR_STATE field.
	UHCI0_STATE0_IN_DSCR_STATE_Pos = 0x12
	// Bit mask of IN_DSCR_STATE field.
	UHCI0_STATE0_IN_DSCR_STATE_Msk = 0xc0000
	// Position of IN_STATE field.
	UHCI0_STATE0_IN_STATE_Pos = 0x14
	// Bit mask of IN_STATE field.
	UHCI0_STATE0_IN_STATE_Msk = 0x700000
	// Position of INFIFO_CNT_DEBUG field.
	UHCI0_STATE0_INFIFO_CNT_DEBUG_Pos = 0x17
	// Bit mask of INFIFO_CNT_DEBUG field.
	UHCI0_STATE0_INFIFO_CNT_DEBUG_Msk = 0xf800000
	// Position of DECODE_STATE field.
	UHCI0_STATE0_DECODE_STATE_Pos = 0x1c
	// Bit mask of DECODE_STATE field.
	UHCI0_STATE0_DECODE_STATE_Msk = 0x70000000

	// STATE1: UHCI encoder status register
	// Position of OUTLINK_DSCR_ADDR field.
	UHCI0_STATE1_OUTLINK_DSCR_ADDR_Pos = 0x0
	// Bit mask of OUTLINK_DSCR_ADDR field.
	UHCI0_STATE1_OUTLINK_DSCR_ADDR_Msk = 0x3ffff
	// Position of OUT_DSCR_STATE field.
	UHCI0_STATE1_OUT_DSCR_STATE_Pos = 0x12
	// Bit mask of OUT_DSCR_STATE field.
	UHCI0_STATE1_OUT_DSCR_STATE_Msk = 0xc0000
	// Position of OUT_STATE field.
	UHCI0_STATE1_OUT_STATE_Pos = 0x14
	// Bit mask of OUT_STATE field.
	UHCI0_STATE1_OUT_STATE_Msk = 0x700000
	// Position of OUTFIFO_CNT field.
	UHCI0_STATE1_OUTFIFO_CNT_Pos = 0x17
	// Bit mask of OUTFIFO_CNT field.
	UHCI0_STATE1_OUTFIFO_CNT_Msk = 0xf800000
	// Position of ENCODE_STATE field.
	UHCI0_STATE1_ENCODE_STATE_Pos = 0x1c
	// Bit mask of ENCODE_STATE field.
	UHCI0_STATE1_ENCODE_STATE_Msk = 0x70000000

	// DMA_OUT_EOF_DES_ADDR: Outlink descriptor address when EOF occurs
	// Position of OUT_EOF_DES_ADDR field.
	UHCI0_DMA_OUT_EOF_DES_ADDR_OUT_EOF_DES_ADDR_Pos = 0x0
	// Bit mask of OUT_EOF_DES_ADDR field.
	UHCI0_DMA_OUT_EOF_DES_ADDR_OUT_EOF_DES_ADDR_Msk = 0xffffffff

	// DMA_IN_SUC_EOF_DES_ADDR: Inlink descriptor address when EOF occurs
	// Position of IN_SUC_EOF_DES_ADDR field.
	UHCI0_DMA_IN_SUC_EOF_DES_ADDR_IN_SUC_EOF_DES_ADDR_Pos = 0x0
	// Bit mask of IN_SUC_EOF_DES_ADDR field.
	UHCI0_DMA_IN_SUC_EOF_DES_ADDR_IN_SUC_EOF_DES_ADDR_Msk = 0xffffffff

	// DMA_IN_ERR_EOF_DES_ADDR: Inlink descriptor address when errors occur
	// Position of IN_ERR_EOF_DES_ADDR field.
	UHCI0_DMA_IN_ERR_EOF_DES_ADDR_IN_ERR_EOF_DES_ADDR_Pos = 0x0
	// Bit mask of IN_ERR_EOF_DES_ADDR field.
	UHCI0_DMA_IN_ERR_EOF_DES_ADDR_IN_ERR_EOF_DES_ADDR_Msk = 0xffffffff

	// DMA_OUT_EOF_BFR_DES_ADDR: Outlink descriptor address before the last transmit descriptor
	// Position of OUT_EOF_BFR_DES_ADDR field.
	UHCI0_DMA_OUT_EOF_BFR_DES_ADDR_OUT_EOF_BFR_DES_ADDR_Pos = 0x0
	// Bit mask of OUT_EOF_BFR_DES_ADDR field.
	UHCI0_DMA_OUT_EOF_BFR_DES_ADDR_OUT_EOF_BFR_DES_ADDR_Msk = 0xffffffff

	// AHB_TEST: AHB test register
	// Position of AHB_TESTMODE field.
	UHCI0_AHB_TEST_AHB_TESTMODE_Pos = 0x0
	// Bit mask of AHB_TESTMODE field.
	UHCI0_AHB_TEST_AHB_TESTMODE_Msk = 0x7
	// Position of AHB_TESTADDR field.
	UHCI0_AHB_TEST_AHB_TESTADDR_Pos = 0x4
	// Bit mask of AHB_TESTADDR field.
	UHCI0_AHB_TEST_AHB_TESTADDR_Msk = 0x30

	// DMA_IN_DSCR: The third word of the next receive descriptor
	// Position of INLINK_DSCR field.
	UHCI0_DMA_IN_DSCR_INLINK_DSCR_Pos = 0x0
	// Bit mask of INLINK_DSCR field.
	UHCI0_DMA_IN_DSCR_INLINK_DSCR_Msk = 0xffffffff

	// DMA_IN_DSCR_BF0: The third word of current receive descriptor
	// Position of INLINK_DSCR_BF0 field.
	UHCI0_DMA_IN_DSCR_BF0_INLINK_DSCR_BF0_Pos = 0x0
	// Bit mask of INLINK_DSCR_BF0 field.
	UHCI0_DMA_IN_DSCR_BF0_INLINK_DSCR_BF0_Msk = 0xffffffff

	// DMA_IN_DSCR_BF1: The second word of current receive descriptor
	// Position of INLINK_DSCR_BF1 field.
	UHCI0_DMA_IN_DSCR_BF1_INLINK_DSCR_BF1_Pos = 0x0
	// Bit mask of INLINK_DSCR_BF1 field.
	UHCI0_DMA_IN_DSCR_BF1_INLINK_DSCR_BF1_Msk = 0xffffffff

	// DMA_OUT_DSCR: The third word of the next transmit descriptor
	// Position of OUTLINK_DSCR field.
	UHCI0_DMA_OUT_DSCR_OUTLINK_DSCR_Pos = 0x0
	// Bit mask of OUTLINK_DSCR field.
	UHCI0_DMA_OUT_DSCR_OUTLINK_DSCR_Msk = 0xffffffff

	// DMA_OUT_DSCR_BF0: The third word of current transmit descriptor
	// Position of OUTLINK_DSCR_BF0 field.
	UHCI0_DMA_OUT_DSCR_BF0_OUTLINK_DSCR_BF0_Pos = 0x0
	// Bit mask of OUTLINK_DSCR_BF0 field.
	UHCI0_DMA_OUT_DSCR_BF0_OUTLINK_DSCR_BF0_Msk = 0xffffffff

	// DMA_OUT_DSCR_BF1: The second word of current transmit descriptor
	// Position of OUTLINK_DSCR_BF1 field.
	UHCI0_DMA_OUT_DSCR_BF1_OUTLINK_DSCR_BF1_Pos = 0x0
	// Bit mask of OUTLINK_DSCR_BF1 field.
	UHCI0_DMA_OUT_DSCR_BF1_OUTLINK_DSCR_BF1_Msk = 0xffffffff

	// ESCAPE_CONF: Escape characters configuration
	// Position of TX_C0_ESC_EN field.
	UHCI0_ESCAPE_CONF_TX_C0_ESC_EN_Pos = 0x0
	// Bit mask of TX_C0_ESC_EN field.
	UHCI0_ESCAPE_CONF_TX_C0_ESC_EN_Msk = 0x1
	// Bit TX_C0_ESC_EN.
	UHCI0_ESCAPE_CONF_TX_C0_ESC_EN = 0x1
	// Position of TX_DB_ESC_EN field.
	UHCI0_ESCAPE_CONF_TX_DB_ESC_EN_Pos = 0x1
	// Bit mask of TX_DB_ESC_EN field.
	UHCI0_ESCAPE_CONF_TX_DB_ESC_EN_Msk = 0x2
	// Bit TX_DB_ESC_EN.
	UHCI0_ESCAPE_CONF_TX_DB_ESC_EN = 0x2
	// Position of TX_11_ESC_EN field.
	UHCI0_ESCAPE_CONF_TX_11_ESC_EN_Pos = 0x2
	// Bit mask of TX_11_ESC_EN field.
	UHCI0_ESCAPE_CONF_TX_11_ESC_EN_Msk = 0x4
	// Bit TX_11_ESC_EN.
	UHCI0_ESCAPE_CONF_TX_11_ESC_EN = 0x4
	// Position of TX_13_ESC_EN field.
	UHCI0_ESCAPE_CONF_TX_13_ESC_EN_Pos = 0x3
	// Bit mask of TX_13_ESC_EN field.
	UHCI0_ESCAPE_CONF_TX_13_ESC_EN_Msk = 0x8
	// Bit TX_13_ESC_EN.
	UHCI0_ESCAPE_CONF_TX_13_ESC_EN = 0x8
	// Position of RX_C0_ESC_EN field.
	UHCI0_ESCAPE_CONF_RX_C0_ESC_EN_Pos = 0x4
	// Bit mask of RX_C0_ESC_EN field.
	UHCI0_ESCAPE_CONF_RX_C0_ESC_EN_Msk = 0x10
	// Bit RX_C0_ESC_EN.
	UHCI0_ESCAPE_CONF_RX_C0_ESC_EN = 0x10
	// Position of RX_DB_ESC_EN field.
	UHCI0_ESCAPE_CONF_RX_DB_ESC_EN_Pos = 0x5
	// Bit mask of RX_DB_ESC_EN field.
	UHCI0_ESCAPE_CONF_RX_DB_ESC_EN_Msk = 0x20
	// Bit RX_DB_ESC_EN.
	UHCI0_ESCAPE_CONF_RX_DB_ESC_EN = 0x20
	// Position of RX_11_ESC_EN field.
	UHCI0_ESCAPE_CONF_RX_11_ESC_EN_Pos = 0x6
	// Bit mask of RX_11_ESC_EN field.
	UHCI0_ESCAPE_CONF_RX_11_ESC_EN_Msk = 0x40
	// Bit RX_11_ESC_EN.
	UHCI0_ESCAPE_CONF_RX_11_ESC_EN = 0x40
	// Position of RX_13_ESC_EN field.
	UHCI0_ESCAPE_CONF_RX_13_ESC_EN_Pos = 0x7
	// Bit mask of RX_13_ESC_EN field.
	UHCI0_ESCAPE_CONF_RX_13_ESC_EN_Msk = 0x80
	// Bit RX_13_ESC_EN.
	UHCI0_ESCAPE_CONF_RX_13_ESC_EN = 0x80

	// HUNG_CONF: Timeout configuration
	// Position of TXFIFO_TIMEOUT field.
	UHCI0_HUNG_CONF_TXFIFO_TIMEOUT_Pos = 0x0
	// Bit mask of TXFIFO_TIMEOUT field.
	UHCI0_HUNG_CONF_TXFIFO_TIMEOUT_Msk = 0xff
	// Position of TXFIFO_TIMEOUT_SHIFT field.
	UHCI0_HUNG_CONF_TXFIFO_TIMEOUT_SHIFT_Pos = 0x8
	// Bit mask of TXFIFO_TIMEOUT_SHIFT field.
	UHCI0_HUNG_CONF_TXFIFO_TIMEOUT_SHIFT_Msk = 0x700
	// Position of TXFIFO_TIMEOUT_ENA field.
	UHCI0_HUNG_CONF_TXFIFO_TIMEOUT_ENA_Pos = 0xb
	// Bit mask of TXFIFO_TIMEOUT_ENA field.
	UHCI0_HUNG_CONF_TXFIFO_TIMEOUT_ENA_Msk = 0x800
	// Bit TXFIFO_TIMEOUT_ENA.
	UHCI0_HUNG_CONF_TXFIFO_TIMEOUT_ENA = 0x800
	// Position of RXFIFO_TIMEOUT field.
	UHCI0_HUNG_CONF_RXFIFO_TIMEOUT_Pos = 0xc
	// Bit mask of RXFIFO_TIMEOUT field.
	UHCI0_HUNG_CONF_RXFIFO_TIMEOUT_Msk = 0xff000
	// Position of RXFIFO_TIMEOUT_SHIFT field.
	UHCI0_HUNG_CONF_RXFIFO_TIMEOUT_SHIFT_Pos = 0x14
	// Bit mask of RXFIFO_TIMEOUT_SHIFT field.
	UHCI0_HUNG_CONF_RXFIFO_TIMEOUT_SHIFT_Msk = 0x700000
	// Position of RXFIFO_TIMEOUT_ENA field.
	UHCI0_HUNG_CONF_RXFIFO_TIMEOUT_ENA_Pos = 0x17
	// Bit mask of RXFIFO_TIMEOUT_ENA field.
	UHCI0_HUNG_CONF_RXFIFO_TIMEOUT_ENA_Msk = 0x800000
	// Bit RXFIFO_TIMEOUT_ENA.
	UHCI0_HUNG_CONF_RXFIFO_TIMEOUT_ENA = 0x800000

	// RX_HEAD: UHCI packet header register
	// Position of RX_HEAD field.
	UHCI0_RX_HEAD_RX_HEAD_Pos = 0x0
	// Bit mask of RX_HEAD field.
	UHCI0_RX_HEAD_RX_HEAD_Msk = 0xffffffff

	// QUICK_SENT: UHCI quick send configuration register
	// Position of SINGLE_SEND_NUM field.
	UHCI0_QUICK_SENT_SINGLE_SEND_NUM_Pos = 0x0
	// Bit mask of SINGLE_SEND_NUM field.
	UHCI0_QUICK_SENT_SINGLE_SEND_NUM_Msk = 0x7
	// Position of SINGLE_SEND_EN field.
	UHCI0_QUICK_SENT_SINGLE_SEND_EN_Pos = 0x3
	// Bit mask of SINGLE_SEND_EN field.
	UHCI0_QUICK_SENT_SINGLE_SEND_EN_Msk = 0x8
	// Bit SINGLE_SEND_EN.
	UHCI0_QUICK_SENT_SINGLE_SEND_EN = 0x8
	// Position of ALWAYS_SEND_NUM field.
	UHCI0_QUICK_SENT_ALWAYS_SEND_NUM_Pos = 0x4
	// Bit mask of ALWAYS_SEND_NUM field.
	UHCI0_QUICK_SENT_ALWAYS_SEND_NUM_Msk = 0x70
	// Position of ALWAYS_SEND_EN field.
	UHCI0_QUICK_SENT_ALWAYS_SEND_EN_Pos = 0x7
	// Bit mask of ALWAYS_SEND_EN field.
	UHCI0_QUICK_SENT_ALWAYS_SEND_EN_Msk = 0x80
	// Bit ALWAYS_SEND_EN.
	UHCI0_QUICK_SENT_ALWAYS_SEND_EN = 0x80

	// REG_Q0_WORD0: Q0_WORD0 quick_sent register
	// Position of SEND_Q0_WORD0 field.
	UHCI0_REG_Q0_WORD0_SEND_Q0_WORD0_Pos = 0x0
	// Bit mask of SEND_Q0_WORD0 field.
	UHCI0_REG_Q0_WORD0_SEND_Q0_WORD0_Msk = 0xffffffff

	// REG_Q0_WORD1: Q0_WORD1 quick_sent register
	// Position of SEND_Q0_WORD1 field.
	UHCI0_REG_Q0_WORD1_SEND_Q0_WORD1_Pos = 0x0
	// Bit mask of SEND_Q0_WORD1 field.
	UHCI0_REG_Q0_WORD1_SEND_Q0_WORD1_Msk = 0xffffffff

	// REG_Q1_WORD0: Q1_WORD0 quick_sent register
	// Position of SEND_Q1_WORD0 field.
	UHCI0_REG_Q1_WORD0_SEND_Q1_WORD0_Pos = 0x0
	// Bit mask of SEND_Q1_WORD0 field.
	UHCI0_REG_Q1_WORD0_SEND_Q1_WORD0_Msk = 0xffffffff

	// REG_Q1_WORD1: Q1_WORD1 quick_sent register
	// Position of SEND_Q1_WORD1 field.
	UHCI0_REG_Q1_WORD1_SEND_Q1_WORD1_Pos = 0x0
	// Bit mask of SEND_Q1_WORD1 field.
	UHCI0_REG_Q1_WORD1_SEND_Q1_WORD1_Msk = 0xffffffff

	// REG_Q2_WORD0: Q2_WORD0 quick_sent register
	// Position of SEND_Q2_WORD0 field.
	UHCI0_REG_Q2_WORD0_SEND_Q2_WORD0_Pos = 0x0
	// Bit mask of SEND_Q2_WORD0 field.
	UHCI0_REG_Q2_WORD0_SEND_Q2_WORD0_Msk = 0xffffffff

	// REG_Q2_WORD1: Q2_WORD1 quick_sent register
	// Position of SEND_Q2_WORD1 field.
	UHCI0_REG_Q2_WORD1_SEND_Q2_WORD1_Pos = 0x0
	// Bit mask of SEND_Q2_WORD1 field.
	UHCI0_REG_Q2_WORD1_SEND_Q2_WORD1_Msk = 0xffffffff

	// REG_Q3_WORD0: Q3_WORD0 quick_sent register
	// Position of SEND_Q3_WORD0 field.
	UHCI0_REG_Q3_WORD0_SEND_Q3_WORD0_Pos = 0x0
	// Bit mask of SEND_Q3_WORD0 field.
	UHCI0_REG_Q3_WORD0_SEND_Q3_WORD0_Msk = 0xffffffff

	// REG_Q3_WORD1: Q3_WORD1 quick_sent register
	// Position of SEND_Q3_WORD1 field.
	UHCI0_REG_Q3_WORD1_SEND_Q3_WORD1_Pos = 0x0
	// Bit mask of SEND_Q3_WORD1 field.
	UHCI0_REG_Q3_WORD1_SEND_Q3_WORD1_Msk = 0xffffffff

	// REG_Q4_WORD0: Q4_WORD0 quick_sent register
	// Position of SEND_Q4_WORD0 field.
	UHCI0_REG_Q4_WORD0_SEND_Q4_WORD0_Pos = 0x0
	// Bit mask of SEND_Q4_WORD0 field.
	UHCI0_REG_Q4_WORD0_SEND_Q4_WORD0_Msk = 0xffffffff

	// REG_Q4_WORD1: Q4_WORD1 quick_sent register
	// Position of SEND_Q4_WORD1 field.
	UHCI0_REG_Q4_WORD1_SEND_Q4_WORD1_Pos = 0x0
	// Bit mask of SEND_Q4_WORD1 field.
	UHCI0_REG_Q4_WORD1_SEND_Q4_WORD1_Msk = 0xffffffff

	// REG_Q5_WORD0: Q5_WORD0 quick_sent register
	// Position of SEND_Q5_WORD0 field.
	UHCI0_REG_Q5_WORD0_SEND_Q5_WORD0_Pos = 0x0
	// Bit mask of SEND_Q5_WORD0 field.
	UHCI0_REG_Q5_WORD0_SEND_Q5_WORD0_Msk = 0xffffffff

	// REG_Q5_WORD1: Q5_WORD1 quick_sent register
	// Position of SEND_Q5_WORD1 field.
	UHCI0_REG_Q5_WORD1_SEND_Q5_WORD1_Pos = 0x0
	// Bit mask of SEND_Q5_WORD1 field.
	UHCI0_REG_Q5_WORD1_SEND_Q5_WORD1_Msk = 0xffffffff

	// REG_Q6_WORD0: Q6_WORD0 quick_sent register
	// Position of SEND_Q6_WORD0 field.
	UHCI0_REG_Q6_WORD0_SEND_Q6_WORD0_Pos = 0x0
	// Bit mask of SEND_Q6_WORD0 field.
	UHCI0_REG_Q6_WORD0_SEND_Q6_WORD0_Msk = 0xffffffff

	// REG_Q6_WORD1: Q6_WORD1 quick_sent register
	// Position of SEND_Q6_WORD1 field.
	UHCI0_REG_Q6_WORD1_SEND_Q6_WORD1_Pos = 0x0
	// Bit mask of SEND_Q6_WORD1 field.
	UHCI0_REG_Q6_WORD1_SEND_Q6_WORD1_Msk = 0xffffffff

	// ESC_CONF0: Escape sequence configuration register 0
	// Position of SEPER_CHAR field.
	UHCI0_ESC_CONF0_SEPER_CHAR_Pos = 0x0
	// Bit mask of SEPER_CHAR field.
	UHCI0_ESC_CONF0_SEPER_CHAR_Msk = 0xff
	// Position of SEPER_ESC_CHAR0 field.
	UHCI0_ESC_CONF0_SEPER_ESC_CHAR0_Pos = 0x8
	// Bit mask of SEPER_ESC_CHAR0 field.
	UHCI0_ESC_CONF0_SEPER_ESC_CHAR0_Msk = 0xff00
	// Position of SEPER_ESC_CHAR1 field.
	UHCI0_ESC_CONF0_SEPER_ESC_CHAR1_Pos = 0x10
	// Bit mask of SEPER_ESC_CHAR1 field.
	UHCI0_ESC_CONF0_SEPER_ESC_CHAR1_Msk = 0xff0000

	// ESC_CONF1: Escape sequence configuration register 1
	// Position of ESC_SEQ0 field.
	UHCI0_ESC_CONF1_ESC_SEQ0_Pos = 0x0
	// Bit mask of ESC_SEQ0 field.
	UHCI0_ESC_CONF1_ESC_SEQ0_Msk = 0xff
	// Position of ESC_SEQ0_CHAR0 field.
	UHCI0_ESC_CONF1_ESC_SEQ0_CHAR0_Pos = 0x8
	// Bit mask of ESC_SEQ0_CHAR0 field.
	UHCI0_ESC_CONF1_ESC_SEQ0_CHAR0_Msk = 0xff00
	// Position of ESC_SEQ0_CHAR1 field.
	UHCI0_ESC_CONF1_ESC_SEQ0_CHAR1_Pos = 0x10
	// Bit mask of ESC_SEQ0_CHAR1 field.
	UHCI0_ESC_CONF1_ESC_SEQ0_CHAR1_Msk = 0xff0000

	// ESC_CONF2: Escape sequence configuration register 2
	// Position of ESC_SEQ1 field.
	UHCI0_ESC_CONF2_ESC_SEQ1_Pos = 0x0
	// Bit mask of ESC_SEQ1 field.
	UHCI0_ESC_CONF2_ESC_SEQ1_Msk = 0xff
	// Position of ESC_SEQ1_CHAR0 field.
	UHCI0_ESC_CONF2_ESC_SEQ1_CHAR0_Pos = 0x8
	// Bit mask of ESC_SEQ1_CHAR0 field.
	UHCI0_ESC_CONF2_ESC_SEQ1_CHAR0_Msk = 0xff00
	// Position of ESC_SEQ1_CHAR1 field.
	UHCI0_ESC_CONF2_ESC_SEQ1_CHAR1_Pos = 0x10
	// Bit mask of ESC_SEQ1_CHAR1 field.
	UHCI0_ESC_CONF2_ESC_SEQ1_CHAR1_Msk = 0xff0000

	// ESC_CONF3: Escape sequence configuration register 3
	// Position of ESC_SEQ2 field.
	UHCI0_ESC_CONF3_ESC_SEQ2_Pos = 0x0
	// Bit mask of ESC_SEQ2 field.
	UHCI0_ESC_CONF3_ESC_SEQ2_Msk = 0xff
	// Position of ESC_SEQ2_CHAR0 field.
	UHCI0_ESC_CONF3_ESC_SEQ2_CHAR0_Pos = 0x8
	// Bit mask of ESC_SEQ2_CHAR0 field.
	UHCI0_ESC_CONF3_ESC_SEQ2_CHAR0_Msk = 0xff00
	// Position of ESC_SEQ2_CHAR1 field.
	UHCI0_ESC_CONF3_ESC_SEQ2_CHAR1_Pos = 0x10
	// Bit mask of ESC_SEQ2_CHAR1 field.
	UHCI0_ESC_CONF3_ESC_SEQ2_CHAR1_Msk = 0xff0000

	// PKT_THRES: Configure register for packet length
	// Position of PKT_THRS field.
	UHCI0_PKT_THRES_PKT_THRS_Pos = 0x0
	// Bit mask of PKT_THRS field.
	UHCI0_PKT_THRES_PKT_THRS_Msk = 0x1fff

	// DATE: UHCI version control register
	// Position of DATE field.
	UHCI0_DATE_DATE_Pos = 0x0
	// Bit mask of DATE field.
	UHCI0_DATE_DATE_Msk = 0xffffffff
)

// Constants for XTS_AES: Peripheral XTS_AES
const (
	// PLAIN_0: Plaintext register %s
	// Position of PLAIN_0 field.
	XTS_AES_PLAIN_PLAIN_0_Pos = 0x0
	// Bit mask of PLAIN_0 field.
	XTS_AES_PLAIN_PLAIN_0_Msk = 0xffffffff

	// LINESIZE: Configures the size of target memory space
	// Position of LINESIZE field.
	XTS_AES_LINESIZE_LINESIZE_Pos = 0x0
	// Bit mask of LINESIZE field.
	XTS_AES_LINESIZE_LINESIZE_Msk = 0x3

	// DESTINATION: Configures the type of the external memory
	// Position of DESTINATION field.
	XTS_AES_DESTINATION_DESTINATION_Pos = 0x0
	// Bit mask of DESTINATION field.
	XTS_AES_DESTINATION_DESTINATION_Msk = 0x1
	// Bit DESTINATION.
	XTS_AES_DESTINATION_DESTINATION = 0x1

	// PHYSICAL_ADDRESS: Physical address
	// Position of PHYSICAL_ADDRESS field.
	XTS_AES_PHYSICAL_ADDRESS_PHYSICAL_ADDRESS_Pos = 0x0
	// Bit mask of PHYSICAL_ADDRESS field.
	XTS_AES_PHYSICAL_ADDRESS_PHYSICAL_ADDRESS_Msk = 0x3fffffff

	// TRIGGER: Activates AES algorithm
	// Position of TRIGGER field.
	XTS_AES_TRIGGER_TRIGGER_Pos = 0x0
	// Bit mask of TRIGGER field.
	XTS_AES_TRIGGER_TRIGGER_Msk = 0x1
	// Bit TRIGGER.
	XTS_AES_TRIGGER_TRIGGER = 0x1

	// RELEASE: Release control
	// Position of RELEASE field.
	XTS_AES_RELEASE_RELEASE_Pos = 0x0
	// Bit mask of RELEASE field.
	XTS_AES_RELEASE_RELEASE_Msk = 0x1
	// Bit RELEASE.
	XTS_AES_RELEASE_RELEASE = 0x1

	// DESTROY: Destroys control
	// Position of DESTROY field.
	XTS_AES_DESTROY_DESTROY_Pos = 0x0
	// Bit mask of DESTROY field.
	XTS_AES_DESTROY_DESTROY_Msk = 0x1
	// Bit DESTROY.
	XTS_AES_DESTROY_DESTROY = 0x1

	// STATE: Status register
	// Position of STATE field.
	XTS_AES_STATE_STATE_Pos = 0x0
	// Bit mask of STATE field.
	XTS_AES_STATE_STATE_Msk = 0x3

	// DATE: Version register
	// Position of DATE field.
	XTS_AES_DATE_DATE_Pos = 0x0
	// Bit mask of DATE field.
	XTS_AES_DATE_DATE_Msk = 0x3fffffff
)
